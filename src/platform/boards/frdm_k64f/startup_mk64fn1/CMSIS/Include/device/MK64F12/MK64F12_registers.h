/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          GNU C Compiler - CodeSourcery Sourcery G++
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    K64P144M120SF5RM, Rev.2, January 2014
**     Version:             rev. 2.7, 2014-10-14
**     Build:               b141016
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2014 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2013-08-12)
**         Initial version.
**     - rev. 2.0 (2013-10-29)
**         Register accessor macros added to the memory map.
**         Symbols for Processor Expert memory map compatibility added to the memory map.
**         Startup file for gcc has been updated according to CMSIS 3.2.
**         System initialization updated.
**         MCG - registers updated.
**         PORTA, PORTB, PORTC, PORTE - registers for digital filter removed.
**     - rev. 2.1 (2013-10-30)
**         Definition of BITBAND macros updated to support peripherals with 32-bit acces disabled.
**     - rev. 2.2 (2013-12-09)
**         DMA - EARS register removed.
**         AIPS0, AIPS1 - MPRA register updated.
**     - rev. 2.3 (2014-01-24)
**         Update according to reference manual rev. 2
**         ENET, MCG, MCM, SIM, USB - registers updated
**     - rev. 2.4 (2014-02-10)
**         The declaration of clock configurations has been moved to separate header file system_MK64F12.h
**         Update of SystemInit() and SystemCoreClockUpdate() functions.
**     - rev. 2.5 (2014-02-10)
**         The declaration of clock configurations has been moved to separate header file system_MK64F12.h
**         Update of SystemInit() and SystemCoreClockUpdate() functions.
**         Module access macro module_BASES replaced by module_BASE_PTRS.
**     - rev. 2.6 (2014-08-28)
**         Update of system files - default clock configuration changed.
**         Update of startup files - possibility to override DefaultISR added.
**     - rev. 2.7 (2014-10-14)
**         Interrupt INT_LPTimer renamed to INT_LPTMR0, interrupt INT_Watchdog renamed to INT_WDOG_EWM.
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __HW_MK64F12_REGISTERS_H__
#define __HW_MK64F12_REGISTERS_H__

#include "MK64F12.h"
#include "fsl_bitaccess.h"

/*
 * MK64F12 ADC
 *
 * Analog-to-Digital Converter
 *
 * Registers defined in this header file:
 * - HW_ADC_SC1n - ADC Status and Control Registers 1
 * - HW_ADC_CFG1 - ADC Configuration Register 1
 * - HW_ADC_CFG2 - ADC Configuration Register 2
 * - HW_ADC_Rn - ADC Data Result Register
 * - HW_ADC_CV1 - Compare Value Registers
 * - HW_ADC_CV2 - Compare Value Registers
 * - HW_ADC_SC2 - Status and Control Register 2
 * - HW_ADC_SC3 - Status and Control Register 3
 * - HW_ADC_OFS - ADC Offset Correction Register
 * - HW_ADC_PG - ADC Plus-Side Gain Register
 * - HW_ADC_MG - ADC Minus-Side Gain Register
 * - HW_ADC_CLPD - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLPS - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 * - HW_ADC_CLMD - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLMS - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 * - HW_ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 *
 * - hw_adc_t - Struct containing all module registers.
 */

#define HW_ADC_INSTANCE_COUNT (2U) /*!< Number of instances of the ADC module. */
#define HW_ADC0 (0U) /*!< Instance number for ADC0. */
#define HW_ADC1 (1U) /*!< Instance number for ADC1. */

/*******************************************************************************
 * HW_ADC_SC1n - ADC Status and Control Registers 1
 ******************************************************************************/

/*!
 * @brief HW_ADC_SC1n - ADC Status and Control Registers 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * SC1A is used for both software and hardware trigger modes of operation. To
 * allow sequential conversions of the ADC to be triggered by internal peripherals,
 * the ADC can have more than one status and control register: one for each
 * conversion. The SC1B-SC1n registers indicate potentially multiple SC1 registers
 * for use only in hardware trigger mode. See the chip configuration information
 * about the number of SC1n registers specific to this device. The SC1n registers
 * have identical fields, and are used in a "ping-pong" approach to control ADC
 * operation. At any one point in time, only one of the SC1n registers is actively
 * controlling ADC conversions. Updating SC1A while SC1n is actively controlling
 * a conversion is allowed, and vice-versa for any of the SC1n registers specific
 * to this MCU. Writing SC1A while SC1A is actively controlling a conversion
 * aborts the current conversion. In Software Trigger mode, when SC2[ADTRG]=0,
 * writes to SC1A subsequently initiate a new conversion, if SC1[ADCH] contains a
 * value other than all 1s. Writing any of the SC1n registers while that specific
 * SC1n register is actively controlling a conversion aborts the current conversion.
 * None of the SC1B-SC1n registers are used for software trigger operation and
 * therefore writes to the SC1B-SC1n registers do not initiate a new conversion.
 */
typedef union _hw_adc_sc1n
{
    uint32_t U;
    struct _hw_adc_sc1n_bitfields
    {
        uint32_t ADCH : 5;             /*!< [4:0] Input channel select */
        uint32_t DIFF : 1;             /*!< [5] Differential Mode Enable */
        uint32_t AIEN : 1;             /*!< [6] Interrupt Enable */
        uint32_t COCO : 1;             /*!< [7] Conversion Complete Flag */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_sc1n_t;

/*!
 * @name Constants and macros for entire ADC_SC1n register
 */
/*@{*/
#define HW_ADC_SC1n_COUNT (2U)

#define HW_ADC_SC1n_ADDR(x, n)   ((uint32_t)(x) + 0x0U + (0x4U * (n)))

#define HW_ADC_SC1n(x, n)        (*(__IO hw_adc_sc1n_t *) HW_ADC_SC1n_ADDR(x, n))
#define HW_ADC_SC1n_RD(x, n)     (HW_ADC_SC1n(x, n).U)
#define HW_ADC_SC1n_WR(x, n, v)  (HW_ADC_SC1n(x, n).U = (v))
#define HW_ADC_SC1n_SET(x, n, v) (HW_ADC_SC1n_WR(x, n, HW_ADC_SC1n_RD(x, n) |  (v)))
#define HW_ADC_SC1n_CLR(x, n, v) (HW_ADC_SC1n_WR(x, n, HW_ADC_SC1n_RD(x, n) & ~(v)))
#define HW_ADC_SC1n_TOG(x, n, v) (HW_ADC_SC1n_WR(x, n, HW_ADC_SC1n_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC1n bitfields
 */

/*!
 * @name Register ADC_SC1n, field ADCH[4:0] (RW)
 *
 * Selects one of the input channels. The input channel decode depends on the
 * value of DIFF. DAD0-DAD3 are associated with the input pin pairs DADPx and
 * DADMx. Some of the input channel options in the bitfield-setting descriptions might
 * not be available for your device. For the actual ADC channel assignments for
 * your device, see the Chip Configuration details. The successive approximation
 * converter subsystem is turned off when the channel select bits are all set,
 * that is, ADCH = 11111. This feature allows explicit disabling of the ADC and
 * isolation of the input channel from all sources. Terminating continuous
 * conversions this way prevents an additional single conversion from being performed. It
 * is not necessary to set ADCH to all 1s to place the ADC in a low-power state
 * when continuous conversions are not enabled because the module automatically
 * enters a low-power state when a conversion completes.
 *
 * Values:
 * - 00000 - When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is
 *     selected as input.
 * - 00001 - When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is
 *     selected as input.
 * - 00010 - When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is
 *     selected as input.
 * - 00011 - When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is
 *     selected as input.
 * - 00100 - When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
 * - 00101 - When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
 * - 00110 - When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
 * - 00111 - When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
 * - 01000 - When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
 * - 01001 - When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
 * - 01010 - When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
 * - 01011 - When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
 * - 01100 - When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
 * - 01101 - When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
 * - 01110 - When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
 * - 01111 - When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
 * - 10000 - When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
 * - 10001 - When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
 * - 10010 - When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
 * - 10011 - When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
 * - 10100 - When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
 * - 10101 - When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
 * - 10110 - When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
 * - 10111 - When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
 * - 11000 - Reserved.
 * - 11001 - Reserved.
 * - 11010 - When DIFF=0, Temp Sensor (single-ended) is selected as input; when
 *     DIFF=1, Temp Sensor (differential) is selected as input.
 * - 11011 - When DIFF=0, Bandgap (single-ended) is selected as input; when
 *     DIFF=1, Bandgap (differential) is selected as input.
 * - 11100 - Reserved.
 * - 11101 - When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH
 *     (differential) is selected as input. Voltage reference selected is determined
 *     by SC2[REFSEL].
 * - 11110 - When DIFF=0,VREFSL is selected as input; when DIFF=1, it is
 *     reserved. Voltage reference selected is determined by SC2[REFSEL].
 * - 11111 - Module is disabled.
 */
/*@{*/
#define BP_ADC_SC1n_ADCH     (0U)          /*!< Bit position for ADC_SC1n_ADCH. */
#define BM_ADC_SC1n_ADCH     (0x0000001FU) /*!< Bit mask for ADC_SC1n_ADCH. */
#define BS_ADC_SC1n_ADCH     (5U)          /*!< Bit field size in bits for ADC_SC1n_ADCH. */

/*! @brief Read current value of the ADC_SC1n_ADCH field. */
#define BR_ADC_SC1n_ADCH(x, n) (HW_ADC_SC1n(x, n).B.ADCH)

/*! @brief Format value for bitfield ADC_SC1n_ADCH. */
#define BF_ADC_SC1n_ADCH(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC1n_ADCH) & BM_ADC_SC1n_ADCH)

/*! @brief Set the ADCH field to a new value. */
#define BW_ADC_SC1n_ADCH(x, n, v) (HW_ADC_SC1n_WR(x, n, (HW_ADC_SC1n_RD(x, n) & ~BM_ADC_SC1n_ADCH) | BF_ADC_SC1n_ADCH(v)))
/*@}*/

/*!
 * @name Register ADC_SC1n, field DIFF[5] (RW)
 *
 * Configures the ADC to operate in differential mode. When enabled, this mode
 * automatically selects from the differential channels, and changes the
 * conversion algorithm and the number of cycles to complete a conversion.
 *
 * Values:
 * - 0 - Single-ended conversions and input channels are selected.
 * - 1 - Differential conversions and input channels are selected.
 */
/*@{*/
#define BP_ADC_SC1n_DIFF     (5U)          /*!< Bit position for ADC_SC1n_DIFF. */
#define BM_ADC_SC1n_DIFF     (0x00000020U) /*!< Bit mask for ADC_SC1n_DIFF. */
#define BS_ADC_SC1n_DIFF     (1U)          /*!< Bit field size in bits for ADC_SC1n_DIFF. */

/*! @brief Read current value of the ADC_SC1n_DIFF field. */
#define BR_ADC_SC1n_DIFF(x, n) (BITBAND_ACCESS32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_DIFF))

/*! @brief Format value for bitfield ADC_SC1n_DIFF. */
#define BF_ADC_SC1n_DIFF(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC1n_DIFF) & BM_ADC_SC1n_DIFF)

/*! @brief Set the DIFF field to a new value. */
#define BW_ADC_SC1n_DIFF(x, n, v) (BITBAND_ACCESS32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_DIFF) = (v))
/*@}*/

/*!
 * @name Register ADC_SC1n, field AIEN[6] (RW)
 *
 * Enables conversion complete interrupts. When COCO becomes set while the
 * respective AIEN is high, an interrupt is asserted.
 *
 * Values:
 * - 0 - Conversion complete interrupt is disabled.
 * - 1 - Conversion complete interrupt is enabled.
 */
/*@{*/
#define BP_ADC_SC1n_AIEN     (6U)          /*!< Bit position for ADC_SC1n_AIEN. */
#define BM_ADC_SC1n_AIEN     (0x00000040U) /*!< Bit mask for ADC_SC1n_AIEN. */
#define BS_ADC_SC1n_AIEN     (1U)          /*!< Bit field size in bits for ADC_SC1n_AIEN. */

/*! @brief Read current value of the ADC_SC1n_AIEN field. */
#define BR_ADC_SC1n_AIEN(x, n) (BITBAND_ACCESS32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_AIEN))

/*! @brief Format value for bitfield ADC_SC1n_AIEN. */
#define BF_ADC_SC1n_AIEN(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC1n_AIEN) & BM_ADC_SC1n_AIEN)

/*! @brief Set the AIEN field to a new value. */
#define BW_ADC_SC1n_AIEN(x, n, v) (BITBAND_ACCESS32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_AIEN) = (v))
/*@}*/

/*!
 * @name Register ADC_SC1n, field COCO[7] (RO)
 *
 * This is a read-only field that is set each time a conversion is completed
 * when the compare function is disabled, or SC2[ACFE]=0 and the hardware average
 * function is disabled, or SC3[AVGE]=0. When the compare function is enabled, or
 * SC2[ACFE]=1, COCO is set upon completion of a conversion only if the compare
 * result is true. When the hardware average function is enabled, or SC3[AVGE]=1,
 * COCO is set upon completion of the selected number of conversions (determined
 * by AVGS). COCO in SC1A is also set at the completion of a calibration sequence.
 * COCO is cleared when the respective SC1n register is written or when the
 * respective Rn register is read.
 *
 * Values:
 * - 0 - Conversion is not completed.
 * - 1 - Conversion is completed.
 */
/*@{*/
#define BP_ADC_SC1n_COCO     (7U)          /*!< Bit position for ADC_SC1n_COCO. */
#define BM_ADC_SC1n_COCO     (0x00000080U) /*!< Bit mask for ADC_SC1n_COCO. */
#define BS_ADC_SC1n_COCO     (1U)          /*!< Bit field size in bits for ADC_SC1n_COCO. */

/*! @brief Read current value of the ADC_SC1n_COCO field. */
#define BR_ADC_SC1n_COCO(x, n) (BITBAND_ACCESS32(HW_ADC_SC1n_ADDR(x, n), BP_ADC_SC1n_COCO))
/*@}*/

/*******************************************************************************
 * HW_ADC_CFG1 - ADC Configuration Register 1
 ******************************************************************************/

/*!
 * @brief HW_ADC_CFG1 - ADC Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The configuration Register 1 (CFG1) selects the mode of operation, clock
 * source, clock divide, and configuration for low power or long sample time.
 */
typedef union _hw_adc_cfg1
{
    uint32_t U;
    struct _hw_adc_cfg1_bitfields
    {
        uint32_t ADICLK : 2;           /*!< [1:0] Input Clock Select */
        uint32_t MODE : 2;             /*!< [3:2] Conversion mode selection */
        uint32_t ADLSMP : 1;           /*!< [4] Sample Time Configuration */
        uint32_t ADIV : 2;             /*!< [6:5] Clock Divide Select */
        uint32_t ADLPC : 1;            /*!< [7] Low-Power Configuration */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_cfg1_t;

/*!
 * @name Constants and macros for entire ADC_CFG1 register
 */
/*@{*/
#define HW_ADC_CFG1_ADDR(x)      ((uint32_t)(x) + 0x8U)

#define HW_ADC_CFG1(x)           (*(__IO hw_adc_cfg1_t *) HW_ADC_CFG1_ADDR(x))
#define HW_ADC_CFG1_RD(x)        (HW_ADC_CFG1(x).U)
#define HW_ADC_CFG1_WR(x, v)     (HW_ADC_CFG1(x).U = (v))
#define HW_ADC_CFG1_SET(x, v)    (HW_ADC_CFG1_WR(x, HW_ADC_CFG1_RD(x) |  (v)))
#define HW_ADC_CFG1_CLR(x, v)    (HW_ADC_CFG1_WR(x, HW_ADC_CFG1_RD(x) & ~(v)))
#define HW_ADC_CFG1_TOG(x, v)    (HW_ADC_CFG1_WR(x, HW_ADC_CFG1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG1 bitfields
 */

/*!
 * @name Register ADC_CFG1, field ADICLK[1:0] (RW)
 *
 * Selects the input clock source to generate the internal clock, ADCK. Note
 * that when the ADACK clock source is selected, it is not required to be active
 * prior to conversion start. When it is selected and it is not active prior to a
 * conversion start, when CFG2[ADACKEN]=0, the asynchronous clock is activated at
 * the start of a conversion and deactivated when conversions are terminated. In
 * this case, there is an associated clock startup delay each time the clock
 * source is re-activated.
 *
 * Values:
 * - 00 - Bus clock
 * - 01 - Alternate clock 2 (ALTCLK2)
 * - 10 - Alternate clock (ALTCLK)
 * - 11 - Asynchronous clock (ADACK)
 */
/*@{*/
#define BP_ADC_CFG1_ADICLK   (0U)          /*!< Bit position for ADC_CFG1_ADICLK. */
#define BM_ADC_CFG1_ADICLK   (0x00000003U) /*!< Bit mask for ADC_CFG1_ADICLK. */
#define BS_ADC_CFG1_ADICLK   (2U)          /*!< Bit field size in bits for ADC_CFG1_ADICLK. */

/*! @brief Read current value of the ADC_CFG1_ADICLK field. */
#define BR_ADC_CFG1_ADICLK(x) (HW_ADC_CFG1(x).B.ADICLK)

/*! @brief Format value for bitfield ADC_CFG1_ADICLK. */
#define BF_ADC_CFG1_ADICLK(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADICLK) & BM_ADC_CFG1_ADICLK)

/*! @brief Set the ADICLK field to a new value. */
#define BW_ADC_CFG1_ADICLK(x, v) (HW_ADC_CFG1_WR(x, (HW_ADC_CFG1_RD(x) & ~BM_ADC_CFG1_ADICLK) | BF_ADC_CFG1_ADICLK(v)))
/*@}*/

/*!
 * @name Register ADC_CFG1, field MODE[3:2] (RW)
 *
 * Selects the ADC resolution mode.
 *
 * Values:
 * - 00 - When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is
 *     differential 9-bit conversion with 2's complement output.
 * - 01 - When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it is
 *     differential 13-bit conversion with 2's complement output.
 * - 10 - When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it is
 *     differential 11-bit conversion with 2's complement output
 * - 11 - When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it is
 *     differential 16-bit conversion with 2's complement output
 */
/*@{*/
#define BP_ADC_CFG1_MODE     (2U)          /*!< Bit position for ADC_CFG1_MODE. */
#define BM_ADC_CFG1_MODE     (0x0000000CU) /*!< Bit mask for ADC_CFG1_MODE. */
#define BS_ADC_CFG1_MODE     (2U)          /*!< Bit field size in bits for ADC_CFG1_MODE. */

/*! @brief Read current value of the ADC_CFG1_MODE field. */
#define BR_ADC_CFG1_MODE(x)  (HW_ADC_CFG1(x).B.MODE)

/*! @brief Format value for bitfield ADC_CFG1_MODE. */
#define BF_ADC_CFG1_MODE(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_MODE) & BM_ADC_CFG1_MODE)

/*! @brief Set the MODE field to a new value. */
#define BW_ADC_CFG1_MODE(x, v) (HW_ADC_CFG1_WR(x, (HW_ADC_CFG1_RD(x) & ~BM_ADC_CFG1_MODE) | BF_ADC_CFG1_MODE(v)))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLSMP[4] (RW)
 *
 * Selects between different sample times based on the conversion mode selected.
 * This field adjusts the sample period to allow higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption if
 * continuous conversions are enabled and high conversion rates are not required.
 * When ADLSMP=1, the long sample time select bits, (ADLSTS[1:0]), can select the
 * extent of the long sample time.
 *
 * Values:
 * - 0 - Short sample time.
 * - 1 - Long sample time.
 */
/*@{*/
#define BP_ADC_CFG1_ADLSMP   (4U)          /*!< Bit position for ADC_CFG1_ADLSMP. */
#define BM_ADC_CFG1_ADLSMP   (0x00000010U) /*!< Bit mask for ADC_CFG1_ADLSMP. */
#define BS_ADC_CFG1_ADLSMP   (1U)          /*!< Bit field size in bits for ADC_CFG1_ADLSMP. */

/*! @brief Read current value of the ADC_CFG1_ADLSMP field. */
#define BR_ADC_CFG1_ADLSMP(x) (BITBAND_ACCESS32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADLSMP))

/*! @brief Format value for bitfield ADC_CFG1_ADLSMP. */
#define BF_ADC_CFG1_ADLSMP(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADLSMP) & BM_ADC_CFG1_ADLSMP)

/*! @brief Set the ADLSMP field to a new value. */
#define BW_ADC_CFG1_ADLSMP(x, v) (BITBAND_ACCESS32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADLSMP) = (v))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADIV[6:5] (RW)
 *
 * Selects the divide ratio used by the ADC to generate the internal clock ADCK.
 *
 * Values:
 * - 00 - The divide ratio is 1 and the clock rate is input clock.
 * - 01 - The divide ratio is 2 and the clock rate is (input clock)/2.
 * - 10 - The divide ratio is 4 and the clock rate is (input clock)/4.
 * - 11 - The divide ratio is 8 and the clock rate is (input clock)/8.
 */
/*@{*/
#define BP_ADC_CFG1_ADIV     (5U)          /*!< Bit position for ADC_CFG1_ADIV. */
#define BM_ADC_CFG1_ADIV     (0x00000060U) /*!< Bit mask for ADC_CFG1_ADIV. */
#define BS_ADC_CFG1_ADIV     (2U)          /*!< Bit field size in bits for ADC_CFG1_ADIV. */

/*! @brief Read current value of the ADC_CFG1_ADIV field. */
#define BR_ADC_CFG1_ADIV(x)  (HW_ADC_CFG1(x).B.ADIV)

/*! @brief Format value for bitfield ADC_CFG1_ADIV. */
#define BF_ADC_CFG1_ADIV(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADIV) & BM_ADC_CFG1_ADIV)

/*! @brief Set the ADIV field to a new value. */
#define BW_ADC_CFG1_ADIV(x, v) (HW_ADC_CFG1_WR(x, (HW_ADC_CFG1_RD(x) & ~BM_ADC_CFG1_ADIV) | BF_ADC_CFG1_ADIV(v)))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLPC[7] (RW)
 *
 * Controls the power configuration of the successive approximation converter.
 * This optimizes power consumption when higher sample rates are not required.
 *
 * Values:
 * - 0 - Normal power configuration.
 * - 1 - Low-power configuration. The power is reduced at the expense of maximum
 *     clock speed.
 */
/*@{*/
#define BP_ADC_CFG1_ADLPC    (7U)          /*!< Bit position for ADC_CFG1_ADLPC. */
#define BM_ADC_CFG1_ADLPC    (0x00000080U) /*!< Bit mask for ADC_CFG1_ADLPC. */
#define BS_ADC_CFG1_ADLPC    (1U)          /*!< Bit field size in bits for ADC_CFG1_ADLPC. */

/*! @brief Read current value of the ADC_CFG1_ADLPC field. */
#define BR_ADC_CFG1_ADLPC(x) (BITBAND_ACCESS32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADLPC))

/*! @brief Format value for bitfield ADC_CFG1_ADLPC. */
#define BF_ADC_CFG1_ADLPC(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG1_ADLPC) & BM_ADC_CFG1_ADLPC)

/*! @brief Set the ADLPC field to a new value. */
#define BW_ADC_CFG1_ADLPC(x, v) (BITBAND_ACCESS32(HW_ADC_CFG1_ADDR(x), BP_ADC_CFG1_ADLPC) = (v))
/*@}*/

/*******************************************************************************
 * HW_ADC_CFG2 - ADC Configuration Register 2
 ******************************************************************************/

/*!
 * @brief HW_ADC_CFG2 - ADC Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Configuration Register 2 (CFG2) selects the special high-speed configuration
 * for very high speed conversions and selects the long sample time duration
 * during long sample mode.
 */
typedef union _hw_adc_cfg2
{
    uint32_t U;
    struct _hw_adc_cfg2_bitfields
    {
        uint32_t ADLSTS : 2;           /*!< [1:0] Long Sample Time Select */
        uint32_t ADHSC : 1;            /*!< [2] High-Speed Configuration */
        uint32_t ADACKEN : 1;          /*!< [3] Asynchronous Clock Output Enable */
        uint32_t MUXSEL : 1;           /*!< [4] ADC Mux Select */
        uint32_t RESERVED0 : 27;       /*!< [31:5]  */
    } B;
} hw_adc_cfg2_t;

/*!
 * @name Constants and macros for entire ADC_CFG2 register
 */
/*@{*/
#define HW_ADC_CFG2_ADDR(x)      ((uint32_t)(x) + 0xCU)

#define HW_ADC_CFG2(x)           (*(__IO hw_adc_cfg2_t *) HW_ADC_CFG2_ADDR(x))
#define HW_ADC_CFG2_RD(x)        (HW_ADC_CFG2(x).U)
#define HW_ADC_CFG2_WR(x, v)     (HW_ADC_CFG2(x).U = (v))
#define HW_ADC_CFG2_SET(x, v)    (HW_ADC_CFG2_WR(x, HW_ADC_CFG2_RD(x) |  (v)))
#define HW_ADC_CFG2_CLR(x, v)    (HW_ADC_CFG2_WR(x, HW_ADC_CFG2_RD(x) & ~(v)))
#define HW_ADC_CFG2_TOG(x, v)    (HW_ADC_CFG2_WR(x, HW_ADC_CFG2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG2 bitfields
 */

/*!
 * @name Register ADC_CFG2, field ADLSTS[1:0] (RW)
 *
 * Selects between the extended sample times when long sample time is selected,
 * that is, when CFG1[ADLSMP]=1. This allows higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption when
 * continuous conversions are enabled if high conversion rates are not required.
 *
 * Values:
 * - 00 - Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles
 *     total.
 * - 01 - 12 extra ADCK cycles; 16 ADCK cycles total sample time.
 * - 10 - 6 extra ADCK cycles; 10 ADCK cycles total sample time.
 * - 11 - 2 extra ADCK cycles; 6 ADCK cycles total sample time.
 */
/*@{*/
#define BP_ADC_CFG2_ADLSTS   (0U)          /*!< Bit position for ADC_CFG2_ADLSTS. */
#define BM_ADC_CFG2_ADLSTS   (0x00000003U) /*!< Bit mask for ADC_CFG2_ADLSTS. */
#define BS_ADC_CFG2_ADLSTS   (2U)          /*!< Bit field size in bits for ADC_CFG2_ADLSTS. */

/*! @brief Read current value of the ADC_CFG2_ADLSTS field. */
#define BR_ADC_CFG2_ADLSTS(x) (HW_ADC_CFG2(x).B.ADLSTS)

/*! @brief Format value for bitfield ADC_CFG2_ADLSTS. */
#define BF_ADC_CFG2_ADLSTS(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_ADLSTS) & BM_ADC_CFG2_ADLSTS)

/*! @brief Set the ADLSTS field to a new value. */
#define BW_ADC_CFG2_ADLSTS(x, v) (HW_ADC_CFG2_WR(x, (HW_ADC_CFG2_RD(x) & ~BM_ADC_CFG2_ADLSTS) | BF_ADC_CFG2_ADLSTS(v)))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADHSC[2] (RW)
 *
 * Configures the ADC for very high-speed operation. The conversion sequence is
 * altered with 2 ADCK cycles added to the conversion time to allow higher speed
 * conversion clocks.
 *
 * Values:
 * - 0 - Normal conversion sequence selected.
 * - 1 - High-speed conversion sequence selected with 2 additional ADCK cycles
 *     to total conversion time.
 */
/*@{*/
#define BP_ADC_CFG2_ADHSC    (2U)          /*!< Bit position for ADC_CFG2_ADHSC. */
#define BM_ADC_CFG2_ADHSC    (0x00000004U) /*!< Bit mask for ADC_CFG2_ADHSC. */
#define BS_ADC_CFG2_ADHSC    (1U)          /*!< Bit field size in bits for ADC_CFG2_ADHSC. */

/*! @brief Read current value of the ADC_CFG2_ADHSC field. */
#define BR_ADC_CFG2_ADHSC(x) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_ADHSC))

/*! @brief Format value for bitfield ADC_CFG2_ADHSC. */
#define BF_ADC_CFG2_ADHSC(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_ADHSC) & BM_ADC_CFG2_ADHSC)

/*! @brief Set the ADHSC field to a new value. */
#define BW_ADC_CFG2_ADHSC(x, v) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_ADHSC) = (v))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADACKEN[3] (RW)
 *
 * Enables the asynchronous clock source and the clock source output regardless
 * of the conversion and status of CFG1[ADICLK]. Based on MCU configuration, the
 * asynchronous clock may be used by other modules. See chip configuration
 * information. Setting this field allows the clock to be used even while the ADC is
 * idle or operating from a different clock source. Also, latency of initiating a
 * single or first-continuous conversion with the asynchronous clock selected is
 * reduced because the ADACK clock is already operational.
 *
 * Values:
 * - 0 - Asynchronous clock output disabled; Asynchronous clock is enabled only
 *     if selected by ADICLK and a conversion is active.
 * - 1 - Asynchronous clock and clock output is enabled regardless of the state
 *     of the ADC.
 */
/*@{*/
#define BP_ADC_CFG2_ADACKEN  (3U)          /*!< Bit position for ADC_CFG2_ADACKEN. */
#define BM_ADC_CFG2_ADACKEN  (0x00000008U) /*!< Bit mask for ADC_CFG2_ADACKEN. */
#define BS_ADC_CFG2_ADACKEN  (1U)          /*!< Bit field size in bits for ADC_CFG2_ADACKEN. */

/*! @brief Read current value of the ADC_CFG2_ADACKEN field. */
#define BR_ADC_CFG2_ADACKEN(x) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_ADACKEN))

/*! @brief Format value for bitfield ADC_CFG2_ADACKEN. */
#define BF_ADC_CFG2_ADACKEN(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_ADACKEN) & BM_ADC_CFG2_ADACKEN)

/*! @brief Set the ADACKEN field to a new value. */
#define BW_ADC_CFG2_ADACKEN(x, v) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_ADACKEN) = (v))
/*@}*/

/*!
 * @name Register ADC_CFG2, field MUXSEL[4] (RW)
 *
 * Changes the ADC mux setting to select between alternate sets of ADC channels.
 *
 * Values:
 * - 0 - ADxxa channels are selected.
 * - 1 - ADxxb channels are selected.
 */
/*@{*/
#define BP_ADC_CFG2_MUXSEL   (4U)          /*!< Bit position for ADC_CFG2_MUXSEL. */
#define BM_ADC_CFG2_MUXSEL   (0x00000010U) /*!< Bit mask for ADC_CFG2_MUXSEL. */
#define BS_ADC_CFG2_MUXSEL   (1U)          /*!< Bit field size in bits for ADC_CFG2_MUXSEL. */

/*! @brief Read current value of the ADC_CFG2_MUXSEL field. */
#define BR_ADC_CFG2_MUXSEL(x) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_MUXSEL))

/*! @brief Format value for bitfield ADC_CFG2_MUXSEL. */
#define BF_ADC_CFG2_MUXSEL(v) ((uint32_t)((uint32_t)(v) << BP_ADC_CFG2_MUXSEL) & BM_ADC_CFG2_MUXSEL)

/*! @brief Set the MUXSEL field to a new value. */
#define BW_ADC_CFG2_MUXSEL(x, v) (BITBAND_ACCESS32(HW_ADC_CFG2_ADDR(x), BP_ADC_CFG2_MUXSEL) = (v))
/*@}*/

/*******************************************************************************
 * HW_ADC_Rn - ADC Data Result Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_Rn - ADC Data Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The data result registers (Rn) contain the result of an ADC conversion of the
 * channel selected by the corresponding status and channel control register
 * (SC1A:SC1n). For every status and channel control register, there is a
 * corresponding data result register. Unused bits in R n are cleared in unsigned
 * right-aligned modes and carry the sign bit (MSB) in sign-extended 2's complement modes.
 * For example, when configured for 10-bit single-ended mode, D[15:10] are
 * cleared. When configured for 11-bit differential mode, D[15:10] carry the sign bit,
 * that is, bit 10 extended through bit 15. The following table describes the
 * behavior of the data result registers in the different modes of operation. Data
 * result register description Conversion mode D15 D14 D13 D12 D11 D10 D9 D8 D7
 * D6 D5 D4 D3 D2 D1 D0 Format 16-bit differential S D D D D D D D D D D D D D D D
 * Signed 2's complement 16-bit single-ended D D D D D D D D D D D D D D D D
 * Unsigned right justified 13-bit differential S S S S D D D D D D D D D D D D
 * Sign-extended 2's complement 12-bit single-ended 0 0 0 0 D D D D D D D D D D D D
 * Unsigned right-justified 11-bit differential S S S S S S D D D D D D D D D D
 * Sign-extended 2's complement 10-bit single-ended 0 0 0 0 0 0 D D D D D D D D D D
 * Unsigned right-justified 9-bit differential S S S S S S S S D D D D D D D D
 * Sign-extended 2's complement 8-bit single-ended 0 0 0 0 0 0 0 0 D D D D D D D D
 * Unsigned right-justified S: Sign bit or sign bit extension; D: Data, which is
 * 2's complement data if indicated
 */
typedef union _hw_adc_rn
{
    uint32_t U;
    struct _hw_adc_rn_bitfields
    {
        uint32_t D : 16;               /*!< [15:0] Data result */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_rn_t;

/*!
 * @name Constants and macros for entire ADC_Rn register
 */
/*@{*/
#define HW_ADC_Rn_COUNT (2U)

#define HW_ADC_Rn_ADDR(x, n)     ((uint32_t)(x) + 0x10U + (0x4U * (n)))

#define HW_ADC_Rn(x, n)          (*(__I hw_adc_rn_t *) HW_ADC_Rn_ADDR(x, n))
#define HW_ADC_Rn_RD(x, n)       (HW_ADC_Rn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual ADC_Rn bitfields
 */

/*!
 * @name Register ADC_Rn, field D[15:0] (RO)
 */
/*@{*/
#define BP_ADC_Rn_D          (0U)          /*!< Bit position for ADC_Rn_D. */
#define BM_ADC_Rn_D          (0x0000FFFFU) /*!< Bit mask for ADC_Rn_D. */
#define BS_ADC_Rn_D          (16U)         /*!< Bit field size in bits for ADC_Rn_D. */

/*! @brief Read current value of the ADC_Rn_D field. */
#define BR_ADC_Rn_D(x, n)    (HW_ADC_Rn(x, n).B.D)
/*@}*/

/*******************************************************************************
 * HW_ADC_CV1 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief HW_ADC_CV1 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
typedef union _hw_adc_cv1
{
    uint32_t U;
    struct _hw_adc_cv1_bitfields
    {
        uint32_t CV : 16;              /*!< [15:0] Compare Value. */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_cv1_t;

/*!
 * @name Constants and macros for entire ADC_CV1 register
 */
/*@{*/
#define HW_ADC_CV1_ADDR(x)       ((uint32_t)(x) + 0x18U)

#define HW_ADC_CV1(x)            (*(__IO hw_adc_cv1_t *) HW_ADC_CV1_ADDR(x))
#define HW_ADC_CV1_RD(x)         (HW_ADC_CV1(x).U)
#define HW_ADC_CV1_WR(x, v)      (HW_ADC_CV1(x).U = (v))
#define HW_ADC_CV1_SET(x, v)     (HW_ADC_CV1_WR(x, HW_ADC_CV1_RD(x) |  (v)))
#define HW_ADC_CV1_CLR(x, v)     (HW_ADC_CV1_WR(x, HW_ADC_CV1_RD(x) & ~(v)))
#define HW_ADC_CV1_TOG(x, v)     (HW_ADC_CV1_WR(x, HW_ADC_CV1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV1 bitfields
 */

/*!
 * @name Register ADC_CV1, field CV[15:0] (RW)
 */
/*@{*/
#define BP_ADC_CV1_CV        (0U)          /*!< Bit position for ADC_CV1_CV. */
#define BM_ADC_CV1_CV        (0x0000FFFFU) /*!< Bit mask for ADC_CV1_CV. */
#define BS_ADC_CV1_CV        (16U)         /*!< Bit field size in bits for ADC_CV1_CV. */

/*! @brief Read current value of the ADC_CV1_CV field. */
#define BR_ADC_CV1_CV(x)     (HW_ADC_CV1(x).B.CV)

/*! @brief Format value for bitfield ADC_CV1_CV. */
#define BF_ADC_CV1_CV(v)     ((uint32_t)((uint32_t)(v) << BP_ADC_CV1_CV) & BM_ADC_CV1_CV)

/*! @brief Set the CV field to a new value. */
#define BW_ADC_CV1_CV(x, v)  (HW_ADC_CV1_WR(x, (HW_ADC_CV1_RD(x) & ~BM_ADC_CV1_CV) | BF_ADC_CV1_CV(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CV2 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief HW_ADC_CV2 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
typedef union _hw_adc_cv2
{
    uint32_t U;
    struct _hw_adc_cv2_bitfields
    {
        uint32_t CV : 16;              /*!< [15:0] Compare Value. */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_cv2_t;

/*!
 * @name Constants and macros for entire ADC_CV2 register
 */
/*@{*/
#define HW_ADC_CV2_ADDR(x)       ((uint32_t)(x) + 0x1CU)

#define HW_ADC_CV2(x)            (*(__IO hw_adc_cv2_t *) HW_ADC_CV2_ADDR(x))
#define HW_ADC_CV2_RD(x)         (HW_ADC_CV2(x).U)
#define HW_ADC_CV2_WR(x, v)      (HW_ADC_CV2(x).U = (v))
#define HW_ADC_CV2_SET(x, v)     (HW_ADC_CV2_WR(x, HW_ADC_CV2_RD(x) |  (v)))
#define HW_ADC_CV2_CLR(x, v)     (HW_ADC_CV2_WR(x, HW_ADC_CV2_RD(x) & ~(v)))
#define HW_ADC_CV2_TOG(x, v)     (HW_ADC_CV2_WR(x, HW_ADC_CV2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV2 bitfields
 */

/*!
 * @name Register ADC_CV2, field CV[15:0] (RW)
 */
/*@{*/
#define BP_ADC_CV2_CV        (0U)          /*!< Bit position for ADC_CV2_CV. */
#define BM_ADC_CV2_CV        (0x0000FFFFU) /*!< Bit mask for ADC_CV2_CV. */
#define BS_ADC_CV2_CV        (16U)         /*!< Bit field size in bits for ADC_CV2_CV. */

/*! @brief Read current value of the ADC_CV2_CV field. */
#define BR_ADC_CV2_CV(x)     (HW_ADC_CV2(x).B.CV)

/*! @brief Format value for bitfield ADC_CV2_CV. */
#define BF_ADC_CV2_CV(v)     ((uint32_t)((uint32_t)(v) << BP_ADC_CV2_CV) & BM_ADC_CV2_CV)

/*! @brief Set the CV field to a new value. */
#define BW_ADC_CV2_CV(x, v)  (HW_ADC_CV2_WR(x, (HW_ADC_CV2_RD(x) & ~BM_ADC_CV2_CV) | BF_ADC_CV2_CV(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_SC2 - Status and Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_ADC_SC2 - Status and Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The status and control register 2 (SC2) contains the conversion active,
 * hardware/software trigger select, compare function, and voltage reference select of
 * the ADC module.
 */
typedef union _hw_adc_sc2
{
    uint32_t U;
    struct _hw_adc_sc2_bitfields
    {
        uint32_t REFSEL : 2;           /*!< [1:0] Voltage Reference Selection */
        uint32_t DMAEN : 1;            /*!< [2] DMA Enable */
        uint32_t ACREN : 1;            /*!< [3] Compare Function Range Enable */
        uint32_t ACFGT : 1;            /*!< [4] Compare Function Greater Than Enable */
        uint32_t ACFE : 1;             /*!< [5] Compare Function Enable */
        uint32_t ADTRG : 1;            /*!< [6] Conversion Trigger Select */
        uint32_t ADACT : 1;            /*!< [7] Conversion Active */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_sc2_t;

/*!
 * @name Constants and macros for entire ADC_SC2 register
 */
/*@{*/
#define HW_ADC_SC2_ADDR(x)       ((uint32_t)(x) + 0x20U)

#define HW_ADC_SC2(x)            (*(__IO hw_adc_sc2_t *) HW_ADC_SC2_ADDR(x))
#define HW_ADC_SC2_RD(x)         (HW_ADC_SC2(x).U)
#define HW_ADC_SC2_WR(x, v)      (HW_ADC_SC2(x).U = (v))
#define HW_ADC_SC2_SET(x, v)     (HW_ADC_SC2_WR(x, HW_ADC_SC2_RD(x) |  (v)))
#define HW_ADC_SC2_CLR(x, v)     (HW_ADC_SC2_WR(x, HW_ADC_SC2_RD(x) & ~(v)))
#define HW_ADC_SC2_TOG(x, v)     (HW_ADC_SC2_WR(x, HW_ADC_SC2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC2 bitfields
 */

/*!
 * @name Register ADC_SC2, field REFSEL[1:0] (RW)
 *
 * Selects the voltage reference source used for conversions.
 *
 * Values:
 * - 00 - Default voltage reference pin pair, that is, external pins VREFH and
 *     VREFL
 * - 01 - Alternate reference pair, that is, VALTH and VALTL . This pair may be
 *     additional external pins or internal sources depending on the MCU
 *     configuration. See the chip configuration information for details specific to this
 *     MCU
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
#define BP_ADC_SC2_REFSEL    (0U)          /*!< Bit position for ADC_SC2_REFSEL. */
#define BM_ADC_SC2_REFSEL    (0x00000003U) /*!< Bit mask for ADC_SC2_REFSEL. */
#define BS_ADC_SC2_REFSEL    (2U)          /*!< Bit field size in bits for ADC_SC2_REFSEL. */

/*! @brief Read current value of the ADC_SC2_REFSEL field. */
#define BR_ADC_SC2_REFSEL(x) (HW_ADC_SC2(x).B.REFSEL)

/*! @brief Format value for bitfield ADC_SC2_REFSEL. */
#define BF_ADC_SC2_REFSEL(v) ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_REFSEL) & BM_ADC_SC2_REFSEL)

/*! @brief Set the REFSEL field to a new value. */
#define BW_ADC_SC2_REFSEL(x, v) (HW_ADC_SC2_WR(x, (HW_ADC_SC2_RD(x) & ~BM_ADC_SC2_REFSEL) | BF_ADC_SC2_REFSEL(v)))
/*@}*/

/*!
 * @name Register ADC_SC2, field DMAEN[2] (RW)
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled and will assert the ADC DMA request during an ADC
 *     conversion complete event noted when any of the SC1n[COCO] flags is asserted.
 */
/*@{*/
#define BP_ADC_SC2_DMAEN     (2U)          /*!< Bit position for ADC_SC2_DMAEN. */
#define BM_ADC_SC2_DMAEN     (0x00000004U) /*!< Bit mask for ADC_SC2_DMAEN. */
#define BS_ADC_SC2_DMAEN     (1U)          /*!< Bit field size in bits for ADC_SC2_DMAEN. */

/*! @brief Read current value of the ADC_SC2_DMAEN field. */
#define BR_ADC_SC2_DMAEN(x)  (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_DMAEN))

/*! @brief Format value for bitfield ADC_SC2_DMAEN. */
#define BF_ADC_SC2_DMAEN(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_DMAEN) & BM_ADC_SC2_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_ADC_SC2_DMAEN(x, v) (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_DMAEN) = (v))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACREN[3] (RW)
 *
 * Configures the compare function to check if the conversion result of the
 * input being monitored is either between or outside the range formed by CV1 and CV2
 * determined by the value of ACFGT. ACFE must be set for ACFGT to have any
 * effect.
 *
 * Values:
 * - 0 - Range function disabled. Only CV1 is compared.
 * - 1 - Range function enabled. Both CV1 and CV2 are compared.
 */
/*@{*/
#define BP_ADC_SC2_ACREN     (3U)          /*!< Bit position for ADC_SC2_ACREN. */
#define BM_ADC_SC2_ACREN     (0x00000008U) /*!< Bit mask for ADC_SC2_ACREN. */
#define BS_ADC_SC2_ACREN     (1U)          /*!< Bit field size in bits for ADC_SC2_ACREN. */

/*! @brief Read current value of the ADC_SC2_ACREN field. */
#define BR_ADC_SC2_ACREN(x)  (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACREN))

/*! @brief Format value for bitfield ADC_SC2_ACREN. */
#define BF_ADC_SC2_ACREN(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ACREN) & BM_ADC_SC2_ACREN)

/*! @brief Set the ACREN field to a new value. */
#define BW_ADC_SC2_ACREN(x, v) (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACREN) = (v))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFGT[4] (RW)
 *
 * Configures the compare function to check the conversion result relative to
 * the CV1 and CV2 based upon the value of ACREN. ACFE must be set for ACFGT to
 * have any effect.
 *
 * Values:
 * - 0 - Configures less than threshold, outside range not inclusive and inside
 *     range not inclusive; functionality based on the values placed in CV1 and
 *     CV2.
 * - 1 - Configures greater than or equal to threshold, outside and inside
 *     ranges inclusive; functionality based on the values placed in CV1 and CV2.
 */
/*@{*/
#define BP_ADC_SC2_ACFGT     (4U)          /*!< Bit position for ADC_SC2_ACFGT. */
#define BM_ADC_SC2_ACFGT     (0x00000010U) /*!< Bit mask for ADC_SC2_ACFGT. */
#define BS_ADC_SC2_ACFGT     (1U)          /*!< Bit field size in bits for ADC_SC2_ACFGT. */

/*! @brief Read current value of the ADC_SC2_ACFGT field. */
#define BR_ADC_SC2_ACFGT(x)  (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACFGT))

/*! @brief Format value for bitfield ADC_SC2_ACFGT. */
#define BF_ADC_SC2_ACFGT(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ACFGT) & BM_ADC_SC2_ACFGT)

/*! @brief Set the ACFGT field to a new value. */
#define BW_ADC_SC2_ACFGT(x, v) (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACFGT) = (v))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFE[5] (RW)
 *
 * Enables the compare function.
 *
 * Values:
 * - 0 - Compare function disabled.
 * - 1 - Compare function enabled.
 */
/*@{*/
#define BP_ADC_SC2_ACFE      (5U)          /*!< Bit position for ADC_SC2_ACFE. */
#define BM_ADC_SC2_ACFE      (0x00000020U) /*!< Bit mask for ADC_SC2_ACFE. */
#define BS_ADC_SC2_ACFE      (1U)          /*!< Bit field size in bits for ADC_SC2_ACFE. */

/*! @brief Read current value of the ADC_SC2_ACFE field. */
#define BR_ADC_SC2_ACFE(x)   (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACFE))

/*! @brief Format value for bitfield ADC_SC2_ACFE. */
#define BF_ADC_SC2_ACFE(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ACFE) & BM_ADC_SC2_ACFE)

/*! @brief Set the ACFE field to a new value. */
#define BW_ADC_SC2_ACFE(x, v) (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ACFE) = (v))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADTRG[6] (RW)
 *
 * Selects the type of trigger used for initiating a conversion. Two types of
 * trigger are selectable: Software trigger: When software trigger is selected, a
 * conversion is initiated following a write to SC1A. Hardware trigger: When
 * hardware trigger is selected, a conversion is initiated following the assertion of
 * the ADHWT input after a pulse of the ADHWTSn input.
 *
 * Values:
 * - 0 - Software trigger selected.
 * - 1 - Hardware trigger selected.
 */
/*@{*/
#define BP_ADC_SC2_ADTRG     (6U)          /*!< Bit position for ADC_SC2_ADTRG. */
#define BM_ADC_SC2_ADTRG     (0x00000040U) /*!< Bit mask for ADC_SC2_ADTRG. */
#define BS_ADC_SC2_ADTRG     (1U)          /*!< Bit field size in bits for ADC_SC2_ADTRG. */

/*! @brief Read current value of the ADC_SC2_ADTRG field. */
#define BR_ADC_SC2_ADTRG(x)  (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ADTRG))

/*! @brief Format value for bitfield ADC_SC2_ADTRG. */
#define BF_ADC_SC2_ADTRG(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_SC2_ADTRG) & BM_ADC_SC2_ADTRG)

/*! @brief Set the ADTRG field to a new value. */
#define BW_ADC_SC2_ADTRG(x, v) (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ADTRG) = (v))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADACT[7] (RO)
 *
 * Indicates that a conversion or hardware averaging is in progress. ADACT is
 * set when a conversion is initiated and cleared when a conversion is completed or
 * aborted.
 *
 * Values:
 * - 0 - Conversion not in progress.
 * - 1 - Conversion in progress.
 */
/*@{*/
#define BP_ADC_SC2_ADACT     (7U)          /*!< Bit position for ADC_SC2_ADACT. */
#define BM_ADC_SC2_ADACT     (0x00000080U) /*!< Bit mask for ADC_SC2_ADACT. */
#define BS_ADC_SC2_ADACT     (1U)          /*!< Bit field size in bits for ADC_SC2_ADACT. */

/*! @brief Read current value of the ADC_SC2_ADACT field. */
#define BR_ADC_SC2_ADACT(x)  (BITBAND_ACCESS32(HW_ADC_SC2_ADDR(x), BP_ADC_SC2_ADACT))
/*@}*/

/*******************************************************************************
 * HW_ADC_SC3 - Status and Control Register 3
 ******************************************************************************/

/*!
 * @brief HW_ADC_SC3 - Status and Control Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Status and Control Register 3 (SC3) controls the calibration, continuous
 * convert, and hardware averaging functions of the ADC module.
 */
typedef union _hw_adc_sc3
{
    uint32_t U;
    struct _hw_adc_sc3_bitfields
    {
        uint32_t AVGS : 2;             /*!< [1:0] Hardware Average Select */
        uint32_t AVGE : 1;             /*!< [2] Hardware Average Enable */
        uint32_t ADCO : 1;             /*!< [3] Continuous Conversion Enable */
        uint32_t RESERVED0 : 2;        /*!< [5:4]  */
        uint32_t CALF : 1;             /*!< [6] Calibration Failed Flag */
        uint32_t CAL : 1;              /*!< [7] Calibration */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_sc3_t;

/*!
 * @name Constants and macros for entire ADC_SC3 register
 */
/*@{*/
#define HW_ADC_SC3_ADDR(x)       ((uint32_t)(x) + 0x24U)

#define HW_ADC_SC3(x)            (*(__IO hw_adc_sc3_t *) HW_ADC_SC3_ADDR(x))
#define HW_ADC_SC3_RD(x)         (HW_ADC_SC3(x).U)
#define HW_ADC_SC3_WR(x, v)      (HW_ADC_SC3(x).U = (v))
#define HW_ADC_SC3_SET(x, v)     (HW_ADC_SC3_WR(x, HW_ADC_SC3_RD(x) |  (v)))
#define HW_ADC_SC3_CLR(x, v)     (HW_ADC_SC3_WR(x, HW_ADC_SC3_RD(x) & ~(v)))
#define HW_ADC_SC3_TOG(x, v)     (HW_ADC_SC3_WR(x, HW_ADC_SC3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC3 bitfields
 */

/*!
 * @name Register ADC_SC3, field AVGS[1:0] (RW)
 *
 * Determines how many ADC conversions will be averaged to create the ADC
 * average result.
 *
 * Values:
 * - 00 - 4 samples averaged.
 * - 01 - 8 samples averaged.
 * - 10 - 16 samples averaged.
 * - 11 - 32 samples averaged.
 */
/*@{*/
#define BP_ADC_SC3_AVGS      (0U)          /*!< Bit position for ADC_SC3_AVGS. */
#define BM_ADC_SC3_AVGS      (0x00000003U) /*!< Bit mask for ADC_SC3_AVGS. */
#define BS_ADC_SC3_AVGS      (2U)          /*!< Bit field size in bits for ADC_SC3_AVGS. */

/*! @brief Read current value of the ADC_SC3_AVGS field. */
#define BR_ADC_SC3_AVGS(x)   (HW_ADC_SC3(x).B.AVGS)

/*! @brief Format value for bitfield ADC_SC3_AVGS. */
#define BF_ADC_SC3_AVGS(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_AVGS) & BM_ADC_SC3_AVGS)

/*! @brief Set the AVGS field to a new value. */
#define BW_ADC_SC3_AVGS(x, v) (HW_ADC_SC3_WR(x, (HW_ADC_SC3_RD(x) & ~BM_ADC_SC3_AVGS) | BF_ADC_SC3_AVGS(v)))
/*@}*/

/*!
 * @name Register ADC_SC3, field AVGE[2] (RW)
 *
 * Enables the hardware average function of the ADC.
 *
 * Values:
 * - 0 - Hardware average function disabled.
 * - 1 - Hardware average function enabled.
 */
/*@{*/
#define BP_ADC_SC3_AVGE      (2U)          /*!< Bit position for ADC_SC3_AVGE. */
#define BM_ADC_SC3_AVGE      (0x00000004U) /*!< Bit mask for ADC_SC3_AVGE. */
#define BS_ADC_SC3_AVGE      (1U)          /*!< Bit field size in bits for ADC_SC3_AVGE. */

/*! @brief Read current value of the ADC_SC3_AVGE field. */
#define BR_ADC_SC3_AVGE(x)   (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_AVGE))

/*! @brief Format value for bitfield ADC_SC3_AVGE. */
#define BF_ADC_SC3_AVGE(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_AVGE) & BM_ADC_SC3_AVGE)

/*! @brief Set the AVGE field to a new value. */
#define BW_ADC_SC3_AVGE(x, v) (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_AVGE) = (v))
/*@}*/

/*!
 * @name Register ADC_SC3, field ADCO[3] (RW)
 *
 * Enables continuous conversions.
 *
 * Values:
 * - 0 - One conversion or one set of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 * - 1 - Continuous conversions or sets of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 */
/*@{*/
#define BP_ADC_SC3_ADCO      (3U)          /*!< Bit position for ADC_SC3_ADCO. */
#define BM_ADC_SC3_ADCO      (0x00000008U) /*!< Bit mask for ADC_SC3_ADCO. */
#define BS_ADC_SC3_ADCO      (1U)          /*!< Bit field size in bits for ADC_SC3_ADCO. */

/*! @brief Read current value of the ADC_SC3_ADCO field. */
#define BR_ADC_SC3_ADCO(x)   (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_ADCO))

/*! @brief Format value for bitfield ADC_SC3_ADCO. */
#define BF_ADC_SC3_ADCO(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_ADCO) & BM_ADC_SC3_ADCO)

/*! @brief Set the ADCO field to a new value. */
#define BW_ADC_SC3_ADCO(x, v) (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_ADCO) = (v))
/*@}*/

/*!
 * @name Register ADC_SC3, field CALF[6] (W1C)
 *
 * Displays the result of the calibration sequence. The calibration sequence
 * will fail if SC2[ADTRG] = 1, any ADC register is written, or any stop mode is
 * entered before the calibration sequence completes. Writing 1 to CALF clears it.
 *
 * Values:
 * - 0 - Calibration completed normally.
 * - 1 - Calibration failed. ADC accuracy specifications are not guaranteed.
 */
/*@{*/
#define BP_ADC_SC3_CALF      (6U)          /*!< Bit position for ADC_SC3_CALF. */
#define BM_ADC_SC3_CALF      (0x00000040U) /*!< Bit mask for ADC_SC3_CALF. */
#define BS_ADC_SC3_CALF      (1U)          /*!< Bit field size in bits for ADC_SC3_CALF. */

/*! @brief Read current value of the ADC_SC3_CALF field. */
#define BR_ADC_SC3_CALF(x)   (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_CALF))

/*! @brief Format value for bitfield ADC_SC3_CALF. */
#define BF_ADC_SC3_CALF(v)   ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_CALF) & BM_ADC_SC3_CALF)

/*! @brief Set the CALF field to a new value. */
#define BW_ADC_SC3_CALF(x, v) (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_CALF) = (v))
/*@}*/

/*!
 * @name Register ADC_SC3, field CAL[7] (RW)
 *
 * Begins the calibration sequence when set. This field stays set while the
 * calibration is in progress and is cleared when the calibration sequence is
 * completed. CALF must be checked to determine the result of the calibration sequence.
 * Once started, the calibration routine cannot be interrupted by writes to the
 * ADC registers or the results will be invalid and CALF will set. Setting CAL
 * will abort any current conversion.
 */
/*@{*/
#define BP_ADC_SC3_CAL       (7U)          /*!< Bit position for ADC_SC3_CAL. */
#define BM_ADC_SC3_CAL       (0x00000080U) /*!< Bit mask for ADC_SC3_CAL. */
#define BS_ADC_SC3_CAL       (1U)          /*!< Bit field size in bits for ADC_SC3_CAL. */

/*! @brief Read current value of the ADC_SC3_CAL field. */
#define BR_ADC_SC3_CAL(x)    (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_CAL))

/*! @brief Format value for bitfield ADC_SC3_CAL. */
#define BF_ADC_SC3_CAL(v)    ((uint32_t)((uint32_t)(v) << BP_ADC_SC3_CAL) & BM_ADC_SC3_CAL)

/*! @brief Set the CAL field to a new value. */
#define BW_ADC_SC3_CAL(x, v) (BITBAND_ACCESS32(HW_ADC_SC3_ADDR(x), BP_ADC_SC3_CAL) = (v))
/*@}*/

/*******************************************************************************
 * HW_ADC_OFS - ADC Offset Correction Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_OFS - ADC Offset Correction Register (RW)
 *
 * Reset value: 0x00000004U
 *
 * The ADC Offset Correction Register (OFS) contains the user-selected or
 * calibration-generated offset error correction value. This register is a 2's
 * complement, left-justified, 16-bit value . The value in OFS is subtracted from the
 * conversion and the result is transferred into the result registers, Rn. If the
 * result is greater than the maximum or less than the minimum result value, it is
 * forced to the appropriate limit for the current mode of operation.
 */
typedef union _hw_adc_ofs
{
    uint32_t U;
    struct _hw_adc_ofs_bitfields
    {
        uint32_t OFS : 16;             /*!< [15:0] Offset Error Correction Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_ofs_t;

/*!
 * @name Constants and macros for entire ADC_OFS register
 */
/*@{*/
#define HW_ADC_OFS_ADDR(x)       ((uint32_t)(x) + 0x28U)

#define HW_ADC_OFS(x)            (*(__IO hw_adc_ofs_t *) HW_ADC_OFS_ADDR(x))
#define HW_ADC_OFS_RD(x)         (HW_ADC_OFS(x).U)
#define HW_ADC_OFS_WR(x, v)      (HW_ADC_OFS(x).U = (v))
#define HW_ADC_OFS_SET(x, v)     (HW_ADC_OFS_WR(x, HW_ADC_OFS_RD(x) |  (v)))
#define HW_ADC_OFS_CLR(x, v)     (HW_ADC_OFS_WR(x, HW_ADC_OFS_RD(x) & ~(v)))
#define HW_ADC_OFS_TOG(x, v)     (HW_ADC_OFS_WR(x, HW_ADC_OFS_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_OFS bitfields
 */

/*!
 * @name Register ADC_OFS, field OFS[15:0] (RW)
 */
/*@{*/
#define BP_ADC_OFS_OFS       (0U)          /*!< Bit position for ADC_OFS_OFS. */
#define BM_ADC_OFS_OFS       (0x0000FFFFU) /*!< Bit mask for ADC_OFS_OFS. */
#define BS_ADC_OFS_OFS       (16U)         /*!< Bit field size in bits for ADC_OFS_OFS. */

/*! @brief Read current value of the ADC_OFS_OFS field. */
#define BR_ADC_OFS_OFS(x)    (HW_ADC_OFS(x).B.OFS)

/*! @brief Format value for bitfield ADC_OFS_OFS. */
#define BF_ADC_OFS_OFS(v)    ((uint32_t)((uint32_t)(v) << BP_ADC_OFS_OFS) & BM_ADC_OFS_OFS)

/*! @brief Set the OFS field to a new value. */
#define BW_ADC_OFS_OFS(x, v) (HW_ADC_OFS_WR(x, (HW_ADC_OFS_RD(x) & ~BM_ADC_OFS_OFS) | BF_ADC_OFS_OFS(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_PG - ADC Plus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_PG - ADC Plus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Plus-Side Gain Register (PG) contains the gain error correction for the
 * plus-side input in differential mode or the overall conversion in single-ended
 * mode. PG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between ADPG15 and ADPG14. This register must be
 * written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met.
 */
typedef union _hw_adc_pg
{
    uint32_t U;
    struct _hw_adc_pg_bitfields
    {
        uint32_t PG : 16;              /*!< [15:0] Plus-Side Gain */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_pg_t;

/*!
 * @name Constants and macros for entire ADC_PG register
 */
/*@{*/
#define HW_ADC_PG_ADDR(x)        ((uint32_t)(x) + 0x2CU)

#define HW_ADC_PG(x)             (*(__IO hw_adc_pg_t *) HW_ADC_PG_ADDR(x))
#define HW_ADC_PG_RD(x)          (HW_ADC_PG(x).U)
#define HW_ADC_PG_WR(x, v)       (HW_ADC_PG(x).U = (v))
#define HW_ADC_PG_SET(x, v)      (HW_ADC_PG_WR(x, HW_ADC_PG_RD(x) |  (v)))
#define HW_ADC_PG_CLR(x, v)      (HW_ADC_PG_WR(x, HW_ADC_PG_RD(x) & ~(v)))
#define HW_ADC_PG_TOG(x, v)      (HW_ADC_PG_WR(x, HW_ADC_PG_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_PG bitfields
 */

/*!
 * @name Register ADC_PG, field PG[15:0] (RW)
 */
/*@{*/
#define BP_ADC_PG_PG         (0U)          /*!< Bit position for ADC_PG_PG. */
#define BM_ADC_PG_PG         (0x0000FFFFU) /*!< Bit mask for ADC_PG_PG. */
#define BS_ADC_PG_PG         (16U)         /*!< Bit field size in bits for ADC_PG_PG. */

/*! @brief Read current value of the ADC_PG_PG field. */
#define BR_ADC_PG_PG(x)      (HW_ADC_PG(x).B.PG)

/*! @brief Format value for bitfield ADC_PG_PG. */
#define BF_ADC_PG_PG(v)      ((uint32_t)((uint32_t)(v) << BP_ADC_PG_PG) & BM_ADC_PG_PG)

/*! @brief Set the PG field to a new value. */
#define BW_ADC_PG_PG(x, v)   (HW_ADC_PG_WR(x, (HW_ADC_PG_RD(x) & ~BM_ADC_PG_PG) | BF_ADC_PG_PG(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_MG - ADC Minus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_MG - ADC Minus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Minus-Side Gain Register (MG) contains the gain error correction for the
 * minus-side input in differential mode. This register is ignored in
 * single-ended mode. MG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between ADMG15 and ADMG14. This register must
 * be written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met.
 */
typedef union _hw_adc_mg
{
    uint32_t U;
    struct _hw_adc_mg_bitfields
    {
        uint32_t MG : 16;              /*!< [15:0] Minus-Side Gain */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_adc_mg_t;

/*!
 * @name Constants and macros for entire ADC_MG register
 */
/*@{*/
#define HW_ADC_MG_ADDR(x)        ((uint32_t)(x) + 0x30U)

#define HW_ADC_MG(x)             (*(__IO hw_adc_mg_t *) HW_ADC_MG_ADDR(x))
#define HW_ADC_MG_RD(x)          (HW_ADC_MG(x).U)
#define HW_ADC_MG_WR(x, v)       (HW_ADC_MG(x).U = (v))
#define HW_ADC_MG_SET(x, v)      (HW_ADC_MG_WR(x, HW_ADC_MG_RD(x) |  (v)))
#define HW_ADC_MG_CLR(x, v)      (HW_ADC_MG_WR(x, HW_ADC_MG_RD(x) & ~(v)))
#define HW_ADC_MG_TOG(x, v)      (HW_ADC_MG_WR(x, HW_ADC_MG_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_MG bitfields
 */

/*!
 * @name Register ADC_MG, field MG[15:0] (RW)
 */
/*@{*/
#define BP_ADC_MG_MG         (0U)          /*!< Bit position for ADC_MG_MG. */
#define BM_ADC_MG_MG         (0x0000FFFFU) /*!< Bit mask for ADC_MG_MG. */
#define BS_ADC_MG_MG         (16U)         /*!< Bit field size in bits for ADC_MG_MG. */

/*! @brief Read current value of the ADC_MG_MG field. */
#define BR_ADC_MG_MG(x)      (HW_ADC_MG(x).B.MG)

/*! @brief Format value for bitfield ADC_MG_MG. */
#define BF_ADC_MG_MG(v)      ((uint32_t)((uint32_t)(v) << BP_ADC_MG_MG) & BM_ADC_MG_MG)

/*! @brief Set the MG field to a new value. */
#define BW_ADC_MG_MG(x, v)   (HW_ADC_MG_WR(x, (HW_ADC_MG_RD(x) & ~BM_ADC_MG_MG) | BF_ADC_MG_MG(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLPD - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLPD - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Plus-Side General Calibration Value Registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLP0[5:0], CLP1[6:0],
 * CLP2[7:0], CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set
 * when the self-calibration sequence is done, that is, CAL is cleared. If these
 * registers are written by the user after calibration, the linearity error
 * specifications may not be met.
 */
typedef union _hw_adc_clpd
{
    uint32_t U;
    struct _hw_adc_clpd_bitfields
    {
        uint32_t CLPD : 6;             /*!< [5:0]  */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clpd_t;

/*!
 * @name Constants and macros for entire ADC_CLPD register
 */
/*@{*/
#define HW_ADC_CLPD_ADDR(x)      ((uint32_t)(x) + 0x34U)

#define HW_ADC_CLPD(x)           (*(__IO hw_adc_clpd_t *) HW_ADC_CLPD_ADDR(x))
#define HW_ADC_CLPD_RD(x)        (HW_ADC_CLPD(x).U)
#define HW_ADC_CLPD_WR(x, v)     (HW_ADC_CLPD(x).U = (v))
#define HW_ADC_CLPD_SET(x, v)    (HW_ADC_CLPD_WR(x, HW_ADC_CLPD_RD(x) |  (v)))
#define HW_ADC_CLPD_CLR(x, v)    (HW_ADC_CLPD_WR(x, HW_ADC_CLPD_RD(x) & ~(v)))
#define HW_ADC_CLPD_TOG(x, v)    (HW_ADC_CLPD_WR(x, HW_ADC_CLPD_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPD bitfields
 */

/*!
 * @name Register ADC_CLPD, field CLPD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLPD_CLPD     (0U)          /*!< Bit position for ADC_CLPD_CLPD. */
#define BM_ADC_CLPD_CLPD     (0x0000003FU) /*!< Bit mask for ADC_CLPD_CLPD. */
#define BS_ADC_CLPD_CLPD     (6U)          /*!< Bit field size in bits for ADC_CLPD_CLPD. */

/*! @brief Read current value of the ADC_CLPD_CLPD field. */
#define BR_ADC_CLPD_CLPD(x)  (HW_ADC_CLPD(x).B.CLPD)

/*! @brief Format value for bitfield ADC_CLPD_CLPD. */
#define BF_ADC_CLPD_CLPD(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLPD_CLPD) & BM_ADC_CLPD_CLPD)

/*! @brief Set the CLPD field to a new value. */
#define BW_ADC_CLPD_CLPD(x, v) (HW_ADC_CLPD_WR(x, (HW_ADC_CLPD_RD(x) & ~BM_ADC_CLPD_CLPD) | BF_ADC_CLPD_CLPD(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLPS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLPS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clps
{
    uint32_t U;
    struct _hw_adc_clps_bitfields
    {
        uint32_t CLPS : 6;             /*!< [5:0]  */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clps_t;

/*!
 * @name Constants and macros for entire ADC_CLPS register
 */
/*@{*/
#define HW_ADC_CLPS_ADDR(x)      ((uint32_t)(x) + 0x38U)

#define HW_ADC_CLPS(x)           (*(__IO hw_adc_clps_t *) HW_ADC_CLPS_ADDR(x))
#define HW_ADC_CLPS_RD(x)        (HW_ADC_CLPS(x).U)
#define HW_ADC_CLPS_WR(x, v)     (HW_ADC_CLPS(x).U = (v))
#define HW_ADC_CLPS_SET(x, v)    (HW_ADC_CLPS_WR(x, HW_ADC_CLPS_RD(x) |  (v)))
#define HW_ADC_CLPS_CLR(x, v)    (HW_ADC_CLPS_WR(x, HW_ADC_CLPS_RD(x) & ~(v)))
#define HW_ADC_CLPS_TOG(x, v)    (HW_ADC_CLPS_WR(x, HW_ADC_CLPS_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS bitfields
 */

/*!
 * @name Register ADC_CLPS, field CLPS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLPS_CLPS     (0U)          /*!< Bit position for ADC_CLPS_CLPS. */
#define BM_ADC_CLPS_CLPS     (0x0000003FU) /*!< Bit mask for ADC_CLPS_CLPS. */
#define BS_ADC_CLPS_CLPS     (6U)          /*!< Bit field size in bits for ADC_CLPS_CLPS. */

/*! @brief Read current value of the ADC_CLPS_CLPS field. */
#define BR_ADC_CLPS_CLPS(x)  (HW_ADC_CLPS(x).B.CLPS)

/*! @brief Format value for bitfield ADC_CLPS_CLPS. */
#define BF_ADC_CLPS_CLPS(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLPS_CLPS) & BM_ADC_CLPS_CLPS)

/*! @brief Set the CLPS field to a new value. */
#define BW_ADC_CLPS_CLPS(x, v) (HW_ADC_CLPS_WR(x, (HW_ADC_CLPS_RD(x) & ~BM_ADC_CLPS_CLPS) | BF_ADC_CLPS_CLPS(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP4 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clp4
{
    uint32_t U;
    struct _hw_adc_clp4_bitfields
    {
        uint32_t CLP4 : 10;            /*!< [9:0]  */
        uint32_t RESERVED0 : 22;       /*!< [31:10]  */
    } B;
} hw_adc_clp4_t;

/*!
 * @name Constants and macros for entire ADC_CLP4 register
 */
/*@{*/
#define HW_ADC_CLP4_ADDR(x)      ((uint32_t)(x) + 0x3CU)

#define HW_ADC_CLP4(x)           (*(__IO hw_adc_clp4_t *) HW_ADC_CLP4_ADDR(x))
#define HW_ADC_CLP4_RD(x)        (HW_ADC_CLP4(x).U)
#define HW_ADC_CLP4_WR(x, v)     (HW_ADC_CLP4(x).U = (v))
#define HW_ADC_CLP4_SET(x, v)    (HW_ADC_CLP4_WR(x, HW_ADC_CLP4_RD(x) |  (v)))
#define HW_ADC_CLP4_CLR(x, v)    (HW_ADC_CLP4_WR(x, HW_ADC_CLP4_RD(x) & ~(v)))
#define HW_ADC_CLP4_TOG(x, v)    (HW_ADC_CLP4_WR(x, HW_ADC_CLP4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP4 bitfields
 */

/*!
 * @name Register ADC_CLP4, field CLP4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLP4_CLP4     (0U)          /*!< Bit position for ADC_CLP4_CLP4. */
#define BM_ADC_CLP4_CLP4     (0x000003FFU) /*!< Bit mask for ADC_CLP4_CLP4. */
#define BS_ADC_CLP4_CLP4     (10U)         /*!< Bit field size in bits for ADC_CLP4_CLP4. */

/*! @brief Read current value of the ADC_CLP4_CLP4 field. */
#define BR_ADC_CLP4_CLP4(x)  (HW_ADC_CLP4(x).B.CLP4)

/*! @brief Format value for bitfield ADC_CLP4_CLP4. */
#define BF_ADC_CLP4_CLP4(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP4_CLP4) & BM_ADC_CLP4_CLP4)

/*! @brief Set the CLP4 field to a new value. */
#define BW_ADC_CLP4_CLP4(x, v) (HW_ADC_CLP4_WR(x, (HW_ADC_CLP4_RD(x) & ~BM_ADC_CLP4_CLP4) | BF_ADC_CLP4_CLP4(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP3 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clp3
{
    uint32_t U;
    struct _hw_adc_clp3_bitfields
    {
        uint32_t CLP3 : 9;             /*!< [8:0]  */
        uint32_t RESERVED0 : 23;       /*!< [31:9]  */
    } B;
} hw_adc_clp3_t;

/*!
 * @name Constants and macros for entire ADC_CLP3 register
 */
/*@{*/
#define HW_ADC_CLP3_ADDR(x)      ((uint32_t)(x) + 0x40U)

#define HW_ADC_CLP3(x)           (*(__IO hw_adc_clp3_t *) HW_ADC_CLP3_ADDR(x))
#define HW_ADC_CLP3_RD(x)        (HW_ADC_CLP3(x).U)
#define HW_ADC_CLP3_WR(x, v)     (HW_ADC_CLP3(x).U = (v))
#define HW_ADC_CLP3_SET(x, v)    (HW_ADC_CLP3_WR(x, HW_ADC_CLP3_RD(x) |  (v)))
#define HW_ADC_CLP3_CLR(x, v)    (HW_ADC_CLP3_WR(x, HW_ADC_CLP3_RD(x) & ~(v)))
#define HW_ADC_CLP3_TOG(x, v)    (HW_ADC_CLP3_WR(x, HW_ADC_CLP3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3 bitfields
 */

/*!
 * @name Register ADC_CLP3, field CLP3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLP3_CLP3     (0U)          /*!< Bit position for ADC_CLP3_CLP3. */
#define BM_ADC_CLP3_CLP3     (0x000001FFU) /*!< Bit mask for ADC_CLP3_CLP3. */
#define BS_ADC_CLP3_CLP3     (9U)          /*!< Bit field size in bits for ADC_CLP3_CLP3. */

/*! @brief Read current value of the ADC_CLP3_CLP3 field. */
#define BR_ADC_CLP3_CLP3(x)  (HW_ADC_CLP3(x).B.CLP3)

/*! @brief Format value for bitfield ADC_CLP3_CLP3. */
#define BF_ADC_CLP3_CLP3(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP3_CLP3) & BM_ADC_CLP3_CLP3)

/*! @brief Set the CLP3 field to a new value. */
#define BW_ADC_CLP3_CLP3(x, v) (HW_ADC_CLP3_WR(x, (HW_ADC_CLP3_RD(x) & ~BM_ADC_CLP3_CLP3) | BF_ADC_CLP3_CLP3(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP2 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clp2
{
    uint32_t U;
    struct _hw_adc_clp2_bitfields
    {
        uint32_t CLP2 : 8;             /*!< [7:0]  */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_clp2_t;

/*!
 * @name Constants and macros for entire ADC_CLP2 register
 */
/*@{*/
#define HW_ADC_CLP2_ADDR(x)      ((uint32_t)(x) + 0x44U)

#define HW_ADC_CLP2(x)           (*(__IO hw_adc_clp2_t *) HW_ADC_CLP2_ADDR(x))
#define HW_ADC_CLP2_RD(x)        (HW_ADC_CLP2(x).U)
#define HW_ADC_CLP2_WR(x, v)     (HW_ADC_CLP2(x).U = (v))
#define HW_ADC_CLP2_SET(x, v)    (HW_ADC_CLP2_WR(x, HW_ADC_CLP2_RD(x) |  (v)))
#define HW_ADC_CLP2_CLR(x, v)    (HW_ADC_CLP2_WR(x, HW_ADC_CLP2_RD(x) & ~(v)))
#define HW_ADC_CLP2_TOG(x, v)    (HW_ADC_CLP2_WR(x, HW_ADC_CLP2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2 bitfields
 */

/*!
 * @name Register ADC_CLP2, field CLP2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLP2_CLP2     (0U)          /*!< Bit position for ADC_CLP2_CLP2. */
#define BM_ADC_CLP2_CLP2     (0x000000FFU) /*!< Bit mask for ADC_CLP2_CLP2. */
#define BS_ADC_CLP2_CLP2     (8U)          /*!< Bit field size in bits for ADC_CLP2_CLP2. */

/*! @brief Read current value of the ADC_CLP2_CLP2 field. */
#define BR_ADC_CLP2_CLP2(x)  (HW_ADC_CLP2(x).B.CLP2)

/*! @brief Format value for bitfield ADC_CLP2_CLP2. */
#define BF_ADC_CLP2_CLP2(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP2_CLP2) & BM_ADC_CLP2_CLP2)

/*! @brief Set the CLP2 field to a new value. */
#define BW_ADC_CLP2_CLP2(x, v) (HW_ADC_CLP2_WR(x, (HW_ADC_CLP2_RD(x) & ~BM_ADC_CLP2_CLP2) | BF_ADC_CLP2_CLP2(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP1 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clp1
{
    uint32_t U;
    struct _hw_adc_clp1_bitfields
    {
        uint32_t CLP1 : 7;             /*!< [6:0]  */
        uint32_t RESERVED0 : 25;       /*!< [31:7]  */
    } B;
} hw_adc_clp1_t;

/*!
 * @name Constants and macros for entire ADC_CLP1 register
 */
/*@{*/
#define HW_ADC_CLP1_ADDR(x)      ((uint32_t)(x) + 0x48U)

#define HW_ADC_CLP1(x)           (*(__IO hw_adc_clp1_t *) HW_ADC_CLP1_ADDR(x))
#define HW_ADC_CLP1_RD(x)        (HW_ADC_CLP1(x).U)
#define HW_ADC_CLP1_WR(x, v)     (HW_ADC_CLP1(x).U = (v))
#define HW_ADC_CLP1_SET(x, v)    (HW_ADC_CLP1_WR(x, HW_ADC_CLP1_RD(x) |  (v)))
#define HW_ADC_CLP1_CLR(x, v)    (HW_ADC_CLP1_WR(x, HW_ADC_CLP1_RD(x) & ~(v)))
#define HW_ADC_CLP1_TOG(x, v)    (HW_ADC_CLP1_WR(x, HW_ADC_CLP1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1 bitfields
 */

/*!
 * @name Register ADC_CLP1, field CLP1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLP1_CLP1     (0U)          /*!< Bit position for ADC_CLP1_CLP1. */
#define BM_ADC_CLP1_CLP1     (0x0000007FU) /*!< Bit mask for ADC_CLP1_CLP1. */
#define BS_ADC_CLP1_CLP1     (7U)          /*!< Bit field size in bits for ADC_CLP1_CLP1. */

/*! @brief Read current value of the ADC_CLP1_CLP1 field. */
#define BR_ADC_CLP1_CLP1(x)  (HW_ADC_CLP1(x).B.CLP1)

/*! @brief Format value for bitfield ADC_CLP1_CLP1. */
#define BF_ADC_CLP1_CLP1(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP1_CLP1) & BM_ADC_CLP1_CLP1)

/*! @brief Set the CLP1 field to a new value. */
#define BW_ADC_CLP1_CLP1(x, v) (HW_ADC_CLP1_WR(x, (HW_ADC_CLP1_RD(x) & ~BM_ADC_CLP1_CLP1) | BF_ADC_CLP1_CLP1(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLP0 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
typedef union _hw_adc_clp0
{
    uint32_t U;
    struct _hw_adc_clp0_bitfields
    {
        uint32_t CLP0 : 6;             /*!< [5:0]  */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clp0_t;

/*!
 * @name Constants and macros for entire ADC_CLP0 register
 */
/*@{*/
#define HW_ADC_CLP0_ADDR(x)      ((uint32_t)(x) + 0x4CU)

#define HW_ADC_CLP0(x)           (*(__IO hw_adc_clp0_t *) HW_ADC_CLP0_ADDR(x))
#define HW_ADC_CLP0_RD(x)        (HW_ADC_CLP0(x).U)
#define HW_ADC_CLP0_WR(x, v)     (HW_ADC_CLP0(x).U = (v))
#define HW_ADC_CLP0_SET(x, v)    (HW_ADC_CLP0_WR(x, HW_ADC_CLP0_RD(x) |  (v)))
#define HW_ADC_CLP0_CLR(x, v)    (HW_ADC_CLP0_WR(x, HW_ADC_CLP0_RD(x) & ~(v)))
#define HW_ADC_CLP0_TOG(x, v)    (HW_ADC_CLP0_WR(x, HW_ADC_CLP0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0 bitfields
 */

/*!
 * @name Register ADC_CLP0, field CLP0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLP0_CLP0     (0U)          /*!< Bit position for ADC_CLP0_CLP0. */
#define BM_ADC_CLP0_CLP0     (0x0000003FU) /*!< Bit mask for ADC_CLP0_CLP0. */
#define BS_ADC_CLP0_CLP0     (6U)          /*!< Bit field size in bits for ADC_CLP0_CLP0. */

/*! @brief Read current value of the ADC_CLP0_CLP0 field. */
#define BR_ADC_CLP0_CLP0(x)  (HW_ADC_CLP0(x).B.CLP0)

/*! @brief Format value for bitfield ADC_CLP0_CLP0. */
#define BF_ADC_CLP0_CLP0(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLP0_CLP0) & BM_ADC_CLP0_CLP0)

/*! @brief Set the CLP0 field to a new value. */
#define BW_ADC_CLP0_CLP0(x, v) (HW_ADC_CLP0_WR(x, (HW_ADC_CLP0_RD(x) & ~BM_ADC_CLP0_CLP0) | BF_ADC_CLP0_CLP0(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLMD - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLMD - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Minus-Side General Calibration Value (CLMx) registers contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLM0[5:0], CLM1[6:0],
 * CLM2[7:0], CLM3[8:0], CLM4[9:0], CLMS[5:0], and CLMD[5:0]. CLMx are automatically
 * set when the self-calibration sequence is done, that is, CAL is cleared. If
 * these registers are written by the user after calibration, the linearity error
 * specifications may not be met.
 */
typedef union _hw_adc_clmd
{
    uint32_t U;
    struct _hw_adc_clmd_bitfields
    {
        uint32_t CLMD : 6;             /*!< [5:0]  */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clmd_t;

/*!
 * @name Constants and macros for entire ADC_CLMD register
 */
/*@{*/
#define HW_ADC_CLMD_ADDR(x)      ((uint32_t)(x) + 0x54U)

#define HW_ADC_CLMD(x)           (*(__IO hw_adc_clmd_t *) HW_ADC_CLMD_ADDR(x))
#define HW_ADC_CLMD_RD(x)        (HW_ADC_CLMD(x).U)
#define HW_ADC_CLMD_WR(x, v)     (HW_ADC_CLMD(x).U = (v))
#define HW_ADC_CLMD_SET(x, v)    (HW_ADC_CLMD_WR(x, HW_ADC_CLMD_RD(x) |  (v)))
#define HW_ADC_CLMD_CLR(x, v)    (HW_ADC_CLMD_WR(x, HW_ADC_CLMD_RD(x) & ~(v)))
#define HW_ADC_CLMD_TOG(x, v)    (HW_ADC_CLMD_WR(x, HW_ADC_CLMD_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMD bitfields
 */

/*!
 * @name Register ADC_CLMD, field CLMD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLMD_CLMD     (0U)          /*!< Bit position for ADC_CLMD_CLMD. */
#define BM_ADC_CLMD_CLMD     (0x0000003FU) /*!< Bit mask for ADC_CLMD_CLMD. */
#define BS_ADC_CLMD_CLMD     (6U)          /*!< Bit field size in bits for ADC_CLMD_CLMD. */

/*! @brief Read current value of the ADC_CLMD_CLMD field. */
#define BR_ADC_CLMD_CLMD(x)  (HW_ADC_CLMD(x).B.CLMD)

/*! @brief Format value for bitfield ADC_CLMD_CLMD. */
#define BF_ADC_CLMD_CLMD(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLMD_CLMD) & BM_ADC_CLMD_CLMD)

/*! @brief Set the CLMD field to a new value. */
#define BW_ADC_CLMD_CLMD(x, v) (HW_ADC_CLMD_WR(x, (HW_ADC_CLMD_RD(x) & ~BM_ADC_CLMD_CLMD) | BF_ADC_CLMD_CLMD(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLMS - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLMS - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clms
{
    uint32_t U;
    struct _hw_adc_clms_bitfields
    {
        uint32_t CLMS : 6;             /*!< [5:0]  */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clms_t;

/*!
 * @name Constants and macros for entire ADC_CLMS register
 */
/*@{*/
#define HW_ADC_CLMS_ADDR(x)      ((uint32_t)(x) + 0x58U)

#define HW_ADC_CLMS(x)           (*(__IO hw_adc_clms_t *) HW_ADC_CLMS_ADDR(x))
#define HW_ADC_CLMS_RD(x)        (HW_ADC_CLMS(x).U)
#define HW_ADC_CLMS_WR(x, v)     (HW_ADC_CLMS(x).U = (v))
#define HW_ADC_CLMS_SET(x, v)    (HW_ADC_CLMS_WR(x, HW_ADC_CLMS_RD(x) |  (v)))
#define HW_ADC_CLMS_CLR(x, v)    (HW_ADC_CLMS_WR(x, HW_ADC_CLMS_RD(x) & ~(v)))
#define HW_ADC_CLMS_TOG(x, v)    (HW_ADC_CLMS_WR(x, HW_ADC_CLMS_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMS bitfields
 */

/*!
 * @name Register ADC_CLMS, field CLMS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLMS_CLMS     (0U)          /*!< Bit position for ADC_CLMS_CLMS. */
#define BM_ADC_CLMS_CLMS     (0x0000003FU) /*!< Bit mask for ADC_CLMS_CLMS. */
#define BS_ADC_CLMS_CLMS     (6U)          /*!< Bit field size in bits for ADC_CLMS_CLMS. */

/*! @brief Read current value of the ADC_CLMS_CLMS field. */
#define BR_ADC_CLMS_CLMS(x)  (HW_ADC_CLMS(x).B.CLMS)

/*! @brief Format value for bitfield ADC_CLMS_CLMS. */
#define BF_ADC_CLMS_CLMS(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLMS_CLMS) & BM_ADC_CLMS_CLMS)

/*! @brief Set the CLMS field to a new value. */
#define BW_ADC_CLMS_CLMS(x, v) (HW_ADC_CLMS_WR(x, (HW_ADC_CLMS_RD(x) & ~BM_ADC_CLMS_CLMS) | BF_ADC_CLMS_CLMS(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLM4 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clm4
{
    uint32_t U;
    struct _hw_adc_clm4_bitfields
    {
        uint32_t CLM4 : 10;            /*!< [9:0]  */
        uint32_t RESERVED0 : 22;       /*!< [31:10]  */
    } B;
} hw_adc_clm4_t;

/*!
 * @name Constants and macros for entire ADC_CLM4 register
 */
/*@{*/
#define HW_ADC_CLM4_ADDR(x)      ((uint32_t)(x) + 0x5CU)

#define HW_ADC_CLM4(x)           (*(__IO hw_adc_clm4_t *) HW_ADC_CLM4_ADDR(x))
#define HW_ADC_CLM4_RD(x)        (HW_ADC_CLM4(x).U)
#define HW_ADC_CLM4_WR(x, v)     (HW_ADC_CLM4(x).U = (v))
#define HW_ADC_CLM4_SET(x, v)    (HW_ADC_CLM4_WR(x, HW_ADC_CLM4_RD(x) |  (v)))
#define HW_ADC_CLM4_CLR(x, v)    (HW_ADC_CLM4_WR(x, HW_ADC_CLM4_RD(x) & ~(v)))
#define HW_ADC_CLM4_TOG(x, v)    (HW_ADC_CLM4_WR(x, HW_ADC_CLM4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM4 bitfields
 */

/*!
 * @name Register ADC_CLM4, field CLM4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLM4_CLM4     (0U)          /*!< Bit position for ADC_CLM4_CLM4. */
#define BM_ADC_CLM4_CLM4     (0x000003FFU) /*!< Bit mask for ADC_CLM4_CLM4. */
#define BS_ADC_CLM4_CLM4     (10U)         /*!< Bit field size in bits for ADC_CLM4_CLM4. */

/*! @brief Read current value of the ADC_CLM4_CLM4 field. */
#define BR_ADC_CLM4_CLM4(x)  (HW_ADC_CLM4(x).B.CLM4)

/*! @brief Format value for bitfield ADC_CLM4_CLM4. */
#define BF_ADC_CLM4_CLM4(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLM4_CLM4) & BM_ADC_CLM4_CLM4)

/*! @brief Set the CLM4 field to a new value. */
#define BW_ADC_CLM4_CLM4(x, v) (HW_ADC_CLM4_WR(x, (HW_ADC_CLM4_RD(x) & ~BM_ADC_CLM4_CLM4) | BF_ADC_CLM4_CLM4(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLM3 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clm3
{
    uint32_t U;
    struct _hw_adc_clm3_bitfields
    {
        uint32_t CLM3 : 9;             /*!< [8:0]  */
        uint32_t RESERVED0 : 23;       /*!< [31:9]  */
    } B;
} hw_adc_clm3_t;

/*!
 * @name Constants and macros for entire ADC_CLM3 register
 */
/*@{*/
#define HW_ADC_CLM3_ADDR(x)      ((uint32_t)(x) + 0x60U)

#define HW_ADC_CLM3(x)           (*(__IO hw_adc_clm3_t *) HW_ADC_CLM3_ADDR(x))
#define HW_ADC_CLM3_RD(x)        (HW_ADC_CLM3(x).U)
#define HW_ADC_CLM3_WR(x, v)     (HW_ADC_CLM3(x).U = (v))
#define HW_ADC_CLM3_SET(x, v)    (HW_ADC_CLM3_WR(x, HW_ADC_CLM3_RD(x) |  (v)))
#define HW_ADC_CLM3_CLR(x, v)    (HW_ADC_CLM3_WR(x, HW_ADC_CLM3_RD(x) & ~(v)))
#define HW_ADC_CLM3_TOG(x, v)    (HW_ADC_CLM3_WR(x, HW_ADC_CLM3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM3 bitfields
 */

/*!
 * @name Register ADC_CLM3, field CLM3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLM3_CLM3     (0U)          /*!< Bit position for ADC_CLM3_CLM3. */
#define BM_ADC_CLM3_CLM3     (0x000001FFU) /*!< Bit mask for ADC_CLM3_CLM3. */
#define BS_ADC_CLM3_CLM3     (9U)          /*!< Bit field size in bits for ADC_CLM3_CLM3. */

/*! @brief Read current value of the ADC_CLM3_CLM3 field. */
#define BR_ADC_CLM3_CLM3(x)  (HW_ADC_CLM3(x).B.CLM3)

/*! @brief Format value for bitfield ADC_CLM3_CLM3. */
#define BF_ADC_CLM3_CLM3(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLM3_CLM3) & BM_ADC_CLM3_CLM3)

/*! @brief Set the CLM3 field to a new value. */
#define BW_ADC_CLM3_CLM3(x, v) (HW_ADC_CLM3_WR(x, (HW_ADC_CLM3_RD(x) & ~BM_ADC_CLM3_CLM3) | BF_ADC_CLM3_CLM3(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLM2 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clm2
{
    uint32_t U;
    struct _hw_adc_clm2_bitfields
    {
        uint32_t CLM2 : 8;             /*!< [7:0]  */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_adc_clm2_t;

/*!
 * @name Constants and macros for entire ADC_CLM2 register
 */
/*@{*/
#define HW_ADC_CLM2_ADDR(x)      ((uint32_t)(x) + 0x64U)

#define HW_ADC_CLM2(x)           (*(__IO hw_adc_clm2_t *) HW_ADC_CLM2_ADDR(x))
#define HW_ADC_CLM2_RD(x)        (HW_ADC_CLM2(x).U)
#define HW_ADC_CLM2_WR(x, v)     (HW_ADC_CLM2(x).U = (v))
#define HW_ADC_CLM2_SET(x, v)    (HW_ADC_CLM2_WR(x, HW_ADC_CLM2_RD(x) |  (v)))
#define HW_ADC_CLM2_CLR(x, v)    (HW_ADC_CLM2_WR(x, HW_ADC_CLM2_RD(x) & ~(v)))
#define HW_ADC_CLM2_TOG(x, v)    (HW_ADC_CLM2_WR(x, HW_ADC_CLM2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM2 bitfields
 */

/*!
 * @name Register ADC_CLM2, field CLM2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLM2_CLM2     (0U)          /*!< Bit position for ADC_CLM2_CLM2. */
#define BM_ADC_CLM2_CLM2     (0x000000FFU) /*!< Bit mask for ADC_CLM2_CLM2. */
#define BS_ADC_CLM2_CLM2     (8U)          /*!< Bit field size in bits for ADC_CLM2_CLM2. */

/*! @brief Read current value of the ADC_CLM2_CLM2 field. */
#define BR_ADC_CLM2_CLM2(x)  (HW_ADC_CLM2(x).B.CLM2)

/*! @brief Format value for bitfield ADC_CLM2_CLM2. */
#define BF_ADC_CLM2_CLM2(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLM2_CLM2) & BM_ADC_CLM2_CLM2)

/*! @brief Set the CLM2 field to a new value. */
#define BW_ADC_CLM2_CLM2(x, v) (HW_ADC_CLM2_WR(x, (HW_ADC_CLM2_RD(x) & ~BM_ADC_CLM2_CLM2) | BF_ADC_CLM2_CLM2(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLM1 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clm1
{
    uint32_t U;
    struct _hw_adc_clm1_bitfields
    {
        uint32_t CLM1 : 7;             /*!< [6:0]  */
        uint32_t RESERVED0 : 25;       /*!< [31:7]  */
    } B;
} hw_adc_clm1_t;

/*!
 * @name Constants and macros for entire ADC_CLM1 register
 */
/*@{*/
#define HW_ADC_CLM1_ADDR(x)      ((uint32_t)(x) + 0x68U)

#define HW_ADC_CLM1(x)           (*(__IO hw_adc_clm1_t *) HW_ADC_CLM1_ADDR(x))
#define HW_ADC_CLM1_RD(x)        (HW_ADC_CLM1(x).U)
#define HW_ADC_CLM1_WR(x, v)     (HW_ADC_CLM1(x).U = (v))
#define HW_ADC_CLM1_SET(x, v)    (HW_ADC_CLM1_WR(x, HW_ADC_CLM1_RD(x) |  (v)))
#define HW_ADC_CLM1_CLR(x, v)    (HW_ADC_CLM1_WR(x, HW_ADC_CLM1_RD(x) & ~(v)))
#define HW_ADC_CLM1_TOG(x, v)    (HW_ADC_CLM1_WR(x, HW_ADC_CLM1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM1 bitfields
 */

/*!
 * @name Register ADC_CLM1, field CLM1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLM1_CLM1     (0U)          /*!< Bit position for ADC_CLM1_CLM1. */
#define BM_ADC_CLM1_CLM1     (0x0000007FU) /*!< Bit mask for ADC_CLM1_CLM1. */
#define BS_ADC_CLM1_CLM1     (7U)          /*!< Bit field size in bits for ADC_CLM1_CLM1. */

/*! @brief Read current value of the ADC_CLM1_CLM1 field. */
#define BR_ADC_CLM1_CLM1(x)  (HW_ADC_CLM1(x).B.CLM1)

/*! @brief Format value for bitfield ADC_CLM1_CLM1. */
#define BF_ADC_CLM1_CLM1(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLM1_CLM1) & BM_ADC_CLM1_CLM1)

/*! @brief Set the CLM1 field to a new value. */
#define BW_ADC_CLM1_CLM1(x, v) (HW_ADC_CLM1_WR(x, (HW_ADC_CLM1_RD(x) & ~BM_ADC_CLM1_CLM1) | BF_ADC_CLM1_CLM1(v)))
/*@}*/

/*******************************************************************************
 * HW_ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief HW_ADC_CLM0 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
typedef union _hw_adc_clm0
{
    uint32_t U;
    struct _hw_adc_clm0_bitfields
    {
        uint32_t CLM0 : 6;             /*!< [5:0]  */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_adc_clm0_t;

/*!
 * @name Constants and macros for entire ADC_CLM0 register
 */
/*@{*/
#define HW_ADC_CLM0_ADDR(x)      ((uint32_t)(x) + 0x6CU)

#define HW_ADC_CLM0(x)           (*(__IO hw_adc_clm0_t *) HW_ADC_CLM0_ADDR(x))
#define HW_ADC_CLM0_RD(x)        (HW_ADC_CLM0(x).U)
#define HW_ADC_CLM0_WR(x, v)     (HW_ADC_CLM0(x).U = (v))
#define HW_ADC_CLM0_SET(x, v)    (HW_ADC_CLM0_WR(x, HW_ADC_CLM0_RD(x) |  (v)))
#define HW_ADC_CLM0_CLR(x, v)    (HW_ADC_CLM0_WR(x, HW_ADC_CLM0_RD(x) & ~(v)))
#define HW_ADC_CLM0_TOG(x, v)    (HW_ADC_CLM0_WR(x, HW_ADC_CLM0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM0 bitfields
 */

/*!
 * @name Register ADC_CLM0, field CLM0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
#define BP_ADC_CLM0_CLM0     (0U)          /*!< Bit position for ADC_CLM0_CLM0. */
#define BM_ADC_CLM0_CLM0     (0x0000003FU) /*!< Bit mask for ADC_CLM0_CLM0. */
#define BS_ADC_CLM0_CLM0     (6U)          /*!< Bit field size in bits for ADC_CLM0_CLM0. */

/*! @brief Read current value of the ADC_CLM0_CLM0 field. */
#define BR_ADC_CLM0_CLM0(x)  (HW_ADC_CLM0(x).B.CLM0)

/*! @brief Format value for bitfield ADC_CLM0_CLM0. */
#define BF_ADC_CLM0_CLM0(v)  ((uint32_t)((uint32_t)(v) << BP_ADC_CLM0_CLM0) & BM_ADC_CLM0_CLM0)

/*! @brief Set the CLM0 field to a new value. */
#define BW_ADC_CLM0_CLM0(x, v) (HW_ADC_CLM0_WR(x, (HW_ADC_CLM0_RD(x) & ~BM_ADC_CLM0_CLM0) | BF_ADC_CLM0_CLM0(v)))
/*@}*/

/*******************************************************************************
 * hw_adc_t - module struct
 ******************************************************************************/
/*!
 * @brief All ADC module registers.
 */
#pragma pack(1)
typedef struct _hw_adc
{
    __IO hw_adc_sc1n_t SC1n[2];            /*!< [0x0] ADC Status and Control Registers 1 */
    __IO hw_adc_cfg1_t CFG1;               /*!< [0x8] ADC Configuration Register 1 */
    __IO hw_adc_cfg2_t CFG2;               /*!< [0xC] ADC Configuration Register 2 */
    __I hw_adc_rn_t Rn[2];                 /*!< [0x10] ADC Data Result Register */
    __IO hw_adc_cv1_t CV1;                 /*!< [0x18] Compare Value Registers */
    __IO hw_adc_cv2_t CV2;                 /*!< [0x1C] Compare Value Registers */
    __IO hw_adc_sc2_t SC2;                 /*!< [0x20] Status and Control Register 2 */
    __IO hw_adc_sc3_t SC3;                 /*!< [0x24] Status and Control Register 3 */
    __IO hw_adc_ofs_t OFS;                 /*!< [0x28] ADC Offset Correction Register */
    __IO hw_adc_pg_t PG;                   /*!< [0x2C] ADC Plus-Side Gain Register */
    __IO hw_adc_mg_t MG;                   /*!< [0x30] ADC Minus-Side Gain Register */
    __IO hw_adc_clpd_t CLPD;               /*!< [0x34] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clps_t CLPS;               /*!< [0x38] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clp4_t CLP4;               /*!< [0x3C] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clp3_t CLP3;               /*!< [0x40] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clp2_t CLP2;               /*!< [0x44] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clp1_t CLP1;               /*!< [0x48] ADC Plus-Side General Calibration Value Register */
    __IO hw_adc_clp0_t CLP0;               /*!< [0x4C] ADC Plus-Side General Calibration Value Register */
    uint8_t _reserved0[4];
    __IO hw_adc_clmd_t CLMD;               /*!< [0x54] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clms_t CLMS;               /*!< [0x58] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clm4_t CLM4;               /*!< [0x5C] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clm3_t CLM3;               /*!< [0x60] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clm2_t CLM2;               /*!< [0x64] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clm1_t CLM1;               /*!< [0x68] ADC Minus-Side General Calibration Value Register */
    __IO hw_adc_clm0_t CLM0;               /*!< [0x6C] ADC Minus-Side General Calibration Value Register */
} hw_adc_t;
#pragma pack()

/*! @brief Macro to access all ADC registers. */
/*! @param x ADC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_ADC_REGS(ADC0_BASE)</code>. */
#define HW_ADC_REGS(x) (*(hw_adc_t *)(x))

/*
 * MK64F12 AIPS
 *
 * AIPS-Lite Bridge
 *
 * Registers defined in this header file:
 * - HW_AIPS_MPRA - Master Privilege Register A
 * - HW_AIPS_PACRA - Peripheral Access Control Register
 * - HW_AIPS_PACRB - Peripheral Access Control Register
 * - HW_AIPS_PACRC - Peripheral Access Control Register
 * - HW_AIPS_PACRD - Peripheral Access Control Register
 * - HW_AIPS_PACRE - Peripheral Access Control Register
 * - HW_AIPS_PACRF - Peripheral Access Control Register
 * - HW_AIPS_PACRG - Peripheral Access Control Register
 * - HW_AIPS_PACRH - Peripheral Access Control Register
 * - HW_AIPS_PACRI - Peripheral Access Control Register
 * - HW_AIPS_PACRJ - Peripheral Access Control Register
 * - HW_AIPS_PACRK - Peripheral Access Control Register
 * - HW_AIPS_PACRL - Peripheral Access Control Register
 * - HW_AIPS_PACRM - Peripheral Access Control Register
 * - HW_AIPS_PACRN - Peripheral Access Control Register
 * - HW_AIPS_PACRO - Peripheral Access Control Register
 * - HW_AIPS_PACRP - Peripheral Access Control Register
 * - HW_AIPS_PACRU - Peripheral Access Control Register
 *
 * - hw_aips_t - Struct containing all module registers.
 */

#define HW_AIPS_INSTANCE_COUNT (2U) /*!< Number of instances of the AIPS module. */
#define HW_AIPS0 (0U) /*!< Instance number for AIPS0. */
#define HW_AIPS1 (1U) /*!< Instance number for AIPS1. */

/*******************************************************************************
 * HW_AIPS_MPRA - Master Privilege Register A
 ******************************************************************************/

/*!
 * @brief HW_AIPS_MPRA - Master Privilege Register A (RW)
 *
 * Reset value: 0x77700000U
 *
 * The MPRA specifies identical 4-bit fields defining the access-privilege level
 * associated with a bus master to various peripherals on the chip. The register
 * provides one field per bus master. At reset, the default value loaded into
 * the MPRA fields is chip-specific. See the chip configuration details for the
 * value of a particular device. A register field that maps to an unimplemented
 * master or peripheral behaves as read-only-zero. Each master is assigned a logical
 * ID from 0 to 15. See the master logical ID assignment table in the
 * chip-specific AIPS information.
 */
typedef union _hw_aips_mpra
{
    uint32_t U;
    struct _hw_aips_mpra_bitfields
    {
        uint32_t RESERVED0 : 8;        /*!< [7:0]  */
        uint32_t MPL5 : 1;             /*!< [8] Master 5 Privilege Level */
        uint32_t MTW5 : 1;             /*!< [9] Master 5 Trusted For Writes */
        uint32_t MTR5 : 1;             /*!< [10] Master 5 Trusted For Read */
        uint32_t RESERVED1 : 1;        /*!< [11]  */
        uint32_t MPL4 : 1;             /*!< [12] Master 4 Privilege Level */
        uint32_t MTW4 : 1;             /*!< [13] Master 4 Trusted For Writes */
        uint32_t MTR4 : 1;             /*!< [14] Master 4 Trusted For Read */
        uint32_t RESERVED2 : 1;        /*!< [15]  */
        uint32_t MPL3 : 1;             /*!< [16] Master 3 Privilege Level */
        uint32_t MTW3 : 1;             /*!< [17] Master 3 Trusted For Writes */
        uint32_t MTR3 : 1;             /*!< [18] Master 3 Trusted For Read */
        uint32_t RESERVED3 : 1;        /*!< [19]  */
        uint32_t MPL2 : 1;             /*!< [20] Master 2 Privilege Level */
        uint32_t MTW2 : 1;             /*!< [21] Master 2 Trusted For Writes */
        uint32_t MTR2 : 1;             /*!< [22] Master 2 Trusted For Read */
        uint32_t RESERVED4 : 1;        /*!< [23]  */
        uint32_t MPL1 : 1;             /*!< [24] Master 1 Privilege Level */
        uint32_t MTW1 : 1;             /*!< [25] Master 1 Trusted for Writes */
        uint32_t MTR1 : 1;             /*!< [26] Master 1 Trusted for Read */
        uint32_t RESERVED5 : 1;        /*!< [27]  */
        uint32_t MPL0 : 1;             /*!< [28] Master 0 Privilege Level */
        uint32_t MTW0 : 1;             /*!< [29] Master 0 Trusted For Writes */
        uint32_t MTR0 : 1;             /*!< [30] Master 0 Trusted For Read */
        uint32_t RESERVED6 : 1;        /*!< [31]  */
    } B;
} hw_aips_mpra_t;

/*!
 * @name Constants and macros for entire AIPS_MPRA register
 */
/*@{*/
#define HW_AIPS_MPRA_ADDR(x)     ((uint32_t)(x) + 0x0U)

#define HW_AIPS_MPRA(x)          (*(__IO hw_aips_mpra_t *) HW_AIPS_MPRA_ADDR(x))
#define HW_AIPS_MPRA_RD(x)       (HW_AIPS_MPRA(x).U)
#define HW_AIPS_MPRA_WR(x, v)    (HW_AIPS_MPRA(x).U = (v))
#define HW_AIPS_MPRA_SET(x, v)   (HW_AIPS_MPRA_WR(x, HW_AIPS_MPRA_RD(x) |  (v)))
#define HW_AIPS_MPRA_CLR(x, v)   (HW_AIPS_MPRA_WR(x, HW_AIPS_MPRA_RD(x) & ~(v)))
#define HW_AIPS_MPRA_TOG(x, v)   (HW_AIPS_MPRA_WR(x, HW_AIPS_MPRA_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_MPRA bitfields
 */

/*!
 * @name Register AIPS_MPRA, field MPL5[8] (RW)
 *
 * Specifies how the privilege level of the master is determined.
 *
 * Values:
 * - 0 - Accesses from this master are forced to user-mode.
 * - 1 - Accesses from this master are not forced to user-mode.
 */
/*@{*/
#define BP_AIPS_MPRA_MPL5    (8U)          /*!< Bit position for AIPS_MPRA_MPL5. */
#define BM_AIPS_MPRA_MPL5    (0x00000100U) /*!< Bit mask for AIPS_MPRA_MPL5. */
#define BS_AIPS_MPRA_MPL5    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MPL5. */

/*! @brief Read current value of the AIPS_MPRA_MPL5 field. */
#define BR_AIPS_MPRA_MPL5(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL5))

/*! @brief Format value for bitfield AIPS_MPRA_MPL5. */
#define BF_AIPS_MPRA_MPL5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MPL5) & BM_AIPS_MPRA_MPL5)

/*! @brief Set the MPL5 field to a new value. */
#define BW_AIPS_MPRA_MPL5(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL5) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTW5[9] (RW)
 *
 * Determines whether the master is trusted for write accesses.
 *
 * Values:
 * - 0 - This master is not trusted for write accesses.
 * - 1 - This master is trusted for write accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTW5    (9U)          /*!< Bit position for AIPS_MPRA_MTW5. */
#define BM_AIPS_MPRA_MTW5    (0x00000200U) /*!< Bit mask for AIPS_MPRA_MTW5. */
#define BS_AIPS_MPRA_MTW5    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTW5. */

/*! @brief Read current value of the AIPS_MPRA_MTW5 field. */
#define BR_AIPS_MPRA_MTW5(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW5))

/*! @brief Format value for bitfield AIPS_MPRA_MTW5. */
#define BF_AIPS_MPRA_MTW5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTW5) & BM_AIPS_MPRA_MTW5)

/*! @brief Set the MTW5 field to a new value. */
#define BW_AIPS_MPRA_MTW5(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW5) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTR5[10] (RW)
 *
 * Determines whether the master is trusted for read accesses.
 *
 * Values:
 * - 0 - This master is not trusted for read accesses.
 * - 1 - This master is trusted for read accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTR5    (10U)         /*!< Bit position for AIPS_MPRA_MTR5. */
#define BM_AIPS_MPRA_MTR5    (0x00000400U) /*!< Bit mask for AIPS_MPRA_MTR5. */
#define BS_AIPS_MPRA_MTR5    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTR5. */

/*! @brief Read current value of the AIPS_MPRA_MTR5 field. */
#define BR_AIPS_MPRA_MTR5(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR5))

/*! @brief Format value for bitfield AIPS_MPRA_MTR5. */
#define BF_AIPS_MPRA_MTR5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTR5) & BM_AIPS_MPRA_MTR5)

/*! @brief Set the MTR5 field to a new value. */
#define BW_AIPS_MPRA_MTR5(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR5) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MPL4[12] (RW)
 *
 * Specifies how the privilege level of the master is determined.
 *
 * Values:
 * - 0 - Accesses from this master are forced to user-mode.
 * - 1 - Accesses from this master are not forced to user-mode.
 */
/*@{*/
#define BP_AIPS_MPRA_MPL4    (12U)         /*!< Bit position for AIPS_MPRA_MPL4. */
#define BM_AIPS_MPRA_MPL4    (0x00001000U) /*!< Bit mask for AIPS_MPRA_MPL4. */
#define BS_AIPS_MPRA_MPL4    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MPL4. */

/*! @brief Read current value of the AIPS_MPRA_MPL4 field. */
#define BR_AIPS_MPRA_MPL4(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL4))

/*! @brief Format value for bitfield AIPS_MPRA_MPL4. */
#define BF_AIPS_MPRA_MPL4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MPL4) & BM_AIPS_MPRA_MPL4)

/*! @brief Set the MPL4 field to a new value. */
#define BW_AIPS_MPRA_MPL4(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL4) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTW4[13] (RW)
 *
 * Determines whether the master is trusted for write accesses.
 *
 * Values:
 * - 0 - This master is not trusted for write accesses.
 * - 1 - This master is trusted for write accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTW4    (13U)         /*!< Bit position for AIPS_MPRA_MTW4. */
#define BM_AIPS_MPRA_MTW4    (0x00002000U) /*!< Bit mask for AIPS_MPRA_MTW4. */
#define BS_AIPS_MPRA_MTW4    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTW4. */

/*! @brief Read current value of the AIPS_MPRA_MTW4 field. */
#define BR_AIPS_MPRA_MTW4(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW4))

/*! @brief Format value for bitfield AIPS_MPRA_MTW4. */
#define BF_AIPS_MPRA_MTW4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTW4) & BM_AIPS_MPRA_MTW4)

/*! @brief Set the MTW4 field to a new value. */
#define BW_AIPS_MPRA_MTW4(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW4) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTR4[14] (RW)
 *
 * Determines whether the master is trusted for read accesses.
 *
 * Values:
 * - 0 - This master is not trusted for read accesses.
 * - 1 - This master is trusted for read accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTR4    (14U)         /*!< Bit position for AIPS_MPRA_MTR4. */
#define BM_AIPS_MPRA_MTR4    (0x00004000U) /*!< Bit mask for AIPS_MPRA_MTR4. */
#define BS_AIPS_MPRA_MTR4    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTR4. */

/*! @brief Read current value of the AIPS_MPRA_MTR4 field. */
#define BR_AIPS_MPRA_MTR4(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR4))

/*! @brief Format value for bitfield AIPS_MPRA_MTR4. */
#define BF_AIPS_MPRA_MTR4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTR4) & BM_AIPS_MPRA_MTR4)

/*! @brief Set the MTR4 field to a new value. */
#define BW_AIPS_MPRA_MTR4(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR4) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MPL3[16] (RW)
 *
 * Specifies how the privilege level of the master is determined.
 *
 * Values:
 * - 0 - Accesses from this master are forced to user-mode.
 * - 1 - Accesses from this master are not forced to user-mode.
 */
/*@{*/
#define BP_AIPS_MPRA_MPL3    (16U)         /*!< Bit position for AIPS_MPRA_MPL3. */
#define BM_AIPS_MPRA_MPL3    (0x00010000U) /*!< Bit mask for AIPS_MPRA_MPL3. */
#define BS_AIPS_MPRA_MPL3    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MPL3. */

/*! @brief Read current value of the AIPS_MPRA_MPL3 field. */
#define BR_AIPS_MPRA_MPL3(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL3))

/*! @brief Format value for bitfield AIPS_MPRA_MPL3. */
#define BF_AIPS_MPRA_MPL3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MPL3) & BM_AIPS_MPRA_MPL3)

/*! @brief Set the MPL3 field to a new value. */
#define BW_AIPS_MPRA_MPL3(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL3) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTW3[17] (RW)
 *
 * Determines whether the master is trusted for write accesses.
 *
 * Values:
 * - 0 - This master is not trusted for write accesses.
 * - 1 - This master is trusted for write accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTW3    (17U)         /*!< Bit position for AIPS_MPRA_MTW3. */
#define BM_AIPS_MPRA_MTW3    (0x00020000U) /*!< Bit mask for AIPS_MPRA_MTW3. */
#define BS_AIPS_MPRA_MTW3    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTW3. */

/*! @brief Read current value of the AIPS_MPRA_MTW3 field. */
#define BR_AIPS_MPRA_MTW3(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW3))

/*! @brief Format value for bitfield AIPS_MPRA_MTW3. */
#define BF_AIPS_MPRA_MTW3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTW3) & BM_AIPS_MPRA_MTW3)

/*! @brief Set the MTW3 field to a new value. */
#define BW_AIPS_MPRA_MTW3(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW3) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTR3[18] (RW)
 *
 * Determines whether the master is trusted for read accesses.
 *
 * Values:
 * - 0 - This master is not trusted for read accesses.
 * - 1 - This master is trusted for read accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTR3    (18U)         /*!< Bit position for AIPS_MPRA_MTR3. */
#define BM_AIPS_MPRA_MTR3    (0x00040000U) /*!< Bit mask for AIPS_MPRA_MTR3. */
#define BS_AIPS_MPRA_MTR3    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTR3. */

/*! @brief Read current value of the AIPS_MPRA_MTR3 field. */
#define BR_AIPS_MPRA_MTR3(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR3))

/*! @brief Format value for bitfield AIPS_MPRA_MTR3. */
#define BF_AIPS_MPRA_MTR3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTR3) & BM_AIPS_MPRA_MTR3)

/*! @brief Set the MTR3 field to a new value. */
#define BW_AIPS_MPRA_MTR3(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR3) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MPL2[20] (RW)
 *
 * Specifies how the privilege level of the master is determined.
 *
 * Values:
 * - 0 - Accesses from this master are forced to user-mode.
 * - 1 - Accesses from this master are not forced to user-mode.
 */
/*@{*/
#define BP_AIPS_MPRA_MPL2    (20U)         /*!< Bit position for AIPS_MPRA_MPL2. */
#define BM_AIPS_MPRA_MPL2    (0x00100000U) /*!< Bit mask for AIPS_MPRA_MPL2. */
#define BS_AIPS_MPRA_MPL2    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MPL2. */

/*! @brief Read current value of the AIPS_MPRA_MPL2 field. */
#define BR_AIPS_MPRA_MPL2(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL2))

/*! @brief Format value for bitfield AIPS_MPRA_MPL2. */
#define BF_AIPS_MPRA_MPL2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MPL2) & BM_AIPS_MPRA_MPL2)

/*! @brief Set the MPL2 field to a new value. */
#define BW_AIPS_MPRA_MPL2(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL2) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTW2[21] (RW)
 *
 * Determines whether the master is trusted for write accesses.
 *
 * Values:
 * - 0 - This master is not trusted for write accesses.
 * - 1 - This master is trusted for write accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTW2    (21U)         /*!< Bit position for AIPS_MPRA_MTW2. */
#define BM_AIPS_MPRA_MTW2    (0x00200000U) /*!< Bit mask for AIPS_MPRA_MTW2. */
#define BS_AIPS_MPRA_MTW2    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTW2. */

/*! @brief Read current value of the AIPS_MPRA_MTW2 field. */
#define BR_AIPS_MPRA_MTW2(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW2))

/*! @brief Format value for bitfield AIPS_MPRA_MTW2. */
#define BF_AIPS_MPRA_MTW2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTW2) & BM_AIPS_MPRA_MTW2)

/*! @brief Set the MTW2 field to a new value. */
#define BW_AIPS_MPRA_MTW2(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW2) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTR2[22] (RW)
 *
 * Determines whether the master is trusted for read accesses.
 *
 * Values:
 * - 0 - This master is not trusted for read accesses.
 * - 1 - This master is trusted for read accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTR2    (22U)         /*!< Bit position for AIPS_MPRA_MTR2. */
#define BM_AIPS_MPRA_MTR2    (0x00400000U) /*!< Bit mask for AIPS_MPRA_MTR2. */
#define BS_AIPS_MPRA_MTR2    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTR2. */

/*! @brief Read current value of the AIPS_MPRA_MTR2 field. */
#define BR_AIPS_MPRA_MTR2(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR2))

/*! @brief Format value for bitfield AIPS_MPRA_MTR2. */
#define BF_AIPS_MPRA_MTR2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTR2) & BM_AIPS_MPRA_MTR2)

/*! @brief Set the MTR2 field to a new value. */
#define BW_AIPS_MPRA_MTR2(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR2) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MPL1[24] (RW)
 *
 * Specifies how the privilege level of the master is determined.
 *
 * Values:
 * - 0 - Accesses from this master are forced to user-mode.
 * - 1 - Accesses from this master are not forced to user-mode.
 */
/*@{*/
#define BP_AIPS_MPRA_MPL1    (24U)         /*!< Bit position for AIPS_MPRA_MPL1. */
#define BM_AIPS_MPRA_MPL1    (0x01000000U) /*!< Bit mask for AIPS_MPRA_MPL1. */
#define BS_AIPS_MPRA_MPL1    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MPL1. */

/*! @brief Read current value of the AIPS_MPRA_MPL1 field. */
#define BR_AIPS_MPRA_MPL1(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL1))

/*! @brief Format value for bitfield AIPS_MPRA_MPL1. */
#define BF_AIPS_MPRA_MPL1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MPL1) & BM_AIPS_MPRA_MPL1)

/*! @brief Set the MPL1 field to a new value. */
#define BW_AIPS_MPRA_MPL1(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL1) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTW1[25] (RW)
 *
 * Determines whether the master is trusted for write accesses.
 *
 * Values:
 * - 0 - This master is not trusted for write accesses.
 * - 1 - This master is trusted for write accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTW1    (25U)         /*!< Bit position for AIPS_MPRA_MTW1. */
#define BM_AIPS_MPRA_MTW1    (0x02000000U) /*!< Bit mask for AIPS_MPRA_MTW1. */
#define BS_AIPS_MPRA_MTW1    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTW1. */

/*! @brief Read current value of the AIPS_MPRA_MTW1 field. */
#define BR_AIPS_MPRA_MTW1(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW1))

/*! @brief Format value for bitfield AIPS_MPRA_MTW1. */
#define BF_AIPS_MPRA_MTW1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTW1) & BM_AIPS_MPRA_MTW1)

/*! @brief Set the MTW1 field to a new value. */
#define BW_AIPS_MPRA_MTW1(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW1) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTR1[26] (RW)
 *
 * Determines whether the master is trusted for read accesses.
 *
 * Values:
 * - 0 - This master is not trusted for read accesses.
 * - 1 - This master is trusted for read accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTR1    (26U)         /*!< Bit position for AIPS_MPRA_MTR1. */
#define BM_AIPS_MPRA_MTR1    (0x04000000U) /*!< Bit mask for AIPS_MPRA_MTR1. */
#define BS_AIPS_MPRA_MTR1    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTR1. */

/*! @brief Read current value of the AIPS_MPRA_MTR1 field. */
#define BR_AIPS_MPRA_MTR1(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR1))

/*! @brief Format value for bitfield AIPS_MPRA_MTR1. */
#define BF_AIPS_MPRA_MTR1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTR1) & BM_AIPS_MPRA_MTR1)

/*! @brief Set the MTR1 field to a new value. */
#define BW_AIPS_MPRA_MTR1(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR1) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MPL0[28] (RW)
 *
 * Specifies how the privilege level of the master is determined.
 *
 * Values:
 * - 0 - Accesses from this master are forced to user-mode.
 * - 1 - Accesses from this master are not forced to user-mode.
 */
/*@{*/
#define BP_AIPS_MPRA_MPL0    (28U)         /*!< Bit position for AIPS_MPRA_MPL0. */
#define BM_AIPS_MPRA_MPL0    (0x10000000U) /*!< Bit mask for AIPS_MPRA_MPL0. */
#define BS_AIPS_MPRA_MPL0    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MPL0. */

/*! @brief Read current value of the AIPS_MPRA_MPL0 field. */
#define BR_AIPS_MPRA_MPL0(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL0))

/*! @brief Format value for bitfield AIPS_MPRA_MPL0. */
#define BF_AIPS_MPRA_MPL0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MPL0) & BM_AIPS_MPRA_MPL0)

/*! @brief Set the MPL0 field to a new value. */
#define BW_AIPS_MPRA_MPL0(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MPL0) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTW0[29] (RW)
 *
 * Determines whether the master is trusted for write accesses.
 *
 * Values:
 * - 0 - This master is not trusted for write accesses.
 * - 1 - This master is trusted for write accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTW0    (29U)         /*!< Bit position for AIPS_MPRA_MTW0. */
#define BM_AIPS_MPRA_MTW0    (0x20000000U) /*!< Bit mask for AIPS_MPRA_MTW0. */
#define BS_AIPS_MPRA_MTW0    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTW0. */

/*! @brief Read current value of the AIPS_MPRA_MTW0 field. */
#define BR_AIPS_MPRA_MTW0(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW0))

/*! @brief Format value for bitfield AIPS_MPRA_MTW0. */
#define BF_AIPS_MPRA_MTW0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTW0) & BM_AIPS_MPRA_MTW0)

/*! @brief Set the MTW0 field to a new value. */
#define BW_AIPS_MPRA_MTW0(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTW0) = (v))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTR0[30] (RW)
 *
 * Determines whether the master is trusted for read accesses.
 *
 * Values:
 * - 0 - This master is not trusted for read accesses.
 * - 1 - This master is trusted for read accesses.
 */
/*@{*/
#define BP_AIPS_MPRA_MTR0    (30U)         /*!< Bit position for AIPS_MPRA_MTR0. */
#define BM_AIPS_MPRA_MTR0    (0x40000000U) /*!< Bit mask for AIPS_MPRA_MTR0. */
#define BS_AIPS_MPRA_MTR0    (1U)          /*!< Bit field size in bits for AIPS_MPRA_MTR0. */

/*! @brief Read current value of the AIPS_MPRA_MTR0 field. */
#define BR_AIPS_MPRA_MTR0(x) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR0))

/*! @brief Format value for bitfield AIPS_MPRA_MTR0. */
#define BF_AIPS_MPRA_MTR0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_MPRA_MTR0) & BM_AIPS_MPRA_MTR0)

/*! @brief Set the MTR0 field to a new value. */
#define BW_AIPS_MPRA_MTR0(x, v) (BITBAND_ACCESS32(HW_AIPS_MPRA_ADDR(x), BP_AIPS_MPRA_MTR0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRA - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRA - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x50004000U
 *
 * Each PACR register consists of eight 4-bit PACR fields. Each PACR field
 * defines the access levels for a particular peripheral. The mapping between a
 * peripheral and its PACR field is shown in the table below. The peripheral assignment
 * to each PACR is defined by the memory map slot that the peripheral is
 * assigned to. See this chip's memory map for the assignment of a particular
 * peripheral. The following table shows the location of each peripheral slot's PACR field
 * in the PACR registers. Offset Register [31:28] [27:24] [23:20] [19:16] [15:12]
 * [11:8] [7:4] [3:0] 0x20 PACRA PACR0 PACR1 PACR2 PACR3 PACR4 PACR5 PACR6 PACR7
 * 0x24 PACRB PACR8 PACR9 PACR10 PACR11 PACR12 PACR13 PACR14 PACR15 0x28 PACRC
 * PACR16 PACR17 PACR18 PACR19 PACR20 PACR21 PACR22 PACR23 0x2C PACRD PACR24
 * PACR25 PACR26 PACR27 PACR28 PACR29 PACR30 PACR31 0x30 Reserved 0x34 Reserved 0x38
 * Reserved 0x3C Reserved 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36 PACR37
 * PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45 PACR46 PACR47
 * 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55 0x4C PACRH
 * PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI PACR64
 * PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73 PACR74
 * PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82 PACR83
 * PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92 PACR93
 * PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101 PACR102
 * PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109 PACR110
 * PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118 PACR119
 * 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126 PACR127 0x80
 * PACRU PACR GBL0 PACR GBL1 Reserved The register field descriptions for PACR
 * A-D, which control peripheral slots 0-31, are shown below. The following
 * section, PACRPeripheral Access Control Register , shows the register field
 * descriptions for PACR E-P. All PACR registers are identical. They are divided into two
 * sections because they occupy two non-contiguous address spaces.
 */
typedef union _hw_aips_pacra
{
    uint32_t U;
    struct _hw_aips_pacra_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacra_t;

/*!
 * @name Constants and macros for entire AIPS_PACRA register
 */
/*@{*/
#define HW_AIPS_PACRA_ADDR(x)    ((uint32_t)(x) + 0x20U)

#define HW_AIPS_PACRA(x)         (*(__IO hw_aips_pacra_t *) HW_AIPS_PACRA_ADDR(x))
#define HW_AIPS_PACRA_RD(x)      (HW_AIPS_PACRA(x).U)
#define HW_AIPS_PACRA_WR(x, v)   (HW_AIPS_PACRA(x).U = (v))
#define HW_AIPS_PACRA_SET(x, v)  (HW_AIPS_PACRA_WR(x, HW_AIPS_PACRA_RD(x) |  (v)))
#define HW_AIPS_PACRA_CLR(x, v)  (HW_AIPS_PACRA_WR(x, HW_AIPS_PACRA_RD(x) & ~(v)))
#define HW_AIPS_PACRA_TOG(x, v)  (HW_AIPS_PACRA_WR(x, HW_AIPS_PACRA_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRA bitfields
 */

/*!
 * @name Register AIPS_PACRA, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRA_TP7    (0U)          /*!< Bit position for AIPS_PACRA_TP7. */
#define BM_AIPS_PACRA_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRA_TP7. */
#define BS_AIPS_PACRA_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRA_TP7. */

/*! @brief Read current value of the AIPS_PACRA_TP7 field. */
#define BR_AIPS_PACRA_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP7))

/*! @brief Format value for bitfield AIPS_PACRA_TP7. */
#define BF_AIPS_PACRA_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_TP7) & BM_AIPS_PACRA_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRA_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRA_WP7    (1U)          /*!< Bit position for AIPS_PACRA_WP7. */
#define BM_AIPS_PACRA_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRA_WP7. */
#define BS_AIPS_PACRA_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRA_WP7. */

/*! @brief Read current value of the AIPS_PACRA_WP7 field. */
#define BR_AIPS_PACRA_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP7))

/*! @brief Format value for bitfield AIPS_PACRA_WP7. */
#define BF_AIPS_PACRA_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_WP7) & BM_AIPS_PACRA_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRA_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRA_SP7    (2U)          /*!< Bit position for AIPS_PACRA_SP7. */
#define BM_AIPS_PACRA_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRA_SP7. */
#define BS_AIPS_PACRA_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRA_SP7. */

/*! @brief Read current value of the AIPS_PACRA_SP7 field. */
#define BR_AIPS_PACRA_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP7))

/*! @brief Format value for bitfield AIPS_PACRA_SP7. */
#define BF_AIPS_PACRA_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_SP7) & BM_AIPS_PACRA_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRA_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRA_TP6    (4U)          /*!< Bit position for AIPS_PACRA_TP6. */
#define BM_AIPS_PACRA_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRA_TP6. */
#define BS_AIPS_PACRA_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRA_TP6. */

/*! @brief Read current value of the AIPS_PACRA_TP6 field. */
#define BR_AIPS_PACRA_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP6))

/*! @brief Format value for bitfield AIPS_PACRA_TP6. */
#define BF_AIPS_PACRA_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_TP6) & BM_AIPS_PACRA_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRA_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRA_WP6    (5U)          /*!< Bit position for AIPS_PACRA_WP6. */
#define BM_AIPS_PACRA_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRA_WP6. */
#define BS_AIPS_PACRA_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRA_WP6. */

/*! @brief Read current value of the AIPS_PACRA_WP6 field. */
#define BR_AIPS_PACRA_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP6))

/*! @brief Format value for bitfield AIPS_PACRA_WP6. */
#define BF_AIPS_PACRA_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_WP6) & BM_AIPS_PACRA_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRA_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRA_SP6    (6U)          /*!< Bit position for AIPS_PACRA_SP6. */
#define BM_AIPS_PACRA_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRA_SP6. */
#define BS_AIPS_PACRA_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRA_SP6. */

/*! @brief Read current value of the AIPS_PACRA_SP6 field. */
#define BR_AIPS_PACRA_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP6))

/*! @brief Format value for bitfield AIPS_PACRA_SP6. */
#define BF_AIPS_PACRA_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_SP6) & BM_AIPS_PACRA_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRA_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRA_TP5    (8U)          /*!< Bit position for AIPS_PACRA_TP5. */
#define BM_AIPS_PACRA_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRA_TP5. */
#define BS_AIPS_PACRA_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRA_TP5. */

/*! @brief Read current value of the AIPS_PACRA_TP5 field. */
#define BR_AIPS_PACRA_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP5))

/*! @brief Format value for bitfield AIPS_PACRA_TP5. */
#define BF_AIPS_PACRA_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_TP5) & BM_AIPS_PACRA_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRA_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRA_WP5    (9U)          /*!< Bit position for AIPS_PACRA_WP5. */
#define BM_AIPS_PACRA_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRA_WP5. */
#define BS_AIPS_PACRA_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRA_WP5. */

/*! @brief Read current value of the AIPS_PACRA_WP5 field. */
#define BR_AIPS_PACRA_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP5))

/*! @brief Format value for bitfield AIPS_PACRA_WP5. */
#define BF_AIPS_PACRA_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_WP5) & BM_AIPS_PACRA_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRA_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRA_SP5    (10U)         /*!< Bit position for AIPS_PACRA_SP5. */
#define BM_AIPS_PACRA_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRA_SP5. */
#define BS_AIPS_PACRA_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRA_SP5. */

/*! @brief Read current value of the AIPS_PACRA_SP5 field. */
#define BR_AIPS_PACRA_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP5))

/*! @brief Format value for bitfield AIPS_PACRA_SP5. */
#define BF_AIPS_PACRA_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_SP5) & BM_AIPS_PACRA_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRA_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRA_TP4    (12U)         /*!< Bit position for AIPS_PACRA_TP4. */
#define BM_AIPS_PACRA_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRA_TP4. */
#define BS_AIPS_PACRA_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRA_TP4. */

/*! @brief Read current value of the AIPS_PACRA_TP4 field. */
#define BR_AIPS_PACRA_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP4))

/*! @brief Format value for bitfield AIPS_PACRA_TP4. */
#define BF_AIPS_PACRA_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_TP4) & BM_AIPS_PACRA_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRA_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRA_WP4    (13U)         /*!< Bit position for AIPS_PACRA_WP4. */
#define BM_AIPS_PACRA_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRA_WP4. */
#define BS_AIPS_PACRA_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRA_WP4. */

/*! @brief Read current value of the AIPS_PACRA_WP4 field. */
#define BR_AIPS_PACRA_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP4))

/*! @brief Format value for bitfield AIPS_PACRA_WP4. */
#define BF_AIPS_PACRA_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_WP4) & BM_AIPS_PACRA_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRA_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRA_SP4    (14U)         /*!< Bit position for AIPS_PACRA_SP4. */
#define BM_AIPS_PACRA_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRA_SP4. */
#define BS_AIPS_PACRA_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRA_SP4. */

/*! @brief Read current value of the AIPS_PACRA_SP4 field. */
#define BR_AIPS_PACRA_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP4))

/*! @brief Format value for bitfield AIPS_PACRA_SP4. */
#define BF_AIPS_PACRA_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_SP4) & BM_AIPS_PACRA_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRA_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRA_TP3    (16U)         /*!< Bit position for AIPS_PACRA_TP3. */
#define BM_AIPS_PACRA_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRA_TP3. */
#define BS_AIPS_PACRA_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRA_TP3. */

/*! @brief Read current value of the AIPS_PACRA_TP3 field. */
#define BR_AIPS_PACRA_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP3))

/*! @brief Format value for bitfield AIPS_PACRA_TP3. */
#define BF_AIPS_PACRA_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_TP3) & BM_AIPS_PACRA_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRA_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRA_WP3    (17U)         /*!< Bit position for AIPS_PACRA_WP3. */
#define BM_AIPS_PACRA_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRA_WP3. */
#define BS_AIPS_PACRA_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRA_WP3. */

/*! @brief Read current value of the AIPS_PACRA_WP3 field. */
#define BR_AIPS_PACRA_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP3))

/*! @brief Format value for bitfield AIPS_PACRA_WP3. */
#define BF_AIPS_PACRA_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_WP3) & BM_AIPS_PACRA_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRA_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRA_SP3    (18U)         /*!< Bit position for AIPS_PACRA_SP3. */
#define BM_AIPS_PACRA_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRA_SP3. */
#define BS_AIPS_PACRA_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRA_SP3. */

/*! @brief Read current value of the AIPS_PACRA_SP3 field. */
#define BR_AIPS_PACRA_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP3))

/*! @brief Format value for bitfield AIPS_PACRA_SP3. */
#define BF_AIPS_PACRA_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_SP3) & BM_AIPS_PACRA_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRA_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRA_TP2    (20U)         /*!< Bit position for AIPS_PACRA_TP2. */
#define BM_AIPS_PACRA_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRA_TP2. */
#define BS_AIPS_PACRA_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRA_TP2. */

/*! @brief Read current value of the AIPS_PACRA_TP2 field. */
#define BR_AIPS_PACRA_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP2))

/*! @brief Format value for bitfield AIPS_PACRA_TP2. */
#define BF_AIPS_PACRA_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_TP2) & BM_AIPS_PACRA_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRA_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRA_WP2    (21U)         /*!< Bit position for AIPS_PACRA_WP2. */
#define BM_AIPS_PACRA_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRA_WP2. */
#define BS_AIPS_PACRA_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRA_WP2. */

/*! @brief Read current value of the AIPS_PACRA_WP2 field. */
#define BR_AIPS_PACRA_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP2))

/*! @brief Format value for bitfield AIPS_PACRA_WP2. */
#define BF_AIPS_PACRA_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_WP2) & BM_AIPS_PACRA_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRA_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRA_SP2    (22U)         /*!< Bit position for AIPS_PACRA_SP2. */
#define BM_AIPS_PACRA_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRA_SP2. */
#define BS_AIPS_PACRA_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRA_SP2. */

/*! @brief Read current value of the AIPS_PACRA_SP2 field. */
#define BR_AIPS_PACRA_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP2))

/*! @brief Format value for bitfield AIPS_PACRA_SP2. */
#define BF_AIPS_PACRA_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_SP2) & BM_AIPS_PACRA_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRA_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRA_TP1    (24U)         /*!< Bit position for AIPS_PACRA_TP1. */
#define BM_AIPS_PACRA_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRA_TP1. */
#define BS_AIPS_PACRA_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRA_TP1. */

/*! @brief Read current value of the AIPS_PACRA_TP1 field. */
#define BR_AIPS_PACRA_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP1))

/*! @brief Format value for bitfield AIPS_PACRA_TP1. */
#define BF_AIPS_PACRA_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_TP1) & BM_AIPS_PACRA_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRA_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRA_WP1    (25U)         /*!< Bit position for AIPS_PACRA_WP1. */
#define BM_AIPS_PACRA_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRA_WP1. */
#define BS_AIPS_PACRA_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRA_WP1. */

/*! @brief Read current value of the AIPS_PACRA_WP1 field. */
#define BR_AIPS_PACRA_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP1))

/*! @brief Format value for bitfield AIPS_PACRA_WP1. */
#define BF_AIPS_PACRA_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_WP1) & BM_AIPS_PACRA_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRA_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRA_SP1    (26U)         /*!< Bit position for AIPS_PACRA_SP1. */
#define BM_AIPS_PACRA_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRA_SP1. */
#define BS_AIPS_PACRA_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRA_SP1. */

/*! @brief Read current value of the AIPS_PACRA_SP1 field. */
#define BR_AIPS_PACRA_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP1))

/*! @brief Format value for bitfield AIPS_PACRA_SP1. */
#define BF_AIPS_PACRA_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_SP1) & BM_AIPS_PACRA_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRA_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRA_TP0    (28U)         /*!< Bit position for AIPS_PACRA_TP0. */
#define BM_AIPS_PACRA_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRA_TP0. */
#define BS_AIPS_PACRA_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRA_TP0. */

/*! @brief Read current value of the AIPS_PACRA_TP0 field. */
#define BR_AIPS_PACRA_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP0))

/*! @brief Format value for bitfield AIPS_PACRA_TP0. */
#define BF_AIPS_PACRA_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_TP0) & BM_AIPS_PACRA_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRA_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRA_WP0    (29U)         /*!< Bit position for AIPS_PACRA_WP0. */
#define BM_AIPS_PACRA_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRA_WP0. */
#define BS_AIPS_PACRA_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRA_WP0. */

/*! @brief Read current value of the AIPS_PACRA_WP0 field. */
#define BR_AIPS_PACRA_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP0))

/*! @brief Format value for bitfield AIPS_PACRA_WP0. */
#define BF_AIPS_PACRA_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_WP0) & BM_AIPS_PACRA_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRA_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRA_SP0    (30U)         /*!< Bit position for AIPS_PACRA_SP0. */
#define BM_AIPS_PACRA_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRA_SP0. */
#define BS_AIPS_PACRA_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRA_SP0. */

/*! @brief Read current value of the AIPS_PACRA_SP0 field. */
#define BR_AIPS_PACRA_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP0))

/*! @brief Format value for bitfield AIPS_PACRA_SP0. */
#define BF_AIPS_PACRA_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRA_SP0) & BM_AIPS_PACRA_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRA_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRA_ADDR(x), BP_AIPS_PACRA_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRB - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRB - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44004400U
 *
 * Each PACR register consists of eight 4-bit PACR fields. Each PACR field
 * defines the access levels for a particular peripheral. The mapping between a
 * peripheral and its PACR field is shown in the table below. The peripheral assignment
 * to each PACR is defined by the memory map slot that the peripheral is
 * assigned to. See this chip's memory map for the assignment of a particular
 * peripheral. The following table shows the location of each peripheral slot's PACR field
 * in the PACR registers. Offset Register [31:28] [27:24] [23:20] [19:16] [15:12]
 * [11:8] [7:4] [3:0] 0x20 PACRA PACR0 PACR1 PACR2 PACR3 PACR4 PACR5 PACR6 PACR7
 * 0x24 PACRB PACR8 PACR9 PACR10 PACR11 PACR12 PACR13 PACR14 PACR15 0x28 PACRC
 * PACR16 PACR17 PACR18 PACR19 PACR20 PACR21 PACR22 PACR23 0x2C PACRD PACR24
 * PACR25 PACR26 PACR27 PACR28 PACR29 PACR30 PACR31 0x30 Reserved 0x34 Reserved 0x38
 * Reserved 0x3C Reserved 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36 PACR37
 * PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45 PACR46 PACR47
 * 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55 0x4C PACRH
 * PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI PACR64
 * PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73 PACR74
 * PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82 PACR83
 * PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92 PACR93
 * PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101 PACR102
 * PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109 PACR110
 * PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118 PACR119
 * 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126 PACR127 0x80
 * PACRU PACR GBL0 PACR GBL1 Reserved The register field descriptions for PACR
 * A-D, which control peripheral slots 0-31, are shown below. The following
 * section, PACRPeripheral Access Control Register , shows the register field
 * descriptions for PACR E-P. All PACR registers are identical. They are divided into two
 * sections because they occupy two non-contiguous address spaces.
 */
typedef union _hw_aips_pacrb
{
    uint32_t U;
    struct _hw_aips_pacrb_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrb_t;

/*!
 * @name Constants and macros for entire AIPS_PACRB register
 */
/*@{*/
#define HW_AIPS_PACRB_ADDR(x)    ((uint32_t)(x) + 0x24U)

#define HW_AIPS_PACRB(x)         (*(__IO hw_aips_pacrb_t *) HW_AIPS_PACRB_ADDR(x))
#define HW_AIPS_PACRB_RD(x)      (HW_AIPS_PACRB(x).U)
#define HW_AIPS_PACRB_WR(x, v)   (HW_AIPS_PACRB(x).U = (v))
#define HW_AIPS_PACRB_SET(x, v)  (HW_AIPS_PACRB_WR(x, HW_AIPS_PACRB_RD(x) |  (v)))
#define HW_AIPS_PACRB_CLR(x, v)  (HW_AIPS_PACRB_WR(x, HW_AIPS_PACRB_RD(x) & ~(v)))
#define HW_AIPS_PACRB_TOG(x, v)  (HW_AIPS_PACRB_WR(x, HW_AIPS_PACRB_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRB bitfields
 */

/*!
 * @name Register AIPS_PACRB, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRB_TP7    (0U)          /*!< Bit position for AIPS_PACRB_TP7. */
#define BM_AIPS_PACRB_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRB_TP7. */
#define BS_AIPS_PACRB_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRB_TP7. */

/*! @brief Read current value of the AIPS_PACRB_TP7 field. */
#define BR_AIPS_PACRB_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP7))

/*! @brief Format value for bitfield AIPS_PACRB_TP7. */
#define BF_AIPS_PACRB_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_TP7) & BM_AIPS_PACRB_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRB_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRB_WP7    (1U)          /*!< Bit position for AIPS_PACRB_WP7. */
#define BM_AIPS_PACRB_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRB_WP7. */
#define BS_AIPS_PACRB_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRB_WP7. */

/*! @brief Read current value of the AIPS_PACRB_WP7 field. */
#define BR_AIPS_PACRB_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP7))

/*! @brief Format value for bitfield AIPS_PACRB_WP7. */
#define BF_AIPS_PACRB_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_WP7) & BM_AIPS_PACRB_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRB_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRB_SP7    (2U)          /*!< Bit position for AIPS_PACRB_SP7. */
#define BM_AIPS_PACRB_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRB_SP7. */
#define BS_AIPS_PACRB_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRB_SP7. */

/*! @brief Read current value of the AIPS_PACRB_SP7 field. */
#define BR_AIPS_PACRB_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP7))

/*! @brief Format value for bitfield AIPS_PACRB_SP7. */
#define BF_AIPS_PACRB_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_SP7) & BM_AIPS_PACRB_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRB_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRB_TP6    (4U)          /*!< Bit position for AIPS_PACRB_TP6. */
#define BM_AIPS_PACRB_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRB_TP6. */
#define BS_AIPS_PACRB_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRB_TP6. */

/*! @brief Read current value of the AIPS_PACRB_TP6 field. */
#define BR_AIPS_PACRB_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP6))

/*! @brief Format value for bitfield AIPS_PACRB_TP6. */
#define BF_AIPS_PACRB_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_TP6) & BM_AIPS_PACRB_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRB_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRB_WP6    (5U)          /*!< Bit position for AIPS_PACRB_WP6. */
#define BM_AIPS_PACRB_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRB_WP6. */
#define BS_AIPS_PACRB_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRB_WP6. */

/*! @brief Read current value of the AIPS_PACRB_WP6 field. */
#define BR_AIPS_PACRB_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP6))

/*! @brief Format value for bitfield AIPS_PACRB_WP6. */
#define BF_AIPS_PACRB_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_WP6) & BM_AIPS_PACRB_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRB_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRB_SP6    (6U)          /*!< Bit position for AIPS_PACRB_SP6. */
#define BM_AIPS_PACRB_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRB_SP6. */
#define BS_AIPS_PACRB_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRB_SP6. */

/*! @brief Read current value of the AIPS_PACRB_SP6 field. */
#define BR_AIPS_PACRB_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP6))

/*! @brief Format value for bitfield AIPS_PACRB_SP6. */
#define BF_AIPS_PACRB_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_SP6) & BM_AIPS_PACRB_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRB_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRB_TP5    (8U)          /*!< Bit position for AIPS_PACRB_TP5. */
#define BM_AIPS_PACRB_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRB_TP5. */
#define BS_AIPS_PACRB_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRB_TP5. */

/*! @brief Read current value of the AIPS_PACRB_TP5 field. */
#define BR_AIPS_PACRB_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP5))

/*! @brief Format value for bitfield AIPS_PACRB_TP5. */
#define BF_AIPS_PACRB_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_TP5) & BM_AIPS_PACRB_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRB_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRB_WP5    (9U)          /*!< Bit position for AIPS_PACRB_WP5. */
#define BM_AIPS_PACRB_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRB_WP5. */
#define BS_AIPS_PACRB_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRB_WP5. */

/*! @brief Read current value of the AIPS_PACRB_WP5 field. */
#define BR_AIPS_PACRB_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP5))

/*! @brief Format value for bitfield AIPS_PACRB_WP5. */
#define BF_AIPS_PACRB_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_WP5) & BM_AIPS_PACRB_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRB_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRB_SP5    (10U)         /*!< Bit position for AIPS_PACRB_SP5. */
#define BM_AIPS_PACRB_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRB_SP5. */
#define BS_AIPS_PACRB_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRB_SP5. */

/*! @brief Read current value of the AIPS_PACRB_SP5 field. */
#define BR_AIPS_PACRB_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP5))

/*! @brief Format value for bitfield AIPS_PACRB_SP5. */
#define BF_AIPS_PACRB_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_SP5) & BM_AIPS_PACRB_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRB_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRB_TP4    (12U)         /*!< Bit position for AIPS_PACRB_TP4. */
#define BM_AIPS_PACRB_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRB_TP4. */
#define BS_AIPS_PACRB_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRB_TP4. */

/*! @brief Read current value of the AIPS_PACRB_TP4 field. */
#define BR_AIPS_PACRB_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP4))

/*! @brief Format value for bitfield AIPS_PACRB_TP4. */
#define BF_AIPS_PACRB_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_TP4) & BM_AIPS_PACRB_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRB_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRB_WP4    (13U)         /*!< Bit position for AIPS_PACRB_WP4. */
#define BM_AIPS_PACRB_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRB_WP4. */
#define BS_AIPS_PACRB_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRB_WP4. */

/*! @brief Read current value of the AIPS_PACRB_WP4 field. */
#define BR_AIPS_PACRB_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP4))

/*! @brief Format value for bitfield AIPS_PACRB_WP4. */
#define BF_AIPS_PACRB_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_WP4) & BM_AIPS_PACRB_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRB_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRB_SP4    (14U)         /*!< Bit position for AIPS_PACRB_SP4. */
#define BM_AIPS_PACRB_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRB_SP4. */
#define BS_AIPS_PACRB_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRB_SP4. */

/*! @brief Read current value of the AIPS_PACRB_SP4 field. */
#define BR_AIPS_PACRB_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP4))

/*! @brief Format value for bitfield AIPS_PACRB_SP4. */
#define BF_AIPS_PACRB_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_SP4) & BM_AIPS_PACRB_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRB_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRB_TP3    (16U)         /*!< Bit position for AIPS_PACRB_TP3. */
#define BM_AIPS_PACRB_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRB_TP3. */
#define BS_AIPS_PACRB_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRB_TP3. */

/*! @brief Read current value of the AIPS_PACRB_TP3 field. */
#define BR_AIPS_PACRB_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP3))

/*! @brief Format value for bitfield AIPS_PACRB_TP3. */
#define BF_AIPS_PACRB_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_TP3) & BM_AIPS_PACRB_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRB_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRB_WP3    (17U)         /*!< Bit position for AIPS_PACRB_WP3. */
#define BM_AIPS_PACRB_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRB_WP3. */
#define BS_AIPS_PACRB_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRB_WP3. */

/*! @brief Read current value of the AIPS_PACRB_WP3 field. */
#define BR_AIPS_PACRB_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP3))

/*! @brief Format value for bitfield AIPS_PACRB_WP3. */
#define BF_AIPS_PACRB_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_WP3) & BM_AIPS_PACRB_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRB_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRB_SP3    (18U)         /*!< Bit position for AIPS_PACRB_SP3. */
#define BM_AIPS_PACRB_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRB_SP3. */
#define BS_AIPS_PACRB_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRB_SP3. */

/*! @brief Read current value of the AIPS_PACRB_SP3 field. */
#define BR_AIPS_PACRB_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP3))

/*! @brief Format value for bitfield AIPS_PACRB_SP3. */
#define BF_AIPS_PACRB_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_SP3) & BM_AIPS_PACRB_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRB_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRB_TP2    (20U)         /*!< Bit position for AIPS_PACRB_TP2. */
#define BM_AIPS_PACRB_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRB_TP2. */
#define BS_AIPS_PACRB_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRB_TP2. */

/*! @brief Read current value of the AIPS_PACRB_TP2 field. */
#define BR_AIPS_PACRB_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP2))

/*! @brief Format value for bitfield AIPS_PACRB_TP2. */
#define BF_AIPS_PACRB_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_TP2) & BM_AIPS_PACRB_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRB_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRB_WP2    (21U)         /*!< Bit position for AIPS_PACRB_WP2. */
#define BM_AIPS_PACRB_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRB_WP2. */
#define BS_AIPS_PACRB_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRB_WP2. */

/*! @brief Read current value of the AIPS_PACRB_WP2 field. */
#define BR_AIPS_PACRB_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP2))

/*! @brief Format value for bitfield AIPS_PACRB_WP2. */
#define BF_AIPS_PACRB_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_WP2) & BM_AIPS_PACRB_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRB_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRB_SP2    (22U)         /*!< Bit position for AIPS_PACRB_SP2. */
#define BM_AIPS_PACRB_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRB_SP2. */
#define BS_AIPS_PACRB_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRB_SP2. */

/*! @brief Read current value of the AIPS_PACRB_SP2 field. */
#define BR_AIPS_PACRB_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP2))

/*! @brief Format value for bitfield AIPS_PACRB_SP2. */
#define BF_AIPS_PACRB_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_SP2) & BM_AIPS_PACRB_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRB_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRB_TP1    (24U)         /*!< Bit position for AIPS_PACRB_TP1. */
#define BM_AIPS_PACRB_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRB_TP1. */
#define BS_AIPS_PACRB_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRB_TP1. */

/*! @brief Read current value of the AIPS_PACRB_TP1 field. */
#define BR_AIPS_PACRB_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP1))

/*! @brief Format value for bitfield AIPS_PACRB_TP1. */
#define BF_AIPS_PACRB_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_TP1) & BM_AIPS_PACRB_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRB_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRB_WP1    (25U)         /*!< Bit position for AIPS_PACRB_WP1. */
#define BM_AIPS_PACRB_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRB_WP1. */
#define BS_AIPS_PACRB_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRB_WP1. */

/*! @brief Read current value of the AIPS_PACRB_WP1 field. */
#define BR_AIPS_PACRB_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP1))

/*! @brief Format value for bitfield AIPS_PACRB_WP1. */
#define BF_AIPS_PACRB_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_WP1) & BM_AIPS_PACRB_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRB_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRB_SP1    (26U)         /*!< Bit position for AIPS_PACRB_SP1. */
#define BM_AIPS_PACRB_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRB_SP1. */
#define BS_AIPS_PACRB_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRB_SP1. */

/*! @brief Read current value of the AIPS_PACRB_SP1 field. */
#define BR_AIPS_PACRB_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP1))

/*! @brief Format value for bitfield AIPS_PACRB_SP1. */
#define BF_AIPS_PACRB_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_SP1) & BM_AIPS_PACRB_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRB_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRB_TP0    (28U)         /*!< Bit position for AIPS_PACRB_TP0. */
#define BM_AIPS_PACRB_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRB_TP0. */
#define BS_AIPS_PACRB_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRB_TP0. */

/*! @brief Read current value of the AIPS_PACRB_TP0 field. */
#define BR_AIPS_PACRB_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP0))

/*! @brief Format value for bitfield AIPS_PACRB_TP0. */
#define BF_AIPS_PACRB_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_TP0) & BM_AIPS_PACRB_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRB_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRB_WP0    (29U)         /*!< Bit position for AIPS_PACRB_WP0. */
#define BM_AIPS_PACRB_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRB_WP0. */
#define BS_AIPS_PACRB_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRB_WP0. */

/*! @brief Read current value of the AIPS_PACRB_WP0 field. */
#define BR_AIPS_PACRB_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP0))

/*! @brief Format value for bitfield AIPS_PACRB_WP0. */
#define BF_AIPS_PACRB_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_WP0) & BM_AIPS_PACRB_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRB_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRB_SP0    (30U)         /*!< Bit position for AIPS_PACRB_SP0. */
#define BM_AIPS_PACRB_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRB_SP0. */
#define BS_AIPS_PACRB_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRB_SP0. */

/*! @brief Read current value of the AIPS_PACRB_SP0 field. */
#define BR_AIPS_PACRB_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP0))

/*! @brief Format value for bitfield AIPS_PACRB_SP0. */
#define BF_AIPS_PACRB_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRB_SP0) & BM_AIPS_PACRB_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRB_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRB_ADDR(x), BP_AIPS_PACRB_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRC - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRC - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PACR register consists of eight 4-bit PACR fields. Each PACR field
 * defines the access levels for a particular peripheral. The mapping between a
 * peripheral and its PACR field is shown in the table below. The peripheral assignment
 * to each PACR is defined by the memory map slot that the peripheral is
 * assigned to. See this chip's memory map for the assignment of a particular
 * peripheral. The following table shows the location of each peripheral slot's PACR field
 * in the PACR registers. Offset Register [31:28] [27:24] [23:20] [19:16] [15:12]
 * [11:8] [7:4] [3:0] 0x20 PACRA PACR0 PACR1 PACR2 PACR3 PACR4 PACR5 PACR6 PACR7
 * 0x24 PACRB PACR8 PACR9 PACR10 PACR11 PACR12 PACR13 PACR14 PACR15 0x28 PACRC
 * PACR16 PACR17 PACR18 PACR19 PACR20 PACR21 PACR22 PACR23 0x2C PACRD PACR24
 * PACR25 PACR26 PACR27 PACR28 PACR29 PACR30 PACR31 0x30 Reserved 0x34 Reserved 0x38
 * Reserved 0x3C Reserved 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36 PACR37
 * PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45 PACR46 PACR47
 * 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55 0x4C PACRH
 * PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI PACR64
 * PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73 PACR74
 * PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82 PACR83
 * PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92 PACR93
 * PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101 PACR102
 * PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109 PACR110
 * PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118 PACR119
 * 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126 PACR127 0x80
 * PACRU PACR GBL0 PACR GBL1 Reserved The register field descriptions for PACR
 * A-D, which control peripheral slots 0-31, are shown below. The following
 * section, PACRPeripheral Access Control Register , shows the register field
 * descriptions for PACR E-P. All PACR registers are identical. They are divided into two
 * sections because they occupy two non-contiguous address spaces.
 */
typedef union _hw_aips_pacrc
{
    uint32_t U;
    struct _hw_aips_pacrc_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrc_t;

/*!
 * @name Constants and macros for entire AIPS_PACRC register
 */
/*@{*/
#define HW_AIPS_PACRC_ADDR(x)    ((uint32_t)(x) + 0x28U)

#define HW_AIPS_PACRC(x)         (*(__IO hw_aips_pacrc_t *) HW_AIPS_PACRC_ADDR(x))
#define HW_AIPS_PACRC_RD(x)      (HW_AIPS_PACRC(x).U)
#define HW_AIPS_PACRC_WR(x, v)   (HW_AIPS_PACRC(x).U = (v))
#define HW_AIPS_PACRC_SET(x, v)  (HW_AIPS_PACRC_WR(x, HW_AIPS_PACRC_RD(x) |  (v)))
#define HW_AIPS_PACRC_CLR(x, v)  (HW_AIPS_PACRC_WR(x, HW_AIPS_PACRC_RD(x) & ~(v)))
#define HW_AIPS_PACRC_TOG(x, v)  (HW_AIPS_PACRC_WR(x, HW_AIPS_PACRC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRC bitfields
 */

/*!
 * @name Register AIPS_PACRC, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRC_TP7    (0U)          /*!< Bit position for AIPS_PACRC_TP7. */
#define BM_AIPS_PACRC_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRC_TP7. */
#define BS_AIPS_PACRC_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRC_TP7. */

/*! @brief Read current value of the AIPS_PACRC_TP7 field. */
#define BR_AIPS_PACRC_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP7))

/*! @brief Format value for bitfield AIPS_PACRC_TP7. */
#define BF_AIPS_PACRC_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_TP7) & BM_AIPS_PACRC_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRC_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRC_WP7    (1U)          /*!< Bit position for AIPS_PACRC_WP7. */
#define BM_AIPS_PACRC_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRC_WP7. */
#define BS_AIPS_PACRC_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRC_WP7. */

/*! @brief Read current value of the AIPS_PACRC_WP7 field. */
#define BR_AIPS_PACRC_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP7))

/*! @brief Format value for bitfield AIPS_PACRC_WP7. */
#define BF_AIPS_PACRC_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_WP7) & BM_AIPS_PACRC_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRC_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRC_SP7    (2U)          /*!< Bit position for AIPS_PACRC_SP7. */
#define BM_AIPS_PACRC_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRC_SP7. */
#define BS_AIPS_PACRC_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRC_SP7. */

/*! @brief Read current value of the AIPS_PACRC_SP7 field. */
#define BR_AIPS_PACRC_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP7))

/*! @brief Format value for bitfield AIPS_PACRC_SP7. */
#define BF_AIPS_PACRC_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_SP7) & BM_AIPS_PACRC_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRC_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRC_TP6    (4U)          /*!< Bit position for AIPS_PACRC_TP6. */
#define BM_AIPS_PACRC_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRC_TP6. */
#define BS_AIPS_PACRC_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRC_TP6. */

/*! @brief Read current value of the AIPS_PACRC_TP6 field. */
#define BR_AIPS_PACRC_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP6))

/*! @brief Format value for bitfield AIPS_PACRC_TP6. */
#define BF_AIPS_PACRC_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_TP6) & BM_AIPS_PACRC_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRC_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRC_WP6    (5U)          /*!< Bit position for AIPS_PACRC_WP6. */
#define BM_AIPS_PACRC_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRC_WP6. */
#define BS_AIPS_PACRC_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRC_WP6. */

/*! @brief Read current value of the AIPS_PACRC_WP6 field. */
#define BR_AIPS_PACRC_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP6))

/*! @brief Format value for bitfield AIPS_PACRC_WP6. */
#define BF_AIPS_PACRC_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_WP6) & BM_AIPS_PACRC_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRC_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRC_SP6    (6U)          /*!< Bit position for AIPS_PACRC_SP6. */
#define BM_AIPS_PACRC_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRC_SP6. */
#define BS_AIPS_PACRC_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRC_SP6. */

/*! @brief Read current value of the AIPS_PACRC_SP6 field. */
#define BR_AIPS_PACRC_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP6))

/*! @brief Format value for bitfield AIPS_PACRC_SP6. */
#define BF_AIPS_PACRC_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_SP6) & BM_AIPS_PACRC_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRC_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRC_TP5    (8U)          /*!< Bit position for AIPS_PACRC_TP5. */
#define BM_AIPS_PACRC_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRC_TP5. */
#define BS_AIPS_PACRC_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRC_TP5. */

/*! @brief Read current value of the AIPS_PACRC_TP5 field. */
#define BR_AIPS_PACRC_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP5))

/*! @brief Format value for bitfield AIPS_PACRC_TP5. */
#define BF_AIPS_PACRC_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_TP5) & BM_AIPS_PACRC_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRC_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRC_WP5    (9U)          /*!< Bit position for AIPS_PACRC_WP5. */
#define BM_AIPS_PACRC_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRC_WP5. */
#define BS_AIPS_PACRC_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRC_WP5. */

/*! @brief Read current value of the AIPS_PACRC_WP5 field. */
#define BR_AIPS_PACRC_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP5))

/*! @brief Format value for bitfield AIPS_PACRC_WP5. */
#define BF_AIPS_PACRC_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_WP5) & BM_AIPS_PACRC_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRC_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRC_SP5    (10U)         /*!< Bit position for AIPS_PACRC_SP5. */
#define BM_AIPS_PACRC_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRC_SP5. */
#define BS_AIPS_PACRC_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRC_SP5. */

/*! @brief Read current value of the AIPS_PACRC_SP5 field. */
#define BR_AIPS_PACRC_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP5))

/*! @brief Format value for bitfield AIPS_PACRC_SP5. */
#define BF_AIPS_PACRC_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_SP5) & BM_AIPS_PACRC_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRC_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRC_TP4    (12U)         /*!< Bit position for AIPS_PACRC_TP4. */
#define BM_AIPS_PACRC_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRC_TP4. */
#define BS_AIPS_PACRC_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRC_TP4. */

/*! @brief Read current value of the AIPS_PACRC_TP4 field. */
#define BR_AIPS_PACRC_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP4))

/*! @brief Format value for bitfield AIPS_PACRC_TP4. */
#define BF_AIPS_PACRC_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_TP4) & BM_AIPS_PACRC_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRC_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRC_WP4    (13U)         /*!< Bit position for AIPS_PACRC_WP4. */
#define BM_AIPS_PACRC_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRC_WP4. */
#define BS_AIPS_PACRC_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRC_WP4. */

/*! @brief Read current value of the AIPS_PACRC_WP4 field. */
#define BR_AIPS_PACRC_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP4))

/*! @brief Format value for bitfield AIPS_PACRC_WP4. */
#define BF_AIPS_PACRC_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_WP4) & BM_AIPS_PACRC_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRC_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRC_SP4    (14U)         /*!< Bit position for AIPS_PACRC_SP4. */
#define BM_AIPS_PACRC_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRC_SP4. */
#define BS_AIPS_PACRC_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRC_SP4. */

/*! @brief Read current value of the AIPS_PACRC_SP4 field. */
#define BR_AIPS_PACRC_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP4))

/*! @brief Format value for bitfield AIPS_PACRC_SP4. */
#define BF_AIPS_PACRC_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_SP4) & BM_AIPS_PACRC_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRC_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRC_TP3    (16U)         /*!< Bit position for AIPS_PACRC_TP3. */
#define BM_AIPS_PACRC_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRC_TP3. */
#define BS_AIPS_PACRC_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRC_TP3. */

/*! @brief Read current value of the AIPS_PACRC_TP3 field. */
#define BR_AIPS_PACRC_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP3))

/*! @brief Format value for bitfield AIPS_PACRC_TP3. */
#define BF_AIPS_PACRC_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_TP3) & BM_AIPS_PACRC_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRC_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRC_WP3    (17U)         /*!< Bit position for AIPS_PACRC_WP3. */
#define BM_AIPS_PACRC_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRC_WP3. */
#define BS_AIPS_PACRC_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRC_WP3. */

/*! @brief Read current value of the AIPS_PACRC_WP3 field. */
#define BR_AIPS_PACRC_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP3))

/*! @brief Format value for bitfield AIPS_PACRC_WP3. */
#define BF_AIPS_PACRC_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_WP3) & BM_AIPS_PACRC_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRC_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRC_SP3    (18U)         /*!< Bit position for AIPS_PACRC_SP3. */
#define BM_AIPS_PACRC_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRC_SP3. */
#define BS_AIPS_PACRC_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRC_SP3. */

/*! @brief Read current value of the AIPS_PACRC_SP3 field. */
#define BR_AIPS_PACRC_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP3))

/*! @brief Format value for bitfield AIPS_PACRC_SP3. */
#define BF_AIPS_PACRC_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_SP3) & BM_AIPS_PACRC_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRC_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRC_TP2    (20U)         /*!< Bit position for AIPS_PACRC_TP2. */
#define BM_AIPS_PACRC_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRC_TP2. */
#define BS_AIPS_PACRC_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRC_TP2. */

/*! @brief Read current value of the AIPS_PACRC_TP2 field. */
#define BR_AIPS_PACRC_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP2))

/*! @brief Format value for bitfield AIPS_PACRC_TP2. */
#define BF_AIPS_PACRC_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_TP2) & BM_AIPS_PACRC_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRC_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRC_WP2    (21U)         /*!< Bit position for AIPS_PACRC_WP2. */
#define BM_AIPS_PACRC_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRC_WP2. */
#define BS_AIPS_PACRC_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRC_WP2. */

/*! @brief Read current value of the AIPS_PACRC_WP2 field. */
#define BR_AIPS_PACRC_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP2))

/*! @brief Format value for bitfield AIPS_PACRC_WP2. */
#define BF_AIPS_PACRC_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_WP2) & BM_AIPS_PACRC_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRC_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRC_SP2    (22U)         /*!< Bit position for AIPS_PACRC_SP2. */
#define BM_AIPS_PACRC_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRC_SP2. */
#define BS_AIPS_PACRC_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRC_SP2. */

/*! @brief Read current value of the AIPS_PACRC_SP2 field. */
#define BR_AIPS_PACRC_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP2))

/*! @brief Format value for bitfield AIPS_PACRC_SP2. */
#define BF_AIPS_PACRC_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_SP2) & BM_AIPS_PACRC_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRC_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRC_TP1    (24U)         /*!< Bit position for AIPS_PACRC_TP1. */
#define BM_AIPS_PACRC_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRC_TP1. */
#define BS_AIPS_PACRC_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRC_TP1. */

/*! @brief Read current value of the AIPS_PACRC_TP1 field. */
#define BR_AIPS_PACRC_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP1))

/*! @brief Format value for bitfield AIPS_PACRC_TP1. */
#define BF_AIPS_PACRC_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_TP1) & BM_AIPS_PACRC_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRC_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRC_WP1    (25U)         /*!< Bit position for AIPS_PACRC_WP1. */
#define BM_AIPS_PACRC_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRC_WP1. */
#define BS_AIPS_PACRC_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRC_WP1. */

/*! @brief Read current value of the AIPS_PACRC_WP1 field. */
#define BR_AIPS_PACRC_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP1))

/*! @brief Format value for bitfield AIPS_PACRC_WP1. */
#define BF_AIPS_PACRC_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_WP1) & BM_AIPS_PACRC_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRC_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRC_SP1    (26U)         /*!< Bit position for AIPS_PACRC_SP1. */
#define BM_AIPS_PACRC_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRC_SP1. */
#define BS_AIPS_PACRC_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRC_SP1. */

/*! @brief Read current value of the AIPS_PACRC_SP1 field. */
#define BR_AIPS_PACRC_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP1))

/*! @brief Format value for bitfield AIPS_PACRC_SP1. */
#define BF_AIPS_PACRC_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_SP1) & BM_AIPS_PACRC_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRC_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRC_TP0    (28U)         /*!< Bit position for AIPS_PACRC_TP0. */
#define BM_AIPS_PACRC_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRC_TP0. */
#define BS_AIPS_PACRC_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRC_TP0. */

/*! @brief Read current value of the AIPS_PACRC_TP0 field. */
#define BR_AIPS_PACRC_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP0))

/*! @brief Format value for bitfield AIPS_PACRC_TP0. */
#define BF_AIPS_PACRC_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_TP0) & BM_AIPS_PACRC_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRC_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRC_WP0    (29U)         /*!< Bit position for AIPS_PACRC_WP0. */
#define BM_AIPS_PACRC_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRC_WP0. */
#define BS_AIPS_PACRC_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRC_WP0. */

/*! @brief Read current value of the AIPS_PACRC_WP0 field. */
#define BR_AIPS_PACRC_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP0))

/*! @brief Format value for bitfield AIPS_PACRC_WP0. */
#define BF_AIPS_PACRC_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_WP0) & BM_AIPS_PACRC_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRC_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRC_SP0    (30U)         /*!< Bit position for AIPS_PACRC_SP0. */
#define BM_AIPS_PACRC_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRC_SP0. */
#define BS_AIPS_PACRC_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRC_SP0. */

/*! @brief Read current value of the AIPS_PACRC_SP0 field. */
#define BR_AIPS_PACRC_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP0))

/*! @brief Format value for bitfield AIPS_PACRC_SP0. */
#define BF_AIPS_PACRC_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRC_SP0) & BM_AIPS_PACRC_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRC_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRC_ADDR(x), BP_AIPS_PACRC_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRD - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRD - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000004U
 *
 * Each PACR register consists of eight 4-bit PACR fields. Each PACR field
 * defines the access levels for a particular peripheral. The mapping between a
 * peripheral and its PACR field is shown in the table below. The peripheral assignment
 * to each PACR is defined by the memory map slot that the peripheral is
 * assigned to. See this chip's memory map for the assignment of a particular
 * peripheral. The following table shows the location of each peripheral slot's PACR field
 * in the PACR registers. Offset Register [31:28] [27:24] [23:20] [19:16] [15:12]
 * [11:8] [7:4] [3:0] 0x20 PACRA PACR0 PACR1 PACR2 PACR3 PACR4 PACR5 PACR6 PACR7
 * 0x24 PACRB PACR8 PACR9 PACR10 PACR11 PACR12 PACR13 PACR14 PACR15 0x28 PACRC
 * PACR16 PACR17 PACR18 PACR19 PACR20 PACR21 PACR22 PACR23 0x2C PACRD PACR24
 * PACR25 PACR26 PACR27 PACR28 PACR29 PACR30 PACR31 0x30 Reserved 0x34 Reserved 0x38
 * Reserved 0x3C Reserved 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36 PACR37
 * PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45 PACR46 PACR47
 * 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55 0x4C PACRH
 * PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI PACR64
 * PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73 PACR74
 * PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82 PACR83
 * PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92 PACR93
 * PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101 PACR102
 * PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109 PACR110
 * PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118 PACR119
 * 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126 PACR127 0x80
 * PACRU PACR GBL0 PACR GBL1 Reserved The register field descriptions for PACR
 * A-D, which control peripheral slots 0-31, are shown below. The following
 * section, PACRPeripheral Access Control Register , shows the register field
 * descriptions for PACR E-P. All PACR registers are identical. They are divided into two
 * sections because they occupy two non-contiguous address spaces.
 */
typedef union _hw_aips_pacrd
{
    uint32_t U;
    struct _hw_aips_pacrd_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrd_t;

/*!
 * @name Constants and macros for entire AIPS_PACRD register
 */
/*@{*/
#define HW_AIPS_PACRD_ADDR(x)    ((uint32_t)(x) + 0x2CU)

#define HW_AIPS_PACRD(x)         (*(__IO hw_aips_pacrd_t *) HW_AIPS_PACRD_ADDR(x))
#define HW_AIPS_PACRD_RD(x)      (HW_AIPS_PACRD(x).U)
#define HW_AIPS_PACRD_WR(x, v)   (HW_AIPS_PACRD(x).U = (v))
#define HW_AIPS_PACRD_SET(x, v)  (HW_AIPS_PACRD_WR(x, HW_AIPS_PACRD_RD(x) |  (v)))
#define HW_AIPS_PACRD_CLR(x, v)  (HW_AIPS_PACRD_WR(x, HW_AIPS_PACRD_RD(x) & ~(v)))
#define HW_AIPS_PACRD_TOG(x, v)  (HW_AIPS_PACRD_WR(x, HW_AIPS_PACRD_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRD bitfields
 */

/*!
 * @name Register AIPS_PACRD, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRD_TP7    (0U)          /*!< Bit position for AIPS_PACRD_TP7. */
#define BM_AIPS_PACRD_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRD_TP7. */
#define BS_AIPS_PACRD_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRD_TP7. */

/*! @brief Read current value of the AIPS_PACRD_TP7 field. */
#define BR_AIPS_PACRD_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP7))

/*! @brief Format value for bitfield AIPS_PACRD_TP7. */
#define BF_AIPS_PACRD_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_TP7) & BM_AIPS_PACRD_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRD_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRD_WP7    (1U)          /*!< Bit position for AIPS_PACRD_WP7. */
#define BM_AIPS_PACRD_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRD_WP7. */
#define BS_AIPS_PACRD_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRD_WP7. */

/*! @brief Read current value of the AIPS_PACRD_WP7 field. */
#define BR_AIPS_PACRD_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP7))

/*! @brief Format value for bitfield AIPS_PACRD_WP7. */
#define BF_AIPS_PACRD_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_WP7) & BM_AIPS_PACRD_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRD_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRD_SP7    (2U)          /*!< Bit position for AIPS_PACRD_SP7. */
#define BM_AIPS_PACRD_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRD_SP7. */
#define BS_AIPS_PACRD_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRD_SP7. */

/*! @brief Read current value of the AIPS_PACRD_SP7 field. */
#define BR_AIPS_PACRD_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP7))

/*! @brief Format value for bitfield AIPS_PACRD_SP7. */
#define BF_AIPS_PACRD_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_SP7) & BM_AIPS_PACRD_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRD_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRD_TP6    (4U)          /*!< Bit position for AIPS_PACRD_TP6. */
#define BM_AIPS_PACRD_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRD_TP6. */
#define BS_AIPS_PACRD_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRD_TP6. */

/*! @brief Read current value of the AIPS_PACRD_TP6 field. */
#define BR_AIPS_PACRD_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP6))

/*! @brief Format value for bitfield AIPS_PACRD_TP6. */
#define BF_AIPS_PACRD_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_TP6) & BM_AIPS_PACRD_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRD_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRD_WP6    (5U)          /*!< Bit position for AIPS_PACRD_WP6. */
#define BM_AIPS_PACRD_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRD_WP6. */
#define BS_AIPS_PACRD_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRD_WP6. */

/*! @brief Read current value of the AIPS_PACRD_WP6 field. */
#define BR_AIPS_PACRD_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP6))

/*! @brief Format value for bitfield AIPS_PACRD_WP6. */
#define BF_AIPS_PACRD_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_WP6) & BM_AIPS_PACRD_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRD_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRD_SP6    (6U)          /*!< Bit position for AIPS_PACRD_SP6. */
#define BM_AIPS_PACRD_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRD_SP6. */
#define BS_AIPS_PACRD_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRD_SP6. */

/*! @brief Read current value of the AIPS_PACRD_SP6 field. */
#define BR_AIPS_PACRD_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP6))

/*! @brief Format value for bitfield AIPS_PACRD_SP6. */
#define BF_AIPS_PACRD_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_SP6) & BM_AIPS_PACRD_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRD_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRD_TP5    (8U)          /*!< Bit position for AIPS_PACRD_TP5. */
#define BM_AIPS_PACRD_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRD_TP5. */
#define BS_AIPS_PACRD_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRD_TP5. */

/*! @brief Read current value of the AIPS_PACRD_TP5 field. */
#define BR_AIPS_PACRD_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP5))

/*! @brief Format value for bitfield AIPS_PACRD_TP5. */
#define BF_AIPS_PACRD_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_TP5) & BM_AIPS_PACRD_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRD_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRD_WP5    (9U)          /*!< Bit position for AIPS_PACRD_WP5. */
#define BM_AIPS_PACRD_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRD_WP5. */
#define BS_AIPS_PACRD_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRD_WP5. */

/*! @brief Read current value of the AIPS_PACRD_WP5 field. */
#define BR_AIPS_PACRD_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP5))

/*! @brief Format value for bitfield AIPS_PACRD_WP5. */
#define BF_AIPS_PACRD_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_WP5) & BM_AIPS_PACRD_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRD_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRD_SP5    (10U)         /*!< Bit position for AIPS_PACRD_SP5. */
#define BM_AIPS_PACRD_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRD_SP5. */
#define BS_AIPS_PACRD_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRD_SP5. */

/*! @brief Read current value of the AIPS_PACRD_SP5 field. */
#define BR_AIPS_PACRD_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP5))

/*! @brief Format value for bitfield AIPS_PACRD_SP5. */
#define BF_AIPS_PACRD_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_SP5) & BM_AIPS_PACRD_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRD_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRD_TP4    (12U)         /*!< Bit position for AIPS_PACRD_TP4. */
#define BM_AIPS_PACRD_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRD_TP4. */
#define BS_AIPS_PACRD_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRD_TP4. */

/*! @brief Read current value of the AIPS_PACRD_TP4 field. */
#define BR_AIPS_PACRD_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP4))

/*! @brief Format value for bitfield AIPS_PACRD_TP4. */
#define BF_AIPS_PACRD_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_TP4) & BM_AIPS_PACRD_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRD_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRD_WP4    (13U)         /*!< Bit position for AIPS_PACRD_WP4. */
#define BM_AIPS_PACRD_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRD_WP4. */
#define BS_AIPS_PACRD_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRD_WP4. */

/*! @brief Read current value of the AIPS_PACRD_WP4 field. */
#define BR_AIPS_PACRD_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP4))

/*! @brief Format value for bitfield AIPS_PACRD_WP4. */
#define BF_AIPS_PACRD_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_WP4) & BM_AIPS_PACRD_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRD_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRD_SP4    (14U)         /*!< Bit position for AIPS_PACRD_SP4. */
#define BM_AIPS_PACRD_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRD_SP4. */
#define BS_AIPS_PACRD_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRD_SP4. */

/*! @brief Read current value of the AIPS_PACRD_SP4 field. */
#define BR_AIPS_PACRD_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP4))

/*! @brief Format value for bitfield AIPS_PACRD_SP4. */
#define BF_AIPS_PACRD_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_SP4) & BM_AIPS_PACRD_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRD_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRD_TP3    (16U)         /*!< Bit position for AIPS_PACRD_TP3. */
#define BM_AIPS_PACRD_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRD_TP3. */
#define BS_AIPS_PACRD_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRD_TP3. */

/*! @brief Read current value of the AIPS_PACRD_TP3 field. */
#define BR_AIPS_PACRD_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP3))

/*! @brief Format value for bitfield AIPS_PACRD_TP3. */
#define BF_AIPS_PACRD_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_TP3) & BM_AIPS_PACRD_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRD_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRD_WP3    (17U)         /*!< Bit position for AIPS_PACRD_WP3. */
#define BM_AIPS_PACRD_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRD_WP3. */
#define BS_AIPS_PACRD_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRD_WP3. */

/*! @brief Read current value of the AIPS_PACRD_WP3 field. */
#define BR_AIPS_PACRD_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP3))

/*! @brief Format value for bitfield AIPS_PACRD_WP3. */
#define BF_AIPS_PACRD_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_WP3) & BM_AIPS_PACRD_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRD_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRD_SP3    (18U)         /*!< Bit position for AIPS_PACRD_SP3. */
#define BM_AIPS_PACRD_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRD_SP3. */
#define BS_AIPS_PACRD_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRD_SP3. */

/*! @brief Read current value of the AIPS_PACRD_SP3 field. */
#define BR_AIPS_PACRD_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP3))

/*! @brief Format value for bitfield AIPS_PACRD_SP3. */
#define BF_AIPS_PACRD_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_SP3) & BM_AIPS_PACRD_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRD_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRD_TP2    (20U)         /*!< Bit position for AIPS_PACRD_TP2. */
#define BM_AIPS_PACRD_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRD_TP2. */
#define BS_AIPS_PACRD_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRD_TP2. */

/*! @brief Read current value of the AIPS_PACRD_TP2 field. */
#define BR_AIPS_PACRD_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP2))

/*! @brief Format value for bitfield AIPS_PACRD_TP2. */
#define BF_AIPS_PACRD_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_TP2) & BM_AIPS_PACRD_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRD_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRD_WP2    (21U)         /*!< Bit position for AIPS_PACRD_WP2. */
#define BM_AIPS_PACRD_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRD_WP2. */
#define BS_AIPS_PACRD_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRD_WP2. */

/*! @brief Read current value of the AIPS_PACRD_WP2 field. */
#define BR_AIPS_PACRD_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP2))

/*! @brief Format value for bitfield AIPS_PACRD_WP2. */
#define BF_AIPS_PACRD_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_WP2) & BM_AIPS_PACRD_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRD_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRD_SP2    (22U)         /*!< Bit position for AIPS_PACRD_SP2. */
#define BM_AIPS_PACRD_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRD_SP2. */
#define BS_AIPS_PACRD_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRD_SP2. */

/*! @brief Read current value of the AIPS_PACRD_SP2 field. */
#define BR_AIPS_PACRD_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP2))

/*! @brief Format value for bitfield AIPS_PACRD_SP2. */
#define BF_AIPS_PACRD_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_SP2) & BM_AIPS_PACRD_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRD_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRD_TP1    (24U)         /*!< Bit position for AIPS_PACRD_TP1. */
#define BM_AIPS_PACRD_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRD_TP1. */
#define BS_AIPS_PACRD_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRD_TP1. */

/*! @brief Read current value of the AIPS_PACRD_TP1 field. */
#define BR_AIPS_PACRD_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP1))

/*! @brief Format value for bitfield AIPS_PACRD_TP1. */
#define BF_AIPS_PACRD_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_TP1) & BM_AIPS_PACRD_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRD_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRD_WP1    (25U)         /*!< Bit position for AIPS_PACRD_WP1. */
#define BM_AIPS_PACRD_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRD_WP1. */
#define BS_AIPS_PACRD_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRD_WP1. */

/*! @brief Read current value of the AIPS_PACRD_WP1 field. */
#define BR_AIPS_PACRD_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP1))

/*! @brief Format value for bitfield AIPS_PACRD_WP1. */
#define BF_AIPS_PACRD_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_WP1) & BM_AIPS_PACRD_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRD_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRD_SP1    (26U)         /*!< Bit position for AIPS_PACRD_SP1. */
#define BM_AIPS_PACRD_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRD_SP1. */
#define BS_AIPS_PACRD_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRD_SP1. */

/*! @brief Read current value of the AIPS_PACRD_SP1 field. */
#define BR_AIPS_PACRD_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP1))

/*! @brief Format value for bitfield AIPS_PACRD_SP1. */
#define BF_AIPS_PACRD_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_SP1) & BM_AIPS_PACRD_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRD_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRD_TP0    (28U)         /*!< Bit position for AIPS_PACRD_TP0. */
#define BM_AIPS_PACRD_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRD_TP0. */
#define BS_AIPS_PACRD_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRD_TP0. */

/*! @brief Read current value of the AIPS_PACRD_TP0 field. */
#define BR_AIPS_PACRD_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP0))

/*! @brief Format value for bitfield AIPS_PACRD_TP0. */
#define BF_AIPS_PACRD_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_TP0) & BM_AIPS_PACRD_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRD_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRD_WP0    (29U)         /*!< Bit position for AIPS_PACRD_WP0. */
#define BM_AIPS_PACRD_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRD_WP0. */
#define BS_AIPS_PACRD_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRD_WP0. */

/*! @brief Read current value of the AIPS_PACRD_WP0 field. */
#define BR_AIPS_PACRD_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP0))

/*! @brief Format value for bitfield AIPS_PACRD_WP0. */
#define BF_AIPS_PACRD_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_WP0) & BM_AIPS_PACRD_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRD_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRD_SP0    (30U)         /*!< Bit position for AIPS_PACRD_SP0. */
#define BM_AIPS_PACRD_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRD_SP0. */
#define BS_AIPS_PACRD_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRD_SP0. */

/*! @brief Read current value of the AIPS_PACRD_SP0 field. */
#define BR_AIPS_PACRD_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP0))

/*! @brief Format value for bitfield AIPS_PACRD_SP0. */
#define BF_AIPS_PACRD_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRD_SP0) & BM_AIPS_PACRD_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRD_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRD_ADDR(x), BP_AIPS_PACRD_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRE - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRE - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacre
{
    uint32_t U;
    struct _hw_aips_pacre_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacre_t;

/*!
 * @name Constants and macros for entire AIPS_PACRE register
 */
/*@{*/
#define HW_AIPS_PACRE_ADDR(x)    ((uint32_t)(x) + 0x40U)

#define HW_AIPS_PACRE(x)         (*(__IO hw_aips_pacre_t *) HW_AIPS_PACRE_ADDR(x))
#define HW_AIPS_PACRE_RD(x)      (HW_AIPS_PACRE(x).U)
#define HW_AIPS_PACRE_WR(x, v)   (HW_AIPS_PACRE(x).U = (v))
#define HW_AIPS_PACRE_SET(x, v)  (HW_AIPS_PACRE_WR(x, HW_AIPS_PACRE_RD(x) |  (v)))
#define HW_AIPS_PACRE_CLR(x, v)  (HW_AIPS_PACRE_WR(x, HW_AIPS_PACRE_RD(x) & ~(v)))
#define HW_AIPS_PACRE_TOG(x, v)  (HW_AIPS_PACRE_WR(x, HW_AIPS_PACRE_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRE bitfields
 */

/*!
 * @name Register AIPS_PACRE, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRE_TP7    (0U)          /*!< Bit position for AIPS_PACRE_TP7. */
#define BM_AIPS_PACRE_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRE_TP7. */
#define BS_AIPS_PACRE_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRE_TP7. */

/*! @brief Read current value of the AIPS_PACRE_TP7 field. */
#define BR_AIPS_PACRE_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP7))

/*! @brief Format value for bitfield AIPS_PACRE_TP7. */
#define BF_AIPS_PACRE_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_TP7) & BM_AIPS_PACRE_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRE_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRE_WP7    (1U)          /*!< Bit position for AIPS_PACRE_WP7. */
#define BM_AIPS_PACRE_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRE_WP7. */
#define BS_AIPS_PACRE_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRE_WP7. */

/*! @brief Read current value of the AIPS_PACRE_WP7 field. */
#define BR_AIPS_PACRE_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP7))

/*! @brief Format value for bitfield AIPS_PACRE_WP7. */
#define BF_AIPS_PACRE_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_WP7) & BM_AIPS_PACRE_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRE_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRE_SP7    (2U)          /*!< Bit position for AIPS_PACRE_SP7. */
#define BM_AIPS_PACRE_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRE_SP7. */
#define BS_AIPS_PACRE_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRE_SP7. */

/*! @brief Read current value of the AIPS_PACRE_SP7 field. */
#define BR_AIPS_PACRE_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP7))

/*! @brief Format value for bitfield AIPS_PACRE_SP7. */
#define BF_AIPS_PACRE_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_SP7) & BM_AIPS_PACRE_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRE_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRE_TP6    (4U)          /*!< Bit position for AIPS_PACRE_TP6. */
#define BM_AIPS_PACRE_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRE_TP6. */
#define BS_AIPS_PACRE_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRE_TP6. */

/*! @brief Read current value of the AIPS_PACRE_TP6 field. */
#define BR_AIPS_PACRE_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP6))

/*! @brief Format value for bitfield AIPS_PACRE_TP6. */
#define BF_AIPS_PACRE_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_TP6) & BM_AIPS_PACRE_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRE_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRE_WP6    (5U)          /*!< Bit position for AIPS_PACRE_WP6. */
#define BM_AIPS_PACRE_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRE_WP6. */
#define BS_AIPS_PACRE_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRE_WP6. */

/*! @brief Read current value of the AIPS_PACRE_WP6 field. */
#define BR_AIPS_PACRE_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP6))

/*! @brief Format value for bitfield AIPS_PACRE_WP6. */
#define BF_AIPS_PACRE_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_WP6) & BM_AIPS_PACRE_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRE_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRE_SP6    (6U)          /*!< Bit position for AIPS_PACRE_SP6. */
#define BM_AIPS_PACRE_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRE_SP6. */
#define BS_AIPS_PACRE_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRE_SP6. */

/*! @brief Read current value of the AIPS_PACRE_SP6 field. */
#define BR_AIPS_PACRE_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP6))

/*! @brief Format value for bitfield AIPS_PACRE_SP6. */
#define BF_AIPS_PACRE_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_SP6) & BM_AIPS_PACRE_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRE_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRE_TP5    (8U)          /*!< Bit position for AIPS_PACRE_TP5. */
#define BM_AIPS_PACRE_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRE_TP5. */
#define BS_AIPS_PACRE_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRE_TP5. */

/*! @brief Read current value of the AIPS_PACRE_TP5 field. */
#define BR_AIPS_PACRE_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP5))

/*! @brief Format value for bitfield AIPS_PACRE_TP5. */
#define BF_AIPS_PACRE_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_TP5) & BM_AIPS_PACRE_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRE_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRE_WP5    (9U)          /*!< Bit position for AIPS_PACRE_WP5. */
#define BM_AIPS_PACRE_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRE_WP5. */
#define BS_AIPS_PACRE_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRE_WP5. */

/*! @brief Read current value of the AIPS_PACRE_WP5 field. */
#define BR_AIPS_PACRE_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP5))

/*! @brief Format value for bitfield AIPS_PACRE_WP5. */
#define BF_AIPS_PACRE_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_WP5) & BM_AIPS_PACRE_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRE_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRE_SP5    (10U)         /*!< Bit position for AIPS_PACRE_SP5. */
#define BM_AIPS_PACRE_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRE_SP5. */
#define BS_AIPS_PACRE_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRE_SP5. */

/*! @brief Read current value of the AIPS_PACRE_SP5 field. */
#define BR_AIPS_PACRE_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP5))

/*! @brief Format value for bitfield AIPS_PACRE_SP5. */
#define BF_AIPS_PACRE_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_SP5) & BM_AIPS_PACRE_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRE_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRE_TP4    (12U)         /*!< Bit position for AIPS_PACRE_TP4. */
#define BM_AIPS_PACRE_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRE_TP4. */
#define BS_AIPS_PACRE_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRE_TP4. */

/*! @brief Read current value of the AIPS_PACRE_TP4 field. */
#define BR_AIPS_PACRE_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP4))

/*! @brief Format value for bitfield AIPS_PACRE_TP4. */
#define BF_AIPS_PACRE_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_TP4) & BM_AIPS_PACRE_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRE_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRE_WP4    (13U)         /*!< Bit position for AIPS_PACRE_WP4. */
#define BM_AIPS_PACRE_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRE_WP4. */
#define BS_AIPS_PACRE_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRE_WP4. */

/*! @brief Read current value of the AIPS_PACRE_WP4 field. */
#define BR_AIPS_PACRE_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP4))

/*! @brief Format value for bitfield AIPS_PACRE_WP4. */
#define BF_AIPS_PACRE_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_WP4) & BM_AIPS_PACRE_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRE_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRE_SP4    (14U)         /*!< Bit position for AIPS_PACRE_SP4. */
#define BM_AIPS_PACRE_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRE_SP4. */
#define BS_AIPS_PACRE_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRE_SP4. */

/*! @brief Read current value of the AIPS_PACRE_SP4 field. */
#define BR_AIPS_PACRE_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP4))

/*! @brief Format value for bitfield AIPS_PACRE_SP4. */
#define BF_AIPS_PACRE_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_SP4) & BM_AIPS_PACRE_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRE_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRE_TP3    (16U)         /*!< Bit position for AIPS_PACRE_TP3. */
#define BM_AIPS_PACRE_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRE_TP3. */
#define BS_AIPS_PACRE_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRE_TP3. */

/*! @brief Read current value of the AIPS_PACRE_TP3 field. */
#define BR_AIPS_PACRE_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP3))

/*! @brief Format value for bitfield AIPS_PACRE_TP3. */
#define BF_AIPS_PACRE_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_TP3) & BM_AIPS_PACRE_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRE_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRE_WP3    (17U)         /*!< Bit position for AIPS_PACRE_WP3. */
#define BM_AIPS_PACRE_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRE_WP3. */
#define BS_AIPS_PACRE_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRE_WP3. */

/*! @brief Read current value of the AIPS_PACRE_WP3 field. */
#define BR_AIPS_PACRE_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP3))

/*! @brief Format value for bitfield AIPS_PACRE_WP3. */
#define BF_AIPS_PACRE_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_WP3) & BM_AIPS_PACRE_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRE_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRE_SP3    (18U)         /*!< Bit position for AIPS_PACRE_SP3. */
#define BM_AIPS_PACRE_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRE_SP3. */
#define BS_AIPS_PACRE_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRE_SP3. */

/*! @brief Read current value of the AIPS_PACRE_SP3 field. */
#define BR_AIPS_PACRE_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP3))

/*! @brief Format value for bitfield AIPS_PACRE_SP3. */
#define BF_AIPS_PACRE_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_SP3) & BM_AIPS_PACRE_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRE_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRE_TP2    (20U)         /*!< Bit position for AIPS_PACRE_TP2. */
#define BM_AIPS_PACRE_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRE_TP2. */
#define BS_AIPS_PACRE_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRE_TP2. */

/*! @brief Read current value of the AIPS_PACRE_TP2 field. */
#define BR_AIPS_PACRE_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP2))

/*! @brief Format value for bitfield AIPS_PACRE_TP2. */
#define BF_AIPS_PACRE_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_TP2) & BM_AIPS_PACRE_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRE_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRE_WP2    (21U)         /*!< Bit position for AIPS_PACRE_WP2. */
#define BM_AIPS_PACRE_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRE_WP2. */
#define BS_AIPS_PACRE_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRE_WP2. */

/*! @brief Read current value of the AIPS_PACRE_WP2 field. */
#define BR_AIPS_PACRE_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP2))

/*! @brief Format value for bitfield AIPS_PACRE_WP2. */
#define BF_AIPS_PACRE_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_WP2) & BM_AIPS_PACRE_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRE_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRE_SP2    (22U)         /*!< Bit position for AIPS_PACRE_SP2. */
#define BM_AIPS_PACRE_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRE_SP2. */
#define BS_AIPS_PACRE_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRE_SP2. */

/*! @brief Read current value of the AIPS_PACRE_SP2 field. */
#define BR_AIPS_PACRE_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP2))

/*! @brief Format value for bitfield AIPS_PACRE_SP2. */
#define BF_AIPS_PACRE_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_SP2) & BM_AIPS_PACRE_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRE_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRE_TP1    (24U)         /*!< Bit position for AIPS_PACRE_TP1. */
#define BM_AIPS_PACRE_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRE_TP1. */
#define BS_AIPS_PACRE_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRE_TP1. */

/*! @brief Read current value of the AIPS_PACRE_TP1 field. */
#define BR_AIPS_PACRE_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP1))

/*! @brief Format value for bitfield AIPS_PACRE_TP1. */
#define BF_AIPS_PACRE_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_TP1) & BM_AIPS_PACRE_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRE_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRE_WP1    (25U)         /*!< Bit position for AIPS_PACRE_WP1. */
#define BM_AIPS_PACRE_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRE_WP1. */
#define BS_AIPS_PACRE_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRE_WP1. */

/*! @brief Read current value of the AIPS_PACRE_WP1 field. */
#define BR_AIPS_PACRE_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP1))

/*! @brief Format value for bitfield AIPS_PACRE_WP1. */
#define BF_AIPS_PACRE_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_WP1) & BM_AIPS_PACRE_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRE_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRE_SP1    (26U)         /*!< Bit position for AIPS_PACRE_SP1. */
#define BM_AIPS_PACRE_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRE_SP1. */
#define BS_AIPS_PACRE_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRE_SP1. */

/*! @brief Read current value of the AIPS_PACRE_SP1 field. */
#define BR_AIPS_PACRE_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP1))

/*! @brief Format value for bitfield AIPS_PACRE_SP1. */
#define BF_AIPS_PACRE_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_SP1) & BM_AIPS_PACRE_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRE_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRE_TP0    (28U)         /*!< Bit position for AIPS_PACRE_TP0. */
#define BM_AIPS_PACRE_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRE_TP0. */
#define BS_AIPS_PACRE_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRE_TP0. */

/*! @brief Read current value of the AIPS_PACRE_TP0 field. */
#define BR_AIPS_PACRE_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP0))

/*! @brief Format value for bitfield AIPS_PACRE_TP0. */
#define BF_AIPS_PACRE_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_TP0) & BM_AIPS_PACRE_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRE_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRE_WP0    (29U)         /*!< Bit position for AIPS_PACRE_WP0. */
#define BM_AIPS_PACRE_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRE_WP0. */
#define BS_AIPS_PACRE_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRE_WP0. */

/*! @brief Read current value of the AIPS_PACRE_WP0 field. */
#define BR_AIPS_PACRE_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP0))

/*! @brief Format value for bitfield AIPS_PACRE_WP0. */
#define BF_AIPS_PACRE_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_WP0) & BM_AIPS_PACRE_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRE_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRE_SP0    (30U)         /*!< Bit position for AIPS_PACRE_SP0. */
#define BM_AIPS_PACRE_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRE_SP0. */
#define BS_AIPS_PACRE_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRE_SP0. */

/*! @brief Read current value of the AIPS_PACRE_SP0 field. */
#define BR_AIPS_PACRE_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP0))

/*! @brief Format value for bitfield AIPS_PACRE_SP0. */
#define BF_AIPS_PACRE_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRE_SP0) & BM_AIPS_PACRE_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRE_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRE_ADDR(x), BP_AIPS_PACRE_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRF - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRF - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacrf
{
    uint32_t U;
    struct _hw_aips_pacrf_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrf_t;

/*!
 * @name Constants and macros for entire AIPS_PACRF register
 */
/*@{*/
#define HW_AIPS_PACRF_ADDR(x)    ((uint32_t)(x) + 0x44U)

#define HW_AIPS_PACRF(x)         (*(__IO hw_aips_pacrf_t *) HW_AIPS_PACRF_ADDR(x))
#define HW_AIPS_PACRF_RD(x)      (HW_AIPS_PACRF(x).U)
#define HW_AIPS_PACRF_WR(x, v)   (HW_AIPS_PACRF(x).U = (v))
#define HW_AIPS_PACRF_SET(x, v)  (HW_AIPS_PACRF_WR(x, HW_AIPS_PACRF_RD(x) |  (v)))
#define HW_AIPS_PACRF_CLR(x, v)  (HW_AIPS_PACRF_WR(x, HW_AIPS_PACRF_RD(x) & ~(v)))
#define HW_AIPS_PACRF_TOG(x, v)  (HW_AIPS_PACRF_WR(x, HW_AIPS_PACRF_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRF bitfields
 */

/*!
 * @name Register AIPS_PACRF, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRF_TP7    (0U)          /*!< Bit position for AIPS_PACRF_TP7. */
#define BM_AIPS_PACRF_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRF_TP7. */
#define BS_AIPS_PACRF_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRF_TP7. */

/*! @brief Read current value of the AIPS_PACRF_TP7 field. */
#define BR_AIPS_PACRF_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP7))

/*! @brief Format value for bitfield AIPS_PACRF_TP7. */
#define BF_AIPS_PACRF_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_TP7) & BM_AIPS_PACRF_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRF_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRF_WP7    (1U)          /*!< Bit position for AIPS_PACRF_WP7. */
#define BM_AIPS_PACRF_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRF_WP7. */
#define BS_AIPS_PACRF_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRF_WP7. */

/*! @brief Read current value of the AIPS_PACRF_WP7 field. */
#define BR_AIPS_PACRF_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP7))

/*! @brief Format value for bitfield AIPS_PACRF_WP7. */
#define BF_AIPS_PACRF_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_WP7) & BM_AIPS_PACRF_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRF_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRF_SP7    (2U)          /*!< Bit position for AIPS_PACRF_SP7. */
#define BM_AIPS_PACRF_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRF_SP7. */
#define BS_AIPS_PACRF_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRF_SP7. */

/*! @brief Read current value of the AIPS_PACRF_SP7 field. */
#define BR_AIPS_PACRF_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP7))

/*! @brief Format value for bitfield AIPS_PACRF_SP7. */
#define BF_AIPS_PACRF_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_SP7) & BM_AIPS_PACRF_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRF_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRF_TP6    (4U)          /*!< Bit position for AIPS_PACRF_TP6. */
#define BM_AIPS_PACRF_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRF_TP6. */
#define BS_AIPS_PACRF_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRF_TP6. */

/*! @brief Read current value of the AIPS_PACRF_TP6 field. */
#define BR_AIPS_PACRF_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP6))

/*! @brief Format value for bitfield AIPS_PACRF_TP6. */
#define BF_AIPS_PACRF_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_TP6) & BM_AIPS_PACRF_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRF_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRF_WP6    (5U)          /*!< Bit position for AIPS_PACRF_WP6. */
#define BM_AIPS_PACRF_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRF_WP6. */
#define BS_AIPS_PACRF_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRF_WP6. */

/*! @brief Read current value of the AIPS_PACRF_WP6 field. */
#define BR_AIPS_PACRF_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP6))

/*! @brief Format value for bitfield AIPS_PACRF_WP6. */
#define BF_AIPS_PACRF_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_WP6) & BM_AIPS_PACRF_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRF_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRF_SP6    (6U)          /*!< Bit position for AIPS_PACRF_SP6. */
#define BM_AIPS_PACRF_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRF_SP6. */
#define BS_AIPS_PACRF_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRF_SP6. */

/*! @brief Read current value of the AIPS_PACRF_SP6 field. */
#define BR_AIPS_PACRF_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP6))

/*! @brief Format value for bitfield AIPS_PACRF_SP6. */
#define BF_AIPS_PACRF_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_SP6) & BM_AIPS_PACRF_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRF_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRF_TP5    (8U)          /*!< Bit position for AIPS_PACRF_TP5. */
#define BM_AIPS_PACRF_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRF_TP5. */
#define BS_AIPS_PACRF_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRF_TP5. */

/*! @brief Read current value of the AIPS_PACRF_TP5 field. */
#define BR_AIPS_PACRF_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP5))

/*! @brief Format value for bitfield AIPS_PACRF_TP5. */
#define BF_AIPS_PACRF_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_TP5) & BM_AIPS_PACRF_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRF_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRF_WP5    (9U)          /*!< Bit position for AIPS_PACRF_WP5. */
#define BM_AIPS_PACRF_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRF_WP5. */
#define BS_AIPS_PACRF_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRF_WP5. */

/*! @brief Read current value of the AIPS_PACRF_WP5 field. */
#define BR_AIPS_PACRF_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP5))

/*! @brief Format value for bitfield AIPS_PACRF_WP5. */
#define BF_AIPS_PACRF_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_WP5) & BM_AIPS_PACRF_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRF_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRF_SP5    (10U)         /*!< Bit position for AIPS_PACRF_SP5. */
#define BM_AIPS_PACRF_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRF_SP5. */
#define BS_AIPS_PACRF_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRF_SP5. */

/*! @brief Read current value of the AIPS_PACRF_SP5 field. */
#define BR_AIPS_PACRF_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP5))

/*! @brief Format value for bitfield AIPS_PACRF_SP5. */
#define BF_AIPS_PACRF_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_SP5) & BM_AIPS_PACRF_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRF_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRF_TP4    (12U)         /*!< Bit position for AIPS_PACRF_TP4. */
#define BM_AIPS_PACRF_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRF_TP4. */
#define BS_AIPS_PACRF_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRF_TP4. */

/*! @brief Read current value of the AIPS_PACRF_TP4 field. */
#define BR_AIPS_PACRF_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP4))

/*! @brief Format value for bitfield AIPS_PACRF_TP4. */
#define BF_AIPS_PACRF_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_TP4) & BM_AIPS_PACRF_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRF_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRF_WP4    (13U)         /*!< Bit position for AIPS_PACRF_WP4. */
#define BM_AIPS_PACRF_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRF_WP4. */
#define BS_AIPS_PACRF_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRF_WP4. */

/*! @brief Read current value of the AIPS_PACRF_WP4 field. */
#define BR_AIPS_PACRF_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP4))

/*! @brief Format value for bitfield AIPS_PACRF_WP4. */
#define BF_AIPS_PACRF_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_WP4) & BM_AIPS_PACRF_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRF_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRF_SP4    (14U)         /*!< Bit position for AIPS_PACRF_SP4. */
#define BM_AIPS_PACRF_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRF_SP4. */
#define BS_AIPS_PACRF_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRF_SP4. */

/*! @brief Read current value of the AIPS_PACRF_SP4 field. */
#define BR_AIPS_PACRF_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP4))

/*! @brief Format value for bitfield AIPS_PACRF_SP4. */
#define BF_AIPS_PACRF_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_SP4) & BM_AIPS_PACRF_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRF_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRF_TP3    (16U)         /*!< Bit position for AIPS_PACRF_TP3. */
#define BM_AIPS_PACRF_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRF_TP3. */
#define BS_AIPS_PACRF_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRF_TP3. */

/*! @brief Read current value of the AIPS_PACRF_TP3 field. */
#define BR_AIPS_PACRF_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP3))

/*! @brief Format value for bitfield AIPS_PACRF_TP3. */
#define BF_AIPS_PACRF_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_TP3) & BM_AIPS_PACRF_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRF_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRF_WP3    (17U)         /*!< Bit position for AIPS_PACRF_WP3. */
#define BM_AIPS_PACRF_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRF_WP3. */
#define BS_AIPS_PACRF_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRF_WP3. */

/*! @brief Read current value of the AIPS_PACRF_WP3 field. */
#define BR_AIPS_PACRF_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP3))

/*! @brief Format value for bitfield AIPS_PACRF_WP3. */
#define BF_AIPS_PACRF_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_WP3) & BM_AIPS_PACRF_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRF_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRF_SP3    (18U)         /*!< Bit position for AIPS_PACRF_SP3. */
#define BM_AIPS_PACRF_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRF_SP3. */
#define BS_AIPS_PACRF_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRF_SP3. */

/*! @brief Read current value of the AIPS_PACRF_SP3 field. */
#define BR_AIPS_PACRF_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP3))

/*! @brief Format value for bitfield AIPS_PACRF_SP3. */
#define BF_AIPS_PACRF_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_SP3) & BM_AIPS_PACRF_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRF_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRF_TP2    (20U)         /*!< Bit position for AIPS_PACRF_TP2. */
#define BM_AIPS_PACRF_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRF_TP2. */
#define BS_AIPS_PACRF_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRF_TP2. */

/*! @brief Read current value of the AIPS_PACRF_TP2 field. */
#define BR_AIPS_PACRF_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP2))

/*! @brief Format value for bitfield AIPS_PACRF_TP2. */
#define BF_AIPS_PACRF_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_TP2) & BM_AIPS_PACRF_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRF_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRF_WP2    (21U)         /*!< Bit position for AIPS_PACRF_WP2. */
#define BM_AIPS_PACRF_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRF_WP2. */
#define BS_AIPS_PACRF_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRF_WP2. */

/*! @brief Read current value of the AIPS_PACRF_WP2 field. */
#define BR_AIPS_PACRF_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP2))

/*! @brief Format value for bitfield AIPS_PACRF_WP2. */
#define BF_AIPS_PACRF_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_WP2) & BM_AIPS_PACRF_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRF_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRF_SP2    (22U)         /*!< Bit position for AIPS_PACRF_SP2. */
#define BM_AIPS_PACRF_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRF_SP2. */
#define BS_AIPS_PACRF_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRF_SP2. */

/*! @brief Read current value of the AIPS_PACRF_SP2 field. */
#define BR_AIPS_PACRF_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP2))

/*! @brief Format value for bitfield AIPS_PACRF_SP2. */
#define BF_AIPS_PACRF_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_SP2) & BM_AIPS_PACRF_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRF_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRF_TP1    (24U)         /*!< Bit position for AIPS_PACRF_TP1. */
#define BM_AIPS_PACRF_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRF_TP1. */
#define BS_AIPS_PACRF_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRF_TP1. */

/*! @brief Read current value of the AIPS_PACRF_TP1 field. */
#define BR_AIPS_PACRF_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP1))

/*! @brief Format value for bitfield AIPS_PACRF_TP1. */
#define BF_AIPS_PACRF_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_TP1) & BM_AIPS_PACRF_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRF_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRF_WP1    (25U)         /*!< Bit position for AIPS_PACRF_WP1. */
#define BM_AIPS_PACRF_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRF_WP1. */
#define BS_AIPS_PACRF_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRF_WP1. */

/*! @brief Read current value of the AIPS_PACRF_WP1 field. */
#define BR_AIPS_PACRF_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP1))

/*! @brief Format value for bitfield AIPS_PACRF_WP1. */
#define BF_AIPS_PACRF_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_WP1) & BM_AIPS_PACRF_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRF_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRF_SP1    (26U)         /*!< Bit position for AIPS_PACRF_SP1. */
#define BM_AIPS_PACRF_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRF_SP1. */
#define BS_AIPS_PACRF_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRF_SP1. */

/*! @brief Read current value of the AIPS_PACRF_SP1 field. */
#define BR_AIPS_PACRF_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP1))

/*! @brief Format value for bitfield AIPS_PACRF_SP1. */
#define BF_AIPS_PACRF_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_SP1) & BM_AIPS_PACRF_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRF_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRF_TP0    (28U)         /*!< Bit position for AIPS_PACRF_TP0. */
#define BM_AIPS_PACRF_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRF_TP0. */
#define BS_AIPS_PACRF_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRF_TP0. */

/*! @brief Read current value of the AIPS_PACRF_TP0 field. */
#define BR_AIPS_PACRF_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP0))

/*! @brief Format value for bitfield AIPS_PACRF_TP0. */
#define BF_AIPS_PACRF_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_TP0) & BM_AIPS_PACRF_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRF_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRF_WP0    (29U)         /*!< Bit position for AIPS_PACRF_WP0. */
#define BM_AIPS_PACRF_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRF_WP0. */
#define BS_AIPS_PACRF_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRF_WP0. */

/*! @brief Read current value of the AIPS_PACRF_WP0 field. */
#define BR_AIPS_PACRF_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP0))

/*! @brief Format value for bitfield AIPS_PACRF_WP0. */
#define BF_AIPS_PACRF_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_WP0) & BM_AIPS_PACRF_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRF_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRF_SP0    (30U)         /*!< Bit position for AIPS_PACRF_SP0. */
#define BM_AIPS_PACRF_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRF_SP0. */
#define BS_AIPS_PACRF_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRF_SP0. */

/*! @brief Read current value of the AIPS_PACRF_SP0 field. */
#define BR_AIPS_PACRF_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP0))

/*! @brief Format value for bitfield AIPS_PACRF_SP0. */
#define BF_AIPS_PACRF_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRF_SP0) & BM_AIPS_PACRF_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRF_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRF_ADDR(x), BP_AIPS_PACRF_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRG - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRG - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacrg
{
    uint32_t U;
    struct _hw_aips_pacrg_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrg_t;

/*!
 * @name Constants and macros for entire AIPS_PACRG register
 */
/*@{*/
#define HW_AIPS_PACRG_ADDR(x)    ((uint32_t)(x) + 0x48U)

#define HW_AIPS_PACRG(x)         (*(__IO hw_aips_pacrg_t *) HW_AIPS_PACRG_ADDR(x))
#define HW_AIPS_PACRG_RD(x)      (HW_AIPS_PACRG(x).U)
#define HW_AIPS_PACRG_WR(x, v)   (HW_AIPS_PACRG(x).U = (v))
#define HW_AIPS_PACRG_SET(x, v)  (HW_AIPS_PACRG_WR(x, HW_AIPS_PACRG_RD(x) |  (v)))
#define HW_AIPS_PACRG_CLR(x, v)  (HW_AIPS_PACRG_WR(x, HW_AIPS_PACRG_RD(x) & ~(v)))
#define HW_AIPS_PACRG_TOG(x, v)  (HW_AIPS_PACRG_WR(x, HW_AIPS_PACRG_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRG bitfields
 */

/*!
 * @name Register AIPS_PACRG, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRG_TP7    (0U)          /*!< Bit position for AIPS_PACRG_TP7. */
#define BM_AIPS_PACRG_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRG_TP7. */
#define BS_AIPS_PACRG_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRG_TP7. */

/*! @brief Read current value of the AIPS_PACRG_TP7 field. */
#define BR_AIPS_PACRG_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP7))

/*! @brief Format value for bitfield AIPS_PACRG_TP7. */
#define BF_AIPS_PACRG_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_TP7) & BM_AIPS_PACRG_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRG_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRG_WP7    (1U)          /*!< Bit position for AIPS_PACRG_WP7. */
#define BM_AIPS_PACRG_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRG_WP7. */
#define BS_AIPS_PACRG_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRG_WP7. */

/*! @brief Read current value of the AIPS_PACRG_WP7 field. */
#define BR_AIPS_PACRG_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP7))

/*! @brief Format value for bitfield AIPS_PACRG_WP7. */
#define BF_AIPS_PACRG_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_WP7) & BM_AIPS_PACRG_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRG_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRG_SP7    (2U)          /*!< Bit position for AIPS_PACRG_SP7. */
#define BM_AIPS_PACRG_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRG_SP7. */
#define BS_AIPS_PACRG_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRG_SP7. */

/*! @brief Read current value of the AIPS_PACRG_SP7 field. */
#define BR_AIPS_PACRG_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP7))

/*! @brief Format value for bitfield AIPS_PACRG_SP7. */
#define BF_AIPS_PACRG_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_SP7) & BM_AIPS_PACRG_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRG_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRG_TP6    (4U)          /*!< Bit position for AIPS_PACRG_TP6. */
#define BM_AIPS_PACRG_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRG_TP6. */
#define BS_AIPS_PACRG_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRG_TP6. */

/*! @brief Read current value of the AIPS_PACRG_TP6 field. */
#define BR_AIPS_PACRG_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP6))

/*! @brief Format value for bitfield AIPS_PACRG_TP6. */
#define BF_AIPS_PACRG_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_TP6) & BM_AIPS_PACRG_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRG_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRG_WP6    (5U)          /*!< Bit position for AIPS_PACRG_WP6. */
#define BM_AIPS_PACRG_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRG_WP6. */
#define BS_AIPS_PACRG_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRG_WP6. */

/*! @brief Read current value of the AIPS_PACRG_WP6 field. */
#define BR_AIPS_PACRG_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP6))

/*! @brief Format value for bitfield AIPS_PACRG_WP6. */
#define BF_AIPS_PACRG_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_WP6) & BM_AIPS_PACRG_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRG_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRG_SP6    (6U)          /*!< Bit position for AIPS_PACRG_SP6. */
#define BM_AIPS_PACRG_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRG_SP6. */
#define BS_AIPS_PACRG_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRG_SP6. */

/*! @brief Read current value of the AIPS_PACRG_SP6 field. */
#define BR_AIPS_PACRG_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP6))

/*! @brief Format value for bitfield AIPS_PACRG_SP6. */
#define BF_AIPS_PACRG_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_SP6) & BM_AIPS_PACRG_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRG_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRG_TP5    (8U)          /*!< Bit position for AIPS_PACRG_TP5. */
#define BM_AIPS_PACRG_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRG_TP5. */
#define BS_AIPS_PACRG_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRG_TP5. */

/*! @brief Read current value of the AIPS_PACRG_TP5 field. */
#define BR_AIPS_PACRG_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP5))

/*! @brief Format value for bitfield AIPS_PACRG_TP5. */
#define BF_AIPS_PACRG_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_TP5) & BM_AIPS_PACRG_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRG_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRG_WP5    (9U)          /*!< Bit position for AIPS_PACRG_WP5. */
#define BM_AIPS_PACRG_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRG_WP5. */
#define BS_AIPS_PACRG_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRG_WP5. */

/*! @brief Read current value of the AIPS_PACRG_WP5 field. */
#define BR_AIPS_PACRG_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP5))

/*! @brief Format value for bitfield AIPS_PACRG_WP5. */
#define BF_AIPS_PACRG_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_WP5) & BM_AIPS_PACRG_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRG_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRG_SP5    (10U)         /*!< Bit position for AIPS_PACRG_SP5. */
#define BM_AIPS_PACRG_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRG_SP5. */
#define BS_AIPS_PACRG_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRG_SP5. */

/*! @brief Read current value of the AIPS_PACRG_SP5 field. */
#define BR_AIPS_PACRG_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP5))

/*! @brief Format value for bitfield AIPS_PACRG_SP5. */
#define BF_AIPS_PACRG_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_SP5) & BM_AIPS_PACRG_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRG_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRG_TP4    (12U)         /*!< Bit position for AIPS_PACRG_TP4. */
#define BM_AIPS_PACRG_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRG_TP4. */
#define BS_AIPS_PACRG_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRG_TP4. */

/*! @brief Read current value of the AIPS_PACRG_TP4 field. */
#define BR_AIPS_PACRG_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP4))

/*! @brief Format value for bitfield AIPS_PACRG_TP4. */
#define BF_AIPS_PACRG_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_TP4) & BM_AIPS_PACRG_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRG_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRG_WP4    (13U)         /*!< Bit position for AIPS_PACRG_WP4. */
#define BM_AIPS_PACRG_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRG_WP4. */
#define BS_AIPS_PACRG_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRG_WP4. */

/*! @brief Read current value of the AIPS_PACRG_WP4 field. */
#define BR_AIPS_PACRG_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP4))

/*! @brief Format value for bitfield AIPS_PACRG_WP4. */
#define BF_AIPS_PACRG_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_WP4) & BM_AIPS_PACRG_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRG_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRG_SP4    (14U)         /*!< Bit position for AIPS_PACRG_SP4. */
#define BM_AIPS_PACRG_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRG_SP4. */
#define BS_AIPS_PACRG_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRG_SP4. */

/*! @brief Read current value of the AIPS_PACRG_SP4 field. */
#define BR_AIPS_PACRG_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP4))

/*! @brief Format value for bitfield AIPS_PACRG_SP4. */
#define BF_AIPS_PACRG_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_SP4) & BM_AIPS_PACRG_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRG_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRG_TP3    (16U)         /*!< Bit position for AIPS_PACRG_TP3. */
#define BM_AIPS_PACRG_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRG_TP3. */
#define BS_AIPS_PACRG_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRG_TP3. */

/*! @brief Read current value of the AIPS_PACRG_TP3 field. */
#define BR_AIPS_PACRG_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP3))

/*! @brief Format value for bitfield AIPS_PACRG_TP3. */
#define BF_AIPS_PACRG_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_TP3) & BM_AIPS_PACRG_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRG_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRG_WP3    (17U)         /*!< Bit position for AIPS_PACRG_WP3. */
#define BM_AIPS_PACRG_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRG_WP3. */
#define BS_AIPS_PACRG_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRG_WP3. */

/*! @brief Read current value of the AIPS_PACRG_WP3 field. */
#define BR_AIPS_PACRG_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP3))

/*! @brief Format value for bitfield AIPS_PACRG_WP3. */
#define BF_AIPS_PACRG_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_WP3) & BM_AIPS_PACRG_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRG_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRG_SP3    (18U)         /*!< Bit position for AIPS_PACRG_SP3. */
#define BM_AIPS_PACRG_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRG_SP3. */
#define BS_AIPS_PACRG_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRG_SP3. */

/*! @brief Read current value of the AIPS_PACRG_SP3 field. */
#define BR_AIPS_PACRG_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP3))

/*! @brief Format value for bitfield AIPS_PACRG_SP3. */
#define BF_AIPS_PACRG_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_SP3) & BM_AIPS_PACRG_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRG_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRG_TP2    (20U)         /*!< Bit position for AIPS_PACRG_TP2. */
#define BM_AIPS_PACRG_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRG_TP2. */
#define BS_AIPS_PACRG_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRG_TP2. */

/*! @brief Read current value of the AIPS_PACRG_TP2 field. */
#define BR_AIPS_PACRG_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP2))

/*! @brief Format value for bitfield AIPS_PACRG_TP2. */
#define BF_AIPS_PACRG_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_TP2) & BM_AIPS_PACRG_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRG_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRG_WP2    (21U)         /*!< Bit position for AIPS_PACRG_WP2. */
#define BM_AIPS_PACRG_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRG_WP2. */
#define BS_AIPS_PACRG_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRG_WP2. */

/*! @brief Read current value of the AIPS_PACRG_WP2 field. */
#define BR_AIPS_PACRG_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP2))

/*! @brief Format value for bitfield AIPS_PACRG_WP2. */
#define BF_AIPS_PACRG_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_WP2) & BM_AIPS_PACRG_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRG_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRG_SP2    (22U)         /*!< Bit position for AIPS_PACRG_SP2. */
#define BM_AIPS_PACRG_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRG_SP2. */
#define BS_AIPS_PACRG_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRG_SP2. */

/*! @brief Read current value of the AIPS_PACRG_SP2 field. */
#define BR_AIPS_PACRG_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP2))

/*! @brief Format value for bitfield AIPS_PACRG_SP2. */
#define BF_AIPS_PACRG_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_SP2) & BM_AIPS_PACRG_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRG_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRG_TP1    (24U)         /*!< Bit position for AIPS_PACRG_TP1. */
#define BM_AIPS_PACRG_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRG_TP1. */
#define BS_AIPS_PACRG_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRG_TP1. */

/*! @brief Read current value of the AIPS_PACRG_TP1 field. */
#define BR_AIPS_PACRG_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP1))

/*! @brief Format value for bitfield AIPS_PACRG_TP1. */
#define BF_AIPS_PACRG_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_TP1) & BM_AIPS_PACRG_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRG_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRG_WP1    (25U)         /*!< Bit position for AIPS_PACRG_WP1. */
#define BM_AIPS_PACRG_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRG_WP1. */
#define BS_AIPS_PACRG_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRG_WP1. */

/*! @brief Read current value of the AIPS_PACRG_WP1 field. */
#define BR_AIPS_PACRG_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP1))

/*! @brief Format value for bitfield AIPS_PACRG_WP1. */
#define BF_AIPS_PACRG_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_WP1) & BM_AIPS_PACRG_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRG_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRG_SP1    (26U)         /*!< Bit position for AIPS_PACRG_SP1. */
#define BM_AIPS_PACRG_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRG_SP1. */
#define BS_AIPS_PACRG_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRG_SP1. */

/*! @brief Read current value of the AIPS_PACRG_SP1 field. */
#define BR_AIPS_PACRG_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP1))

/*! @brief Format value for bitfield AIPS_PACRG_SP1. */
#define BF_AIPS_PACRG_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_SP1) & BM_AIPS_PACRG_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRG_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRG_TP0    (28U)         /*!< Bit position for AIPS_PACRG_TP0. */
#define BM_AIPS_PACRG_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRG_TP0. */
#define BS_AIPS_PACRG_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRG_TP0. */

/*! @brief Read current value of the AIPS_PACRG_TP0 field. */
#define BR_AIPS_PACRG_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP0))

/*! @brief Format value for bitfield AIPS_PACRG_TP0. */
#define BF_AIPS_PACRG_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_TP0) & BM_AIPS_PACRG_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRG_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRG_WP0    (29U)         /*!< Bit position for AIPS_PACRG_WP0. */
#define BM_AIPS_PACRG_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRG_WP0. */
#define BS_AIPS_PACRG_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRG_WP0. */

/*! @brief Read current value of the AIPS_PACRG_WP0 field. */
#define BR_AIPS_PACRG_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP0))

/*! @brief Format value for bitfield AIPS_PACRG_WP0. */
#define BF_AIPS_PACRG_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_WP0) & BM_AIPS_PACRG_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRG_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRG_SP0    (30U)         /*!< Bit position for AIPS_PACRG_SP0. */
#define BM_AIPS_PACRG_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRG_SP0. */
#define BS_AIPS_PACRG_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRG_SP0. */

/*! @brief Read current value of the AIPS_PACRG_SP0 field. */
#define BR_AIPS_PACRG_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP0))

/*! @brief Format value for bitfield AIPS_PACRG_SP0. */
#define BF_AIPS_PACRG_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRG_SP0) & BM_AIPS_PACRG_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRG_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRG_ADDR(x), BP_AIPS_PACRG_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRH - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRH - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacrh
{
    uint32_t U;
    struct _hw_aips_pacrh_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrh_t;

/*!
 * @name Constants and macros for entire AIPS_PACRH register
 */
/*@{*/
#define HW_AIPS_PACRH_ADDR(x)    ((uint32_t)(x) + 0x4CU)

#define HW_AIPS_PACRH(x)         (*(__IO hw_aips_pacrh_t *) HW_AIPS_PACRH_ADDR(x))
#define HW_AIPS_PACRH_RD(x)      (HW_AIPS_PACRH(x).U)
#define HW_AIPS_PACRH_WR(x, v)   (HW_AIPS_PACRH(x).U = (v))
#define HW_AIPS_PACRH_SET(x, v)  (HW_AIPS_PACRH_WR(x, HW_AIPS_PACRH_RD(x) |  (v)))
#define HW_AIPS_PACRH_CLR(x, v)  (HW_AIPS_PACRH_WR(x, HW_AIPS_PACRH_RD(x) & ~(v)))
#define HW_AIPS_PACRH_TOG(x, v)  (HW_AIPS_PACRH_WR(x, HW_AIPS_PACRH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRH bitfields
 */

/*!
 * @name Register AIPS_PACRH, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRH_TP7    (0U)          /*!< Bit position for AIPS_PACRH_TP7. */
#define BM_AIPS_PACRH_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRH_TP7. */
#define BS_AIPS_PACRH_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRH_TP7. */

/*! @brief Read current value of the AIPS_PACRH_TP7 field. */
#define BR_AIPS_PACRH_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP7))

/*! @brief Format value for bitfield AIPS_PACRH_TP7. */
#define BF_AIPS_PACRH_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_TP7) & BM_AIPS_PACRH_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRH_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRH_WP7    (1U)          /*!< Bit position for AIPS_PACRH_WP7. */
#define BM_AIPS_PACRH_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRH_WP7. */
#define BS_AIPS_PACRH_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRH_WP7. */

/*! @brief Read current value of the AIPS_PACRH_WP7 field. */
#define BR_AIPS_PACRH_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP7))

/*! @brief Format value for bitfield AIPS_PACRH_WP7. */
#define BF_AIPS_PACRH_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_WP7) & BM_AIPS_PACRH_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRH_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRH_SP7    (2U)          /*!< Bit position for AIPS_PACRH_SP7. */
#define BM_AIPS_PACRH_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRH_SP7. */
#define BS_AIPS_PACRH_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRH_SP7. */

/*! @brief Read current value of the AIPS_PACRH_SP7 field. */
#define BR_AIPS_PACRH_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP7))

/*! @brief Format value for bitfield AIPS_PACRH_SP7. */
#define BF_AIPS_PACRH_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_SP7) & BM_AIPS_PACRH_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRH_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRH_TP6    (4U)          /*!< Bit position for AIPS_PACRH_TP6. */
#define BM_AIPS_PACRH_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRH_TP6. */
#define BS_AIPS_PACRH_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRH_TP6. */

/*! @brief Read current value of the AIPS_PACRH_TP6 field. */
#define BR_AIPS_PACRH_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP6))

/*! @brief Format value for bitfield AIPS_PACRH_TP6. */
#define BF_AIPS_PACRH_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_TP6) & BM_AIPS_PACRH_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRH_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRH_WP6    (5U)          /*!< Bit position for AIPS_PACRH_WP6. */
#define BM_AIPS_PACRH_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRH_WP6. */
#define BS_AIPS_PACRH_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRH_WP6. */

/*! @brief Read current value of the AIPS_PACRH_WP6 field. */
#define BR_AIPS_PACRH_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP6))

/*! @brief Format value for bitfield AIPS_PACRH_WP6. */
#define BF_AIPS_PACRH_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_WP6) & BM_AIPS_PACRH_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRH_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRH_SP6    (6U)          /*!< Bit position for AIPS_PACRH_SP6. */
#define BM_AIPS_PACRH_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRH_SP6. */
#define BS_AIPS_PACRH_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRH_SP6. */

/*! @brief Read current value of the AIPS_PACRH_SP6 field. */
#define BR_AIPS_PACRH_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP6))

/*! @brief Format value for bitfield AIPS_PACRH_SP6. */
#define BF_AIPS_PACRH_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_SP6) & BM_AIPS_PACRH_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRH_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRH_TP5    (8U)          /*!< Bit position for AIPS_PACRH_TP5. */
#define BM_AIPS_PACRH_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRH_TP5. */
#define BS_AIPS_PACRH_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRH_TP5. */

/*! @brief Read current value of the AIPS_PACRH_TP5 field. */
#define BR_AIPS_PACRH_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP5))

/*! @brief Format value for bitfield AIPS_PACRH_TP5. */
#define BF_AIPS_PACRH_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_TP5) & BM_AIPS_PACRH_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRH_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRH_WP5    (9U)          /*!< Bit position for AIPS_PACRH_WP5. */
#define BM_AIPS_PACRH_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRH_WP5. */
#define BS_AIPS_PACRH_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRH_WP5. */

/*! @brief Read current value of the AIPS_PACRH_WP5 field. */
#define BR_AIPS_PACRH_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP5))

/*! @brief Format value for bitfield AIPS_PACRH_WP5. */
#define BF_AIPS_PACRH_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_WP5) & BM_AIPS_PACRH_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRH_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRH_SP5    (10U)         /*!< Bit position for AIPS_PACRH_SP5. */
#define BM_AIPS_PACRH_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRH_SP5. */
#define BS_AIPS_PACRH_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRH_SP5. */

/*! @brief Read current value of the AIPS_PACRH_SP5 field. */
#define BR_AIPS_PACRH_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP5))

/*! @brief Format value for bitfield AIPS_PACRH_SP5. */
#define BF_AIPS_PACRH_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_SP5) & BM_AIPS_PACRH_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRH_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRH_TP4    (12U)         /*!< Bit position for AIPS_PACRH_TP4. */
#define BM_AIPS_PACRH_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRH_TP4. */
#define BS_AIPS_PACRH_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRH_TP4. */

/*! @brief Read current value of the AIPS_PACRH_TP4 field. */
#define BR_AIPS_PACRH_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP4))

/*! @brief Format value for bitfield AIPS_PACRH_TP4. */
#define BF_AIPS_PACRH_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_TP4) & BM_AIPS_PACRH_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRH_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRH_WP4    (13U)         /*!< Bit position for AIPS_PACRH_WP4. */
#define BM_AIPS_PACRH_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRH_WP4. */
#define BS_AIPS_PACRH_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRH_WP4. */

/*! @brief Read current value of the AIPS_PACRH_WP4 field. */
#define BR_AIPS_PACRH_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP4))

/*! @brief Format value for bitfield AIPS_PACRH_WP4. */
#define BF_AIPS_PACRH_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_WP4) & BM_AIPS_PACRH_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRH_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRH_SP4    (14U)         /*!< Bit position for AIPS_PACRH_SP4. */
#define BM_AIPS_PACRH_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRH_SP4. */
#define BS_AIPS_PACRH_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRH_SP4. */

/*! @brief Read current value of the AIPS_PACRH_SP4 field. */
#define BR_AIPS_PACRH_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP4))

/*! @brief Format value for bitfield AIPS_PACRH_SP4. */
#define BF_AIPS_PACRH_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_SP4) & BM_AIPS_PACRH_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRH_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRH_TP3    (16U)         /*!< Bit position for AIPS_PACRH_TP3. */
#define BM_AIPS_PACRH_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRH_TP3. */
#define BS_AIPS_PACRH_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRH_TP3. */

/*! @brief Read current value of the AIPS_PACRH_TP3 field. */
#define BR_AIPS_PACRH_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP3))

/*! @brief Format value for bitfield AIPS_PACRH_TP3. */
#define BF_AIPS_PACRH_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_TP3) & BM_AIPS_PACRH_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRH_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRH_WP3    (17U)         /*!< Bit position for AIPS_PACRH_WP3. */
#define BM_AIPS_PACRH_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRH_WP3. */
#define BS_AIPS_PACRH_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRH_WP3. */

/*! @brief Read current value of the AIPS_PACRH_WP3 field. */
#define BR_AIPS_PACRH_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP3))

/*! @brief Format value for bitfield AIPS_PACRH_WP3. */
#define BF_AIPS_PACRH_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_WP3) & BM_AIPS_PACRH_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRH_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRH_SP3    (18U)         /*!< Bit position for AIPS_PACRH_SP3. */
#define BM_AIPS_PACRH_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRH_SP3. */
#define BS_AIPS_PACRH_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRH_SP3. */

/*! @brief Read current value of the AIPS_PACRH_SP3 field. */
#define BR_AIPS_PACRH_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP3))

/*! @brief Format value for bitfield AIPS_PACRH_SP3. */
#define BF_AIPS_PACRH_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_SP3) & BM_AIPS_PACRH_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRH_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRH_TP2    (20U)         /*!< Bit position for AIPS_PACRH_TP2. */
#define BM_AIPS_PACRH_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRH_TP2. */
#define BS_AIPS_PACRH_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRH_TP2. */

/*! @brief Read current value of the AIPS_PACRH_TP2 field. */
#define BR_AIPS_PACRH_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP2))

/*! @brief Format value for bitfield AIPS_PACRH_TP2. */
#define BF_AIPS_PACRH_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_TP2) & BM_AIPS_PACRH_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRH_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRH_WP2    (21U)         /*!< Bit position for AIPS_PACRH_WP2. */
#define BM_AIPS_PACRH_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRH_WP2. */
#define BS_AIPS_PACRH_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRH_WP2. */

/*! @brief Read current value of the AIPS_PACRH_WP2 field. */
#define BR_AIPS_PACRH_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP2))

/*! @brief Format value for bitfield AIPS_PACRH_WP2. */
#define BF_AIPS_PACRH_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_WP2) & BM_AIPS_PACRH_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRH_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRH_SP2    (22U)         /*!< Bit position for AIPS_PACRH_SP2. */
#define BM_AIPS_PACRH_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRH_SP2. */
#define BS_AIPS_PACRH_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRH_SP2. */

/*! @brief Read current value of the AIPS_PACRH_SP2 field. */
#define BR_AIPS_PACRH_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP2))

/*! @brief Format value for bitfield AIPS_PACRH_SP2. */
#define BF_AIPS_PACRH_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_SP2) & BM_AIPS_PACRH_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRH_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRH_TP1    (24U)         /*!< Bit position for AIPS_PACRH_TP1. */
#define BM_AIPS_PACRH_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRH_TP1. */
#define BS_AIPS_PACRH_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRH_TP1. */

/*! @brief Read current value of the AIPS_PACRH_TP1 field. */
#define BR_AIPS_PACRH_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP1))

/*! @brief Format value for bitfield AIPS_PACRH_TP1. */
#define BF_AIPS_PACRH_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_TP1) & BM_AIPS_PACRH_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRH_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRH_WP1    (25U)         /*!< Bit position for AIPS_PACRH_WP1. */
#define BM_AIPS_PACRH_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRH_WP1. */
#define BS_AIPS_PACRH_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRH_WP1. */

/*! @brief Read current value of the AIPS_PACRH_WP1 field. */
#define BR_AIPS_PACRH_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP1))

/*! @brief Format value for bitfield AIPS_PACRH_WP1. */
#define BF_AIPS_PACRH_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_WP1) & BM_AIPS_PACRH_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRH_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRH_SP1    (26U)         /*!< Bit position for AIPS_PACRH_SP1. */
#define BM_AIPS_PACRH_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRH_SP1. */
#define BS_AIPS_PACRH_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRH_SP1. */

/*! @brief Read current value of the AIPS_PACRH_SP1 field. */
#define BR_AIPS_PACRH_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP1))

/*! @brief Format value for bitfield AIPS_PACRH_SP1. */
#define BF_AIPS_PACRH_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_SP1) & BM_AIPS_PACRH_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRH_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRH_TP0    (28U)         /*!< Bit position for AIPS_PACRH_TP0. */
#define BM_AIPS_PACRH_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRH_TP0. */
#define BS_AIPS_PACRH_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRH_TP0. */

/*! @brief Read current value of the AIPS_PACRH_TP0 field. */
#define BR_AIPS_PACRH_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP0))

/*! @brief Format value for bitfield AIPS_PACRH_TP0. */
#define BF_AIPS_PACRH_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_TP0) & BM_AIPS_PACRH_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRH_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRH_WP0    (29U)         /*!< Bit position for AIPS_PACRH_WP0. */
#define BM_AIPS_PACRH_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRH_WP0. */
#define BS_AIPS_PACRH_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRH_WP0. */

/*! @brief Read current value of the AIPS_PACRH_WP0 field. */
#define BR_AIPS_PACRH_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP0))

/*! @brief Format value for bitfield AIPS_PACRH_WP0. */
#define BF_AIPS_PACRH_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_WP0) & BM_AIPS_PACRH_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRH_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRH_SP0    (30U)         /*!< Bit position for AIPS_PACRH_SP0. */
#define BM_AIPS_PACRH_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRH_SP0. */
#define BS_AIPS_PACRH_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRH_SP0. */

/*! @brief Read current value of the AIPS_PACRH_SP0 field. */
#define BR_AIPS_PACRH_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP0))

/*! @brief Format value for bitfield AIPS_PACRH_SP0. */
#define BF_AIPS_PACRH_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRH_SP0) & BM_AIPS_PACRH_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRH_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRH_ADDR(x), BP_AIPS_PACRH_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRI - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRI - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacri
{
    uint32_t U;
    struct _hw_aips_pacri_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacri_t;

/*!
 * @name Constants and macros for entire AIPS_PACRI register
 */
/*@{*/
#define HW_AIPS_PACRI_ADDR(x)    ((uint32_t)(x) + 0x50U)

#define HW_AIPS_PACRI(x)         (*(__IO hw_aips_pacri_t *) HW_AIPS_PACRI_ADDR(x))
#define HW_AIPS_PACRI_RD(x)      (HW_AIPS_PACRI(x).U)
#define HW_AIPS_PACRI_WR(x, v)   (HW_AIPS_PACRI(x).U = (v))
#define HW_AIPS_PACRI_SET(x, v)  (HW_AIPS_PACRI_WR(x, HW_AIPS_PACRI_RD(x) |  (v)))
#define HW_AIPS_PACRI_CLR(x, v)  (HW_AIPS_PACRI_WR(x, HW_AIPS_PACRI_RD(x) & ~(v)))
#define HW_AIPS_PACRI_TOG(x, v)  (HW_AIPS_PACRI_WR(x, HW_AIPS_PACRI_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRI bitfields
 */

/*!
 * @name Register AIPS_PACRI, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRI_TP7    (0U)          /*!< Bit position for AIPS_PACRI_TP7. */
#define BM_AIPS_PACRI_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRI_TP7. */
#define BS_AIPS_PACRI_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRI_TP7. */

/*! @brief Read current value of the AIPS_PACRI_TP7 field. */
#define BR_AIPS_PACRI_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP7))

/*! @brief Format value for bitfield AIPS_PACRI_TP7. */
#define BF_AIPS_PACRI_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_TP7) & BM_AIPS_PACRI_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRI_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRI_WP7    (1U)          /*!< Bit position for AIPS_PACRI_WP7. */
#define BM_AIPS_PACRI_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRI_WP7. */
#define BS_AIPS_PACRI_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRI_WP7. */

/*! @brief Read current value of the AIPS_PACRI_WP7 field. */
#define BR_AIPS_PACRI_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP7))

/*! @brief Format value for bitfield AIPS_PACRI_WP7. */
#define BF_AIPS_PACRI_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_WP7) & BM_AIPS_PACRI_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRI_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRI_SP7    (2U)          /*!< Bit position for AIPS_PACRI_SP7. */
#define BM_AIPS_PACRI_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRI_SP7. */
#define BS_AIPS_PACRI_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRI_SP7. */

/*! @brief Read current value of the AIPS_PACRI_SP7 field. */
#define BR_AIPS_PACRI_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP7))

/*! @brief Format value for bitfield AIPS_PACRI_SP7. */
#define BF_AIPS_PACRI_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_SP7) & BM_AIPS_PACRI_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRI_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRI_TP6    (4U)          /*!< Bit position for AIPS_PACRI_TP6. */
#define BM_AIPS_PACRI_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRI_TP6. */
#define BS_AIPS_PACRI_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRI_TP6. */

/*! @brief Read current value of the AIPS_PACRI_TP6 field. */
#define BR_AIPS_PACRI_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP6))

/*! @brief Format value for bitfield AIPS_PACRI_TP6. */
#define BF_AIPS_PACRI_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_TP6) & BM_AIPS_PACRI_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRI_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRI_WP6    (5U)          /*!< Bit position for AIPS_PACRI_WP6. */
#define BM_AIPS_PACRI_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRI_WP6. */
#define BS_AIPS_PACRI_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRI_WP6. */

/*! @brief Read current value of the AIPS_PACRI_WP6 field. */
#define BR_AIPS_PACRI_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP6))

/*! @brief Format value for bitfield AIPS_PACRI_WP6. */
#define BF_AIPS_PACRI_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_WP6) & BM_AIPS_PACRI_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRI_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRI_SP6    (6U)          /*!< Bit position for AIPS_PACRI_SP6. */
#define BM_AIPS_PACRI_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRI_SP6. */
#define BS_AIPS_PACRI_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRI_SP6. */

/*! @brief Read current value of the AIPS_PACRI_SP6 field. */
#define BR_AIPS_PACRI_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP6))

/*! @brief Format value for bitfield AIPS_PACRI_SP6. */
#define BF_AIPS_PACRI_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_SP6) & BM_AIPS_PACRI_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRI_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRI_TP5    (8U)          /*!< Bit position for AIPS_PACRI_TP5. */
#define BM_AIPS_PACRI_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRI_TP5. */
#define BS_AIPS_PACRI_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRI_TP5. */

/*! @brief Read current value of the AIPS_PACRI_TP5 field. */
#define BR_AIPS_PACRI_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP5))

/*! @brief Format value for bitfield AIPS_PACRI_TP5. */
#define BF_AIPS_PACRI_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_TP5) & BM_AIPS_PACRI_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRI_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRI_WP5    (9U)          /*!< Bit position for AIPS_PACRI_WP5. */
#define BM_AIPS_PACRI_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRI_WP5. */
#define BS_AIPS_PACRI_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRI_WP5. */

/*! @brief Read current value of the AIPS_PACRI_WP5 field. */
#define BR_AIPS_PACRI_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP5))

/*! @brief Format value for bitfield AIPS_PACRI_WP5. */
#define BF_AIPS_PACRI_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_WP5) & BM_AIPS_PACRI_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRI_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRI_SP5    (10U)         /*!< Bit position for AIPS_PACRI_SP5. */
#define BM_AIPS_PACRI_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRI_SP5. */
#define BS_AIPS_PACRI_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRI_SP5. */

/*! @brief Read current value of the AIPS_PACRI_SP5 field. */
#define BR_AIPS_PACRI_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP5))

/*! @brief Format value for bitfield AIPS_PACRI_SP5. */
#define BF_AIPS_PACRI_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_SP5) & BM_AIPS_PACRI_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRI_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRI_TP4    (12U)         /*!< Bit position for AIPS_PACRI_TP4. */
#define BM_AIPS_PACRI_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRI_TP4. */
#define BS_AIPS_PACRI_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRI_TP4. */

/*! @brief Read current value of the AIPS_PACRI_TP4 field. */
#define BR_AIPS_PACRI_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP4))

/*! @brief Format value for bitfield AIPS_PACRI_TP4. */
#define BF_AIPS_PACRI_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_TP4) & BM_AIPS_PACRI_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRI_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRI_WP4    (13U)         /*!< Bit position for AIPS_PACRI_WP4. */
#define BM_AIPS_PACRI_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRI_WP4. */
#define BS_AIPS_PACRI_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRI_WP4. */

/*! @brief Read current value of the AIPS_PACRI_WP4 field. */
#define BR_AIPS_PACRI_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP4))

/*! @brief Format value for bitfield AIPS_PACRI_WP4. */
#define BF_AIPS_PACRI_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_WP4) & BM_AIPS_PACRI_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRI_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRI_SP4    (14U)         /*!< Bit position for AIPS_PACRI_SP4. */
#define BM_AIPS_PACRI_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRI_SP4. */
#define BS_AIPS_PACRI_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRI_SP4. */

/*! @brief Read current value of the AIPS_PACRI_SP4 field. */
#define BR_AIPS_PACRI_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP4))

/*! @brief Format value for bitfield AIPS_PACRI_SP4. */
#define BF_AIPS_PACRI_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_SP4) & BM_AIPS_PACRI_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRI_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRI_TP3    (16U)         /*!< Bit position for AIPS_PACRI_TP3. */
#define BM_AIPS_PACRI_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRI_TP3. */
#define BS_AIPS_PACRI_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRI_TP3. */

/*! @brief Read current value of the AIPS_PACRI_TP3 field. */
#define BR_AIPS_PACRI_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP3))

/*! @brief Format value for bitfield AIPS_PACRI_TP3. */
#define BF_AIPS_PACRI_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_TP3) & BM_AIPS_PACRI_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRI_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRI_WP3    (17U)         /*!< Bit position for AIPS_PACRI_WP3. */
#define BM_AIPS_PACRI_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRI_WP3. */
#define BS_AIPS_PACRI_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRI_WP3. */

/*! @brief Read current value of the AIPS_PACRI_WP3 field. */
#define BR_AIPS_PACRI_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP3))

/*! @brief Format value for bitfield AIPS_PACRI_WP3. */
#define BF_AIPS_PACRI_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_WP3) & BM_AIPS_PACRI_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRI_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRI_SP3    (18U)         /*!< Bit position for AIPS_PACRI_SP3. */
#define BM_AIPS_PACRI_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRI_SP3. */
#define BS_AIPS_PACRI_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRI_SP3. */

/*! @brief Read current value of the AIPS_PACRI_SP3 field. */
#define BR_AIPS_PACRI_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP3))

/*! @brief Format value for bitfield AIPS_PACRI_SP3. */
#define BF_AIPS_PACRI_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_SP3) & BM_AIPS_PACRI_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRI_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRI_TP2    (20U)         /*!< Bit position for AIPS_PACRI_TP2. */
#define BM_AIPS_PACRI_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRI_TP2. */
#define BS_AIPS_PACRI_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRI_TP2. */

/*! @brief Read current value of the AIPS_PACRI_TP2 field. */
#define BR_AIPS_PACRI_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP2))

/*! @brief Format value for bitfield AIPS_PACRI_TP2. */
#define BF_AIPS_PACRI_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_TP2) & BM_AIPS_PACRI_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRI_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRI_WP2    (21U)         /*!< Bit position for AIPS_PACRI_WP2. */
#define BM_AIPS_PACRI_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRI_WP2. */
#define BS_AIPS_PACRI_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRI_WP2. */

/*! @brief Read current value of the AIPS_PACRI_WP2 field. */
#define BR_AIPS_PACRI_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP2))

/*! @brief Format value for bitfield AIPS_PACRI_WP2. */
#define BF_AIPS_PACRI_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_WP2) & BM_AIPS_PACRI_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRI_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRI_SP2    (22U)         /*!< Bit position for AIPS_PACRI_SP2. */
#define BM_AIPS_PACRI_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRI_SP2. */
#define BS_AIPS_PACRI_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRI_SP2. */

/*! @brief Read current value of the AIPS_PACRI_SP2 field. */
#define BR_AIPS_PACRI_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP2))

/*! @brief Format value for bitfield AIPS_PACRI_SP2. */
#define BF_AIPS_PACRI_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_SP2) & BM_AIPS_PACRI_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRI_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRI_TP1    (24U)         /*!< Bit position for AIPS_PACRI_TP1. */
#define BM_AIPS_PACRI_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRI_TP1. */
#define BS_AIPS_PACRI_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRI_TP1. */

/*! @brief Read current value of the AIPS_PACRI_TP1 field. */
#define BR_AIPS_PACRI_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP1))

/*! @brief Format value for bitfield AIPS_PACRI_TP1. */
#define BF_AIPS_PACRI_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_TP1) & BM_AIPS_PACRI_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRI_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRI_WP1    (25U)         /*!< Bit position for AIPS_PACRI_WP1. */
#define BM_AIPS_PACRI_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRI_WP1. */
#define BS_AIPS_PACRI_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRI_WP1. */

/*! @brief Read current value of the AIPS_PACRI_WP1 field. */
#define BR_AIPS_PACRI_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP1))

/*! @brief Format value for bitfield AIPS_PACRI_WP1. */
#define BF_AIPS_PACRI_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_WP1) & BM_AIPS_PACRI_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRI_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRI_SP1    (26U)         /*!< Bit position for AIPS_PACRI_SP1. */
#define BM_AIPS_PACRI_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRI_SP1. */
#define BS_AIPS_PACRI_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRI_SP1. */

/*! @brief Read current value of the AIPS_PACRI_SP1 field. */
#define BR_AIPS_PACRI_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP1))

/*! @brief Format value for bitfield AIPS_PACRI_SP1. */
#define BF_AIPS_PACRI_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_SP1) & BM_AIPS_PACRI_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRI_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRI_TP0    (28U)         /*!< Bit position for AIPS_PACRI_TP0. */
#define BM_AIPS_PACRI_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRI_TP0. */
#define BS_AIPS_PACRI_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRI_TP0. */

/*! @brief Read current value of the AIPS_PACRI_TP0 field. */
#define BR_AIPS_PACRI_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP0))

/*! @brief Format value for bitfield AIPS_PACRI_TP0. */
#define BF_AIPS_PACRI_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_TP0) & BM_AIPS_PACRI_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRI_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRI_WP0    (29U)         /*!< Bit position for AIPS_PACRI_WP0. */
#define BM_AIPS_PACRI_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRI_WP0. */
#define BS_AIPS_PACRI_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRI_WP0. */

/*! @brief Read current value of the AIPS_PACRI_WP0 field. */
#define BR_AIPS_PACRI_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP0))

/*! @brief Format value for bitfield AIPS_PACRI_WP0. */
#define BF_AIPS_PACRI_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_WP0) & BM_AIPS_PACRI_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRI_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRI_SP0    (30U)         /*!< Bit position for AIPS_PACRI_SP0. */
#define BM_AIPS_PACRI_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRI_SP0. */
#define BS_AIPS_PACRI_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRI_SP0. */

/*! @brief Read current value of the AIPS_PACRI_SP0 field. */
#define BR_AIPS_PACRI_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP0))

/*! @brief Format value for bitfield AIPS_PACRI_SP0. */
#define BF_AIPS_PACRI_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRI_SP0) & BM_AIPS_PACRI_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRI_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRI_ADDR(x), BP_AIPS_PACRI_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRJ - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRJ - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacrj
{
    uint32_t U;
    struct _hw_aips_pacrj_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrj_t;

/*!
 * @name Constants and macros for entire AIPS_PACRJ register
 */
/*@{*/
#define HW_AIPS_PACRJ_ADDR(x)    ((uint32_t)(x) + 0x54U)

#define HW_AIPS_PACRJ(x)         (*(__IO hw_aips_pacrj_t *) HW_AIPS_PACRJ_ADDR(x))
#define HW_AIPS_PACRJ_RD(x)      (HW_AIPS_PACRJ(x).U)
#define HW_AIPS_PACRJ_WR(x, v)   (HW_AIPS_PACRJ(x).U = (v))
#define HW_AIPS_PACRJ_SET(x, v)  (HW_AIPS_PACRJ_WR(x, HW_AIPS_PACRJ_RD(x) |  (v)))
#define HW_AIPS_PACRJ_CLR(x, v)  (HW_AIPS_PACRJ_WR(x, HW_AIPS_PACRJ_RD(x) & ~(v)))
#define HW_AIPS_PACRJ_TOG(x, v)  (HW_AIPS_PACRJ_WR(x, HW_AIPS_PACRJ_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRJ bitfields
 */

/*!
 * @name Register AIPS_PACRJ, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRJ_TP7    (0U)          /*!< Bit position for AIPS_PACRJ_TP7. */
#define BM_AIPS_PACRJ_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRJ_TP7. */
#define BS_AIPS_PACRJ_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_TP7. */

/*! @brief Read current value of the AIPS_PACRJ_TP7 field. */
#define BR_AIPS_PACRJ_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP7))

/*! @brief Format value for bitfield AIPS_PACRJ_TP7. */
#define BF_AIPS_PACRJ_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_TP7) & BM_AIPS_PACRJ_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRJ_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRJ_WP7    (1U)          /*!< Bit position for AIPS_PACRJ_WP7. */
#define BM_AIPS_PACRJ_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRJ_WP7. */
#define BS_AIPS_PACRJ_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_WP7. */

/*! @brief Read current value of the AIPS_PACRJ_WP7 field. */
#define BR_AIPS_PACRJ_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP7))

/*! @brief Format value for bitfield AIPS_PACRJ_WP7. */
#define BF_AIPS_PACRJ_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_WP7) & BM_AIPS_PACRJ_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRJ_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRJ_SP7    (2U)          /*!< Bit position for AIPS_PACRJ_SP7. */
#define BM_AIPS_PACRJ_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRJ_SP7. */
#define BS_AIPS_PACRJ_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_SP7. */

/*! @brief Read current value of the AIPS_PACRJ_SP7 field. */
#define BR_AIPS_PACRJ_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP7))

/*! @brief Format value for bitfield AIPS_PACRJ_SP7. */
#define BF_AIPS_PACRJ_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_SP7) & BM_AIPS_PACRJ_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRJ_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRJ_TP6    (4U)          /*!< Bit position for AIPS_PACRJ_TP6. */
#define BM_AIPS_PACRJ_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRJ_TP6. */
#define BS_AIPS_PACRJ_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_TP6. */

/*! @brief Read current value of the AIPS_PACRJ_TP6 field. */
#define BR_AIPS_PACRJ_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP6))

/*! @brief Format value for bitfield AIPS_PACRJ_TP6. */
#define BF_AIPS_PACRJ_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_TP6) & BM_AIPS_PACRJ_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRJ_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRJ_WP6    (5U)          /*!< Bit position for AIPS_PACRJ_WP6. */
#define BM_AIPS_PACRJ_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRJ_WP6. */
#define BS_AIPS_PACRJ_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_WP6. */

/*! @brief Read current value of the AIPS_PACRJ_WP6 field. */
#define BR_AIPS_PACRJ_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP6))

/*! @brief Format value for bitfield AIPS_PACRJ_WP6. */
#define BF_AIPS_PACRJ_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_WP6) & BM_AIPS_PACRJ_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRJ_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRJ_SP6    (6U)          /*!< Bit position for AIPS_PACRJ_SP6. */
#define BM_AIPS_PACRJ_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRJ_SP6. */
#define BS_AIPS_PACRJ_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_SP6. */

/*! @brief Read current value of the AIPS_PACRJ_SP6 field. */
#define BR_AIPS_PACRJ_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP6))

/*! @brief Format value for bitfield AIPS_PACRJ_SP6. */
#define BF_AIPS_PACRJ_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_SP6) & BM_AIPS_PACRJ_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRJ_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRJ_TP5    (8U)          /*!< Bit position for AIPS_PACRJ_TP5. */
#define BM_AIPS_PACRJ_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRJ_TP5. */
#define BS_AIPS_PACRJ_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_TP5. */

/*! @brief Read current value of the AIPS_PACRJ_TP5 field. */
#define BR_AIPS_PACRJ_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP5))

/*! @brief Format value for bitfield AIPS_PACRJ_TP5. */
#define BF_AIPS_PACRJ_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_TP5) & BM_AIPS_PACRJ_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRJ_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRJ_WP5    (9U)          /*!< Bit position for AIPS_PACRJ_WP5. */
#define BM_AIPS_PACRJ_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRJ_WP5. */
#define BS_AIPS_PACRJ_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_WP5. */

/*! @brief Read current value of the AIPS_PACRJ_WP5 field. */
#define BR_AIPS_PACRJ_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP5))

/*! @brief Format value for bitfield AIPS_PACRJ_WP5. */
#define BF_AIPS_PACRJ_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_WP5) & BM_AIPS_PACRJ_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRJ_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRJ_SP5    (10U)         /*!< Bit position for AIPS_PACRJ_SP5. */
#define BM_AIPS_PACRJ_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRJ_SP5. */
#define BS_AIPS_PACRJ_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_SP5. */

/*! @brief Read current value of the AIPS_PACRJ_SP5 field. */
#define BR_AIPS_PACRJ_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP5))

/*! @brief Format value for bitfield AIPS_PACRJ_SP5. */
#define BF_AIPS_PACRJ_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_SP5) & BM_AIPS_PACRJ_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRJ_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRJ_TP4    (12U)         /*!< Bit position for AIPS_PACRJ_TP4. */
#define BM_AIPS_PACRJ_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRJ_TP4. */
#define BS_AIPS_PACRJ_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_TP4. */

/*! @brief Read current value of the AIPS_PACRJ_TP4 field. */
#define BR_AIPS_PACRJ_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP4))

/*! @brief Format value for bitfield AIPS_PACRJ_TP4. */
#define BF_AIPS_PACRJ_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_TP4) & BM_AIPS_PACRJ_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRJ_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRJ_WP4    (13U)         /*!< Bit position for AIPS_PACRJ_WP4. */
#define BM_AIPS_PACRJ_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRJ_WP4. */
#define BS_AIPS_PACRJ_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_WP4. */

/*! @brief Read current value of the AIPS_PACRJ_WP4 field. */
#define BR_AIPS_PACRJ_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP4))

/*! @brief Format value for bitfield AIPS_PACRJ_WP4. */
#define BF_AIPS_PACRJ_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_WP4) & BM_AIPS_PACRJ_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRJ_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRJ_SP4    (14U)         /*!< Bit position for AIPS_PACRJ_SP4. */
#define BM_AIPS_PACRJ_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRJ_SP4. */
#define BS_AIPS_PACRJ_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_SP4. */

/*! @brief Read current value of the AIPS_PACRJ_SP4 field. */
#define BR_AIPS_PACRJ_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP4))

/*! @brief Format value for bitfield AIPS_PACRJ_SP4. */
#define BF_AIPS_PACRJ_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_SP4) & BM_AIPS_PACRJ_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRJ_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRJ_TP3    (16U)         /*!< Bit position for AIPS_PACRJ_TP3. */
#define BM_AIPS_PACRJ_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRJ_TP3. */
#define BS_AIPS_PACRJ_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_TP3. */

/*! @brief Read current value of the AIPS_PACRJ_TP3 field. */
#define BR_AIPS_PACRJ_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP3))

/*! @brief Format value for bitfield AIPS_PACRJ_TP3. */
#define BF_AIPS_PACRJ_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_TP3) & BM_AIPS_PACRJ_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRJ_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRJ_WP3    (17U)         /*!< Bit position for AIPS_PACRJ_WP3. */
#define BM_AIPS_PACRJ_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRJ_WP3. */
#define BS_AIPS_PACRJ_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_WP3. */

/*! @brief Read current value of the AIPS_PACRJ_WP3 field. */
#define BR_AIPS_PACRJ_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP3))

/*! @brief Format value for bitfield AIPS_PACRJ_WP3. */
#define BF_AIPS_PACRJ_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_WP3) & BM_AIPS_PACRJ_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRJ_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRJ_SP3    (18U)         /*!< Bit position for AIPS_PACRJ_SP3. */
#define BM_AIPS_PACRJ_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRJ_SP3. */
#define BS_AIPS_PACRJ_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_SP3. */

/*! @brief Read current value of the AIPS_PACRJ_SP3 field. */
#define BR_AIPS_PACRJ_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP3))

/*! @brief Format value for bitfield AIPS_PACRJ_SP3. */
#define BF_AIPS_PACRJ_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_SP3) & BM_AIPS_PACRJ_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRJ_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRJ_TP2    (20U)         /*!< Bit position for AIPS_PACRJ_TP2. */
#define BM_AIPS_PACRJ_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRJ_TP2. */
#define BS_AIPS_PACRJ_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_TP2. */

/*! @brief Read current value of the AIPS_PACRJ_TP2 field. */
#define BR_AIPS_PACRJ_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP2))

/*! @brief Format value for bitfield AIPS_PACRJ_TP2. */
#define BF_AIPS_PACRJ_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_TP2) & BM_AIPS_PACRJ_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRJ_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRJ_WP2    (21U)         /*!< Bit position for AIPS_PACRJ_WP2. */
#define BM_AIPS_PACRJ_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRJ_WP2. */
#define BS_AIPS_PACRJ_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_WP2. */

/*! @brief Read current value of the AIPS_PACRJ_WP2 field. */
#define BR_AIPS_PACRJ_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP2))

/*! @brief Format value for bitfield AIPS_PACRJ_WP2. */
#define BF_AIPS_PACRJ_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_WP2) & BM_AIPS_PACRJ_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRJ_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRJ_SP2    (22U)         /*!< Bit position for AIPS_PACRJ_SP2. */
#define BM_AIPS_PACRJ_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRJ_SP2. */
#define BS_AIPS_PACRJ_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_SP2. */

/*! @brief Read current value of the AIPS_PACRJ_SP2 field. */
#define BR_AIPS_PACRJ_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP2))

/*! @brief Format value for bitfield AIPS_PACRJ_SP2. */
#define BF_AIPS_PACRJ_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_SP2) & BM_AIPS_PACRJ_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRJ_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRJ_TP1    (24U)         /*!< Bit position for AIPS_PACRJ_TP1. */
#define BM_AIPS_PACRJ_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRJ_TP1. */
#define BS_AIPS_PACRJ_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_TP1. */

/*! @brief Read current value of the AIPS_PACRJ_TP1 field. */
#define BR_AIPS_PACRJ_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP1))

/*! @brief Format value for bitfield AIPS_PACRJ_TP1. */
#define BF_AIPS_PACRJ_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_TP1) & BM_AIPS_PACRJ_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRJ_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRJ_WP1    (25U)         /*!< Bit position for AIPS_PACRJ_WP1. */
#define BM_AIPS_PACRJ_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRJ_WP1. */
#define BS_AIPS_PACRJ_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_WP1. */

/*! @brief Read current value of the AIPS_PACRJ_WP1 field. */
#define BR_AIPS_PACRJ_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP1))

/*! @brief Format value for bitfield AIPS_PACRJ_WP1. */
#define BF_AIPS_PACRJ_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_WP1) & BM_AIPS_PACRJ_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRJ_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRJ_SP1    (26U)         /*!< Bit position for AIPS_PACRJ_SP1. */
#define BM_AIPS_PACRJ_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRJ_SP1. */
#define BS_AIPS_PACRJ_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_SP1. */

/*! @brief Read current value of the AIPS_PACRJ_SP1 field. */
#define BR_AIPS_PACRJ_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP1))

/*! @brief Format value for bitfield AIPS_PACRJ_SP1. */
#define BF_AIPS_PACRJ_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_SP1) & BM_AIPS_PACRJ_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRJ_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRJ_TP0    (28U)         /*!< Bit position for AIPS_PACRJ_TP0. */
#define BM_AIPS_PACRJ_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRJ_TP0. */
#define BS_AIPS_PACRJ_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_TP0. */

/*! @brief Read current value of the AIPS_PACRJ_TP0 field. */
#define BR_AIPS_PACRJ_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP0))

/*! @brief Format value for bitfield AIPS_PACRJ_TP0. */
#define BF_AIPS_PACRJ_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_TP0) & BM_AIPS_PACRJ_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRJ_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRJ_WP0    (29U)         /*!< Bit position for AIPS_PACRJ_WP0. */
#define BM_AIPS_PACRJ_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRJ_WP0. */
#define BS_AIPS_PACRJ_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_WP0. */

/*! @brief Read current value of the AIPS_PACRJ_WP0 field. */
#define BR_AIPS_PACRJ_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP0))

/*! @brief Format value for bitfield AIPS_PACRJ_WP0. */
#define BF_AIPS_PACRJ_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_WP0) & BM_AIPS_PACRJ_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRJ_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRJ_SP0    (30U)         /*!< Bit position for AIPS_PACRJ_SP0. */
#define BM_AIPS_PACRJ_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRJ_SP0. */
#define BS_AIPS_PACRJ_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRJ_SP0. */

/*! @brief Read current value of the AIPS_PACRJ_SP0 field. */
#define BR_AIPS_PACRJ_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP0))

/*! @brief Format value for bitfield AIPS_PACRJ_SP0. */
#define BF_AIPS_PACRJ_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRJ_SP0) & BM_AIPS_PACRJ_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRJ_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRJ_ADDR(x), BP_AIPS_PACRJ_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRK - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRK - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacrk
{
    uint32_t U;
    struct _hw_aips_pacrk_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrk_t;

/*!
 * @name Constants and macros for entire AIPS_PACRK register
 */
/*@{*/
#define HW_AIPS_PACRK_ADDR(x)    ((uint32_t)(x) + 0x58U)

#define HW_AIPS_PACRK(x)         (*(__IO hw_aips_pacrk_t *) HW_AIPS_PACRK_ADDR(x))
#define HW_AIPS_PACRK_RD(x)      (HW_AIPS_PACRK(x).U)
#define HW_AIPS_PACRK_WR(x, v)   (HW_AIPS_PACRK(x).U = (v))
#define HW_AIPS_PACRK_SET(x, v)  (HW_AIPS_PACRK_WR(x, HW_AIPS_PACRK_RD(x) |  (v)))
#define HW_AIPS_PACRK_CLR(x, v)  (HW_AIPS_PACRK_WR(x, HW_AIPS_PACRK_RD(x) & ~(v)))
#define HW_AIPS_PACRK_TOG(x, v)  (HW_AIPS_PACRK_WR(x, HW_AIPS_PACRK_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRK bitfields
 */

/*!
 * @name Register AIPS_PACRK, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRK_TP7    (0U)          /*!< Bit position for AIPS_PACRK_TP7. */
#define BM_AIPS_PACRK_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRK_TP7. */
#define BS_AIPS_PACRK_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRK_TP7. */

/*! @brief Read current value of the AIPS_PACRK_TP7 field. */
#define BR_AIPS_PACRK_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP7))

/*! @brief Format value for bitfield AIPS_PACRK_TP7. */
#define BF_AIPS_PACRK_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_TP7) & BM_AIPS_PACRK_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRK_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRK_WP7    (1U)          /*!< Bit position for AIPS_PACRK_WP7. */
#define BM_AIPS_PACRK_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRK_WP7. */
#define BS_AIPS_PACRK_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRK_WP7. */

/*! @brief Read current value of the AIPS_PACRK_WP7 field. */
#define BR_AIPS_PACRK_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP7))

/*! @brief Format value for bitfield AIPS_PACRK_WP7. */
#define BF_AIPS_PACRK_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_WP7) & BM_AIPS_PACRK_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRK_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRK_SP7    (2U)          /*!< Bit position for AIPS_PACRK_SP7. */
#define BM_AIPS_PACRK_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRK_SP7. */
#define BS_AIPS_PACRK_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRK_SP7. */

/*! @brief Read current value of the AIPS_PACRK_SP7 field. */
#define BR_AIPS_PACRK_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP7))

/*! @brief Format value for bitfield AIPS_PACRK_SP7. */
#define BF_AIPS_PACRK_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_SP7) & BM_AIPS_PACRK_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRK_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRK_TP6    (4U)          /*!< Bit position for AIPS_PACRK_TP6. */
#define BM_AIPS_PACRK_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRK_TP6. */
#define BS_AIPS_PACRK_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRK_TP6. */

/*! @brief Read current value of the AIPS_PACRK_TP6 field. */
#define BR_AIPS_PACRK_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP6))

/*! @brief Format value for bitfield AIPS_PACRK_TP6. */
#define BF_AIPS_PACRK_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_TP6) & BM_AIPS_PACRK_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRK_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRK_WP6    (5U)          /*!< Bit position for AIPS_PACRK_WP6. */
#define BM_AIPS_PACRK_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRK_WP6. */
#define BS_AIPS_PACRK_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRK_WP6. */

/*! @brief Read current value of the AIPS_PACRK_WP6 field. */
#define BR_AIPS_PACRK_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP6))

/*! @brief Format value for bitfield AIPS_PACRK_WP6. */
#define BF_AIPS_PACRK_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_WP6) & BM_AIPS_PACRK_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRK_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRK_SP6    (6U)          /*!< Bit position for AIPS_PACRK_SP6. */
#define BM_AIPS_PACRK_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRK_SP6. */
#define BS_AIPS_PACRK_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRK_SP6. */

/*! @brief Read current value of the AIPS_PACRK_SP6 field. */
#define BR_AIPS_PACRK_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP6))

/*! @brief Format value for bitfield AIPS_PACRK_SP6. */
#define BF_AIPS_PACRK_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_SP6) & BM_AIPS_PACRK_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRK_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRK_TP5    (8U)          /*!< Bit position for AIPS_PACRK_TP5. */
#define BM_AIPS_PACRK_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRK_TP5. */
#define BS_AIPS_PACRK_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRK_TP5. */

/*! @brief Read current value of the AIPS_PACRK_TP5 field. */
#define BR_AIPS_PACRK_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP5))

/*! @brief Format value for bitfield AIPS_PACRK_TP5. */
#define BF_AIPS_PACRK_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_TP5) & BM_AIPS_PACRK_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRK_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRK_WP5    (9U)          /*!< Bit position for AIPS_PACRK_WP5. */
#define BM_AIPS_PACRK_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRK_WP5. */
#define BS_AIPS_PACRK_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRK_WP5. */

/*! @brief Read current value of the AIPS_PACRK_WP5 field. */
#define BR_AIPS_PACRK_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP5))

/*! @brief Format value for bitfield AIPS_PACRK_WP5. */
#define BF_AIPS_PACRK_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_WP5) & BM_AIPS_PACRK_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRK_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRK_SP5    (10U)         /*!< Bit position for AIPS_PACRK_SP5. */
#define BM_AIPS_PACRK_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRK_SP5. */
#define BS_AIPS_PACRK_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRK_SP5. */

/*! @brief Read current value of the AIPS_PACRK_SP5 field. */
#define BR_AIPS_PACRK_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP5))

/*! @brief Format value for bitfield AIPS_PACRK_SP5. */
#define BF_AIPS_PACRK_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_SP5) & BM_AIPS_PACRK_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRK_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRK_TP4    (12U)         /*!< Bit position for AIPS_PACRK_TP4. */
#define BM_AIPS_PACRK_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRK_TP4. */
#define BS_AIPS_PACRK_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRK_TP4. */

/*! @brief Read current value of the AIPS_PACRK_TP4 field. */
#define BR_AIPS_PACRK_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP4))

/*! @brief Format value for bitfield AIPS_PACRK_TP4. */
#define BF_AIPS_PACRK_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_TP4) & BM_AIPS_PACRK_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRK_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRK_WP4    (13U)         /*!< Bit position for AIPS_PACRK_WP4. */
#define BM_AIPS_PACRK_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRK_WP4. */
#define BS_AIPS_PACRK_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRK_WP4. */

/*! @brief Read current value of the AIPS_PACRK_WP4 field. */
#define BR_AIPS_PACRK_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP4))

/*! @brief Format value for bitfield AIPS_PACRK_WP4. */
#define BF_AIPS_PACRK_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_WP4) & BM_AIPS_PACRK_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRK_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRK_SP4    (14U)         /*!< Bit position for AIPS_PACRK_SP4. */
#define BM_AIPS_PACRK_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRK_SP4. */
#define BS_AIPS_PACRK_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRK_SP4. */

/*! @brief Read current value of the AIPS_PACRK_SP4 field. */
#define BR_AIPS_PACRK_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP4))

/*! @brief Format value for bitfield AIPS_PACRK_SP4. */
#define BF_AIPS_PACRK_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_SP4) & BM_AIPS_PACRK_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRK_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRK_TP3    (16U)         /*!< Bit position for AIPS_PACRK_TP3. */
#define BM_AIPS_PACRK_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRK_TP3. */
#define BS_AIPS_PACRK_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRK_TP3. */

/*! @brief Read current value of the AIPS_PACRK_TP3 field. */
#define BR_AIPS_PACRK_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP3))

/*! @brief Format value for bitfield AIPS_PACRK_TP3. */
#define BF_AIPS_PACRK_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_TP3) & BM_AIPS_PACRK_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRK_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRK_WP3    (17U)         /*!< Bit position for AIPS_PACRK_WP3. */
#define BM_AIPS_PACRK_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRK_WP3. */
#define BS_AIPS_PACRK_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRK_WP3. */

/*! @brief Read current value of the AIPS_PACRK_WP3 field. */
#define BR_AIPS_PACRK_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP3))

/*! @brief Format value for bitfield AIPS_PACRK_WP3. */
#define BF_AIPS_PACRK_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_WP3) & BM_AIPS_PACRK_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRK_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRK_SP3    (18U)         /*!< Bit position for AIPS_PACRK_SP3. */
#define BM_AIPS_PACRK_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRK_SP3. */
#define BS_AIPS_PACRK_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRK_SP3. */

/*! @brief Read current value of the AIPS_PACRK_SP3 field. */
#define BR_AIPS_PACRK_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP3))

/*! @brief Format value for bitfield AIPS_PACRK_SP3. */
#define BF_AIPS_PACRK_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_SP3) & BM_AIPS_PACRK_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRK_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRK_TP2    (20U)         /*!< Bit position for AIPS_PACRK_TP2. */
#define BM_AIPS_PACRK_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRK_TP2. */
#define BS_AIPS_PACRK_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRK_TP2. */

/*! @brief Read current value of the AIPS_PACRK_TP2 field. */
#define BR_AIPS_PACRK_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP2))

/*! @brief Format value for bitfield AIPS_PACRK_TP2. */
#define BF_AIPS_PACRK_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_TP2) & BM_AIPS_PACRK_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRK_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRK_WP2    (21U)         /*!< Bit position for AIPS_PACRK_WP2. */
#define BM_AIPS_PACRK_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRK_WP2. */
#define BS_AIPS_PACRK_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRK_WP2. */

/*! @brief Read current value of the AIPS_PACRK_WP2 field. */
#define BR_AIPS_PACRK_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP2))

/*! @brief Format value for bitfield AIPS_PACRK_WP2. */
#define BF_AIPS_PACRK_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_WP2) & BM_AIPS_PACRK_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRK_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRK_SP2    (22U)         /*!< Bit position for AIPS_PACRK_SP2. */
#define BM_AIPS_PACRK_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRK_SP2. */
#define BS_AIPS_PACRK_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRK_SP2. */

/*! @brief Read current value of the AIPS_PACRK_SP2 field. */
#define BR_AIPS_PACRK_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP2))

/*! @brief Format value for bitfield AIPS_PACRK_SP2. */
#define BF_AIPS_PACRK_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_SP2) & BM_AIPS_PACRK_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRK_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRK_TP1    (24U)         /*!< Bit position for AIPS_PACRK_TP1. */
#define BM_AIPS_PACRK_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRK_TP1. */
#define BS_AIPS_PACRK_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRK_TP1. */

/*! @brief Read current value of the AIPS_PACRK_TP1 field. */
#define BR_AIPS_PACRK_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP1))

/*! @brief Format value for bitfield AIPS_PACRK_TP1. */
#define BF_AIPS_PACRK_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_TP1) & BM_AIPS_PACRK_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRK_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRK_WP1    (25U)         /*!< Bit position for AIPS_PACRK_WP1. */
#define BM_AIPS_PACRK_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRK_WP1. */
#define BS_AIPS_PACRK_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRK_WP1. */

/*! @brief Read current value of the AIPS_PACRK_WP1 field. */
#define BR_AIPS_PACRK_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP1))

/*! @brief Format value for bitfield AIPS_PACRK_WP1. */
#define BF_AIPS_PACRK_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_WP1) & BM_AIPS_PACRK_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRK_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRK_SP1    (26U)         /*!< Bit position for AIPS_PACRK_SP1. */
#define BM_AIPS_PACRK_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRK_SP1. */
#define BS_AIPS_PACRK_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRK_SP1. */

/*! @brief Read current value of the AIPS_PACRK_SP1 field. */
#define BR_AIPS_PACRK_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP1))

/*! @brief Format value for bitfield AIPS_PACRK_SP1. */
#define BF_AIPS_PACRK_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_SP1) & BM_AIPS_PACRK_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRK_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRK_TP0    (28U)         /*!< Bit position for AIPS_PACRK_TP0. */
#define BM_AIPS_PACRK_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRK_TP0. */
#define BS_AIPS_PACRK_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRK_TP0. */

/*! @brief Read current value of the AIPS_PACRK_TP0 field. */
#define BR_AIPS_PACRK_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP0))

/*! @brief Format value for bitfield AIPS_PACRK_TP0. */
#define BF_AIPS_PACRK_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_TP0) & BM_AIPS_PACRK_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRK_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRK_WP0    (29U)         /*!< Bit position for AIPS_PACRK_WP0. */
#define BM_AIPS_PACRK_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRK_WP0. */
#define BS_AIPS_PACRK_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRK_WP0. */

/*! @brief Read current value of the AIPS_PACRK_WP0 field. */
#define BR_AIPS_PACRK_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP0))

/*! @brief Format value for bitfield AIPS_PACRK_WP0. */
#define BF_AIPS_PACRK_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_WP0) & BM_AIPS_PACRK_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRK_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRK_SP0    (30U)         /*!< Bit position for AIPS_PACRK_SP0. */
#define BM_AIPS_PACRK_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRK_SP0. */
#define BS_AIPS_PACRK_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRK_SP0. */

/*! @brief Read current value of the AIPS_PACRK_SP0 field. */
#define BR_AIPS_PACRK_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP0))

/*! @brief Format value for bitfield AIPS_PACRK_SP0. */
#define BF_AIPS_PACRK_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRK_SP0) & BM_AIPS_PACRK_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRK_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRK_ADDR(x), BP_AIPS_PACRK_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRL - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRL - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacrl
{
    uint32_t U;
    struct _hw_aips_pacrl_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrl_t;

/*!
 * @name Constants and macros for entire AIPS_PACRL register
 */
/*@{*/
#define HW_AIPS_PACRL_ADDR(x)    ((uint32_t)(x) + 0x5CU)

#define HW_AIPS_PACRL(x)         (*(__IO hw_aips_pacrl_t *) HW_AIPS_PACRL_ADDR(x))
#define HW_AIPS_PACRL_RD(x)      (HW_AIPS_PACRL(x).U)
#define HW_AIPS_PACRL_WR(x, v)   (HW_AIPS_PACRL(x).U = (v))
#define HW_AIPS_PACRL_SET(x, v)  (HW_AIPS_PACRL_WR(x, HW_AIPS_PACRL_RD(x) |  (v)))
#define HW_AIPS_PACRL_CLR(x, v)  (HW_AIPS_PACRL_WR(x, HW_AIPS_PACRL_RD(x) & ~(v)))
#define HW_AIPS_PACRL_TOG(x, v)  (HW_AIPS_PACRL_WR(x, HW_AIPS_PACRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRL bitfields
 */

/*!
 * @name Register AIPS_PACRL, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRL_TP7    (0U)          /*!< Bit position for AIPS_PACRL_TP7. */
#define BM_AIPS_PACRL_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRL_TP7. */
#define BS_AIPS_PACRL_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRL_TP7. */

/*! @brief Read current value of the AIPS_PACRL_TP7 field. */
#define BR_AIPS_PACRL_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP7))

/*! @brief Format value for bitfield AIPS_PACRL_TP7. */
#define BF_AIPS_PACRL_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_TP7) & BM_AIPS_PACRL_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRL_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRL_WP7    (1U)          /*!< Bit position for AIPS_PACRL_WP7. */
#define BM_AIPS_PACRL_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRL_WP7. */
#define BS_AIPS_PACRL_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRL_WP7. */

/*! @brief Read current value of the AIPS_PACRL_WP7 field. */
#define BR_AIPS_PACRL_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP7))

/*! @brief Format value for bitfield AIPS_PACRL_WP7. */
#define BF_AIPS_PACRL_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_WP7) & BM_AIPS_PACRL_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRL_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRL_SP7    (2U)          /*!< Bit position for AIPS_PACRL_SP7. */
#define BM_AIPS_PACRL_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRL_SP7. */
#define BS_AIPS_PACRL_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRL_SP7. */

/*! @brief Read current value of the AIPS_PACRL_SP7 field. */
#define BR_AIPS_PACRL_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP7))

/*! @brief Format value for bitfield AIPS_PACRL_SP7. */
#define BF_AIPS_PACRL_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_SP7) & BM_AIPS_PACRL_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRL_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRL_TP6    (4U)          /*!< Bit position for AIPS_PACRL_TP6. */
#define BM_AIPS_PACRL_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRL_TP6. */
#define BS_AIPS_PACRL_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRL_TP6. */

/*! @brief Read current value of the AIPS_PACRL_TP6 field. */
#define BR_AIPS_PACRL_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP6))

/*! @brief Format value for bitfield AIPS_PACRL_TP6. */
#define BF_AIPS_PACRL_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_TP6) & BM_AIPS_PACRL_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRL_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRL_WP6    (5U)          /*!< Bit position for AIPS_PACRL_WP6. */
#define BM_AIPS_PACRL_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRL_WP6. */
#define BS_AIPS_PACRL_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRL_WP6. */

/*! @brief Read current value of the AIPS_PACRL_WP6 field. */
#define BR_AIPS_PACRL_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP6))

/*! @brief Format value for bitfield AIPS_PACRL_WP6. */
#define BF_AIPS_PACRL_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_WP6) & BM_AIPS_PACRL_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRL_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRL_SP6    (6U)          /*!< Bit position for AIPS_PACRL_SP6. */
#define BM_AIPS_PACRL_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRL_SP6. */
#define BS_AIPS_PACRL_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRL_SP6. */

/*! @brief Read current value of the AIPS_PACRL_SP6 field. */
#define BR_AIPS_PACRL_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP6))

/*! @brief Format value for bitfield AIPS_PACRL_SP6. */
#define BF_AIPS_PACRL_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_SP6) & BM_AIPS_PACRL_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRL_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRL_TP5    (8U)          /*!< Bit position for AIPS_PACRL_TP5. */
#define BM_AIPS_PACRL_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRL_TP5. */
#define BS_AIPS_PACRL_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRL_TP5. */

/*! @brief Read current value of the AIPS_PACRL_TP5 field. */
#define BR_AIPS_PACRL_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP5))

/*! @brief Format value for bitfield AIPS_PACRL_TP5. */
#define BF_AIPS_PACRL_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_TP5) & BM_AIPS_PACRL_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRL_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRL_WP5    (9U)          /*!< Bit position for AIPS_PACRL_WP5. */
#define BM_AIPS_PACRL_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRL_WP5. */
#define BS_AIPS_PACRL_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRL_WP5. */

/*! @brief Read current value of the AIPS_PACRL_WP5 field. */
#define BR_AIPS_PACRL_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP5))

/*! @brief Format value for bitfield AIPS_PACRL_WP5. */
#define BF_AIPS_PACRL_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_WP5) & BM_AIPS_PACRL_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRL_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRL_SP5    (10U)         /*!< Bit position for AIPS_PACRL_SP5. */
#define BM_AIPS_PACRL_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRL_SP5. */
#define BS_AIPS_PACRL_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRL_SP5. */

/*! @brief Read current value of the AIPS_PACRL_SP5 field. */
#define BR_AIPS_PACRL_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP5))

/*! @brief Format value for bitfield AIPS_PACRL_SP5. */
#define BF_AIPS_PACRL_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_SP5) & BM_AIPS_PACRL_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRL_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRL_TP4    (12U)         /*!< Bit position for AIPS_PACRL_TP4. */
#define BM_AIPS_PACRL_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRL_TP4. */
#define BS_AIPS_PACRL_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRL_TP4. */

/*! @brief Read current value of the AIPS_PACRL_TP4 field. */
#define BR_AIPS_PACRL_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP4))

/*! @brief Format value for bitfield AIPS_PACRL_TP4. */
#define BF_AIPS_PACRL_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_TP4) & BM_AIPS_PACRL_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRL_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRL_WP4    (13U)         /*!< Bit position for AIPS_PACRL_WP4. */
#define BM_AIPS_PACRL_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRL_WP4. */
#define BS_AIPS_PACRL_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRL_WP4. */

/*! @brief Read current value of the AIPS_PACRL_WP4 field. */
#define BR_AIPS_PACRL_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP4))

/*! @brief Format value for bitfield AIPS_PACRL_WP4. */
#define BF_AIPS_PACRL_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_WP4) & BM_AIPS_PACRL_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRL_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRL_SP4    (14U)         /*!< Bit position for AIPS_PACRL_SP4. */
#define BM_AIPS_PACRL_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRL_SP4. */
#define BS_AIPS_PACRL_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRL_SP4. */

/*! @brief Read current value of the AIPS_PACRL_SP4 field. */
#define BR_AIPS_PACRL_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP4))

/*! @brief Format value for bitfield AIPS_PACRL_SP4. */
#define BF_AIPS_PACRL_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_SP4) & BM_AIPS_PACRL_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRL_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRL_TP3    (16U)         /*!< Bit position for AIPS_PACRL_TP3. */
#define BM_AIPS_PACRL_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRL_TP3. */
#define BS_AIPS_PACRL_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRL_TP3. */

/*! @brief Read current value of the AIPS_PACRL_TP3 field. */
#define BR_AIPS_PACRL_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP3))

/*! @brief Format value for bitfield AIPS_PACRL_TP3. */
#define BF_AIPS_PACRL_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_TP3) & BM_AIPS_PACRL_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRL_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRL_WP3    (17U)         /*!< Bit position for AIPS_PACRL_WP3. */
#define BM_AIPS_PACRL_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRL_WP3. */
#define BS_AIPS_PACRL_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRL_WP3. */

/*! @brief Read current value of the AIPS_PACRL_WP3 field. */
#define BR_AIPS_PACRL_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP3))

/*! @brief Format value for bitfield AIPS_PACRL_WP3. */
#define BF_AIPS_PACRL_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_WP3) & BM_AIPS_PACRL_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRL_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRL_SP3    (18U)         /*!< Bit position for AIPS_PACRL_SP3. */
#define BM_AIPS_PACRL_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRL_SP3. */
#define BS_AIPS_PACRL_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRL_SP3. */

/*! @brief Read current value of the AIPS_PACRL_SP3 field. */
#define BR_AIPS_PACRL_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP3))

/*! @brief Format value for bitfield AIPS_PACRL_SP3. */
#define BF_AIPS_PACRL_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_SP3) & BM_AIPS_PACRL_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRL_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRL_TP2    (20U)         /*!< Bit position for AIPS_PACRL_TP2. */
#define BM_AIPS_PACRL_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRL_TP2. */
#define BS_AIPS_PACRL_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRL_TP2. */

/*! @brief Read current value of the AIPS_PACRL_TP2 field. */
#define BR_AIPS_PACRL_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP2))

/*! @brief Format value for bitfield AIPS_PACRL_TP2. */
#define BF_AIPS_PACRL_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_TP2) & BM_AIPS_PACRL_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRL_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRL_WP2    (21U)         /*!< Bit position for AIPS_PACRL_WP2. */
#define BM_AIPS_PACRL_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRL_WP2. */
#define BS_AIPS_PACRL_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRL_WP2. */

/*! @brief Read current value of the AIPS_PACRL_WP2 field. */
#define BR_AIPS_PACRL_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP2))

/*! @brief Format value for bitfield AIPS_PACRL_WP2. */
#define BF_AIPS_PACRL_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_WP2) & BM_AIPS_PACRL_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRL_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRL_SP2    (22U)         /*!< Bit position for AIPS_PACRL_SP2. */
#define BM_AIPS_PACRL_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRL_SP2. */
#define BS_AIPS_PACRL_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRL_SP2. */

/*! @brief Read current value of the AIPS_PACRL_SP2 field. */
#define BR_AIPS_PACRL_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP2))

/*! @brief Format value for bitfield AIPS_PACRL_SP2. */
#define BF_AIPS_PACRL_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_SP2) & BM_AIPS_PACRL_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRL_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRL_TP1    (24U)         /*!< Bit position for AIPS_PACRL_TP1. */
#define BM_AIPS_PACRL_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRL_TP1. */
#define BS_AIPS_PACRL_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRL_TP1. */

/*! @brief Read current value of the AIPS_PACRL_TP1 field. */
#define BR_AIPS_PACRL_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP1))

/*! @brief Format value for bitfield AIPS_PACRL_TP1. */
#define BF_AIPS_PACRL_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_TP1) & BM_AIPS_PACRL_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRL_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRL_WP1    (25U)         /*!< Bit position for AIPS_PACRL_WP1. */
#define BM_AIPS_PACRL_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRL_WP1. */
#define BS_AIPS_PACRL_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRL_WP1. */

/*! @brief Read current value of the AIPS_PACRL_WP1 field. */
#define BR_AIPS_PACRL_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP1))

/*! @brief Format value for bitfield AIPS_PACRL_WP1. */
#define BF_AIPS_PACRL_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_WP1) & BM_AIPS_PACRL_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRL_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRL_SP1    (26U)         /*!< Bit position for AIPS_PACRL_SP1. */
#define BM_AIPS_PACRL_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRL_SP1. */
#define BS_AIPS_PACRL_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRL_SP1. */

/*! @brief Read current value of the AIPS_PACRL_SP1 field. */
#define BR_AIPS_PACRL_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP1))

/*! @brief Format value for bitfield AIPS_PACRL_SP1. */
#define BF_AIPS_PACRL_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_SP1) & BM_AIPS_PACRL_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRL_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRL_TP0    (28U)         /*!< Bit position for AIPS_PACRL_TP0. */
#define BM_AIPS_PACRL_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRL_TP0. */
#define BS_AIPS_PACRL_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRL_TP0. */

/*! @brief Read current value of the AIPS_PACRL_TP0 field. */
#define BR_AIPS_PACRL_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP0))

/*! @brief Format value for bitfield AIPS_PACRL_TP0. */
#define BF_AIPS_PACRL_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_TP0) & BM_AIPS_PACRL_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRL_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRL_WP0    (29U)         /*!< Bit position for AIPS_PACRL_WP0. */
#define BM_AIPS_PACRL_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRL_WP0. */
#define BS_AIPS_PACRL_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRL_WP0. */

/*! @brief Read current value of the AIPS_PACRL_WP0 field. */
#define BR_AIPS_PACRL_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP0))

/*! @brief Format value for bitfield AIPS_PACRL_WP0. */
#define BF_AIPS_PACRL_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_WP0) & BM_AIPS_PACRL_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRL_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRL_SP0    (30U)         /*!< Bit position for AIPS_PACRL_SP0. */
#define BM_AIPS_PACRL_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRL_SP0. */
#define BS_AIPS_PACRL_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRL_SP0. */

/*! @brief Read current value of the AIPS_PACRL_SP0 field. */
#define BR_AIPS_PACRL_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP0))

/*! @brief Format value for bitfield AIPS_PACRL_SP0. */
#define BF_AIPS_PACRL_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRL_SP0) & BM_AIPS_PACRL_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRL_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRL_ADDR(x), BP_AIPS_PACRL_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRM - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRM - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacrm
{
    uint32_t U;
    struct _hw_aips_pacrm_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrm_t;

/*!
 * @name Constants and macros for entire AIPS_PACRM register
 */
/*@{*/
#define HW_AIPS_PACRM_ADDR(x)    ((uint32_t)(x) + 0x60U)

#define HW_AIPS_PACRM(x)         (*(__IO hw_aips_pacrm_t *) HW_AIPS_PACRM_ADDR(x))
#define HW_AIPS_PACRM_RD(x)      (HW_AIPS_PACRM(x).U)
#define HW_AIPS_PACRM_WR(x, v)   (HW_AIPS_PACRM(x).U = (v))
#define HW_AIPS_PACRM_SET(x, v)  (HW_AIPS_PACRM_WR(x, HW_AIPS_PACRM_RD(x) |  (v)))
#define HW_AIPS_PACRM_CLR(x, v)  (HW_AIPS_PACRM_WR(x, HW_AIPS_PACRM_RD(x) & ~(v)))
#define HW_AIPS_PACRM_TOG(x, v)  (HW_AIPS_PACRM_WR(x, HW_AIPS_PACRM_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRM bitfields
 */

/*!
 * @name Register AIPS_PACRM, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRM_TP7    (0U)          /*!< Bit position for AIPS_PACRM_TP7. */
#define BM_AIPS_PACRM_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRM_TP7. */
#define BS_AIPS_PACRM_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRM_TP7. */

/*! @brief Read current value of the AIPS_PACRM_TP7 field. */
#define BR_AIPS_PACRM_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP7))

/*! @brief Format value for bitfield AIPS_PACRM_TP7. */
#define BF_AIPS_PACRM_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_TP7) & BM_AIPS_PACRM_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRM_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRM_WP7    (1U)          /*!< Bit position for AIPS_PACRM_WP7. */
#define BM_AIPS_PACRM_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRM_WP7. */
#define BS_AIPS_PACRM_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRM_WP7. */

/*! @brief Read current value of the AIPS_PACRM_WP7 field. */
#define BR_AIPS_PACRM_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP7))

/*! @brief Format value for bitfield AIPS_PACRM_WP7. */
#define BF_AIPS_PACRM_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_WP7) & BM_AIPS_PACRM_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRM_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRM_SP7    (2U)          /*!< Bit position for AIPS_PACRM_SP7. */
#define BM_AIPS_PACRM_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRM_SP7. */
#define BS_AIPS_PACRM_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRM_SP7. */

/*! @brief Read current value of the AIPS_PACRM_SP7 field. */
#define BR_AIPS_PACRM_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP7))

/*! @brief Format value for bitfield AIPS_PACRM_SP7. */
#define BF_AIPS_PACRM_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_SP7) & BM_AIPS_PACRM_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRM_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRM_TP6    (4U)          /*!< Bit position for AIPS_PACRM_TP6. */
#define BM_AIPS_PACRM_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRM_TP6. */
#define BS_AIPS_PACRM_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRM_TP6. */

/*! @brief Read current value of the AIPS_PACRM_TP6 field. */
#define BR_AIPS_PACRM_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP6))

/*! @brief Format value for bitfield AIPS_PACRM_TP6. */
#define BF_AIPS_PACRM_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_TP6) & BM_AIPS_PACRM_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRM_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRM_WP6    (5U)          /*!< Bit position for AIPS_PACRM_WP6. */
#define BM_AIPS_PACRM_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRM_WP6. */
#define BS_AIPS_PACRM_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRM_WP6. */

/*! @brief Read current value of the AIPS_PACRM_WP6 field. */
#define BR_AIPS_PACRM_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP6))

/*! @brief Format value for bitfield AIPS_PACRM_WP6. */
#define BF_AIPS_PACRM_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_WP6) & BM_AIPS_PACRM_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRM_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRM_SP6    (6U)          /*!< Bit position for AIPS_PACRM_SP6. */
#define BM_AIPS_PACRM_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRM_SP6. */
#define BS_AIPS_PACRM_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRM_SP6. */

/*! @brief Read current value of the AIPS_PACRM_SP6 field. */
#define BR_AIPS_PACRM_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP6))

/*! @brief Format value for bitfield AIPS_PACRM_SP6. */
#define BF_AIPS_PACRM_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_SP6) & BM_AIPS_PACRM_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRM_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRM_TP5    (8U)          /*!< Bit position for AIPS_PACRM_TP5. */
#define BM_AIPS_PACRM_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRM_TP5. */
#define BS_AIPS_PACRM_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRM_TP5. */

/*! @brief Read current value of the AIPS_PACRM_TP5 field. */
#define BR_AIPS_PACRM_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP5))

/*! @brief Format value for bitfield AIPS_PACRM_TP5. */
#define BF_AIPS_PACRM_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_TP5) & BM_AIPS_PACRM_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRM_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRM_WP5    (9U)          /*!< Bit position for AIPS_PACRM_WP5. */
#define BM_AIPS_PACRM_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRM_WP5. */
#define BS_AIPS_PACRM_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRM_WP5. */

/*! @brief Read current value of the AIPS_PACRM_WP5 field. */
#define BR_AIPS_PACRM_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP5))

/*! @brief Format value for bitfield AIPS_PACRM_WP5. */
#define BF_AIPS_PACRM_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_WP5) & BM_AIPS_PACRM_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRM_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRM_SP5    (10U)         /*!< Bit position for AIPS_PACRM_SP5. */
#define BM_AIPS_PACRM_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRM_SP5. */
#define BS_AIPS_PACRM_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRM_SP5. */

/*! @brief Read current value of the AIPS_PACRM_SP5 field. */
#define BR_AIPS_PACRM_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP5))

/*! @brief Format value for bitfield AIPS_PACRM_SP5. */
#define BF_AIPS_PACRM_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_SP5) & BM_AIPS_PACRM_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRM_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRM_TP4    (12U)         /*!< Bit position for AIPS_PACRM_TP4. */
#define BM_AIPS_PACRM_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRM_TP4. */
#define BS_AIPS_PACRM_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRM_TP4. */

/*! @brief Read current value of the AIPS_PACRM_TP4 field. */
#define BR_AIPS_PACRM_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP4))

/*! @brief Format value for bitfield AIPS_PACRM_TP4. */
#define BF_AIPS_PACRM_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_TP4) & BM_AIPS_PACRM_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRM_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRM_WP4    (13U)         /*!< Bit position for AIPS_PACRM_WP4. */
#define BM_AIPS_PACRM_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRM_WP4. */
#define BS_AIPS_PACRM_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRM_WP4. */

/*! @brief Read current value of the AIPS_PACRM_WP4 field. */
#define BR_AIPS_PACRM_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP4))

/*! @brief Format value for bitfield AIPS_PACRM_WP4. */
#define BF_AIPS_PACRM_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_WP4) & BM_AIPS_PACRM_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRM_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRM_SP4    (14U)         /*!< Bit position for AIPS_PACRM_SP4. */
#define BM_AIPS_PACRM_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRM_SP4. */
#define BS_AIPS_PACRM_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRM_SP4. */

/*! @brief Read current value of the AIPS_PACRM_SP4 field. */
#define BR_AIPS_PACRM_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP4))

/*! @brief Format value for bitfield AIPS_PACRM_SP4. */
#define BF_AIPS_PACRM_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_SP4) & BM_AIPS_PACRM_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRM_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRM_TP3    (16U)         /*!< Bit position for AIPS_PACRM_TP3. */
#define BM_AIPS_PACRM_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRM_TP3. */
#define BS_AIPS_PACRM_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRM_TP3. */

/*! @brief Read current value of the AIPS_PACRM_TP3 field. */
#define BR_AIPS_PACRM_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP3))

/*! @brief Format value for bitfield AIPS_PACRM_TP3. */
#define BF_AIPS_PACRM_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_TP3) & BM_AIPS_PACRM_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRM_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRM_WP3    (17U)         /*!< Bit position for AIPS_PACRM_WP3. */
#define BM_AIPS_PACRM_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRM_WP3. */
#define BS_AIPS_PACRM_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRM_WP3. */

/*! @brief Read current value of the AIPS_PACRM_WP3 field. */
#define BR_AIPS_PACRM_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP3))

/*! @brief Format value for bitfield AIPS_PACRM_WP3. */
#define BF_AIPS_PACRM_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_WP3) & BM_AIPS_PACRM_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRM_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRM_SP3    (18U)         /*!< Bit position for AIPS_PACRM_SP3. */
#define BM_AIPS_PACRM_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRM_SP3. */
#define BS_AIPS_PACRM_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRM_SP3. */

/*! @brief Read current value of the AIPS_PACRM_SP3 field. */
#define BR_AIPS_PACRM_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP3))

/*! @brief Format value for bitfield AIPS_PACRM_SP3. */
#define BF_AIPS_PACRM_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_SP3) & BM_AIPS_PACRM_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRM_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRM_TP2    (20U)         /*!< Bit position for AIPS_PACRM_TP2. */
#define BM_AIPS_PACRM_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRM_TP2. */
#define BS_AIPS_PACRM_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRM_TP2. */

/*! @brief Read current value of the AIPS_PACRM_TP2 field. */
#define BR_AIPS_PACRM_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP2))

/*! @brief Format value for bitfield AIPS_PACRM_TP2. */
#define BF_AIPS_PACRM_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_TP2) & BM_AIPS_PACRM_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRM_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRM_WP2    (21U)         /*!< Bit position for AIPS_PACRM_WP2. */
#define BM_AIPS_PACRM_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRM_WP2. */
#define BS_AIPS_PACRM_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRM_WP2. */

/*! @brief Read current value of the AIPS_PACRM_WP2 field. */
#define BR_AIPS_PACRM_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP2))

/*! @brief Format value for bitfield AIPS_PACRM_WP2. */
#define BF_AIPS_PACRM_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_WP2) & BM_AIPS_PACRM_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRM_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRM_SP2    (22U)         /*!< Bit position for AIPS_PACRM_SP2. */
#define BM_AIPS_PACRM_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRM_SP2. */
#define BS_AIPS_PACRM_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRM_SP2. */

/*! @brief Read current value of the AIPS_PACRM_SP2 field. */
#define BR_AIPS_PACRM_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP2))

/*! @brief Format value for bitfield AIPS_PACRM_SP2. */
#define BF_AIPS_PACRM_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_SP2) & BM_AIPS_PACRM_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRM_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRM_TP1    (24U)         /*!< Bit position for AIPS_PACRM_TP1. */
#define BM_AIPS_PACRM_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRM_TP1. */
#define BS_AIPS_PACRM_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRM_TP1. */

/*! @brief Read current value of the AIPS_PACRM_TP1 field. */
#define BR_AIPS_PACRM_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP1))

/*! @brief Format value for bitfield AIPS_PACRM_TP1. */
#define BF_AIPS_PACRM_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_TP1) & BM_AIPS_PACRM_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRM_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRM_WP1    (25U)         /*!< Bit position for AIPS_PACRM_WP1. */
#define BM_AIPS_PACRM_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRM_WP1. */
#define BS_AIPS_PACRM_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRM_WP1. */

/*! @brief Read current value of the AIPS_PACRM_WP1 field. */
#define BR_AIPS_PACRM_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP1))

/*! @brief Format value for bitfield AIPS_PACRM_WP1. */
#define BF_AIPS_PACRM_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_WP1) & BM_AIPS_PACRM_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRM_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRM_SP1    (26U)         /*!< Bit position for AIPS_PACRM_SP1. */
#define BM_AIPS_PACRM_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRM_SP1. */
#define BS_AIPS_PACRM_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRM_SP1. */

/*! @brief Read current value of the AIPS_PACRM_SP1 field. */
#define BR_AIPS_PACRM_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP1))

/*! @brief Format value for bitfield AIPS_PACRM_SP1. */
#define BF_AIPS_PACRM_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_SP1) & BM_AIPS_PACRM_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRM_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRM_TP0    (28U)         /*!< Bit position for AIPS_PACRM_TP0. */
#define BM_AIPS_PACRM_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRM_TP0. */
#define BS_AIPS_PACRM_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRM_TP0. */

/*! @brief Read current value of the AIPS_PACRM_TP0 field. */
#define BR_AIPS_PACRM_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP0))

/*! @brief Format value for bitfield AIPS_PACRM_TP0. */
#define BF_AIPS_PACRM_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_TP0) & BM_AIPS_PACRM_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRM_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRM_WP0    (29U)         /*!< Bit position for AIPS_PACRM_WP0. */
#define BM_AIPS_PACRM_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRM_WP0. */
#define BS_AIPS_PACRM_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRM_WP0. */

/*! @brief Read current value of the AIPS_PACRM_WP0 field. */
#define BR_AIPS_PACRM_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP0))

/*! @brief Format value for bitfield AIPS_PACRM_WP0. */
#define BF_AIPS_PACRM_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_WP0) & BM_AIPS_PACRM_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRM_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRM_SP0    (30U)         /*!< Bit position for AIPS_PACRM_SP0. */
#define BM_AIPS_PACRM_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRM_SP0. */
#define BS_AIPS_PACRM_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRM_SP0. */

/*! @brief Read current value of the AIPS_PACRM_SP0 field. */
#define BR_AIPS_PACRM_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP0))

/*! @brief Format value for bitfield AIPS_PACRM_SP0. */
#define BF_AIPS_PACRM_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRM_SP0) & BM_AIPS_PACRM_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRM_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRM_ADDR(x), BP_AIPS_PACRM_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRN - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRN - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacrn
{
    uint32_t U;
    struct _hw_aips_pacrn_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrn_t;

/*!
 * @name Constants and macros for entire AIPS_PACRN register
 */
/*@{*/
#define HW_AIPS_PACRN_ADDR(x)    ((uint32_t)(x) + 0x64U)

#define HW_AIPS_PACRN(x)         (*(__IO hw_aips_pacrn_t *) HW_AIPS_PACRN_ADDR(x))
#define HW_AIPS_PACRN_RD(x)      (HW_AIPS_PACRN(x).U)
#define HW_AIPS_PACRN_WR(x, v)   (HW_AIPS_PACRN(x).U = (v))
#define HW_AIPS_PACRN_SET(x, v)  (HW_AIPS_PACRN_WR(x, HW_AIPS_PACRN_RD(x) |  (v)))
#define HW_AIPS_PACRN_CLR(x, v)  (HW_AIPS_PACRN_WR(x, HW_AIPS_PACRN_RD(x) & ~(v)))
#define HW_AIPS_PACRN_TOG(x, v)  (HW_AIPS_PACRN_WR(x, HW_AIPS_PACRN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRN bitfields
 */

/*!
 * @name Register AIPS_PACRN, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRN_TP7    (0U)          /*!< Bit position for AIPS_PACRN_TP7. */
#define BM_AIPS_PACRN_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRN_TP7. */
#define BS_AIPS_PACRN_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRN_TP7. */

/*! @brief Read current value of the AIPS_PACRN_TP7 field. */
#define BR_AIPS_PACRN_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP7))

/*! @brief Format value for bitfield AIPS_PACRN_TP7. */
#define BF_AIPS_PACRN_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_TP7) & BM_AIPS_PACRN_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRN_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRN_WP7    (1U)          /*!< Bit position for AIPS_PACRN_WP7. */
#define BM_AIPS_PACRN_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRN_WP7. */
#define BS_AIPS_PACRN_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRN_WP7. */

/*! @brief Read current value of the AIPS_PACRN_WP7 field. */
#define BR_AIPS_PACRN_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP7))

/*! @brief Format value for bitfield AIPS_PACRN_WP7. */
#define BF_AIPS_PACRN_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_WP7) & BM_AIPS_PACRN_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRN_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRN_SP7    (2U)          /*!< Bit position for AIPS_PACRN_SP7. */
#define BM_AIPS_PACRN_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRN_SP7. */
#define BS_AIPS_PACRN_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRN_SP7. */

/*! @brief Read current value of the AIPS_PACRN_SP7 field. */
#define BR_AIPS_PACRN_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP7))

/*! @brief Format value for bitfield AIPS_PACRN_SP7. */
#define BF_AIPS_PACRN_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_SP7) & BM_AIPS_PACRN_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRN_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRN_TP6    (4U)          /*!< Bit position for AIPS_PACRN_TP6. */
#define BM_AIPS_PACRN_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRN_TP6. */
#define BS_AIPS_PACRN_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRN_TP6. */

/*! @brief Read current value of the AIPS_PACRN_TP6 field. */
#define BR_AIPS_PACRN_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP6))

/*! @brief Format value for bitfield AIPS_PACRN_TP6. */
#define BF_AIPS_PACRN_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_TP6) & BM_AIPS_PACRN_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRN_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRN_WP6    (5U)          /*!< Bit position for AIPS_PACRN_WP6. */
#define BM_AIPS_PACRN_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRN_WP6. */
#define BS_AIPS_PACRN_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRN_WP6. */

/*! @brief Read current value of the AIPS_PACRN_WP6 field. */
#define BR_AIPS_PACRN_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP6))

/*! @brief Format value for bitfield AIPS_PACRN_WP6. */
#define BF_AIPS_PACRN_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_WP6) & BM_AIPS_PACRN_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRN_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRN_SP6    (6U)          /*!< Bit position for AIPS_PACRN_SP6. */
#define BM_AIPS_PACRN_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRN_SP6. */
#define BS_AIPS_PACRN_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRN_SP6. */

/*! @brief Read current value of the AIPS_PACRN_SP6 field. */
#define BR_AIPS_PACRN_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP6))

/*! @brief Format value for bitfield AIPS_PACRN_SP6. */
#define BF_AIPS_PACRN_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_SP6) & BM_AIPS_PACRN_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRN_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRN_TP5    (8U)          /*!< Bit position for AIPS_PACRN_TP5. */
#define BM_AIPS_PACRN_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRN_TP5. */
#define BS_AIPS_PACRN_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRN_TP5. */

/*! @brief Read current value of the AIPS_PACRN_TP5 field. */
#define BR_AIPS_PACRN_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP5))

/*! @brief Format value for bitfield AIPS_PACRN_TP5. */
#define BF_AIPS_PACRN_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_TP5) & BM_AIPS_PACRN_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRN_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRN_WP5    (9U)          /*!< Bit position for AIPS_PACRN_WP5. */
#define BM_AIPS_PACRN_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRN_WP5. */
#define BS_AIPS_PACRN_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRN_WP5. */

/*! @brief Read current value of the AIPS_PACRN_WP5 field. */
#define BR_AIPS_PACRN_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP5))

/*! @brief Format value for bitfield AIPS_PACRN_WP5. */
#define BF_AIPS_PACRN_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_WP5) & BM_AIPS_PACRN_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRN_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRN_SP5    (10U)         /*!< Bit position for AIPS_PACRN_SP5. */
#define BM_AIPS_PACRN_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRN_SP5. */
#define BS_AIPS_PACRN_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRN_SP5. */

/*! @brief Read current value of the AIPS_PACRN_SP5 field. */
#define BR_AIPS_PACRN_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP5))

/*! @brief Format value for bitfield AIPS_PACRN_SP5. */
#define BF_AIPS_PACRN_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_SP5) & BM_AIPS_PACRN_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRN_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRN_TP4    (12U)         /*!< Bit position for AIPS_PACRN_TP4. */
#define BM_AIPS_PACRN_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRN_TP4. */
#define BS_AIPS_PACRN_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRN_TP4. */

/*! @brief Read current value of the AIPS_PACRN_TP4 field. */
#define BR_AIPS_PACRN_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP4))

/*! @brief Format value for bitfield AIPS_PACRN_TP4. */
#define BF_AIPS_PACRN_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_TP4) & BM_AIPS_PACRN_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRN_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRN_WP4    (13U)         /*!< Bit position for AIPS_PACRN_WP4. */
#define BM_AIPS_PACRN_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRN_WP4. */
#define BS_AIPS_PACRN_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRN_WP4. */

/*! @brief Read current value of the AIPS_PACRN_WP4 field. */
#define BR_AIPS_PACRN_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP4))

/*! @brief Format value for bitfield AIPS_PACRN_WP4. */
#define BF_AIPS_PACRN_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_WP4) & BM_AIPS_PACRN_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRN_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRN_SP4    (14U)         /*!< Bit position for AIPS_PACRN_SP4. */
#define BM_AIPS_PACRN_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRN_SP4. */
#define BS_AIPS_PACRN_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRN_SP4. */

/*! @brief Read current value of the AIPS_PACRN_SP4 field. */
#define BR_AIPS_PACRN_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP4))

/*! @brief Format value for bitfield AIPS_PACRN_SP4. */
#define BF_AIPS_PACRN_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_SP4) & BM_AIPS_PACRN_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRN_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRN_TP3    (16U)         /*!< Bit position for AIPS_PACRN_TP3. */
#define BM_AIPS_PACRN_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRN_TP3. */
#define BS_AIPS_PACRN_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRN_TP3. */

/*! @brief Read current value of the AIPS_PACRN_TP3 field. */
#define BR_AIPS_PACRN_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP3))

/*! @brief Format value for bitfield AIPS_PACRN_TP3. */
#define BF_AIPS_PACRN_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_TP3) & BM_AIPS_PACRN_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRN_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRN_WP3    (17U)         /*!< Bit position for AIPS_PACRN_WP3. */
#define BM_AIPS_PACRN_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRN_WP3. */
#define BS_AIPS_PACRN_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRN_WP3. */

/*! @brief Read current value of the AIPS_PACRN_WP3 field. */
#define BR_AIPS_PACRN_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP3))

/*! @brief Format value for bitfield AIPS_PACRN_WP3. */
#define BF_AIPS_PACRN_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_WP3) & BM_AIPS_PACRN_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRN_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRN_SP3    (18U)         /*!< Bit position for AIPS_PACRN_SP3. */
#define BM_AIPS_PACRN_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRN_SP3. */
#define BS_AIPS_PACRN_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRN_SP3. */

/*! @brief Read current value of the AIPS_PACRN_SP3 field. */
#define BR_AIPS_PACRN_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP3))

/*! @brief Format value for bitfield AIPS_PACRN_SP3. */
#define BF_AIPS_PACRN_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_SP3) & BM_AIPS_PACRN_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRN_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRN_TP2    (20U)         /*!< Bit position for AIPS_PACRN_TP2. */
#define BM_AIPS_PACRN_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRN_TP2. */
#define BS_AIPS_PACRN_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRN_TP2. */

/*! @brief Read current value of the AIPS_PACRN_TP2 field. */
#define BR_AIPS_PACRN_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP2))

/*! @brief Format value for bitfield AIPS_PACRN_TP2. */
#define BF_AIPS_PACRN_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_TP2) & BM_AIPS_PACRN_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRN_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRN_WP2    (21U)         /*!< Bit position for AIPS_PACRN_WP2. */
#define BM_AIPS_PACRN_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRN_WP2. */
#define BS_AIPS_PACRN_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRN_WP2. */

/*! @brief Read current value of the AIPS_PACRN_WP2 field. */
#define BR_AIPS_PACRN_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP2))

/*! @brief Format value for bitfield AIPS_PACRN_WP2. */
#define BF_AIPS_PACRN_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_WP2) & BM_AIPS_PACRN_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRN_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRN_SP2    (22U)         /*!< Bit position for AIPS_PACRN_SP2. */
#define BM_AIPS_PACRN_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRN_SP2. */
#define BS_AIPS_PACRN_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRN_SP2. */

/*! @brief Read current value of the AIPS_PACRN_SP2 field. */
#define BR_AIPS_PACRN_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP2))

/*! @brief Format value for bitfield AIPS_PACRN_SP2. */
#define BF_AIPS_PACRN_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_SP2) & BM_AIPS_PACRN_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRN_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRN_TP1    (24U)         /*!< Bit position for AIPS_PACRN_TP1. */
#define BM_AIPS_PACRN_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRN_TP1. */
#define BS_AIPS_PACRN_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRN_TP1. */

/*! @brief Read current value of the AIPS_PACRN_TP1 field. */
#define BR_AIPS_PACRN_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP1))

/*! @brief Format value for bitfield AIPS_PACRN_TP1. */
#define BF_AIPS_PACRN_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_TP1) & BM_AIPS_PACRN_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRN_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRN_WP1    (25U)         /*!< Bit position for AIPS_PACRN_WP1. */
#define BM_AIPS_PACRN_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRN_WP1. */
#define BS_AIPS_PACRN_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRN_WP1. */

/*! @brief Read current value of the AIPS_PACRN_WP1 field. */
#define BR_AIPS_PACRN_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP1))

/*! @brief Format value for bitfield AIPS_PACRN_WP1. */
#define BF_AIPS_PACRN_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_WP1) & BM_AIPS_PACRN_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRN_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRN_SP1    (26U)         /*!< Bit position for AIPS_PACRN_SP1. */
#define BM_AIPS_PACRN_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRN_SP1. */
#define BS_AIPS_PACRN_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRN_SP1. */

/*! @brief Read current value of the AIPS_PACRN_SP1 field. */
#define BR_AIPS_PACRN_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP1))

/*! @brief Format value for bitfield AIPS_PACRN_SP1. */
#define BF_AIPS_PACRN_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_SP1) & BM_AIPS_PACRN_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRN_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRN_TP0    (28U)         /*!< Bit position for AIPS_PACRN_TP0. */
#define BM_AIPS_PACRN_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRN_TP0. */
#define BS_AIPS_PACRN_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRN_TP0. */

/*! @brief Read current value of the AIPS_PACRN_TP0 field. */
#define BR_AIPS_PACRN_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP0))

/*! @brief Format value for bitfield AIPS_PACRN_TP0. */
#define BF_AIPS_PACRN_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_TP0) & BM_AIPS_PACRN_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRN_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRN_WP0    (29U)         /*!< Bit position for AIPS_PACRN_WP0. */
#define BM_AIPS_PACRN_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRN_WP0. */
#define BS_AIPS_PACRN_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRN_WP0. */

/*! @brief Read current value of the AIPS_PACRN_WP0 field. */
#define BR_AIPS_PACRN_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP0))

/*! @brief Format value for bitfield AIPS_PACRN_WP0. */
#define BF_AIPS_PACRN_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_WP0) & BM_AIPS_PACRN_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRN_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRN_SP0    (30U)         /*!< Bit position for AIPS_PACRN_SP0. */
#define BM_AIPS_PACRN_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRN_SP0. */
#define BS_AIPS_PACRN_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRN_SP0. */

/*! @brief Read current value of the AIPS_PACRN_SP0 field. */
#define BR_AIPS_PACRN_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP0))

/*! @brief Format value for bitfield AIPS_PACRN_SP0. */
#define BF_AIPS_PACRN_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRN_SP0) & BM_AIPS_PACRN_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRN_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRN_ADDR(x), BP_AIPS_PACRN_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRO - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRO - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacro
{
    uint32_t U;
    struct _hw_aips_pacro_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacro_t;

/*!
 * @name Constants and macros for entire AIPS_PACRO register
 */
/*@{*/
#define HW_AIPS_PACRO_ADDR(x)    ((uint32_t)(x) + 0x68U)

#define HW_AIPS_PACRO(x)         (*(__IO hw_aips_pacro_t *) HW_AIPS_PACRO_ADDR(x))
#define HW_AIPS_PACRO_RD(x)      (HW_AIPS_PACRO(x).U)
#define HW_AIPS_PACRO_WR(x, v)   (HW_AIPS_PACRO(x).U = (v))
#define HW_AIPS_PACRO_SET(x, v)  (HW_AIPS_PACRO_WR(x, HW_AIPS_PACRO_RD(x) |  (v)))
#define HW_AIPS_PACRO_CLR(x, v)  (HW_AIPS_PACRO_WR(x, HW_AIPS_PACRO_RD(x) & ~(v)))
#define HW_AIPS_PACRO_TOG(x, v)  (HW_AIPS_PACRO_WR(x, HW_AIPS_PACRO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRO bitfields
 */

/*!
 * @name Register AIPS_PACRO, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRO_TP7    (0U)          /*!< Bit position for AIPS_PACRO_TP7. */
#define BM_AIPS_PACRO_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRO_TP7. */
#define BS_AIPS_PACRO_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRO_TP7. */

/*! @brief Read current value of the AIPS_PACRO_TP7 field. */
#define BR_AIPS_PACRO_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP7))

/*! @brief Format value for bitfield AIPS_PACRO_TP7. */
#define BF_AIPS_PACRO_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_TP7) & BM_AIPS_PACRO_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRO_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRO_WP7    (1U)          /*!< Bit position for AIPS_PACRO_WP7. */
#define BM_AIPS_PACRO_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRO_WP7. */
#define BS_AIPS_PACRO_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRO_WP7. */

/*! @brief Read current value of the AIPS_PACRO_WP7 field. */
#define BR_AIPS_PACRO_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP7))

/*! @brief Format value for bitfield AIPS_PACRO_WP7. */
#define BF_AIPS_PACRO_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_WP7) & BM_AIPS_PACRO_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRO_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRO_SP7    (2U)          /*!< Bit position for AIPS_PACRO_SP7. */
#define BM_AIPS_PACRO_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRO_SP7. */
#define BS_AIPS_PACRO_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRO_SP7. */

/*! @brief Read current value of the AIPS_PACRO_SP7 field. */
#define BR_AIPS_PACRO_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP7))

/*! @brief Format value for bitfield AIPS_PACRO_SP7. */
#define BF_AIPS_PACRO_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_SP7) & BM_AIPS_PACRO_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRO_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRO_TP6    (4U)          /*!< Bit position for AIPS_PACRO_TP6. */
#define BM_AIPS_PACRO_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRO_TP6. */
#define BS_AIPS_PACRO_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRO_TP6. */

/*! @brief Read current value of the AIPS_PACRO_TP6 field. */
#define BR_AIPS_PACRO_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP6))

/*! @brief Format value for bitfield AIPS_PACRO_TP6. */
#define BF_AIPS_PACRO_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_TP6) & BM_AIPS_PACRO_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRO_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRO_WP6    (5U)          /*!< Bit position for AIPS_PACRO_WP6. */
#define BM_AIPS_PACRO_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRO_WP6. */
#define BS_AIPS_PACRO_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRO_WP6. */

/*! @brief Read current value of the AIPS_PACRO_WP6 field. */
#define BR_AIPS_PACRO_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP6))

/*! @brief Format value for bitfield AIPS_PACRO_WP6. */
#define BF_AIPS_PACRO_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_WP6) & BM_AIPS_PACRO_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRO_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRO_SP6    (6U)          /*!< Bit position for AIPS_PACRO_SP6. */
#define BM_AIPS_PACRO_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRO_SP6. */
#define BS_AIPS_PACRO_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRO_SP6. */

/*! @brief Read current value of the AIPS_PACRO_SP6 field. */
#define BR_AIPS_PACRO_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP6))

/*! @brief Format value for bitfield AIPS_PACRO_SP6. */
#define BF_AIPS_PACRO_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_SP6) & BM_AIPS_PACRO_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRO_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRO_TP5    (8U)          /*!< Bit position for AIPS_PACRO_TP5. */
#define BM_AIPS_PACRO_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRO_TP5. */
#define BS_AIPS_PACRO_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRO_TP5. */

/*! @brief Read current value of the AIPS_PACRO_TP5 field. */
#define BR_AIPS_PACRO_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP5))

/*! @brief Format value for bitfield AIPS_PACRO_TP5. */
#define BF_AIPS_PACRO_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_TP5) & BM_AIPS_PACRO_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRO_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRO_WP5    (9U)          /*!< Bit position for AIPS_PACRO_WP5. */
#define BM_AIPS_PACRO_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRO_WP5. */
#define BS_AIPS_PACRO_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRO_WP5. */

/*! @brief Read current value of the AIPS_PACRO_WP5 field. */
#define BR_AIPS_PACRO_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP5))

/*! @brief Format value for bitfield AIPS_PACRO_WP5. */
#define BF_AIPS_PACRO_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_WP5) & BM_AIPS_PACRO_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRO_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRO_SP5    (10U)         /*!< Bit position for AIPS_PACRO_SP5. */
#define BM_AIPS_PACRO_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRO_SP5. */
#define BS_AIPS_PACRO_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRO_SP5. */

/*! @brief Read current value of the AIPS_PACRO_SP5 field. */
#define BR_AIPS_PACRO_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP5))

/*! @brief Format value for bitfield AIPS_PACRO_SP5. */
#define BF_AIPS_PACRO_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_SP5) & BM_AIPS_PACRO_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRO_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRO_TP4    (12U)         /*!< Bit position for AIPS_PACRO_TP4. */
#define BM_AIPS_PACRO_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRO_TP4. */
#define BS_AIPS_PACRO_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRO_TP4. */

/*! @brief Read current value of the AIPS_PACRO_TP4 field. */
#define BR_AIPS_PACRO_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP4))

/*! @brief Format value for bitfield AIPS_PACRO_TP4. */
#define BF_AIPS_PACRO_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_TP4) & BM_AIPS_PACRO_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRO_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRO_WP4    (13U)         /*!< Bit position for AIPS_PACRO_WP4. */
#define BM_AIPS_PACRO_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRO_WP4. */
#define BS_AIPS_PACRO_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRO_WP4. */

/*! @brief Read current value of the AIPS_PACRO_WP4 field. */
#define BR_AIPS_PACRO_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP4))

/*! @brief Format value for bitfield AIPS_PACRO_WP4. */
#define BF_AIPS_PACRO_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_WP4) & BM_AIPS_PACRO_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRO_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRO_SP4    (14U)         /*!< Bit position for AIPS_PACRO_SP4. */
#define BM_AIPS_PACRO_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRO_SP4. */
#define BS_AIPS_PACRO_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRO_SP4. */

/*! @brief Read current value of the AIPS_PACRO_SP4 field. */
#define BR_AIPS_PACRO_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP4))

/*! @brief Format value for bitfield AIPS_PACRO_SP4. */
#define BF_AIPS_PACRO_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_SP4) & BM_AIPS_PACRO_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRO_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRO_TP3    (16U)         /*!< Bit position for AIPS_PACRO_TP3. */
#define BM_AIPS_PACRO_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRO_TP3. */
#define BS_AIPS_PACRO_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRO_TP3. */

/*! @brief Read current value of the AIPS_PACRO_TP3 field. */
#define BR_AIPS_PACRO_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP3))

/*! @brief Format value for bitfield AIPS_PACRO_TP3. */
#define BF_AIPS_PACRO_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_TP3) & BM_AIPS_PACRO_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRO_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRO_WP3    (17U)         /*!< Bit position for AIPS_PACRO_WP3. */
#define BM_AIPS_PACRO_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRO_WP3. */
#define BS_AIPS_PACRO_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRO_WP3. */

/*! @brief Read current value of the AIPS_PACRO_WP3 field. */
#define BR_AIPS_PACRO_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP3))

/*! @brief Format value for bitfield AIPS_PACRO_WP3. */
#define BF_AIPS_PACRO_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_WP3) & BM_AIPS_PACRO_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRO_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRO_SP3    (18U)         /*!< Bit position for AIPS_PACRO_SP3. */
#define BM_AIPS_PACRO_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRO_SP3. */
#define BS_AIPS_PACRO_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRO_SP3. */

/*! @brief Read current value of the AIPS_PACRO_SP3 field. */
#define BR_AIPS_PACRO_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP3))

/*! @brief Format value for bitfield AIPS_PACRO_SP3. */
#define BF_AIPS_PACRO_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_SP3) & BM_AIPS_PACRO_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRO_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRO_TP2    (20U)         /*!< Bit position for AIPS_PACRO_TP2. */
#define BM_AIPS_PACRO_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRO_TP2. */
#define BS_AIPS_PACRO_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRO_TP2. */

/*! @brief Read current value of the AIPS_PACRO_TP2 field. */
#define BR_AIPS_PACRO_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP2))

/*! @brief Format value for bitfield AIPS_PACRO_TP2. */
#define BF_AIPS_PACRO_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_TP2) & BM_AIPS_PACRO_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRO_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRO_WP2    (21U)         /*!< Bit position for AIPS_PACRO_WP2. */
#define BM_AIPS_PACRO_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRO_WP2. */
#define BS_AIPS_PACRO_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRO_WP2. */

/*! @brief Read current value of the AIPS_PACRO_WP2 field. */
#define BR_AIPS_PACRO_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP2))

/*! @brief Format value for bitfield AIPS_PACRO_WP2. */
#define BF_AIPS_PACRO_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_WP2) & BM_AIPS_PACRO_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRO_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRO_SP2    (22U)         /*!< Bit position for AIPS_PACRO_SP2. */
#define BM_AIPS_PACRO_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRO_SP2. */
#define BS_AIPS_PACRO_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRO_SP2. */

/*! @brief Read current value of the AIPS_PACRO_SP2 field. */
#define BR_AIPS_PACRO_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP2))

/*! @brief Format value for bitfield AIPS_PACRO_SP2. */
#define BF_AIPS_PACRO_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_SP2) & BM_AIPS_PACRO_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRO_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRO_TP1    (24U)         /*!< Bit position for AIPS_PACRO_TP1. */
#define BM_AIPS_PACRO_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRO_TP1. */
#define BS_AIPS_PACRO_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRO_TP1. */

/*! @brief Read current value of the AIPS_PACRO_TP1 field. */
#define BR_AIPS_PACRO_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP1))

/*! @brief Format value for bitfield AIPS_PACRO_TP1. */
#define BF_AIPS_PACRO_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_TP1) & BM_AIPS_PACRO_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRO_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRO_WP1    (25U)         /*!< Bit position for AIPS_PACRO_WP1. */
#define BM_AIPS_PACRO_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRO_WP1. */
#define BS_AIPS_PACRO_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRO_WP1. */

/*! @brief Read current value of the AIPS_PACRO_WP1 field. */
#define BR_AIPS_PACRO_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP1))

/*! @brief Format value for bitfield AIPS_PACRO_WP1. */
#define BF_AIPS_PACRO_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_WP1) & BM_AIPS_PACRO_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRO_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRO_SP1    (26U)         /*!< Bit position for AIPS_PACRO_SP1. */
#define BM_AIPS_PACRO_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRO_SP1. */
#define BS_AIPS_PACRO_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRO_SP1. */

/*! @brief Read current value of the AIPS_PACRO_SP1 field. */
#define BR_AIPS_PACRO_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP1))

/*! @brief Format value for bitfield AIPS_PACRO_SP1. */
#define BF_AIPS_PACRO_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_SP1) & BM_AIPS_PACRO_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRO_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRO_TP0    (28U)         /*!< Bit position for AIPS_PACRO_TP0. */
#define BM_AIPS_PACRO_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRO_TP0. */
#define BS_AIPS_PACRO_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRO_TP0. */

/*! @brief Read current value of the AIPS_PACRO_TP0 field. */
#define BR_AIPS_PACRO_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP0))

/*! @brief Format value for bitfield AIPS_PACRO_TP0. */
#define BF_AIPS_PACRO_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_TP0) & BM_AIPS_PACRO_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRO_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRO_WP0    (29U)         /*!< Bit position for AIPS_PACRO_WP0. */
#define BM_AIPS_PACRO_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRO_WP0. */
#define BS_AIPS_PACRO_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRO_WP0. */

/*! @brief Read current value of the AIPS_PACRO_WP0 field. */
#define BR_AIPS_PACRO_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP0))

/*! @brief Format value for bitfield AIPS_PACRO_WP0. */
#define BF_AIPS_PACRO_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_WP0) & BM_AIPS_PACRO_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRO_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRO_SP0    (30U)         /*!< Bit position for AIPS_PACRO_SP0. */
#define BM_AIPS_PACRO_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRO_SP0. */
#define BS_AIPS_PACRO_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRO_SP0. */

/*! @brief Read current value of the AIPS_PACRO_SP0 field. */
#define BR_AIPS_PACRO_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP0))

/*! @brief Format value for bitfield AIPS_PACRO_SP0. */
#define BF_AIPS_PACRO_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRO_SP0) & BM_AIPS_PACRO_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRO_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRO_ADDR(x), BP_AIPS_PACRO_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRP - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRP - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44444444U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
typedef union _hw_aips_pacrp
{
    uint32_t U;
    struct _hw_aips_pacrp_bitfields
    {
        uint32_t TP7 : 1;              /*!< [0] Trusted Protect */
        uint32_t WP7 : 1;              /*!< [1] Write Protect */
        uint32_t SP7 : 1;              /*!< [2] Supervisor Protect */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TP6 : 1;              /*!< [4] Trusted Protect */
        uint32_t WP6 : 1;              /*!< [5] Write Protect */
        uint32_t SP6 : 1;              /*!< [6] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t TP5 : 1;              /*!< [8] Trusted Protect */
        uint32_t WP5 : 1;              /*!< [9] Write Protect */
        uint32_t SP5 : 1;              /*!< [10] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t TP4 : 1;              /*!< [12] Trusted Protect */
        uint32_t WP4 : 1;              /*!< [13] Write Protect */
        uint32_t SP4 : 1;              /*!< [14] Supervisor Protect */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t TP3 : 1;              /*!< [16] Trusted Protect */
        uint32_t WP3 : 1;              /*!< [17] Write Protect */
        uint32_t SP3 : 1;              /*!< [18] Supervisor Protect */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t TP2 : 1;              /*!< [20] Trusted Protect */
        uint32_t WP2 : 1;              /*!< [21] Write Protect */
        uint32_t SP2 : 1;              /*!< [22] Supervisor Protect */
        uint32_t RESERVED5 : 1;        /*!< [23]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED6 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED7 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacrp_t;

/*!
 * @name Constants and macros for entire AIPS_PACRP register
 */
/*@{*/
#define HW_AIPS_PACRP_ADDR(x)    ((uint32_t)(x) + 0x6CU)

#define HW_AIPS_PACRP(x)         (*(__IO hw_aips_pacrp_t *) HW_AIPS_PACRP_ADDR(x))
#define HW_AIPS_PACRP_RD(x)      (HW_AIPS_PACRP(x).U)
#define HW_AIPS_PACRP_WR(x, v)   (HW_AIPS_PACRP(x).U = (v))
#define HW_AIPS_PACRP_SET(x, v)  (HW_AIPS_PACRP_WR(x, HW_AIPS_PACRP_RD(x) |  (v)))
#define HW_AIPS_PACRP_CLR(x, v)  (HW_AIPS_PACRP_WR(x, HW_AIPS_PACRP_RD(x) & ~(v)))
#define HW_AIPS_PACRP_TOG(x, v)  (HW_AIPS_PACRP_WR(x, HW_AIPS_PACRP_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRP bitfields
 */

/*!
 * @name Register AIPS_PACRP, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRP_TP7    (0U)          /*!< Bit position for AIPS_PACRP_TP7. */
#define BM_AIPS_PACRP_TP7    (0x00000001U) /*!< Bit mask for AIPS_PACRP_TP7. */
#define BS_AIPS_PACRP_TP7    (1U)          /*!< Bit field size in bits for AIPS_PACRP_TP7. */

/*! @brief Read current value of the AIPS_PACRP_TP7 field. */
#define BR_AIPS_PACRP_TP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP7))

/*! @brief Format value for bitfield AIPS_PACRP_TP7. */
#define BF_AIPS_PACRP_TP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_TP7) & BM_AIPS_PACRP_TP7)

/*! @brief Set the TP7 field to a new value. */
#define BW_AIPS_PACRP_TP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRP_WP7    (1U)          /*!< Bit position for AIPS_PACRP_WP7. */
#define BM_AIPS_PACRP_WP7    (0x00000002U) /*!< Bit mask for AIPS_PACRP_WP7. */
#define BS_AIPS_PACRP_WP7    (1U)          /*!< Bit field size in bits for AIPS_PACRP_WP7. */

/*! @brief Read current value of the AIPS_PACRP_WP7 field. */
#define BR_AIPS_PACRP_WP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP7))

/*! @brief Format value for bitfield AIPS_PACRP_WP7. */
#define BF_AIPS_PACRP_WP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_WP7) & BM_AIPS_PACRP_WP7)

/*! @brief Set the WP7 field to a new value. */
#define BW_AIPS_PACRP_WP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRP_SP7    (2U)          /*!< Bit position for AIPS_PACRP_SP7. */
#define BM_AIPS_PACRP_SP7    (0x00000004U) /*!< Bit mask for AIPS_PACRP_SP7. */
#define BS_AIPS_PACRP_SP7    (1U)          /*!< Bit field size in bits for AIPS_PACRP_SP7. */

/*! @brief Read current value of the AIPS_PACRP_SP7 field. */
#define BR_AIPS_PACRP_SP7(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP7))

/*! @brief Format value for bitfield AIPS_PACRP_SP7. */
#define BF_AIPS_PACRP_SP7(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_SP7) & BM_AIPS_PACRP_SP7)

/*! @brief Set the SP7 field to a new value. */
#define BW_AIPS_PACRP_SP7(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP7) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRP_TP6    (4U)          /*!< Bit position for AIPS_PACRP_TP6. */
#define BM_AIPS_PACRP_TP6    (0x00000010U) /*!< Bit mask for AIPS_PACRP_TP6. */
#define BS_AIPS_PACRP_TP6    (1U)          /*!< Bit field size in bits for AIPS_PACRP_TP6. */

/*! @brief Read current value of the AIPS_PACRP_TP6 field. */
#define BR_AIPS_PACRP_TP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP6))

/*! @brief Format value for bitfield AIPS_PACRP_TP6. */
#define BF_AIPS_PACRP_TP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_TP6) & BM_AIPS_PACRP_TP6)

/*! @brief Set the TP6 field to a new value. */
#define BW_AIPS_PACRP_TP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRP_WP6    (5U)          /*!< Bit position for AIPS_PACRP_WP6. */
#define BM_AIPS_PACRP_WP6    (0x00000020U) /*!< Bit mask for AIPS_PACRP_WP6. */
#define BS_AIPS_PACRP_WP6    (1U)          /*!< Bit field size in bits for AIPS_PACRP_WP6. */

/*! @brief Read current value of the AIPS_PACRP_WP6 field. */
#define BR_AIPS_PACRP_WP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP6))

/*! @brief Format value for bitfield AIPS_PACRP_WP6. */
#define BF_AIPS_PACRP_WP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_WP6) & BM_AIPS_PACRP_WP6)

/*! @brief Set the WP6 field to a new value. */
#define BW_AIPS_PACRP_WP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRP_SP6    (6U)          /*!< Bit position for AIPS_PACRP_SP6. */
#define BM_AIPS_PACRP_SP6    (0x00000040U) /*!< Bit mask for AIPS_PACRP_SP6. */
#define BS_AIPS_PACRP_SP6    (1U)          /*!< Bit field size in bits for AIPS_PACRP_SP6. */

/*! @brief Read current value of the AIPS_PACRP_SP6 field. */
#define BR_AIPS_PACRP_SP6(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP6))

/*! @brief Format value for bitfield AIPS_PACRP_SP6. */
#define BF_AIPS_PACRP_SP6(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_SP6) & BM_AIPS_PACRP_SP6)

/*! @brief Set the SP6 field to a new value. */
#define BW_AIPS_PACRP_SP6(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP6) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRP_TP5    (8U)          /*!< Bit position for AIPS_PACRP_TP5. */
#define BM_AIPS_PACRP_TP5    (0x00000100U) /*!< Bit mask for AIPS_PACRP_TP5. */
#define BS_AIPS_PACRP_TP5    (1U)          /*!< Bit field size in bits for AIPS_PACRP_TP5. */

/*! @brief Read current value of the AIPS_PACRP_TP5 field. */
#define BR_AIPS_PACRP_TP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP5))

/*! @brief Format value for bitfield AIPS_PACRP_TP5. */
#define BF_AIPS_PACRP_TP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_TP5) & BM_AIPS_PACRP_TP5)

/*! @brief Set the TP5 field to a new value. */
#define BW_AIPS_PACRP_TP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRP_WP5    (9U)          /*!< Bit position for AIPS_PACRP_WP5. */
#define BM_AIPS_PACRP_WP5    (0x00000200U) /*!< Bit mask for AIPS_PACRP_WP5. */
#define BS_AIPS_PACRP_WP5    (1U)          /*!< Bit field size in bits for AIPS_PACRP_WP5. */

/*! @brief Read current value of the AIPS_PACRP_WP5 field. */
#define BR_AIPS_PACRP_WP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP5))

/*! @brief Format value for bitfield AIPS_PACRP_WP5. */
#define BF_AIPS_PACRP_WP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_WP5) & BM_AIPS_PACRP_WP5)

/*! @brief Set the WP5 field to a new value. */
#define BW_AIPS_PACRP_WP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRP_SP5    (10U)         /*!< Bit position for AIPS_PACRP_SP5. */
#define BM_AIPS_PACRP_SP5    (0x00000400U) /*!< Bit mask for AIPS_PACRP_SP5. */
#define BS_AIPS_PACRP_SP5    (1U)          /*!< Bit field size in bits for AIPS_PACRP_SP5. */

/*! @brief Read current value of the AIPS_PACRP_SP5 field. */
#define BR_AIPS_PACRP_SP5(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP5))

/*! @brief Format value for bitfield AIPS_PACRP_SP5. */
#define BF_AIPS_PACRP_SP5(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_SP5) & BM_AIPS_PACRP_SP5)

/*! @brief Set the SP5 field to a new value. */
#define BW_AIPS_PACRP_SP5(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP5) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRP_TP4    (12U)         /*!< Bit position for AIPS_PACRP_TP4. */
#define BM_AIPS_PACRP_TP4    (0x00001000U) /*!< Bit mask for AIPS_PACRP_TP4. */
#define BS_AIPS_PACRP_TP4    (1U)          /*!< Bit field size in bits for AIPS_PACRP_TP4. */

/*! @brief Read current value of the AIPS_PACRP_TP4 field. */
#define BR_AIPS_PACRP_TP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP4))

/*! @brief Format value for bitfield AIPS_PACRP_TP4. */
#define BF_AIPS_PACRP_TP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_TP4) & BM_AIPS_PACRP_TP4)

/*! @brief Set the TP4 field to a new value. */
#define BW_AIPS_PACRP_TP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRP_WP4    (13U)         /*!< Bit position for AIPS_PACRP_WP4. */
#define BM_AIPS_PACRP_WP4    (0x00002000U) /*!< Bit mask for AIPS_PACRP_WP4. */
#define BS_AIPS_PACRP_WP4    (1U)          /*!< Bit field size in bits for AIPS_PACRP_WP4. */

/*! @brief Read current value of the AIPS_PACRP_WP4 field. */
#define BR_AIPS_PACRP_WP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP4))

/*! @brief Format value for bitfield AIPS_PACRP_WP4. */
#define BF_AIPS_PACRP_WP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_WP4) & BM_AIPS_PACRP_WP4)

/*! @brief Set the WP4 field to a new value. */
#define BW_AIPS_PACRP_WP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRP_SP4    (14U)         /*!< Bit position for AIPS_PACRP_SP4. */
#define BM_AIPS_PACRP_SP4    (0x00004000U) /*!< Bit mask for AIPS_PACRP_SP4. */
#define BS_AIPS_PACRP_SP4    (1U)          /*!< Bit field size in bits for AIPS_PACRP_SP4. */

/*! @brief Read current value of the AIPS_PACRP_SP4 field. */
#define BR_AIPS_PACRP_SP4(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP4))

/*! @brief Format value for bitfield AIPS_PACRP_SP4. */
#define BF_AIPS_PACRP_SP4(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_SP4) & BM_AIPS_PACRP_SP4)

/*! @brief Set the SP4 field to a new value. */
#define BW_AIPS_PACRP_SP4(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP4) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRP_TP3    (16U)         /*!< Bit position for AIPS_PACRP_TP3. */
#define BM_AIPS_PACRP_TP3    (0x00010000U) /*!< Bit mask for AIPS_PACRP_TP3. */
#define BS_AIPS_PACRP_TP3    (1U)          /*!< Bit field size in bits for AIPS_PACRP_TP3. */

/*! @brief Read current value of the AIPS_PACRP_TP3 field. */
#define BR_AIPS_PACRP_TP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP3))

/*! @brief Format value for bitfield AIPS_PACRP_TP3. */
#define BF_AIPS_PACRP_TP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_TP3) & BM_AIPS_PACRP_TP3)

/*! @brief Set the TP3 field to a new value. */
#define BW_AIPS_PACRP_TP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRP_WP3    (17U)         /*!< Bit position for AIPS_PACRP_WP3. */
#define BM_AIPS_PACRP_WP3    (0x00020000U) /*!< Bit mask for AIPS_PACRP_WP3. */
#define BS_AIPS_PACRP_WP3    (1U)          /*!< Bit field size in bits for AIPS_PACRP_WP3. */

/*! @brief Read current value of the AIPS_PACRP_WP3 field. */
#define BR_AIPS_PACRP_WP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP3))

/*! @brief Format value for bitfield AIPS_PACRP_WP3. */
#define BF_AIPS_PACRP_WP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_WP3) & BM_AIPS_PACRP_WP3)

/*! @brief Set the WP3 field to a new value. */
#define BW_AIPS_PACRP_WP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRP_SP3    (18U)         /*!< Bit position for AIPS_PACRP_SP3. */
#define BM_AIPS_PACRP_SP3    (0x00040000U) /*!< Bit mask for AIPS_PACRP_SP3. */
#define BS_AIPS_PACRP_SP3    (1U)          /*!< Bit field size in bits for AIPS_PACRP_SP3. */

/*! @brief Read current value of the AIPS_PACRP_SP3 field. */
#define BR_AIPS_PACRP_SP3(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP3))

/*! @brief Format value for bitfield AIPS_PACRP_SP3. */
#define BF_AIPS_PACRP_SP3(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_SP3) & BM_AIPS_PACRP_SP3)

/*! @brief Set the SP3 field to a new value. */
#define BW_AIPS_PACRP_SP3(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP3) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRP_TP2    (20U)         /*!< Bit position for AIPS_PACRP_TP2. */
#define BM_AIPS_PACRP_TP2    (0x00100000U) /*!< Bit mask for AIPS_PACRP_TP2. */
#define BS_AIPS_PACRP_TP2    (1U)          /*!< Bit field size in bits for AIPS_PACRP_TP2. */

/*! @brief Read current value of the AIPS_PACRP_TP2 field. */
#define BR_AIPS_PACRP_TP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP2))

/*! @brief Format value for bitfield AIPS_PACRP_TP2. */
#define BF_AIPS_PACRP_TP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_TP2) & BM_AIPS_PACRP_TP2)

/*! @brief Set the TP2 field to a new value. */
#define BW_AIPS_PACRP_TP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRP_WP2    (21U)         /*!< Bit position for AIPS_PACRP_WP2. */
#define BM_AIPS_PACRP_WP2    (0x00200000U) /*!< Bit mask for AIPS_PACRP_WP2. */
#define BS_AIPS_PACRP_WP2    (1U)          /*!< Bit field size in bits for AIPS_PACRP_WP2. */

/*! @brief Read current value of the AIPS_PACRP_WP2 field. */
#define BR_AIPS_PACRP_WP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP2))

/*! @brief Format value for bitfield AIPS_PACRP_WP2. */
#define BF_AIPS_PACRP_WP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_WP2) & BM_AIPS_PACRP_WP2)

/*! @brief Set the WP2 field to a new value. */
#define BW_AIPS_PACRP_WP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRP_SP2    (22U)         /*!< Bit position for AIPS_PACRP_SP2. */
#define BM_AIPS_PACRP_SP2    (0x00400000U) /*!< Bit mask for AIPS_PACRP_SP2. */
#define BS_AIPS_PACRP_SP2    (1U)          /*!< Bit field size in bits for AIPS_PACRP_SP2. */

/*! @brief Read current value of the AIPS_PACRP_SP2 field. */
#define BR_AIPS_PACRP_SP2(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP2))

/*! @brief Format value for bitfield AIPS_PACRP_SP2. */
#define BF_AIPS_PACRP_SP2(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_SP2) & BM_AIPS_PACRP_SP2)

/*! @brief Set the SP2 field to a new value. */
#define BW_AIPS_PACRP_SP2(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP2) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRP_TP1    (24U)         /*!< Bit position for AIPS_PACRP_TP1. */
#define BM_AIPS_PACRP_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRP_TP1. */
#define BS_AIPS_PACRP_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRP_TP1. */

/*! @brief Read current value of the AIPS_PACRP_TP1 field. */
#define BR_AIPS_PACRP_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP1))

/*! @brief Format value for bitfield AIPS_PACRP_TP1. */
#define BF_AIPS_PACRP_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_TP1) & BM_AIPS_PACRP_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRP_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRP_WP1    (25U)         /*!< Bit position for AIPS_PACRP_WP1. */
#define BM_AIPS_PACRP_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRP_WP1. */
#define BS_AIPS_PACRP_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRP_WP1. */

/*! @brief Read current value of the AIPS_PACRP_WP1 field. */
#define BR_AIPS_PACRP_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP1))

/*! @brief Format value for bitfield AIPS_PACRP_WP1. */
#define BF_AIPS_PACRP_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_WP1) & BM_AIPS_PACRP_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRP_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRP_SP1    (26U)         /*!< Bit position for AIPS_PACRP_SP1. */
#define BM_AIPS_PACRP_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRP_SP1. */
#define BS_AIPS_PACRP_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRP_SP1. */

/*! @brief Read current value of the AIPS_PACRP_SP1 field. */
#define BR_AIPS_PACRP_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP1))

/*! @brief Format value for bitfield AIPS_PACRP_SP1. */
#define BF_AIPS_PACRP_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_SP1) & BM_AIPS_PACRP_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRP_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRP_TP0    (28U)         /*!< Bit position for AIPS_PACRP_TP0. */
#define BM_AIPS_PACRP_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRP_TP0. */
#define BS_AIPS_PACRP_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRP_TP0. */

/*! @brief Read current value of the AIPS_PACRP_TP0 field. */
#define BR_AIPS_PACRP_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP0))

/*! @brief Format value for bitfield AIPS_PACRP_TP0. */
#define BF_AIPS_PACRP_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_TP0) & BM_AIPS_PACRP_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRP_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRP_WP0    (29U)         /*!< Bit position for AIPS_PACRP_WP0. */
#define BM_AIPS_PACRP_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRP_WP0. */
#define BS_AIPS_PACRP_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRP_WP0. */

/*! @brief Read current value of the AIPS_PACRP_WP0 field. */
#define BR_AIPS_PACRP_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP0))

/*! @brief Format value for bitfield AIPS_PACRP_WP0. */
#define BF_AIPS_PACRP_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_WP0) & BM_AIPS_PACRP_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRP_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRP_SP0    (30U)         /*!< Bit position for AIPS_PACRP_SP0. */
#define BM_AIPS_PACRP_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRP_SP0. */
#define BS_AIPS_PACRP_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRP_SP0. */

/*! @brief Read current value of the AIPS_PACRP_SP0 field. */
#define BR_AIPS_PACRP_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP0))

/*! @brief Format value for bitfield AIPS_PACRP_SP0. */
#define BF_AIPS_PACRP_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRP_SP0) & BM_AIPS_PACRP_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRP_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRP_ADDR(x), BP_AIPS_PACRP_SP0) = (v))
/*@}*/

/*******************************************************************************
 * HW_AIPS_PACRU - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief HW_AIPS_PACRU - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x44000000U
 *
 * PACRU defines the access levels for the two global spaces.
 */
typedef union _hw_aips_pacru
{
    uint32_t U;
    struct _hw_aips_pacru_bitfields
    {
        uint32_t RESERVED0 : 24;       /*!< [23:0]  */
        uint32_t TP1 : 1;              /*!< [24] Trusted Protect */
        uint32_t WP1 : 1;              /*!< [25] Write Protect */
        uint32_t SP1 : 1;              /*!< [26] Supervisor Protect */
        uint32_t RESERVED1 : 1;        /*!< [27]  */
        uint32_t TP0 : 1;              /*!< [28] Trusted Protect */
        uint32_t WP0 : 1;              /*!< [29] Write Protect */
        uint32_t SP0 : 1;              /*!< [30] Supervisor Protect */
        uint32_t RESERVED2 : 1;        /*!< [31]  */
    } B;
} hw_aips_pacru_t;

/*!
 * @name Constants and macros for entire AIPS_PACRU register
 */
/*@{*/
#define HW_AIPS_PACRU_ADDR(x)    ((uint32_t)(x) + 0x80U)

#define HW_AIPS_PACRU(x)         (*(__IO hw_aips_pacru_t *) HW_AIPS_PACRU_ADDR(x))
#define HW_AIPS_PACRU_RD(x)      (HW_AIPS_PACRU(x).U)
#define HW_AIPS_PACRU_WR(x, v)   (HW_AIPS_PACRU(x).U = (v))
#define HW_AIPS_PACRU_SET(x, v)  (HW_AIPS_PACRU_WR(x, HW_AIPS_PACRU_RD(x) |  (v)))
#define HW_AIPS_PACRU_CLR(x, v)  (HW_AIPS_PACRU_WR(x, HW_AIPS_PACRU_RD(x) & ~(v)))
#define HW_AIPS_PACRU_TOG(x, v)  (HW_AIPS_PACRU_WR(x, HW_AIPS_PACRU_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRU bitfields
 */

/*!
 * @name Register AIPS_PACRU, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRU_TP1    (24U)         /*!< Bit position for AIPS_PACRU_TP1. */
#define BM_AIPS_PACRU_TP1    (0x01000000U) /*!< Bit mask for AIPS_PACRU_TP1. */
#define BS_AIPS_PACRU_TP1    (1U)          /*!< Bit field size in bits for AIPS_PACRU_TP1. */

/*! @brief Read current value of the AIPS_PACRU_TP1 field. */
#define BR_AIPS_PACRU_TP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_TP1))

/*! @brief Format value for bitfield AIPS_PACRU_TP1. */
#define BF_AIPS_PACRU_TP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRU_TP1) & BM_AIPS_PACRU_TP1)

/*! @brief Set the TP1 field to a new value. */
#define BW_AIPS_PACRU_TP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_TP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRU, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRU_WP1    (25U)         /*!< Bit position for AIPS_PACRU_WP1. */
#define BM_AIPS_PACRU_WP1    (0x02000000U) /*!< Bit mask for AIPS_PACRU_WP1. */
#define BS_AIPS_PACRU_WP1    (1U)          /*!< Bit field size in bits for AIPS_PACRU_WP1. */

/*! @brief Read current value of the AIPS_PACRU_WP1 field. */
#define BR_AIPS_PACRU_WP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_WP1))

/*! @brief Format value for bitfield AIPS_PACRU_WP1. */
#define BF_AIPS_PACRU_WP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRU_WP1) & BM_AIPS_PACRU_WP1)

/*! @brief Set the WP1 field to a new value. */
#define BW_AIPS_PACRU_WP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_WP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRU, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRU_SP1    (26U)         /*!< Bit position for AIPS_PACRU_SP1. */
#define BM_AIPS_PACRU_SP1    (0x04000000U) /*!< Bit mask for AIPS_PACRU_SP1. */
#define BS_AIPS_PACRU_SP1    (1U)          /*!< Bit field size in bits for AIPS_PACRU_SP1. */

/*! @brief Read current value of the AIPS_PACRU_SP1 field. */
#define BR_AIPS_PACRU_SP1(x) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_SP1))

/*! @brief Format value for bitfield AIPS_PACRU_SP1. */
#define BF_AIPS_PACRU_SP1(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRU_SP1) & BM_AIPS_PACRU_SP1)

/*! @brief Set the SP1 field to a new value. */
#define BW_AIPS_PACRU_SP1(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_SP1) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRU, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0 - Accesses from an untrusted master are allowed.
 * - 1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
#define BP_AIPS_PACRU_TP0    (28U)         /*!< Bit position for AIPS_PACRU_TP0. */
#define BM_AIPS_PACRU_TP0    (0x10000000U) /*!< Bit mask for AIPS_PACRU_TP0. */
#define BS_AIPS_PACRU_TP0    (1U)          /*!< Bit field size in bits for AIPS_PACRU_TP0. */

/*! @brief Read current value of the AIPS_PACRU_TP0 field. */
#define BR_AIPS_PACRU_TP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_TP0))

/*! @brief Format value for bitfield AIPS_PACRU_TP0. */
#define BF_AIPS_PACRU_TP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRU_TP0) & BM_AIPS_PACRU_TP0)

/*! @brief Set the TP0 field to a new value. */
#define BW_AIPS_PACRU_TP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_TP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRU, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0 - This peripheral allows write accesses.
 * - 1 - This peripheral is write protected.
 */
/*@{*/
#define BP_AIPS_PACRU_WP0    (29U)         /*!< Bit position for AIPS_PACRU_WP0. */
#define BM_AIPS_PACRU_WP0    (0x20000000U) /*!< Bit mask for AIPS_PACRU_WP0. */
#define BS_AIPS_PACRU_WP0    (1U)          /*!< Bit field size in bits for AIPS_PACRU_WP0. */

/*! @brief Read current value of the AIPS_PACRU_WP0 field. */
#define BR_AIPS_PACRU_WP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_WP0))

/*! @brief Format value for bitfield AIPS_PACRU_WP0. */
#define BF_AIPS_PACRU_WP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRU_WP0) & BM_AIPS_PACRU_WP0)

/*! @brief Set the WP0 field to a new value. */
#define BW_AIPS_PACRU_WP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_WP0) = (v))
/*@}*/

/*!
 * @name Register AIPS_PACRU, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
#define BP_AIPS_PACRU_SP0    (30U)         /*!< Bit position for AIPS_PACRU_SP0. */
#define BM_AIPS_PACRU_SP0    (0x40000000U) /*!< Bit mask for AIPS_PACRU_SP0. */
#define BS_AIPS_PACRU_SP0    (1U)          /*!< Bit field size in bits for AIPS_PACRU_SP0. */

/*! @brief Read current value of the AIPS_PACRU_SP0 field. */
#define BR_AIPS_PACRU_SP0(x) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_SP0))

/*! @brief Format value for bitfield AIPS_PACRU_SP0. */
#define BF_AIPS_PACRU_SP0(v) ((uint32_t)((uint32_t)(v) << BP_AIPS_PACRU_SP0) & BM_AIPS_PACRU_SP0)

/*! @brief Set the SP0 field to a new value. */
#define BW_AIPS_PACRU_SP0(x, v) (BITBAND_ACCESS32(HW_AIPS_PACRU_ADDR(x), BP_AIPS_PACRU_SP0) = (v))
/*@}*/

/*******************************************************************************
 * hw_aips_t - module struct
 ******************************************************************************/
/*!
 * @brief All AIPS module registers.
 */
#pragma pack(1)
typedef struct _hw_aips
{
    __IO hw_aips_mpra_t MPRA;              /*!< [0x0] Master Privilege Register A */
    uint8_t _reserved0[28];
    __IO hw_aips_pacra_t PACRA;            /*!< [0x20] Peripheral Access Control Register */
    __IO hw_aips_pacrb_t PACRB;            /*!< [0x24] Peripheral Access Control Register */
    __IO hw_aips_pacrc_t PACRC;            /*!< [0x28] Peripheral Access Control Register */
    __IO hw_aips_pacrd_t PACRD;            /*!< [0x2C] Peripheral Access Control Register */
    uint8_t _reserved1[16];
    __IO hw_aips_pacre_t PACRE;            /*!< [0x40] Peripheral Access Control Register */
    __IO hw_aips_pacrf_t PACRF;            /*!< [0x44] Peripheral Access Control Register */
    __IO hw_aips_pacrg_t PACRG;            /*!< [0x48] Peripheral Access Control Register */
    __IO hw_aips_pacrh_t PACRH;            /*!< [0x4C] Peripheral Access Control Register */
    __IO hw_aips_pacri_t PACRI;            /*!< [0x50] Peripheral Access Control Register */
    __IO hw_aips_pacrj_t PACRJ;            /*!< [0x54] Peripheral Access Control Register */
    __IO hw_aips_pacrk_t PACRK;            /*!< [0x58] Peripheral Access Control Register */
    __IO hw_aips_pacrl_t PACRL;            /*!< [0x5C] Peripheral Access Control Register */
    __IO hw_aips_pacrm_t PACRM;            /*!< [0x60] Peripheral Access Control Register */
    __IO hw_aips_pacrn_t PACRN;            /*!< [0x64] Peripheral Access Control Register */
    __IO hw_aips_pacro_t PACRO;            /*!< [0x68] Peripheral Access Control Register */
    __IO hw_aips_pacrp_t PACRP;            /*!< [0x6C] Peripheral Access Control Register */
    uint8_t _reserved2[16];
    __IO hw_aips_pacru_t PACRU;            /*!< [0x80] Peripheral Access Control Register */
} hw_aips_t;
#pragma pack()

/*! @brief Macro to access all AIPS registers. */
/*! @param x AIPS module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_AIPS_REGS(AIPS0_BASE)</code>. */
#define HW_AIPS_REGS(x) (*(hw_aips_t *)(x))

/*
 * MK64F12 AXBS
 *
 * Crossbar switch
 *
 * Registers defined in this header file:
 * - HW_AXBS_PRSn - Priority Registers Slave
 * - HW_AXBS_CRSn - Control Register
 * - HW_AXBS_MGPCR0 - Master General Purpose Control Register
 * - HW_AXBS_MGPCR1 - Master General Purpose Control Register
 * - HW_AXBS_MGPCR2 - Master General Purpose Control Register
 * - HW_AXBS_MGPCR3 - Master General Purpose Control Register
 * - HW_AXBS_MGPCR4 - Master General Purpose Control Register
 * - HW_AXBS_MGPCR5 - Master General Purpose Control Register
 *
 * - hw_axbs_t - Struct containing all module registers.
 */

#define HW_AXBS_INSTANCE_COUNT (1U) /*!< Number of instances of the AXBS module. */
#define HW_AXBS (0U) /*!< Instance number for AXBS. */

/*******************************************************************************
 * HW_AXBS_PRSn - Priority Registers Slave
 ******************************************************************************/

/*!
 * @brief HW_AXBS_PRSn - Priority Registers Slave (RW)
 *
 * Reset value: 0x00543210U
 *
 * The priority registers (PRSn) set the priority of each master port on a per
 * slave port basis and reside in each slave port. The priority register can be
 * accessed only with 32-bit accesses. After the CRSn[RO] bit is set, the PRSn
 * register can only be read; attempts to write to it have no effect on PRSn and
 * result in a bus-error response to the master initiating the write. Two available
 * masters must not be programmed with the same priority level. Attempts to
 * program two or more masters with the same priority level result in a bus-error
 * response and the PRSn is not updated. Valid values for the Mn priority fields
 * depend on which masters are available on the chip. This information can be found in
 * the chip-specific information for the crossbar. If the chip contains less
 * than five masters, values 0 to 3 are valid. Writing other values will result in
 * an error. If the chip contains five or more masters, valid values are 0 to n-1,
 * where n is the number of masters attached to the AXBS module. Other values
 * will result in an error.
 */
typedef union _hw_axbs_prsn
{
    uint32_t U;
    struct _hw_axbs_prsn_bitfields
    {
        uint32_t M0 : 3;               /*!< [2:0] Master 0 Priority. Sets the arbitration
                                        * priority for this port on the associated slave port. */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t M1 : 3;               /*!< [6:4] Master 1 Priority. Sets the arbitration
                                        * priority for this port on the associated slave port. */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t M2 : 3;               /*!< [10:8] Master 2 Priority. Sets the arbitration
                                        * priority for this port on the associated slave port. */
        uint32_t RESERVED2 : 1;        /*!< [11]  */
        uint32_t M3 : 3;               /*!< [14:12] Master 3 Priority. Sets the arbitration
                                        * priority for this port on the associated slave port. */
        uint32_t RESERVED3 : 1;        /*!< [15]  */
        uint32_t M4 : 3;               /*!< [18:16] Master 4 Priority. Sets the arbitration
                                        * priority for this port on the associated slave port. */
        uint32_t RESERVED4 : 1;        /*!< [19]  */
        uint32_t M5 : 3;               /*!< [22:20] Master 5 Priority. Sets the arbitration
                                        * priority for this port on the associated slave port. */
        uint32_t RESERVED5 : 9;        /*!< [31:23]  */
    } B;
} hw_axbs_prsn_t;

/*!
 * @name Constants and macros for entire AXBS_PRSn register
 */
/*@{*/
#define HW_AXBS_PRSn_COUNT (5U)

#define HW_AXBS_PRSn_ADDR(x, n)  ((uint32_t)(x) + 0x0U + (0x100U * (n)))

#define HW_AXBS_PRSn(x, n)       (*(__IO hw_axbs_prsn_t *) HW_AXBS_PRSn_ADDR(x, n))
#define HW_AXBS_PRSn_RD(x, n)    (HW_AXBS_PRSn(x, n).U)
#define HW_AXBS_PRSn_WR(x, n, v) (HW_AXBS_PRSn(x, n).U = (v))
#define HW_AXBS_PRSn_SET(x, n, v) (HW_AXBS_PRSn_WR(x, n, HW_AXBS_PRSn_RD(x, n) |  (v)))
#define HW_AXBS_PRSn_CLR(x, n, v) (HW_AXBS_PRSn_WR(x, n, HW_AXBS_PRSn_RD(x, n) & ~(v)))
#define HW_AXBS_PRSn_TOG(x, n, v) (HW_AXBS_PRSn_WR(x, n, HW_AXBS_PRSn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AXBS_PRSn bitfields
 */

/*!
 * @name Register AXBS_PRSn, field M0[2:0] (RW)
 *
 * Values:
 * - 000 - This master has level 1, or highest, priority when accessing the
 *     slave port.
 * - 001 - This master has level 2 priority when accessing the slave port.
 * - 010 - This master has level 3 priority when accessing the slave port.
 * - 011 - This master has level 4 priority when accessing the slave port.
 * - 100 - This master has level 5 priority when accessing the slave port.
 * - 101 - This master has level 6 priority when accessing the slave port.
 * - 110 - This master has level 7 priority when accessing the slave port.
 * - 111 - This master has level 8, or lowest, priority when accessing the slave
 *     port.
 */
/*@{*/
#define BP_AXBS_PRSn_M0      (0U)          /*!< Bit position for AXBS_PRSn_M0. */
#define BM_AXBS_PRSn_M0      (0x00000007U) /*!< Bit mask for AXBS_PRSn_M0. */
#define BS_AXBS_PRSn_M0      (3U)          /*!< Bit field size in bits for AXBS_PRSn_M0. */

/*! @brief Read current value of the AXBS_PRSn_M0 field. */
#define BR_AXBS_PRSn_M0(x, n) (HW_AXBS_PRSn(x, n).B.M0)

/*! @brief Format value for bitfield AXBS_PRSn_M0. */
#define BF_AXBS_PRSn_M0(v)   ((uint32_t)((uint32_t)(v) << BP_AXBS_PRSn_M0) & BM_AXBS_PRSn_M0)

/*! @brief Set the M0 field to a new value. */
#define BW_AXBS_PRSn_M0(x, n, v) (HW_AXBS_PRSn_WR(x, n, (HW_AXBS_PRSn_RD(x, n) & ~BM_AXBS_PRSn_M0) | BF_AXBS_PRSn_M0(v)))
/*@}*/

/*!
 * @name Register AXBS_PRSn, field M1[6:4] (RW)
 *
 * Values:
 * - 000 - This master has level 1, or highest, priority when accessing the
 *     slave port.
 * - 001 - This master has level 2 priority when accessing the slave port.
 * - 010 - This master has level 3 priority when accessing the slave port.
 * - 011 - This master has level 4 priority when accessing the slave port.
 * - 100 - This master has level 5 priority when accessing the slave port.
 * - 101 - This master has level 6 priority when accessing the slave port.
 * - 110 - This master has level 7 priority when accessing the slave port.
 * - 111 - This master has level 8, or lowest, priority when accessing the slave
 *     port.
 */
/*@{*/
#define BP_AXBS_PRSn_M1      (4U)          /*!< Bit position for AXBS_PRSn_M1. */
#define BM_AXBS_PRSn_M1      (0x00000070U) /*!< Bit mask for AXBS_PRSn_M1. */
#define BS_AXBS_PRSn_M1      (3U)          /*!< Bit field size in bits for AXBS_PRSn_M1. */

/*! @brief Read current value of the AXBS_PRSn_M1 field. */
#define BR_AXBS_PRSn_M1(x, n) (HW_AXBS_PRSn(x, n).B.M1)

/*! @brief Format value for bitfield AXBS_PRSn_M1. */
#define BF_AXBS_PRSn_M1(v)   ((uint32_t)((uint32_t)(v) << BP_AXBS_PRSn_M1) & BM_AXBS_PRSn_M1)

/*! @brief Set the M1 field to a new value. */
#define BW_AXBS_PRSn_M1(x, n, v) (HW_AXBS_PRSn_WR(x, n, (HW_AXBS_PRSn_RD(x, n) & ~BM_AXBS_PRSn_M1) | BF_AXBS_PRSn_M1(v)))
/*@}*/

/*!
 * @name Register AXBS_PRSn, field M2[10:8] (RW)
 *
 * Values:
 * - 000 - This master has level 1, or highest, priority when accessing the
 *     slave port.
 * - 001 - This master has level 2 priority when accessing the slave port.
 * - 010 - This master has level 3 priority when accessing the slave port.
 * - 011 - This master has level 4 priority when accessing the slave port.
 * - 100 - This master has level 5 priority when accessing the slave port.
 * - 101 - This master has level 6 priority when accessing the slave port.
 * - 110 - This master has level 7 priority when accessing the slave port.
 * - 111 - This master has level 8, or lowest, priority when accessing the slave
 *     port.
 */
/*@{*/
#define BP_AXBS_PRSn_M2      (8U)          /*!< Bit position for AXBS_PRSn_M2. */
#define BM_AXBS_PRSn_M2      (0x00000700U) /*!< Bit mask for AXBS_PRSn_M2. */
#define BS_AXBS_PRSn_M2      (3U)          /*!< Bit field size in bits for AXBS_PRSn_M2. */

/*! @brief Read current value of the AXBS_PRSn_M2 field. */
#define BR_AXBS_PRSn_M2(x, n) (HW_AXBS_PRSn(x, n).B.M2)

/*! @brief Format value for bitfield AXBS_PRSn_M2. */
#define BF_AXBS_PRSn_M2(v)   ((uint32_t)((uint32_t)(v) << BP_AXBS_PRSn_M2) & BM_AXBS_PRSn_M2)

/*! @brief Set the M2 field to a new value. */
#define BW_AXBS_PRSn_M2(x, n, v) (HW_AXBS_PRSn_WR(x, n, (HW_AXBS_PRSn_RD(x, n) & ~BM_AXBS_PRSn_M2) | BF_AXBS_PRSn_M2(v)))
/*@}*/

/*!
 * @name Register AXBS_PRSn, field M3[14:12] (RW)
 *
 * Values:
 * - 000 - This master has level 1, or highest, priority when accessing the
 *     slave port.
 * - 001 - This master has level 2 priority when accessing the slave port.
 * - 010 - This master has level 3 priority when accessing the slave port.
 * - 011 - This master has level 4 priority when accessing the slave port.
 * - 100 - This master has level 5 priority when accessing the slave port.
 * - 101 - This master has level 6 priority when accessing the slave port.
 * - 110 - This master has level 7 priority when accessing the slave port.
 * - 111 - This master has level 8, or lowest, priority when accessing the slave
 *     port.
 */
/*@{*/
#define BP_AXBS_PRSn_M3      (12U)         /*!< Bit position for AXBS_PRSn_M3. */
#define BM_AXBS_PRSn_M3      (0x00007000U) /*!< Bit mask for AXBS_PRSn_M3. */
#define BS_AXBS_PRSn_M3      (3U)          /*!< Bit field size in bits for AXBS_PRSn_M3. */

/*! @brief Read current value of the AXBS_PRSn_M3 field. */
#define BR_AXBS_PRSn_M3(x, n) (HW_AXBS_PRSn(x, n).B.M3)

/*! @brief Format value for bitfield AXBS_PRSn_M3. */
#define BF_AXBS_PRSn_M3(v)   ((uint32_t)((uint32_t)(v) << BP_AXBS_PRSn_M3) & BM_AXBS_PRSn_M3)

/*! @brief Set the M3 field to a new value. */
#define BW_AXBS_PRSn_M3(x, n, v) (HW_AXBS_PRSn_WR(x, n, (HW_AXBS_PRSn_RD(x, n) & ~BM_AXBS_PRSn_M3) | BF_AXBS_PRSn_M3(v)))
/*@}*/

/*!
 * @name Register AXBS_PRSn, field M4[18:16] (RW)
 *
 * Values:
 * - 000 - This master has level 1, or highest, priority when accessing the
 *     slave port.
 * - 001 - This master has level 2 priority when accessing the slave port.
 * - 010 - This master has level 3 priority when accessing the slave port.
 * - 011 - This master has level 4 priority when accessing the slave port.
 * - 100 - This master has level 5 priority when accessing the slave port.
 * - 101 - This master has level 6 priority when accessing the slave port.
 * - 110 - This master has level 7 priority when accessing the slave port.
 * - 111 - This master has level 8, or lowest, priority when accessing the slave
 *     port.
 */
/*@{*/
#define BP_AXBS_PRSn_M4      (16U)         /*!< Bit position for AXBS_PRSn_M4. */
#define BM_AXBS_PRSn_M4      (0x00070000U) /*!< Bit mask for AXBS_PRSn_M4. */
#define BS_AXBS_PRSn_M4      (3U)          /*!< Bit field size in bits for AXBS_PRSn_M4. */

/*! @brief Read current value of the AXBS_PRSn_M4 field. */
#define BR_AXBS_PRSn_M4(x, n) (HW_AXBS_PRSn(x, n).B.M4)

/*! @brief Format value for bitfield AXBS_PRSn_M4. */
#define BF_AXBS_PRSn_M4(v)   ((uint32_t)((uint32_t)(v) << BP_AXBS_PRSn_M4) & BM_AXBS_PRSn_M4)

/*! @brief Set the M4 field to a new value. */
#define BW_AXBS_PRSn_M4(x, n, v) (HW_AXBS_PRSn_WR(x, n, (HW_AXBS_PRSn_RD(x, n) & ~BM_AXBS_PRSn_M4) | BF_AXBS_PRSn_M4(v)))
/*@}*/

/*!
 * @name Register AXBS_PRSn, field M5[22:20] (RW)
 *
 * Values:
 * - 000 - This master has level 1, or highest, priority when accessing the
 *     slave port.
 * - 001 - This master has level 2 priority when accessing the slave port.
 * - 010 - This master has level 3 priority when accessing the slave port.
 * - 011 - This master has level 4 priority when accessing the slave port.
 * - 100 - This master has level 5 priority when accessing the slave port.
 * - 101 - This master has level 6 priority when accessing the slave port.
 * - 110 - This master has level 7 priority when accessing the slave port.
 * - 111 - This master has level 8, or lowest, priority when accessing the slave
 *     port.
 */
/*@{*/
#define BP_AXBS_PRSn_M5      (20U)         /*!< Bit position for AXBS_PRSn_M5. */
#define BM_AXBS_PRSn_M5      (0x00700000U) /*!< Bit mask for AXBS_PRSn_M5. */
#define BS_AXBS_PRSn_M5      (3U)          /*!< Bit field size in bits for AXBS_PRSn_M5. */

/*! @brief Read current value of the AXBS_PRSn_M5 field. */
#define BR_AXBS_PRSn_M5(x, n) (HW_AXBS_PRSn(x, n).B.M5)

/*! @brief Format value for bitfield AXBS_PRSn_M5. */
#define BF_AXBS_PRSn_M5(v)   ((uint32_t)((uint32_t)(v) << BP_AXBS_PRSn_M5) & BM_AXBS_PRSn_M5)

/*! @brief Set the M5 field to a new value. */
#define BW_AXBS_PRSn_M5(x, n, v) (HW_AXBS_PRSn_WR(x, n, (HW_AXBS_PRSn_RD(x, n) & ~BM_AXBS_PRSn_M5) | BF_AXBS_PRSn_M5(v)))
/*@}*/
/*******************************************************************************
 * HW_AXBS_CRSn - Control Register
 ******************************************************************************/

/*!
 * @brief HW_AXBS_CRSn - Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers control several features of each slave port and must be
 * accessed using 32-bit accesses. After CRSn[RO] is set, the PRSn can only be read;
 * attempts to write to it have no effect and result in an error response.
 */
typedef union _hw_axbs_crsn
{
    uint32_t U;
    struct _hw_axbs_crsn_bitfields
    {
        uint32_t PARK : 3;             /*!< [2:0] Park */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t PCTL : 2;             /*!< [5:4] Parking Control */
        uint32_t RESERVED1 : 2;        /*!< [7:6]  */
        uint32_t ARB : 2;              /*!< [9:8] Arbitration Mode */
        uint32_t RESERVED2 : 20;       /*!< [29:10]  */
        uint32_t HLP : 1;              /*!< [30] Halt Low Priority */
        uint32_t RO : 1;               /*!< [31] Read Only */
    } B;
} hw_axbs_crsn_t;

/*!
 * @name Constants and macros for entire AXBS_CRSn register
 */
/*@{*/
#define HW_AXBS_CRSn_COUNT (5U)

#define HW_AXBS_CRSn_ADDR(x, n)  ((uint32_t)(x) + 0x10U + (0x100U * (n)))

#define HW_AXBS_CRSn(x, n)       (*(__IO hw_axbs_crsn_t *) HW_AXBS_CRSn_ADDR(x, n))
#define HW_AXBS_CRSn_RD(x, n)    (HW_AXBS_CRSn(x, n).U)
#define HW_AXBS_CRSn_WR(x, n, v) (HW_AXBS_CRSn(x, n).U = (v))
#define HW_AXBS_CRSn_SET(x, n, v) (HW_AXBS_CRSn_WR(x, n, HW_AXBS_CRSn_RD(x, n) |  (v)))
#define HW_AXBS_CRSn_CLR(x, n, v) (HW_AXBS_CRSn_WR(x, n, HW_AXBS_CRSn_RD(x, n) & ~(v)))
#define HW_AXBS_CRSn_TOG(x, n, v) (HW_AXBS_CRSn_WR(x, n, HW_AXBS_CRSn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AXBS_CRSn bitfields
 */

/*!
 * @name Register AXBS_CRSn, field PARK[2:0] (RW)
 *
 * Determines which master port the current slave port parks on when no masters
 * are actively making requests and the PCTL bits are cleared. Select only master
 * ports that are present on the chip. Otherwise, undefined behavior might occur.
 *
 * Values:
 * - 000 - Park on master port M0
 * - 001 - Park on master port M1
 * - 010 - Park on master port M2
 * - 011 - Park on master port M3
 * - 100 - Park on master port M4
 * - 101 - Park on master port M5
 * - 110 - Park on master port M6
 * - 111 - Park on master port M7
 */
/*@{*/
#define BP_AXBS_CRSn_PARK    (0U)          /*!< Bit position for AXBS_CRSn_PARK. */
#define BM_AXBS_CRSn_PARK    (0x00000007U) /*!< Bit mask for AXBS_CRSn_PARK. */
#define BS_AXBS_CRSn_PARK    (3U)          /*!< Bit field size in bits for AXBS_CRSn_PARK. */

/*! @brief Read current value of the AXBS_CRSn_PARK field. */
#define BR_AXBS_CRSn_PARK(x, n) (HW_AXBS_CRSn(x, n).B.PARK)

/*! @brief Format value for bitfield AXBS_CRSn_PARK. */
#define BF_AXBS_CRSn_PARK(v) ((uint32_t)((uint32_t)(v) << BP_AXBS_CRSn_PARK) & BM_AXBS_CRSn_PARK)

/*! @brief Set the PARK field to a new value. */
#define BW_AXBS_CRSn_PARK(x, n, v) (HW_AXBS_CRSn_WR(x, n, (HW_AXBS_CRSn_RD(x, n) & ~BM_AXBS_CRSn_PARK) | BF_AXBS_CRSn_PARK(v)))
/*@}*/

/*!
 * @name Register AXBS_CRSn, field PCTL[5:4] (RW)
 *
 * Determines the slave port's parking control. The low-power park feature
 * results in an overall power savings if the slave port is not saturated. However,
 * this forces an extra latency clock when any master tries to access the slave
 * port while not in use because it is not parked on any master.
 *
 * Values:
 * - 00 - When no master makes a request, the arbiter parks the slave port on
 *     the master port defined by the PARK field
 * - 01 - When no master makes a request, the arbiter parks the slave port on
 *     the last master to be in control of the slave port
 * - 10 - When no master makes a request, the slave port is not parked on a
 *     master and the arbiter drives all outputs to a constant safe state
 * - 11 - Reserved
 */
/*@{*/
#define BP_AXBS_CRSn_PCTL    (4U)          /*!< Bit position for AXBS_CRSn_PCTL. */
#define BM_AXBS_CRSn_PCTL    (0x00000030U) /*!< Bit mask for AXBS_CRSn_PCTL. */
#define BS_AXBS_CRSn_PCTL    (2U)          /*!< Bit field size in bits for AXBS_CRSn_PCTL. */

/*! @brief Read current value of the AXBS_CRSn_PCTL field. */
#define BR_AXBS_CRSn_PCTL(x, n) (HW_AXBS_CRSn(x, n).B.PCTL)

/*! @brief Format value for bitfield AXBS_CRSn_PCTL. */
#define BF_AXBS_CRSn_PCTL(v) ((uint32_t)((uint32_t)(v) << BP_AXBS_CRSn_PCTL) & BM_AXBS_CRSn_PCTL)

/*! @brief Set the PCTL field to a new value. */
#define BW_AXBS_CRSn_PCTL(x, n, v) (HW_AXBS_CRSn_WR(x, n, (HW_AXBS_CRSn_RD(x, n) & ~BM_AXBS_CRSn_PCTL) | BF_AXBS_CRSn_PCTL(v)))
/*@}*/

/*!
 * @name Register AXBS_CRSn, field ARB[9:8] (RW)
 *
 * Selects the arbitration policy for the slave port.
 *
 * Values:
 * - 00 - Fixed priority
 * - 01 - Round-robin, or rotating, priority
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
#define BP_AXBS_CRSn_ARB     (8U)          /*!< Bit position for AXBS_CRSn_ARB. */
#define BM_AXBS_CRSn_ARB     (0x00000300U) /*!< Bit mask for AXBS_CRSn_ARB. */
#define BS_AXBS_CRSn_ARB     (2U)          /*!< Bit field size in bits for AXBS_CRSn_ARB. */

/*! @brief Read current value of the AXBS_CRSn_ARB field. */
#define BR_AXBS_CRSn_ARB(x, n) (HW_AXBS_CRSn(x, n).B.ARB)

/*! @brief Format value for bitfield AXBS_CRSn_ARB. */
#define BF_AXBS_CRSn_ARB(v)  ((uint32_t)((uint32_t)(v) << BP_AXBS_CRSn_ARB) & BM_AXBS_CRSn_ARB)

/*! @brief Set the ARB field to a new value. */
#define BW_AXBS_CRSn_ARB(x, n, v) (HW_AXBS_CRSn_WR(x, n, (HW_AXBS_CRSn_RD(x, n) & ~BM_AXBS_CRSn_ARB) | BF_AXBS_CRSn_ARB(v)))
/*@}*/

/*!
 * @name Register AXBS_CRSn, field HLP[30] (RW)
 *
 * Sets the initial arbitration priority for low power mode requests . Setting
 * this bit will not affect the request for low power mode from attaining highest
 * priority once it has control of the slave ports.
 *
 * Values:
 * - 0 - The low power mode request has the highest priority for arbitration on
 *     this slave port
 * - 1 - The low power mode request has the lowest initial priority for
 *     arbitration on this slave port
 */
/*@{*/
#define BP_AXBS_CRSn_HLP     (30U)         /*!< Bit position for AXBS_CRSn_HLP. */
#define BM_AXBS_CRSn_HLP     (0x40000000U) /*!< Bit mask for AXBS_CRSn_HLP. */
#define BS_AXBS_CRSn_HLP     (1U)          /*!< Bit field size in bits for AXBS_CRSn_HLP. */

/*! @brief Read current value of the AXBS_CRSn_HLP field. */
#define BR_AXBS_CRSn_HLP(x, n) (BITBAND_ACCESS32(HW_AXBS_CRSn_ADDR(x, n), BP_AXBS_CRSn_HLP))

/*! @brief Format value for bitfield AXBS_CRSn_HLP. */
#define BF_AXBS_CRSn_HLP(v)  ((uint32_t)((uint32_t)(v) << BP_AXBS_CRSn_HLP) & BM_AXBS_CRSn_HLP)

/*! @brief Set the HLP field to a new value. */
#define BW_AXBS_CRSn_HLP(x, n, v) (BITBAND_ACCESS32(HW_AXBS_CRSn_ADDR(x, n), BP_AXBS_CRSn_HLP) = (v))
/*@}*/

/*!
 * @name Register AXBS_CRSn, field RO[31] (RW)
 *
 * Forces the slave port's CSRn and PRSn registers to be read-only. After set,
 * only a hardware reset clears it.
 *
 * Values:
 * - 0 - The slave port's registers are writeable
 * - 1 - The slave port's registers are read-only and cannot be written.
 *     Attempted writes have no effect on the registers and result in a bus error
 *     response.
 */
/*@{*/
#define BP_AXBS_CRSn_RO      (31U)         /*!< Bit position for AXBS_CRSn_RO. */
#define BM_AXBS_CRSn_RO      (0x80000000U) /*!< Bit mask for AXBS_CRSn_RO. */
#define BS_AXBS_CRSn_RO      (1U)          /*!< Bit field size in bits for AXBS_CRSn_RO. */

/*! @brief Read current value of the AXBS_CRSn_RO field. */
#define BR_AXBS_CRSn_RO(x, n) (BITBAND_ACCESS32(HW_AXBS_CRSn_ADDR(x, n), BP_AXBS_CRSn_RO))

/*! @brief Format value for bitfield AXBS_CRSn_RO. */
#define BF_AXBS_CRSn_RO(v)   ((uint32_t)((uint32_t)(v) << BP_AXBS_CRSn_RO) & BM_AXBS_CRSn_RO)

/*! @brief Set the RO field to a new value. */
#define BW_AXBS_CRSn_RO(x, n, v) (BITBAND_ACCESS32(HW_AXBS_CRSn_ADDR(x, n), BP_AXBS_CRSn_RO) = (v))
/*@}*/

/*******************************************************************************
 * HW_AXBS_MGPCR0 - Master General Purpose Control Register
 ******************************************************************************/

/*!
 * @brief HW_AXBS_MGPCR0 - Master General Purpose Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MGPCR controls only whether the master's undefined length burst accesses
 * are allowed to complete uninterrupted or whether they can be broken by
 * requests from higher priority masters. The MGPCR can be accessed only in Supervisor
 * mode with 32-bit accesses.
 */
typedef union _hw_axbs_mgpcr0
{
    uint32_t U;
    struct _hw_axbs_mgpcr0_bitfields
    {
        uint32_t AULB : 3;             /*!< [2:0] Arbitrates On Undefined Length Bursts */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_axbs_mgpcr0_t;

/*!
 * @name Constants and macros for entire AXBS_MGPCR0 register
 */
/*@{*/
#define HW_AXBS_MGPCR0_ADDR(x)   ((uint32_t)(x) + 0x800U)

#define HW_AXBS_MGPCR0(x)        (*(__IO hw_axbs_mgpcr0_t *) HW_AXBS_MGPCR0_ADDR(x))
#define HW_AXBS_MGPCR0_RD(x)     (HW_AXBS_MGPCR0(x).U)
#define HW_AXBS_MGPCR0_WR(x, v)  (HW_AXBS_MGPCR0(x).U = (v))
#define HW_AXBS_MGPCR0_SET(x, v) (HW_AXBS_MGPCR0_WR(x, HW_AXBS_MGPCR0_RD(x) |  (v)))
#define HW_AXBS_MGPCR0_CLR(x, v) (HW_AXBS_MGPCR0_WR(x, HW_AXBS_MGPCR0_RD(x) & ~(v)))
#define HW_AXBS_MGPCR0_TOG(x, v) (HW_AXBS_MGPCR0_WR(x, HW_AXBS_MGPCR0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AXBS_MGPCR0 bitfields
 */

/*!
 * @name Register AXBS_MGPCR0, field AULB[2:0] (RW)
 *
 * Determines whether, and when, the crossbar switch arbitrates away the slave
 * port the master owns when the master is performing undefined length burst
 * accesses.
 *
 * Values:
 * - 000 - No arbitration is allowed during an undefined length burst
 * - 001 - Arbitration is allowed at any time during an undefined length burst
 * - 010 - Arbitration is allowed after four beats of an undefined length burst
 * - 011 - Arbitration is allowed after eight beats of an undefined length burst
 * - 100 - Arbitration is allowed after 16 beats of an undefined length burst
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
#define BP_AXBS_MGPCR0_AULB  (0U)          /*!< Bit position for AXBS_MGPCR0_AULB. */
#define BM_AXBS_MGPCR0_AULB  (0x00000007U) /*!< Bit mask for AXBS_MGPCR0_AULB. */
#define BS_AXBS_MGPCR0_AULB  (3U)          /*!< Bit field size in bits for AXBS_MGPCR0_AULB. */

/*! @brief Read current value of the AXBS_MGPCR0_AULB field. */
#define BR_AXBS_MGPCR0_AULB(x) (HW_AXBS_MGPCR0(x).B.AULB)

/*! @brief Format value for bitfield AXBS_MGPCR0_AULB. */
#define BF_AXBS_MGPCR0_AULB(v) ((uint32_t)((uint32_t)(v) << BP_AXBS_MGPCR0_AULB) & BM_AXBS_MGPCR0_AULB)

/*! @brief Set the AULB field to a new value. */
#define BW_AXBS_MGPCR0_AULB(x, v) (HW_AXBS_MGPCR0_WR(x, (HW_AXBS_MGPCR0_RD(x) & ~BM_AXBS_MGPCR0_AULB) | BF_AXBS_MGPCR0_AULB(v)))
/*@}*/

/*******************************************************************************
 * HW_AXBS_MGPCR1 - Master General Purpose Control Register
 ******************************************************************************/

/*!
 * @brief HW_AXBS_MGPCR1 - Master General Purpose Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MGPCR controls only whether the master's undefined length burst accesses
 * are allowed to complete uninterrupted or whether they can be broken by
 * requests from higher priority masters. The MGPCR can be accessed only in Supervisor
 * mode with 32-bit accesses.
 */
typedef union _hw_axbs_mgpcr1
{
    uint32_t U;
    struct _hw_axbs_mgpcr1_bitfields
    {
        uint32_t AULB : 3;             /*!< [2:0] Arbitrates On Undefined Length Bursts */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_axbs_mgpcr1_t;

/*!
 * @name Constants and macros for entire AXBS_MGPCR1 register
 */
/*@{*/
#define HW_AXBS_MGPCR1_ADDR(x)   ((uint32_t)(x) + 0x900U)

#define HW_AXBS_MGPCR1(x)        (*(__IO hw_axbs_mgpcr1_t *) HW_AXBS_MGPCR1_ADDR(x))
#define HW_AXBS_MGPCR1_RD(x)     (HW_AXBS_MGPCR1(x).U)
#define HW_AXBS_MGPCR1_WR(x, v)  (HW_AXBS_MGPCR1(x).U = (v))
#define HW_AXBS_MGPCR1_SET(x, v) (HW_AXBS_MGPCR1_WR(x, HW_AXBS_MGPCR1_RD(x) |  (v)))
#define HW_AXBS_MGPCR1_CLR(x, v) (HW_AXBS_MGPCR1_WR(x, HW_AXBS_MGPCR1_RD(x) & ~(v)))
#define HW_AXBS_MGPCR1_TOG(x, v) (HW_AXBS_MGPCR1_WR(x, HW_AXBS_MGPCR1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AXBS_MGPCR1 bitfields
 */

/*!
 * @name Register AXBS_MGPCR1, field AULB[2:0] (RW)
 *
 * Determines whether, and when, the crossbar switch arbitrates away the slave
 * port the master owns when the master is performing undefined length burst
 * accesses.
 *
 * Values:
 * - 000 - No arbitration is allowed during an undefined length burst
 * - 001 - Arbitration is allowed at any time during an undefined length burst
 * - 010 - Arbitration is allowed after four beats of an undefined length burst
 * - 011 - Arbitration is allowed after eight beats of an undefined length burst
 * - 100 - Arbitration is allowed after 16 beats of an undefined length burst
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
#define BP_AXBS_MGPCR1_AULB  (0U)          /*!< Bit position for AXBS_MGPCR1_AULB. */
#define BM_AXBS_MGPCR1_AULB  (0x00000007U) /*!< Bit mask for AXBS_MGPCR1_AULB. */
#define BS_AXBS_MGPCR1_AULB  (3U)          /*!< Bit field size in bits for AXBS_MGPCR1_AULB. */

/*! @brief Read current value of the AXBS_MGPCR1_AULB field. */
#define BR_AXBS_MGPCR1_AULB(x) (HW_AXBS_MGPCR1(x).B.AULB)

/*! @brief Format value for bitfield AXBS_MGPCR1_AULB. */
#define BF_AXBS_MGPCR1_AULB(v) ((uint32_t)((uint32_t)(v) << BP_AXBS_MGPCR1_AULB) & BM_AXBS_MGPCR1_AULB)

/*! @brief Set the AULB field to a new value. */
#define BW_AXBS_MGPCR1_AULB(x, v) (HW_AXBS_MGPCR1_WR(x, (HW_AXBS_MGPCR1_RD(x) & ~BM_AXBS_MGPCR1_AULB) | BF_AXBS_MGPCR1_AULB(v)))
/*@}*/

/*******************************************************************************
 * HW_AXBS_MGPCR2 - Master General Purpose Control Register
 ******************************************************************************/

/*!
 * @brief HW_AXBS_MGPCR2 - Master General Purpose Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MGPCR controls only whether the master's undefined length burst accesses
 * are allowed to complete uninterrupted or whether they can be broken by
 * requests from higher priority masters. The MGPCR can be accessed only in Supervisor
 * mode with 32-bit accesses.
 */
typedef union _hw_axbs_mgpcr2
{
    uint32_t U;
    struct _hw_axbs_mgpcr2_bitfields
    {
        uint32_t AULB : 3;             /*!< [2:0] Arbitrates On Undefined Length Bursts */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_axbs_mgpcr2_t;

/*!
 * @name Constants and macros for entire AXBS_MGPCR2 register
 */
/*@{*/
#define HW_AXBS_MGPCR2_ADDR(x)   ((uint32_t)(x) + 0xA00U)

#define HW_AXBS_MGPCR2(x)        (*(__IO hw_axbs_mgpcr2_t *) HW_AXBS_MGPCR2_ADDR(x))
#define HW_AXBS_MGPCR2_RD(x)     (HW_AXBS_MGPCR2(x).U)
#define HW_AXBS_MGPCR2_WR(x, v)  (HW_AXBS_MGPCR2(x).U = (v))
#define HW_AXBS_MGPCR2_SET(x, v) (HW_AXBS_MGPCR2_WR(x, HW_AXBS_MGPCR2_RD(x) |  (v)))
#define HW_AXBS_MGPCR2_CLR(x, v) (HW_AXBS_MGPCR2_WR(x, HW_AXBS_MGPCR2_RD(x) & ~(v)))
#define HW_AXBS_MGPCR2_TOG(x, v) (HW_AXBS_MGPCR2_WR(x, HW_AXBS_MGPCR2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AXBS_MGPCR2 bitfields
 */

/*!
 * @name Register AXBS_MGPCR2, field AULB[2:0] (RW)
 *
 * Determines whether, and when, the crossbar switch arbitrates away the slave
 * port the master owns when the master is performing undefined length burst
 * accesses.
 *
 * Values:
 * - 000 - No arbitration is allowed during an undefined length burst
 * - 001 - Arbitration is allowed at any time during an undefined length burst
 * - 010 - Arbitration is allowed after four beats of an undefined length burst
 * - 011 - Arbitration is allowed after eight beats of an undefined length burst
 * - 100 - Arbitration is allowed after 16 beats of an undefined length burst
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
#define BP_AXBS_MGPCR2_AULB  (0U)          /*!< Bit position for AXBS_MGPCR2_AULB. */
#define BM_AXBS_MGPCR2_AULB  (0x00000007U) /*!< Bit mask for AXBS_MGPCR2_AULB. */
#define BS_AXBS_MGPCR2_AULB  (3U)          /*!< Bit field size in bits for AXBS_MGPCR2_AULB. */

/*! @brief Read current value of the AXBS_MGPCR2_AULB field. */
#define BR_AXBS_MGPCR2_AULB(x) (HW_AXBS_MGPCR2(x).B.AULB)

/*! @brief Format value for bitfield AXBS_MGPCR2_AULB. */
#define BF_AXBS_MGPCR2_AULB(v) ((uint32_t)((uint32_t)(v) << BP_AXBS_MGPCR2_AULB) & BM_AXBS_MGPCR2_AULB)

/*! @brief Set the AULB field to a new value. */
#define BW_AXBS_MGPCR2_AULB(x, v) (HW_AXBS_MGPCR2_WR(x, (HW_AXBS_MGPCR2_RD(x) & ~BM_AXBS_MGPCR2_AULB) | BF_AXBS_MGPCR2_AULB(v)))
/*@}*/

/*******************************************************************************
 * HW_AXBS_MGPCR3 - Master General Purpose Control Register
 ******************************************************************************/

/*!
 * @brief HW_AXBS_MGPCR3 - Master General Purpose Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MGPCR controls only whether the master's undefined length burst accesses
 * are allowed to complete uninterrupted or whether they can be broken by
 * requests from higher priority masters. The MGPCR can be accessed only in Supervisor
 * mode with 32-bit accesses.
 */
typedef union _hw_axbs_mgpcr3
{
    uint32_t U;
    struct _hw_axbs_mgpcr3_bitfields
    {
        uint32_t AULB : 3;             /*!< [2:0] Arbitrates On Undefined Length Bursts */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_axbs_mgpcr3_t;

/*!
 * @name Constants and macros for entire AXBS_MGPCR3 register
 */
/*@{*/
#define HW_AXBS_MGPCR3_ADDR(x)   ((uint32_t)(x) + 0xB00U)

#define HW_AXBS_MGPCR3(x)        (*(__IO hw_axbs_mgpcr3_t *) HW_AXBS_MGPCR3_ADDR(x))
#define HW_AXBS_MGPCR3_RD(x)     (HW_AXBS_MGPCR3(x).U)
#define HW_AXBS_MGPCR3_WR(x, v)  (HW_AXBS_MGPCR3(x).U = (v))
#define HW_AXBS_MGPCR3_SET(x, v) (HW_AXBS_MGPCR3_WR(x, HW_AXBS_MGPCR3_RD(x) |  (v)))
#define HW_AXBS_MGPCR3_CLR(x, v) (HW_AXBS_MGPCR3_WR(x, HW_AXBS_MGPCR3_RD(x) & ~(v)))
#define HW_AXBS_MGPCR3_TOG(x, v) (HW_AXBS_MGPCR3_WR(x, HW_AXBS_MGPCR3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AXBS_MGPCR3 bitfields
 */

/*!
 * @name Register AXBS_MGPCR3, field AULB[2:0] (RW)
 *
 * Determines whether, and when, the crossbar switch arbitrates away the slave
 * port the master owns when the master is performing undefined length burst
 * accesses.
 *
 * Values:
 * - 000 - No arbitration is allowed during an undefined length burst
 * - 001 - Arbitration is allowed at any time during an undefined length burst
 * - 010 - Arbitration is allowed after four beats of an undefined length burst
 * - 011 - Arbitration is allowed after eight beats of an undefined length burst
 * - 100 - Arbitration is allowed after 16 beats of an undefined length burst
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
#define BP_AXBS_MGPCR3_AULB  (0U)          /*!< Bit position for AXBS_MGPCR3_AULB. */
#define BM_AXBS_MGPCR3_AULB  (0x00000007U) /*!< Bit mask for AXBS_MGPCR3_AULB. */
#define BS_AXBS_MGPCR3_AULB  (3U)          /*!< Bit field size in bits for AXBS_MGPCR3_AULB. */

/*! @brief Read current value of the AXBS_MGPCR3_AULB field. */
#define BR_AXBS_MGPCR3_AULB(x) (HW_AXBS_MGPCR3(x).B.AULB)

/*! @brief Format value for bitfield AXBS_MGPCR3_AULB. */
#define BF_AXBS_MGPCR3_AULB(v) ((uint32_t)((uint32_t)(v) << BP_AXBS_MGPCR3_AULB) & BM_AXBS_MGPCR3_AULB)

/*! @brief Set the AULB field to a new value. */
#define BW_AXBS_MGPCR3_AULB(x, v) (HW_AXBS_MGPCR3_WR(x, (HW_AXBS_MGPCR3_RD(x) & ~BM_AXBS_MGPCR3_AULB) | BF_AXBS_MGPCR3_AULB(v)))
/*@}*/

/*******************************************************************************
 * HW_AXBS_MGPCR4 - Master General Purpose Control Register
 ******************************************************************************/

/*!
 * @brief HW_AXBS_MGPCR4 - Master General Purpose Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MGPCR controls only whether the master's undefined length burst accesses
 * are allowed to complete uninterrupted or whether they can be broken by
 * requests from higher priority masters. The MGPCR can be accessed only in Supervisor
 * mode with 32-bit accesses.
 */
typedef union _hw_axbs_mgpcr4
{
    uint32_t U;
    struct _hw_axbs_mgpcr4_bitfields
    {
        uint32_t AULB : 3;             /*!< [2:0] Arbitrates On Undefined Length Bursts */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_axbs_mgpcr4_t;

/*!
 * @name Constants and macros for entire AXBS_MGPCR4 register
 */
/*@{*/
#define HW_AXBS_MGPCR4_ADDR(x)   ((uint32_t)(x) + 0xC00U)

#define HW_AXBS_MGPCR4(x)        (*(__IO hw_axbs_mgpcr4_t *) HW_AXBS_MGPCR4_ADDR(x))
#define HW_AXBS_MGPCR4_RD(x)     (HW_AXBS_MGPCR4(x).U)
#define HW_AXBS_MGPCR4_WR(x, v)  (HW_AXBS_MGPCR4(x).U = (v))
#define HW_AXBS_MGPCR4_SET(x, v) (HW_AXBS_MGPCR4_WR(x, HW_AXBS_MGPCR4_RD(x) |  (v)))
#define HW_AXBS_MGPCR4_CLR(x, v) (HW_AXBS_MGPCR4_WR(x, HW_AXBS_MGPCR4_RD(x) & ~(v)))
#define HW_AXBS_MGPCR4_TOG(x, v) (HW_AXBS_MGPCR4_WR(x, HW_AXBS_MGPCR4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AXBS_MGPCR4 bitfields
 */

/*!
 * @name Register AXBS_MGPCR4, field AULB[2:0] (RW)
 *
 * Determines whether, and when, the crossbar switch arbitrates away the slave
 * port the master owns when the master is performing undefined length burst
 * accesses.
 *
 * Values:
 * - 000 - No arbitration is allowed during an undefined length burst
 * - 001 - Arbitration is allowed at any time during an undefined length burst
 * - 010 - Arbitration is allowed after four beats of an undefined length burst
 * - 011 - Arbitration is allowed after eight beats of an undefined length burst
 * - 100 - Arbitration is allowed after 16 beats of an undefined length burst
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
#define BP_AXBS_MGPCR4_AULB  (0U)          /*!< Bit position for AXBS_MGPCR4_AULB. */
#define BM_AXBS_MGPCR4_AULB  (0x00000007U) /*!< Bit mask for AXBS_MGPCR4_AULB. */
#define BS_AXBS_MGPCR4_AULB  (3U)          /*!< Bit field size in bits for AXBS_MGPCR4_AULB. */

/*! @brief Read current value of the AXBS_MGPCR4_AULB field. */
#define BR_AXBS_MGPCR4_AULB(x) (HW_AXBS_MGPCR4(x).B.AULB)

/*! @brief Format value for bitfield AXBS_MGPCR4_AULB. */
#define BF_AXBS_MGPCR4_AULB(v) ((uint32_t)((uint32_t)(v) << BP_AXBS_MGPCR4_AULB) & BM_AXBS_MGPCR4_AULB)

/*! @brief Set the AULB field to a new value. */
#define BW_AXBS_MGPCR4_AULB(x, v) (HW_AXBS_MGPCR4_WR(x, (HW_AXBS_MGPCR4_RD(x) & ~BM_AXBS_MGPCR4_AULB) | BF_AXBS_MGPCR4_AULB(v)))
/*@}*/

/*******************************************************************************
 * HW_AXBS_MGPCR5 - Master General Purpose Control Register
 ******************************************************************************/

/*!
 * @brief HW_AXBS_MGPCR5 - Master General Purpose Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MGPCR controls only whether the master's undefined length burst accesses
 * are allowed to complete uninterrupted or whether they can be broken by
 * requests from higher priority masters. The MGPCR can be accessed only in Supervisor
 * mode with 32-bit accesses.
 */
typedef union _hw_axbs_mgpcr5
{
    uint32_t U;
    struct _hw_axbs_mgpcr5_bitfields
    {
        uint32_t AULB : 3;             /*!< [2:0] Arbitrates On Undefined Length Bursts */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_axbs_mgpcr5_t;

/*!
 * @name Constants and macros for entire AXBS_MGPCR5 register
 */
/*@{*/
#define HW_AXBS_MGPCR5_ADDR(x)   ((uint32_t)(x) + 0xD00U)

#define HW_AXBS_MGPCR5(x)        (*(__IO hw_axbs_mgpcr5_t *) HW_AXBS_MGPCR5_ADDR(x))
#define HW_AXBS_MGPCR5_RD(x)     (HW_AXBS_MGPCR5(x).U)
#define HW_AXBS_MGPCR5_WR(x, v)  (HW_AXBS_MGPCR5(x).U = (v))
#define HW_AXBS_MGPCR5_SET(x, v) (HW_AXBS_MGPCR5_WR(x, HW_AXBS_MGPCR5_RD(x) |  (v)))
#define HW_AXBS_MGPCR5_CLR(x, v) (HW_AXBS_MGPCR5_WR(x, HW_AXBS_MGPCR5_RD(x) & ~(v)))
#define HW_AXBS_MGPCR5_TOG(x, v) (HW_AXBS_MGPCR5_WR(x, HW_AXBS_MGPCR5_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual AXBS_MGPCR5 bitfields
 */

/*!
 * @name Register AXBS_MGPCR5, field AULB[2:0] (RW)
 *
 * Determines whether, and when, the crossbar switch arbitrates away the slave
 * port the master owns when the master is performing undefined length burst
 * accesses.
 *
 * Values:
 * - 000 - No arbitration is allowed during an undefined length burst
 * - 001 - Arbitration is allowed at any time during an undefined length burst
 * - 010 - Arbitration is allowed after four beats of an undefined length burst
 * - 011 - Arbitration is allowed after eight beats of an undefined length burst
 * - 100 - Arbitration is allowed after 16 beats of an undefined length burst
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
#define BP_AXBS_MGPCR5_AULB  (0U)          /*!< Bit position for AXBS_MGPCR5_AULB. */
#define BM_AXBS_MGPCR5_AULB  (0x00000007U) /*!< Bit mask for AXBS_MGPCR5_AULB. */
#define BS_AXBS_MGPCR5_AULB  (3U)          /*!< Bit field size in bits for AXBS_MGPCR5_AULB. */

/*! @brief Read current value of the AXBS_MGPCR5_AULB field. */
#define BR_AXBS_MGPCR5_AULB(x) (HW_AXBS_MGPCR5(x).B.AULB)

/*! @brief Format value for bitfield AXBS_MGPCR5_AULB. */
#define BF_AXBS_MGPCR5_AULB(v) ((uint32_t)((uint32_t)(v) << BP_AXBS_MGPCR5_AULB) & BM_AXBS_MGPCR5_AULB)

/*! @brief Set the AULB field to a new value. */
#define BW_AXBS_MGPCR5_AULB(x, v) (HW_AXBS_MGPCR5_WR(x, (HW_AXBS_MGPCR5_RD(x) & ~BM_AXBS_MGPCR5_AULB) | BF_AXBS_MGPCR5_AULB(v)))
/*@}*/

/*******************************************************************************
 * hw_axbs_t - module struct
 ******************************************************************************/
/*!
 * @brief All AXBS module registers.
 */
#pragma pack(1)
typedef struct _hw_axbs
{
    struct {
        __IO hw_axbs_prsn_t PRSn;          /*!< [0x0] Priority Registers Slave */
        uint8_t _reserved0[12];
        __IO hw_axbs_crsn_t CRSn;          /*!< [0x10] Control Register */
        uint8_t _reserved1[236];
    } SLAVE[5];
    uint8_t _reserved0[768];
    __IO hw_axbs_mgpcr0_t MGPCR0;          /*!< [0x800] Master General Purpose Control Register */
    uint8_t _reserved1[252];
    __IO hw_axbs_mgpcr1_t MGPCR1;          /*!< [0x900] Master General Purpose Control Register */
    uint8_t _reserved2[252];
    __IO hw_axbs_mgpcr2_t MGPCR2;          /*!< [0xA00] Master General Purpose Control Register */
    uint8_t _reserved3[252];
    __IO hw_axbs_mgpcr3_t MGPCR3;          /*!< [0xB00] Master General Purpose Control Register */
    uint8_t _reserved4[252];
    __IO hw_axbs_mgpcr4_t MGPCR4;          /*!< [0xC00] Master General Purpose Control Register */
    uint8_t _reserved5[252];
    __IO hw_axbs_mgpcr5_t MGPCR5;          /*!< [0xD00] Master General Purpose Control Register */
} hw_axbs_t;
#pragma pack()

/*! @brief Macro to access all AXBS registers. */
/*! @param x AXBS module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_AXBS_REGS(AXBS_BASE)</code>. */
#define HW_AXBS_REGS(x) (*(hw_axbs_t *)(x))

/*
 * MK64F12 CAN
 *
 * Flex Controller Area Network module
 *
 * Registers defined in this header file:
 * - HW_CAN_MCR - Module Configuration Register
 * - HW_CAN_CTRL1 - Control 1 register
 * - HW_CAN_TIMER - Free Running Timer
 * - HW_CAN_RXMGMASK - Rx Mailboxes Global Mask Register
 * - HW_CAN_RX14MASK - Rx 14 Mask register
 * - HW_CAN_RX15MASK - Rx 15 Mask register
 * - HW_CAN_ECR - Error Counter
 * - HW_CAN_ESR1 - Error and Status 1 register
 * - HW_CAN_IMASK1 - Interrupt Masks 1 register
 * - HW_CAN_IFLAG1 - Interrupt Flags 1 register
 * - HW_CAN_CTRL2 - Control 2 register
 * - HW_CAN_ESR2 - Error and Status 2 register
 * - HW_CAN_CRCR - CRC Register
 * - HW_CAN_RXFGMASK - Rx FIFO Global Mask register
 * - HW_CAN_RXFIR - Rx FIFO Information Register
 * - HW_CAN_CSn - Message Buffer 0 CS Register
 * - HW_CAN_IDn - Message Buffer 0 ID Register
 * - HW_CAN_WORD0n - Message Buffer 0 WORD0 Register
 * - HW_CAN_WORD1n - Message Buffer 0 WORD1 Register
 * - HW_CAN_RXIMRn - Rx Individual Mask Registers
 *
 * - hw_can_t - Struct containing all module registers.
 */

#define HW_CAN_INSTANCE_COUNT (1U) /*!< Number of instances of the CAN module. */
#define HW_CAN0 (0U) /*!< Instance number for CAN0. */

/*******************************************************************************
 * HW_CAN_MCR - Module Configuration Register
 ******************************************************************************/

/*!
 * @brief HW_CAN_MCR - Module Configuration Register (RW)
 *
 * Reset value: 0xD890000FU
 *
 * This register defines global system configurations, such as the module
 * operation modes and the maximum message buffer configuration.
 */
typedef union _hw_can_mcr
{
    uint32_t U;
    struct _hw_can_mcr_bitfields
    {
        uint32_t MAXMB : 7;            /*!< [6:0] Number Of The Last Message Buffer */
        uint32_t RESERVED0 : 1;        /*!< [7]  */
        uint32_t IDAM : 2;             /*!< [9:8] ID Acceptance Mode */
        uint32_t RESERVED1 : 2;        /*!< [11:10]  */
        uint32_t AEN : 1;              /*!< [12] Abort Enable */
        uint32_t LPRIOEN : 1;          /*!< [13] Local Priority Enable */
        uint32_t RESERVED2 : 2;        /*!< [15:14]  */
        uint32_t IRMQ : 1;             /*!< [16] Individual Rx Masking And Queue Enable */
        uint32_t SRXDIS : 1;           /*!< [17] Self Reception Disable */
        uint32_t RESERVED3 : 1;        /*!< [18]  */
        uint32_t WAKSRC : 1;           /*!< [19] Wake Up Source */
        uint32_t LPMACK : 1;           /*!< [20] Low-Power Mode Acknowledge */
        uint32_t WRNEN : 1;            /*!< [21] Warning Interrupt Enable */
        uint32_t SLFWAK : 1;           /*!< [22] Self Wake Up */
        uint32_t SUPV : 1;             /*!< [23] Supervisor Mode */
        uint32_t FRZACK : 1;           /*!< [24] Freeze Mode Acknowledge */
        uint32_t SOFTRST : 1;          /*!< [25] Soft Reset */
        uint32_t WAKMSK : 1;           /*!< [26] Wake Up Interrupt Mask */
        uint32_t NOTRDY : 1;           /*!< [27] FlexCAN Not Ready */
        uint32_t HALT : 1;             /*!< [28] Halt FlexCAN */
        uint32_t RFEN : 1;             /*!< [29] Rx FIFO Enable */
        uint32_t FRZ : 1;              /*!< [30] Freeze Enable */
        uint32_t MDIS : 1;             /*!< [31] Module Disable */
    } B;
} hw_can_mcr_t;

/*!
 * @name Constants and macros for entire CAN_MCR register
 */
/*@{*/
#define HW_CAN_MCR_ADDR(x)       ((uint32_t)(x) + 0x0U)

#define HW_CAN_MCR(x)            (*(__IO hw_can_mcr_t *) HW_CAN_MCR_ADDR(x))
#define HW_CAN_MCR_RD(x)         (HW_CAN_MCR(x).U)
#define HW_CAN_MCR_WR(x, v)      (HW_CAN_MCR(x).U = (v))
#define HW_CAN_MCR_SET(x, v)     (HW_CAN_MCR_WR(x, HW_CAN_MCR_RD(x) |  (v)))
#define HW_CAN_MCR_CLR(x, v)     (HW_CAN_MCR_WR(x, HW_CAN_MCR_RD(x) & ~(v)))
#define HW_CAN_MCR_TOG(x, v)     (HW_CAN_MCR_WR(x, HW_CAN_MCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_MCR bitfields
 */

/*!
 * @name Register CAN_MCR, field MAXMB[6:0] (RW)
 *
 * This 7-bit field defines the number of the last Message Buffers that will
 * take part in the matching and arbitration processes. The reset value (0x0F) is
 * equivalent to a 16 MB configuration. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Number of the last MB =
 * MAXMB MAXMB must be programmed with a value smaller than the parameter
 * NUMBER_OF_MB, otherwise the number of the last effective Message Buffer will be:
 * (NUMBER_OF_MB - 1) Additionally, the value of MAXMB must encompass the FIFO size
 * defined by CTRL2[RFFN]. MAXMB also impacts the definition of the minimum number
 * of peripheral clocks per CAN bit as described in Table "Minimum Ratio Between
 * Peripheral Clock Frequency and CAN Bit Rate" (in Section "Arbitration and
 * Matching Timing").
 */
/*@{*/
#define BP_CAN_MCR_MAXMB     (0U)          /*!< Bit position for CAN_MCR_MAXMB. */
#define BM_CAN_MCR_MAXMB     (0x0000007FU) /*!< Bit mask for CAN_MCR_MAXMB. */
#define BS_CAN_MCR_MAXMB     (7U)          /*!< Bit field size in bits for CAN_MCR_MAXMB. */

/*! @brief Read current value of the CAN_MCR_MAXMB field. */
#define BR_CAN_MCR_MAXMB(x)  (HW_CAN_MCR(x).B.MAXMB)

/*! @brief Format value for bitfield CAN_MCR_MAXMB. */
#define BF_CAN_MCR_MAXMB(v)  ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_MAXMB) & BM_CAN_MCR_MAXMB)

/*! @brief Set the MAXMB field to a new value. */
#define BW_CAN_MCR_MAXMB(x, v) (HW_CAN_MCR_WR(x, (HW_CAN_MCR_RD(x) & ~BM_CAN_MCR_MAXMB) | BF_CAN_MCR_MAXMB(v)))
/*@}*/

/*!
 * @name Register CAN_MCR, field IDAM[9:8] (RW)
 *
 * This 2-bit field identifies the format of the Rx FIFO ID Filter Table
 * elements. Note that all elements of the table are configured at the same time by this
 * field (they are all the same format). See Section "Rx FIFO Structure". This
 * field can be written only in Freeze mode because it is blocked by hardware in
 * other modes.
 *
 * Values:
 * - 00 - Format A: One full ID (standard and extended) per ID Filter Table
 *     element.
 * - 01 - Format B: Two full standard IDs or two partial 14-bit (standard and
 *     extended) IDs per ID Filter Table element.
 * - 10 - Format C: Four partial 8-bit Standard IDs per ID Filter Table element.
 * - 11 - Format D: All frames rejected.
 */
/*@{*/
#define BP_CAN_MCR_IDAM      (8U)          /*!< Bit position for CAN_MCR_IDAM. */
#define BM_CAN_MCR_IDAM      (0x00000300U) /*!< Bit mask for CAN_MCR_IDAM. */
#define BS_CAN_MCR_IDAM      (2U)          /*!< Bit field size in bits for CAN_MCR_IDAM. */

/*! @brief Read current value of the CAN_MCR_IDAM field. */
#define BR_CAN_MCR_IDAM(x)   (HW_CAN_MCR(x).B.IDAM)

/*! @brief Format value for bitfield CAN_MCR_IDAM. */
#define BF_CAN_MCR_IDAM(v)   ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_IDAM) & BM_CAN_MCR_IDAM)

/*! @brief Set the IDAM field to a new value. */
#define BW_CAN_MCR_IDAM(x, v) (HW_CAN_MCR_WR(x, (HW_CAN_MCR_RD(x) & ~BM_CAN_MCR_IDAM) | BF_CAN_MCR_IDAM(v)))
/*@}*/

/*!
 * @name Register CAN_MCR, field AEN[12] (RW)
 *
 * This bit is supplied for backwards compatibility with legacy applications.
 * When asserted, it enables the Tx abort mechanism. This mechanism guarantees a
 * safe procedure for aborting a pending transmission, so that no frame is sent in
 * the CAN bus without notification. This bit can be written only in Freeze mode
 * because it is blocked by hardware in other modes. When MCR[AEN] is asserted,
 * only the abort mechanism (see Section "Transmission Abort Mechanism") must be
 * used for updating Mailboxes configured for transmission. Writing the Abort code
 * into Rx Mailboxes can cause unpredictable results when the MCR[AEN] is
 * asserted.
 *
 * Values:
 * - 0 - Abort disabled.
 * - 1 - Abort enabled.
 */
/*@{*/
#define BP_CAN_MCR_AEN       (12U)         /*!< Bit position for CAN_MCR_AEN. */
#define BM_CAN_MCR_AEN       (0x00001000U) /*!< Bit mask for CAN_MCR_AEN. */
#define BS_CAN_MCR_AEN       (1U)          /*!< Bit field size in bits for CAN_MCR_AEN. */

/*! @brief Read current value of the CAN_MCR_AEN field. */
#define BR_CAN_MCR_AEN(x)    (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_AEN))

/*! @brief Format value for bitfield CAN_MCR_AEN. */
#define BF_CAN_MCR_AEN(v)    ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_AEN) & BM_CAN_MCR_AEN)

/*! @brief Set the AEN field to a new value. */
#define BW_CAN_MCR_AEN(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_AEN) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field LPRIOEN[13] (RW)
 *
 * This bit is provided for backwards compatibility with legacy applications. It
 * controls whether the local priority feature is enabled or not. It is used to
 * expand the ID used during the arbitration process. With this expanded ID
 * concept, the arbitration process is done based on the full 32-bit word, but the
 * actual transmitted ID still has 11-bit for standard frames and 29-bit for
 * extended frames. This bit can be written only in Freeze mode because it is blocked by
 * hardware in other modes.
 *
 * Values:
 * - 0 - Local Priority disabled.
 * - 1 - Local Priority enabled.
 */
/*@{*/
#define BP_CAN_MCR_LPRIOEN   (13U)         /*!< Bit position for CAN_MCR_LPRIOEN. */
#define BM_CAN_MCR_LPRIOEN   (0x00002000U) /*!< Bit mask for CAN_MCR_LPRIOEN. */
#define BS_CAN_MCR_LPRIOEN   (1U)          /*!< Bit field size in bits for CAN_MCR_LPRIOEN. */

/*! @brief Read current value of the CAN_MCR_LPRIOEN field. */
#define BR_CAN_MCR_LPRIOEN(x) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_LPRIOEN))

/*! @brief Format value for bitfield CAN_MCR_LPRIOEN. */
#define BF_CAN_MCR_LPRIOEN(v) ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_LPRIOEN) & BM_CAN_MCR_LPRIOEN)

/*! @brief Set the LPRIOEN field to a new value. */
#define BW_CAN_MCR_LPRIOEN(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_LPRIOEN) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field IRMQ[16] (RW)
 *
 * This bit indicates whether Rx matching process will be based either on
 * individual masking and queue or on masking scheme with RXMGMASK, RX14MASK and
 * RX15MASK, RXFGMASK. This bit can be written only in Freeze mode because it is
 * blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Individual Rx masking and queue feature are disabled. For backward
 *     compatibility with legacy applications, the reading of C/S word locks the MB
 *     even if it is EMPTY.
 * - 1 - Individual Rx masking and queue feature are enabled.
 */
/*@{*/
#define BP_CAN_MCR_IRMQ      (16U)         /*!< Bit position for CAN_MCR_IRMQ. */
#define BM_CAN_MCR_IRMQ      (0x00010000U) /*!< Bit mask for CAN_MCR_IRMQ. */
#define BS_CAN_MCR_IRMQ      (1U)          /*!< Bit field size in bits for CAN_MCR_IRMQ. */

/*! @brief Read current value of the CAN_MCR_IRMQ field. */
#define BR_CAN_MCR_IRMQ(x)   (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_IRMQ))

/*! @brief Format value for bitfield CAN_MCR_IRMQ. */
#define BF_CAN_MCR_IRMQ(v)   ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_IRMQ) & BM_CAN_MCR_IRMQ)

/*! @brief Set the IRMQ field to a new value. */
#define BW_CAN_MCR_IRMQ(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_IRMQ) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field SRXDIS[17] (RW)
 *
 * This bit defines whether FlexCAN is allowed to receive frames transmitted by
 * itself. If this bit is asserted, frames transmitted by the module will not be
 * stored in any MB, regardless if the MB is programmed with an ID that matches
 * the transmitted frame, and no interrupt flag or interrupt signal will be
 * generated due to the frame reception. This bit can be written only in Freeze mode
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Self reception enabled.
 * - 1 - Self reception disabled.
 */
/*@{*/
#define BP_CAN_MCR_SRXDIS    (17U)         /*!< Bit position for CAN_MCR_SRXDIS. */
#define BM_CAN_MCR_SRXDIS    (0x00020000U) /*!< Bit mask for CAN_MCR_SRXDIS. */
#define BS_CAN_MCR_SRXDIS    (1U)          /*!< Bit field size in bits for CAN_MCR_SRXDIS. */

/*! @brief Read current value of the CAN_MCR_SRXDIS field. */
#define BR_CAN_MCR_SRXDIS(x) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_SRXDIS))

/*! @brief Format value for bitfield CAN_MCR_SRXDIS. */
#define BF_CAN_MCR_SRXDIS(v) ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_SRXDIS) & BM_CAN_MCR_SRXDIS)

/*! @brief Set the SRXDIS field to a new value. */
#define BW_CAN_MCR_SRXDIS(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_SRXDIS) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field WAKSRC[19] (RW)
 *
 * This bit defines whether the integrated low-pass filter is applied to protect
 * the Rx CAN input from spurious wake up. This bit can be written only in
 * Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - FlexCAN uses the unfiltered Rx input to detect recessive to dominant
 *     edges on the CAN bus.
 * - 1 - FlexCAN uses the filtered Rx input to detect recessive to dominant
 *     edges on the CAN bus.
 */
/*@{*/
#define BP_CAN_MCR_WAKSRC    (19U)         /*!< Bit position for CAN_MCR_WAKSRC. */
#define BM_CAN_MCR_WAKSRC    (0x00080000U) /*!< Bit mask for CAN_MCR_WAKSRC. */
#define BS_CAN_MCR_WAKSRC    (1U)          /*!< Bit field size in bits for CAN_MCR_WAKSRC. */

/*! @brief Read current value of the CAN_MCR_WAKSRC field. */
#define BR_CAN_MCR_WAKSRC(x) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_WAKSRC))

/*! @brief Format value for bitfield CAN_MCR_WAKSRC. */
#define BF_CAN_MCR_WAKSRC(v) ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_WAKSRC) & BM_CAN_MCR_WAKSRC)

/*! @brief Set the WAKSRC field to a new value. */
#define BW_CAN_MCR_WAKSRC(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_WAKSRC) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field LPMACK[20] (RO)
 *
 * This read-only bit indicates that FlexCAN is in a low-power mode (Disable
 * mode , Stop mode ). A low-power mode cannot be entered until all current
 * transmission or reception processes have finished, so the CPU can poll the LPMACK bit
 * to know when FlexCAN has actually entered low power mode. LPMACK will be
 * asserted within 180 CAN bits from the low-power mode request by the CPU, and
 * negated within 2 CAN bits after the low-power mode request removal (see Section
 * "Protocol Timing").
 *
 * Values:
 * - 0 - FlexCAN is not in a low-power mode.
 * - 1 - FlexCAN is in a low-power mode.
 */
/*@{*/
#define BP_CAN_MCR_LPMACK    (20U)         /*!< Bit position for CAN_MCR_LPMACK. */
#define BM_CAN_MCR_LPMACK    (0x00100000U) /*!< Bit mask for CAN_MCR_LPMACK. */
#define BS_CAN_MCR_LPMACK    (1U)          /*!< Bit field size in bits for CAN_MCR_LPMACK. */

/*! @brief Read current value of the CAN_MCR_LPMACK field. */
#define BR_CAN_MCR_LPMACK(x) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_LPMACK))
/*@}*/

/*!
 * @name Register CAN_MCR, field WRNEN[21] (RW)
 *
 * When asserted, this bit enables the generation of the TWRNINT and RWRNINT
 * flags in the Error and Status Register. If WRNEN is negated, the TWRNINT and
 * RWRNINT flags will always be zero, independent of the values of the error
 * counters, and no warning interrupt will ever be generated. This bit can be written
 * only in Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - TWRNINT and RWRNINT bits are zero, independent of the values in the
 *     error counters.
 * - 1 - TWRNINT and RWRNINT bits are set when the respective error counter
 *     transitions from less than 96 to greater than or equal to 96.
 */
/*@{*/
#define BP_CAN_MCR_WRNEN     (21U)         /*!< Bit position for CAN_MCR_WRNEN. */
#define BM_CAN_MCR_WRNEN     (0x00200000U) /*!< Bit mask for CAN_MCR_WRNEN. */
#define BS_CAN_MCR_WRNEN     (1U)          /*!< Bit field size in bits for CAN_MCR_WRNEN. */

/*! @brief Read current value of the CAN_MCR_WRNEN field. */
#define BR_CAN_MCR_WRNEN(x)  (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_WRNEN))

/*! @brief Format value for bitfield CAN_MCR_WRNEN. */
#define BF_CAN_MCR_WRNEN(v)  ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_WRNEN) & BM_CAN_MCR_WRNEN)

/*! @brief Set the WRNEN field to a new value. */
#define BW_CAN_MCR_WRNEN(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_WRNEN) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field SLFWAK[22] (RW)
 *
 * This bit enables the Self Wake Up feature when FlexCAN is in a low-power mode
 * other than Disable mode. When this feature is enabled, the FlexCAN module
 * monitors the bus for wake up event, that is, a recessive-to-dominant transition.
 * If a wake up event is detected during Stop mode, then FlexCAN generates, if
 * enabled to do so, a Wake Up interrupt to the CPU so that it can exit Stop mode
 * globally and FlexCAN can request to resume the clocks. When FlexCAN is in a
 * low-power mode other than Disable mode, this bit cannot be written as it is
 * blocked by hardware.
 *
 * Values:
 * - 0 - FlexCAN Self Wake Up feature is disabled.
 * - 1 - FlexCAN Self Wake Up feature is enabled.
 */
/*@{*/
#define BP_CAN_MCR_SLFWAK    (22U)         /*!< Bit position for CAN_MCR_SLFWAK. */
#define BM_CAN_MCR_SLFWAK    (0x00400000U) /*!< Bit mask for CAN_MCR_SLFWAK. */
#define BS_CAN_MCR_SLFWAK    (1U)          /*!< Bit field size in bits for CAN_MCR_SLFWAK. */

/*! @brief Read current value of the CAN_MCR_SLFWAK field. */
#define BR_CAN_MCR_SLFWAK(x) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_SLFWAK))

/*! @brief Format value for bitfield CAN_MCR_SLFWAK. */
#define BF_CAN_MCR_SLFWAK(v) ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_SLFWAK) & BM_CAN_MCR_SLFWAK)

/*! @brief Set the SLFWAK field to a new value. */
#define BW_CAN_MCR_SLFWAK(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_SLFWAK) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field SUPV[23] (RW)
 *
 * This bit configures the FlexCAN to be either in Supervisor or User mode. The
 * registers affected by this bit are marked as S/U in the Access Type column of
 * the module memory map. Reset value of this bit is 1, so the affected registers
 * start with Supervisor access allowance only . This bit can be written only in
 * Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - FlexCAN is in User mode. Affected registers allow both Supervisor and
 *     Unrestricted accesses .
 * - 1 - FlexCAN is in Supervisor mode. Affected registers allow only Supervisor
 *     access. Unrestricted access behaves as though the access was done to an
 *     unimplemented register location .
 */
/*@{*/
#define BP_CAN_MCR_SUPV      (23U)         /*!< Bit position for CAN_MCR_SUPV. */
#define BM_CAN_MCR_SUPV      (0x00800000U) /*!< Bit mask for CAN_MCR_SUPV. */
#define BS_CAN_MCR_SUPV      (1U)          /*!< Bit field size in bits for CAN_MCR_SUPV. */

/*! @brief Read current value of the CAN_MCR_SUPV field. */
#define BR_CAN_MCR_SUPV(x)   (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_SUPV))

/*! @brief Format value for bitfield CAN_MCR_SUPV. */
#define BF_CAN_MCR_SUPV(v)   ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_SUPV) & BM_CAN_MCR_SUPV)

/*! @brief Set the SUPV field to a new value. */
#define BW_CAN_MCR_SUPV(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_SUPV) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field FRZACK[24] (RO)
 *
 * This read-only bit indicates that FlexCAN is in Freeze mode and its prescaler
 * is stopped. The Freeze mode request cannot be granted until current
 * transmission or reception processes have finished. Therefore the software can poll the
 * FRZACK bit to know when FlexCAN has actually entered Freeze mode. If Freeze
 * Mode request is negated, then this bit is negated after the FlexCAN prescaler is
 * running again. If Freeze mode is requested while FlexCAN is in a low power
 * mode, then the FRZACK bit will be set only when the low-power mode is exited.
 * See Section "Freeze Mode". FRZACK will be asserted within 178 CAN bits from the
 * freeze mode request by the CPU, and negated within 2 CAN bits after the freeze
 * mode request removal (see Section "Protocol Timing").
 *
 * Values:
 * - 0 - FlexCAN not in Freeze mode, prescaler running.
 * - 1 - FlexCAN in Freeze mode, prescaler stopped.
 */
/*@{*/
#define BP_CAN_MCR_FRZACK    (24U)         /*!< Bit position for CAN_MCR_FRZACK. */
#define BM_CAN_MCR_FRZACK    (0x01000000U) /*!< Bit mask for CAN_MCR_FRZACK. */
#define BS_CAN_MCR_FRZACK    (1U)          /*!< Bit field size in bits for CAN_MCR_FRZACK. */

/*! @brief Read current value of the CAN_MCR_FRZACK field. */
#define BR_CAN_MCR_FRZACK(x) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_FRZACK))
/*@}*/

/*!
 * @name Register CAN_MCR, field SOFTRST[25] (RW)
 *
 * When this bit is asserted, FlexCAN resets its internal state machines and
 * some of the memory mapped registers. The following registers are reset: MCR
 * (except the MDIS bit), TIMER , ECR, ESR1, ESR2, IMASK1, IMASK2, IFLAG1, IFLAG2 and
 * CRCR. Configuration registers that control the interface to the CAN bus are
 * not affected by soft reset. The following registers are unaffected: CTRL1,
 * CTRL2, all RXIMR registers, RXMGMASK, RX14MASK, RX15MASK, RXFGMASK, RXFIR, all
 * Message Buffers . The SOFTRST bit can be asserted directly by the CPU when it
 * writes to the MCR Register, but it is also asserted when global soft reset is
 * requested at MCU level . Because soft reset is synchronous and has to follow a
 * request/acknowledge procedure across clock domains, it may take some time to
 * fully propagate its effect. The SOFTRST bit remains asserted while reset is
 * pending, and is automatically negated when reset completes. Therefore, software can
 * poll this bit to know when the soft reset has completed. Soft reset cannot be
 * applied while clocks are shut down in a low power mode. The module should be
 * first removed from low power mode, and then soft reset can be applied.
 *
 * Values:
 * - 0 - No reset request.
 * - 1 - Resets the registers affected by soft reset.
 */
/*@{*/
#define BP_CAN_MCR_SOFTRST   (25U)         /*!< Bit position for CAN_MCR_SOFTRST. */
#define BM_CAN_MCR_SOFTRST   (0x02000000U) /*!< Bit mask for CAN_MCR_SOFTRST. */
#define BS_CAN_MCR_SOFTRST   (1U)          /*!< Bit field size in bits for CAN_MCR_SOFTRST. */

/*! @brief Read current value of the CAN_MCR_SOFTRST field. */
#define BR_CAN_MCR_SOFTRST(x) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_SOFTRST))

/*! @brief Format value for bitfield CAN_MCR_SOFTRST. */
#define BF_CAN_MCR_SOFTRST(v) ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_SOFTRST) & BM_CAN_MCR_SOFTRST)

/*! @brief Set the SOFTRST field to a new value. */
#define BW_CAN_MCR_SOFTRST(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_SOFTRST) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field WAKMSK[26] (RW)
 *
 * This bit enables the Wake Up Interrupt generation under Self Wake Up
 * mechanism.
 *
 * Values:
 * - 0 - Wake Up Interrupt is disabled.
 * - 1 - Wake Up Interrupt is enabled.
 */
/*@{*/
#define BP_CAN_MCR_WAKMSK    (26U)         /*!< Bit position for CAN_MCR_WAKMSK. */
#define BM_CAN_MCR_WAKMSK    (0x04000000U) /*!< Bit mask for CAN_MCR_WAKMSK. */
#define BS_CAN_MCR_WAKMSK    (1U)          /*!< Bit field size in bits for CAN_MCR_WAKMSK. */

/*! @brief Read current value of the CAN_MCR_WAKMSK field. */
#define BR_CAN_MCR_WAKMSK(x) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_WAKMSK))

/*! @brief Format value for bitfield CAN_MCR_WAKMSK. */
#define BF_CAN_MCR_WAKMSK(v) ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_WAKMSK) & BM_CAN_MCR_WAKMSK)

/*! @brief Set the WAKMSK field to a new value. */
#define BW_CAN_MCR_WAKMSK(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_WAKMSK) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field NOTRDY[27] (RO)
 *
 * This read-only bit indicates that FlexCAN is either in Disable mode , Stop
 * mode or Freeze mode. It is negated once FlexCAN has exited these modes.
 *
 * Values:
 * - 0 - FlexCAN module is either in Normal mode, Listen-Only mode or Loop-Back
 *     mode.
 * - 1 - FlexCAN module is either in Disable mode , Stop mode or Freeze mode.
 */
/*@{*/
#define BP_CAN_MCR_NOTRDY    (27U)         /*!< Bit position for CAN_MCR_NOTRDY. */
#define BM_CAN_MCR_NOTRDY    (0x08000000U) /*!< Bit mask for CAN_MCR_NOTRDY. */
#define BS_CAN_MCR_NOTRDY    (1U)          /*!< Bit field size in bits for CAN_MCR_NOTRDY. */

/*! @brief Read current value of the CAN_MCR_NOTRDY field. */
#define BR_CAN_MCR_NOTRDY(x) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_NOTRDY))
/*@}*/

/*!
 * @name Register CAN_MCR, field HALT[28] (RW)
 *
 * Assertion of this bit puts the FlexCAN module into Freeze mode. The CPU
 * should clear it after initializing the Message Buffers and Control Register. No
 * reception or transmission is performed by FlexCAN before this bit is cleared.
 * Freeze mode cannot be entered while FlexCAN is in a low power mode.
 *
 * Values:
 * - 0 - No Freeze mode request.
 * - 1 - Enters Freeze mode if the FRZ bit is asserted.
 */
/*@{*/
#define BP_CAN_MCR_HALT      (28U)         /*!< Bit position for CAN_MCR_HALT. */
#define BM_CAN_MCR_HALT      (0x10000000U) /*!< Bit mask for CAN_MCR_HALT. */
#define BS_CAN_MCR_HALT      (1U)          /*!< Bit field size in bits for CAN_MCR_HALT. */

/*! @brief Read current value of the CAN_MCR_HALT field. */
#define BR_CAN_MCR_HALT(x)   (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_HALT))

/*! @brief Format value for bitfield CAN_MCR_HALT. */
#define BF_CAN_MCR_HALT(v)   ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_HALT) & BM_CAN_MCR_HALT)

/*! @brief Set the HALT field to a new value. */
#define BW_CAN_MCR_HALT(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_HALT) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field RFEN[29] (RW)
 *
 * This bit controls whether the Rx FIFO feature is enabled or not. When RFEN is
 * set, MBs 0 to 5 cannot be used for normal reception and transmission because
 * the corresponding memory region (0x80-0xDC) is used by the FIFO engine as well
 * as additional MBs (up to 32, depending on CTRL2[RFFN] setting) which are used
 * as Rx FIFO ID Filter Table elements. RFEN also impacts the definition of the
 * minimum number of peripheral clocks per CAN bit as described in the table
 * "Minimum Ratio Between Peripheral Clock Frequency and CAN Bit Rate" (in section
 * "Arbitration and Matching Timing"). This bit can be written only in Freeze mode
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Rx FIFO not enabled.
 * - 1 - Rx FIFO enabled.
 */
/*@{*/
#define BP_CAN_MCR_RFEN      (29U)         /*!< Bit position for CAN_MCR_RFEN. */
#define BM_CAN_MCR_RFEN      (0x20000000U) /*!< Bit mask for CAN_MCR_RFEN. */
#define BS_CAN_MCR_RFEN      (1U)          /*!< Bit field size in bits for CAN_MCR_RFEN. */

/*! @brief Read current value of the CAN_MCR_RFEN field. */
#define BR_CAN_MCR_RFEN(x)   (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_RFEN))

/*! @brief Format value for bitfield CAN_MCR_RFEN. */
#define BF_CAN_MCR_RFEN(v)   ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_RFEN) & BM_CAN_MCR_RFEN)

/*! @brief Set the RFEN field to a new value. */
#define BW_CAN_MCR_RFEN(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_RFEN) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field FRZ[30] (RW)
 *
 * The FRZ bit specifies the FlexCAN behavior when the HALT bit in the MCR
 * Register is set or when Debug mode is requested at MCU level . When FRZ is
 * asserted, FlexCAN is enabled to enter Freeze mode. Negation of this bit field causes
 * FlexCAN to exit from Freeze mode.
 *
 * Values:
 * - 0 - Not enabled to enter Freeze mode.
 * - 1 - Enabled to enter Freeze mode.
 */
/*@{*/
#define BP_CAN_MCR_FRZ       (30U)         /*!< Bit position for CAN_MCR_FRZ. */
#define BM_CAN_MCR_FRZ       (0x40000000U) /*!< Bit mask for CAN_MCR_FRZ. */
#define BS_CAN_MCR_FRZ       (1U)          /*!< Bit field size in bits for CAN_MCR_FRZ. */

/*! @brief Read current value of the CAN_MCR_FRZ field. */
#define BR_CAN_MCR_FRZ(x)    (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_FRZ))

/*! @brief Format value for bitfield CAN_MCR_FRZ. */
#define BF_CAN_MCR_FRZ(v)    ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_FRZ) & BM_CAN_MCR_FRZ)

/*! @brief Set the FRZ field to a new value. */
#define BW_CAN_MCR_FRZ(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_FRZ) = (v))
/*@}*/

/*!
 * @name Register CAN_MCR, field MDIS[31] (RW)
 *
 * This bit controls whether FlexCAN is enabled or not. When disabled, FlexCAN
 * disables the clocks to the CAN Protocol Engine and Controller Host Interface
 * sub-modules. This is the only bit within this register not affected by soft
 * reset.
 *
 * Values:
 * - 0 - Enable the FlexCAN module.
 * - 1 - Disable the FlexCAN module.
 */
/*@{*/
#define BP_CAN_MCR_MDIS      (31U)         /*!< Bit position for CAN_MCR_MDIS. */
#define BM_CAN_MCR_MDIS      (0x80000000U) /*!< Bit mask for CAN_MCR_MDIS. */
#define BS_CAN_MCR_MDIS      (1U)          /*!< Bit field size in bits for CAN_MCR_MDIS. */

/*! @brief Read current value of the CAN_MCR_MDIS field. */
#define BR_CAN_MCR_MDIS(x)   (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_MDIS))

/*! @brief Format value for bitfield CAN_MCR_MDIS. */
#define BF_CAN_MCR_MDIS(v)   ((uint32_t)((uint32_t)(v) << BP_CAN_MCR_MDIS) & BM_CAN_MCR_MDIS)

/*! @brief Set the MDIS field to a new value. */
#define BW_CAN_MCR_MDIS(x, v) (BITBAND_ACCESS32(HW_CAN_MCR_ADDR(x), BP_CAN_MCR_MDIS) = (v))
/*@}*/

/*******************************************************************************
 * HW_CAN_CTRL1 - Control 1 register
 ******************************************************************************/

/*!
 * @brief HW_CAN_CTRL1 - Control 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is defined for specific FlexCAN control features related to the
 * CAN bus, such as bit-rate, programmable sampling point within an Rx bit, Loop
 * Back mode, Listen-Only mode, Bus Off recovery behavior and interrupt enabling
 * (Bus-Off, Error, Warning). It also determines the Division Factor for the
 * clock prescaler.
 */
typedef union _hw_can_ctrl1
{
    uint32_t U;
    struct _hw_can_ctrl1_bitfields
    {
        uint32_t PROPSEG : 3;          /*!< [2:0] Propagation Segment */
        uint32_t LOM : 1;              /*!< [3] Listen-Only Mode */
        uint32_t LBUF : 1;             /*!< [4] Lowest Buffer Transmitted First */
        uint32_t TSYN : 1;             /*!< [5] Timer Sync */
        uint32_t BOFFREC : 1;          /*!< [6] Bus Off Recovery */
        uint32_t SMP : 1;              /*!< [7] CAN Bit Sampling */
        uint32_t RESERVED0 : 2;        /*!< [9:8]  */
        uint32_t RWRNMSK : 1;          /*!< [10] Rx Warning Interrupt Mask */
        uint32_t TWRNMSK : 1;          /*!< [11] Tx Warning Interrupt Mask */
        uint32_t LPB : 1;              /*!< [12] Loop Back Mode */
        uint32_t CLKSRC : 1;           /*!< [13] CAN Engine Clock Source */
        uint32_t ERRMSK : 1;           /*!< [14] Error Mask */
        uint32_t BOFFMSK : 1;          /*!< [15] Bus Off Mask */
        uint32_t PSEG2 : 3;            /*!< [18:16] Phase Segment 2 */
        uint32_t PSEG1 : 3;            /*!< [21:19] Phase Segment 1 */
        uint32_t RJW : 2;              /*!< [23:22] Resync Jump Width */
        uint32_t PRESDIV : 8;          /*!< [31:24] Prescaler Division Factor */
    } B;
} hw_can_ctrl1_t;

/*!
 * @name Constants and macros for entire CAN_CTRL1 register
 */
/*@{*/
#define HW_CAN_CTRL1_ADDR(x)     ((uint32_t)(x) + 0x4U)

#define HW_CAN_CTRL1(x)          (*(__IO hw_can_ctrl1_t *) HW_CAN_CTRL1_ADDR(x))
#define HW_CAN_CTRL1_RD(x)       (HW_CAN_CTRL1(x).U)
#define HW_CAN_CTRL1_WR(x, v)    (HW_CAN_CTRL1(x).U = (v))
#define HW_CAN_CTRL1_SET(x, v)   (HW_CAN_CTRL1_WR(x, HW_CAN_CTRL1_RD(x) |  (v)))
#define HW_CAN_CTRL1_CLR(x, v)   (HW_CAN_CTRL1_WR(x, HW_CAN_CTRL1_RD(x) & ~(v)))
#define HW_CAN_CTRL1_TOG(x, v)   (HW_CAN_CTRL1_WR(x, HW_CAN_CTRL1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_CTRL1 bitfields
 */

/*!
 * @name Register CAN_CTRL1, field PROPSEG[2:0] (RW)
 *
 * This 3-bit field defines the length of the Propagation Segment in the bit
 * time. The valid programmable values are 0-7. This field can be written only in
 * Freeze mode because it is blocked by hardware in other modes. Propagation
 * Segment Time = (PROPSEG + 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
#define BP_CAN_CTRL1_PROPSEG (0U)          /*!< Bit position for CAN_CTRL1_PROPSEG. */
#define BM_CAN_CTRL1_PROPSEG (0x00000007U) /*!< Bit mask for CAN_CTRL1_PROPSEG. */
#define BS_CAN_CTRL1_PROPSEG (3U)          /*!< Bit field size in bits for CAN_CTRL1_PROPSEG. */

/*! @brief Read current value of the CAN_CTRL1_PROPSEG field. */
#define BR_CAN_CTRL1_PROPSEG(x) (HW_CAN_CTRL1(x).B.PROPSEG)

/*! @brief Format value for bitfield CAN_CTRL1_PROPSEG. */
#define BF_CAN_CTRL1_PROPSEG(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_PROPSEG) & BM_CAN_CTRL1_PROPSEG)

/*! @brief Set the PROPSEG field to a new value. */
#define BW_CAN_CTRL1_PROPSEG(x, v) (HW_CAN_CTRL1_WR(x, (HW_CAN_CTRL1_RD(x) & ~BM_CAN_CTRL1_PROPSEG) | BF_CAN_CTRL1_PROPSEG(v)))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LOM[3] (RW)
 *
 * This bit configures FlexCAN to operate in Listen-Only mode. In this mode,
 * transmission is disabled, all error counters are frozen and the module operates
 * in a CAN Error Passive mode. Only messages acknowledged by another CAN station
 * will be received. If FlexCAN detects a message that has not been acknowledged,
 * it will flag a BIT0 error without changing the REC, as if it was trying to
 * acknowledge the message. Listen-Only mode acknowledgement can be obtained by the
 * state of ESR1[FLTCONF] field which is Passive Error when Listen-Only mode is
 * entered. There can be some delay between the Listen-Only mode request and
 * acknowledge. This bit can be written only in Freeze mode because it is blocked by
 * hardware in other modes.
 *
 * Values:
 * - 0 - Listen-Only mode is deactivated.
 * - 1 - FlexCAN module operates in Listen-Only mode.
 */
/*@{*/
#define BP_CAN_CTRL1_LOM     (3U)          /*!< Bit position for CAN_CTRL1_LOM. */
#define BM_CAN_CTRL1_LOM     (0x00000008U) /*!< Bit mask for CAN_CTRL1_LOM. */
#define BS_CAN_CTRL1_LOM     (1U)          /*!< Bit field size in bits for CAN_CTRL1_LOM. */

/*! @brief Read current value of the CAN_CTRL1_LOM field. */
#define BR_CAN_CTRL1_LOM(x)  (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_LOM))

/*! @brief Format value for bitfield CAN_CTRL1_LOM. */
#define BF_CAN_CTRL1_LOM(v)  ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_LOM) & BM_CAN_CTRL1_LOM)

/*! @brief Set the LOM field to a new value. */
#define BW_CAN_CTRL1_LOM(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_LOM) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LBUF[4] (RW)
 *
 * This bit defines the ordering mechanism for Message Buffer transmission. When
 * asserted, the LPRIOEN bit does not affect the priority arbitration. This bit
 * can be written only in Freeze mode because it is blocked by hardware in other
 * modes.
 *
 * Values:
 * - 0 - Buffer with highest priority is transmitted first.
 * - 1 - Lowest number buffer is transmitted first.
 */
/*@{*/
#define BP_CAN_CTRL1_LBUF    (4U)          /*!< Bit position for CAN_CTRL1_LBUF. */
#define BM_CAN_CTRL1_LBUF    (0x00000010U) /*!< Bit mask for CAN_CTRL1_LBUF. */
#define BS_CAN_CTRL1_LBUF    (1U)          /*!< Bit field size in bits for CAN_CTRL1_LBUF. */

/*! @brief Read current value of the CAN_CTRL1_LBUF field. */
#define BR_CAN_CTRL1_LBUF(x) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_LBUF))

/*! @brief Format value for bitfield CAN_CTRL1_LBUF. */
#define BF_CAN_CTRL1_LBUF(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_LBUF) & BM_CAN_CTRL1_LBUF)

/*! @brief Set the LBUF field to a new value. */
#define BW_CAN_CTRL1_LBUF(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_LBUF) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field TSYN[5] (RW)
 *
 * This bit enables a mechanism that resets the free-running timer each time a
 * message is received in Message Buffer 0. This feature provides means to
 * synchronize multiple FlexCAN stations with a special "SYNC" message, that is, global
 * network time. If the RFEN bit in MCR is set (Rx FIFO enabled), the first
 * available Mailbox, according to CTRL2[RFFN] setting, is used for timer
 * synchronization instead of MB0. This bit can be written only in Freeze mode because it is
 * blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Timer Sync feature disabled
 * - 1 - Timer Sync feature enabled
 */
/*@{*/
#define BP_CAN_CTRL1_TSYN    (5U)          /*!< Bit position for CAN_CTRL1_TSYN. */
#define BM_CAN_CTRL1_TSYN    (0x00000020U) /*!< Bit mask for CAN_CTRL1_TSYN. */
#define BS_CAN_CTRL1_TSYN    (1U)          /*!< Bit field size in bits for CAN_CTRL1_TSYN. */

/*! @brief Read current value of the CAN_CTRL1_TSYN field. */
#define BR_CAN_CTRL1_TSYN(x) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_TSYN))

/*! @brief Format value for bitfield CAN_CTRL1_TSYN. */
#define BF_CAN_CTRL1_TSYN(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_TSYN) & BM_CAN_CTRL1_TSYN)

/*! @brief Set the TSYN field to a new value. */
#define BW_CAN_CTRL1_TSYN(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_TSYN) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field BOFFREC[6] (RW)
 *
 * This bit defines how FlexCAN recovers from Bus Off state. If this bit is
 * negated, automatic recovering from Bus Off state occurs according to the CAN
 * Specification 2.0B. If the bit is asserted, automatic recovering from Bus Off is
 * disabled and the module remains in Bus Off state until the bit is negated by the
 * user. If the negation occurs before 128 sequences of 11 recessive bits are
 * detected on the CAN bus, then Bus Off recovery happens as if the BOFFREC bit had
 * never been asserted. If the negation occurs after 128 sequences of 11
 * recessive bits occurred, then FlexCAN will re-synchronize to the bus by waiting for
 * 11 recessive bits before joining the bus. After negation, the BOFFREC bit can
 * be re-asserted again during Bus Off, but it will be effective only the next
 * time the module enters Bus Off. If BOFFREC was negated when the module entered
 * Bus Off, asserting it during Bus Off will not be effective for the current Bus
 * Off recovery.
 *
 * Values:
 * - 0 - Automatic recovering from Bus Off state enabled, according to CAN Spec
 *     2.0 part B.
 * - 1 - Automatic recovering from Bus Off state disabled.
 */
/*@{*/
#define BP_CAN_CTRL1_BOFFREC (6U)          /*!< Bit position for CAN_CTRL1_BOFFREC. */
#define BM_CAN_CTRL1_BOFFREC (0x00000040U) /*!< Bit mask for CAN_CTRL1_BOFFREC. */
#define BS_CAN_CTRL1_BOFFREC (1U)          /*!< Bit field size in bits for CAN_CTRL1_BOFFREC. */

/*! @brief Read current value of the CAN_CTRL1_BOFFREC field. */
#define BR_CAN_CTRL1_BOFFREC(x) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_BOFFREC))

/*! @brief Format value for bitfield CAN_CTRL1_BOFFREC. */
#define BF_CAN_CTRL1_BOFFREC(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_BOFFREC) & BM_CAN_CTRL1_BOFFREC)

/*! @brief Set the BOFFREC field to a new value. */
#define BW_CAN_CTRL1_BOFFREC(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_BOFFREC) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field SMP[7] (RW)
 *
 * This bit defines the sampling mode of CAN bits at the Rx input. This bit can
 * be written only in Freeze mode because it is blocked by hardware in other
 * modes.
 *
 * Values:
 * - 0 - Just one sample is used to determine the bit value.
 * - 1 - Three samples are used to determine the value of the received bit: the
 *     regular one (sample point) and 2 preceding samples; a majority rule is
 *     used.
 */
/*@{*/
#define BP_CAN_CTRL1_SMP     (7U)          /*!< Bit position for CAN_CTRL1_SMP. */
#define BM_CAN_CTRL1_SMP     (0x00000080U) /*!< Bit mask for CAN_CTRL1_SMP. */
#define BS_CAN_CTRL1_SMP     (1U)          /*!< Bit field size in bits for CAN_CTRL1_SMP. */

/*! @brief Read current value of the CAN_CTRL1_SMP field. */
#define BR_CAN_CTRL1_SMP(x)  (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_SMP))

/*! @brief Format value for bitfield CAN_CTRL1_SMP. */
#define BF_CAN_CTRL1_SMP(v)  ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_SMP) & BM_CAN_CTRL1_SMP)

/*! @brief Set the SMP field to a new value. */
#define BW_CAN_CTRL1_SMP(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_SMP) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field RWRNMSK[10] (RW)
 *
 * This bit provides a mask for the Rx Warning Interrupt associated with the
 * RWRNINT flag in the Error and Status Register. This bit is read as zero when
 * MCR[WRNEN] bit is negated. This bit can be written only if MCR[WRNEN] bit is
 * asserted.
 *
 * Values:
 * - 0 - Rx Warning Interrupt disabled.
 * - 1 - Rx Warning Interrupt enabled.
 */
/*@{*/
#define BP_CAN_CTRL1_RWRNMSK (10U)         /*!< Bit position for CAN_CTRL1_RWRNMSK. */
#define BM_CAN_CTRL1_RWRNMSK (0x00000400U) /*!< Bit mask for CAN_CTRL1_RWRNMSK. */
#define BS_CAN_CTRL1_RWRNMSK (1U)          /*!< Bit field size in bits for CAN_CTRL1_RWRNMSK. */

/*! @brief Read current value of the CAN_CTRL1_RWRNMSK field. */
#define BR_CAN_CTRL1_RWRNMSK(x) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_RWRNMSK))

/*! @brief Format value for bitfield CAN_CTRL1_RWRNMSK. */
#define BF_CAN_CTRL1_RWRNMSK(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_RWRNMSK) & BM_CAN_CTRL1_RWRNMSK)

/*! @brief Set the RWRNMSK field to a new value. */
#define BW_CAN_CTRL1_RWRNMSK(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_RWRNMSK) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field TWRNMSK[11] (RW)
 *
 * This bit provides a mask for the Tx Warning Interrupt associated with the
 * TWRNINT flag in the Error and Status Register. This bit is read as zero when
 * MCR[WRNEN] bit is negated. This bit can be written only if MCR[WRNEN] bit is
 * asserted.
 *
 * Values:
 * - 0 - Tx Warning Interrupt disabled.
 * - 1 - Tx Warning Interrupt enabled.
 */
/*@{*/
#define BP_CAN_CTRL1_TWRNMSK (11U)         /*!< Bit position for CAN_CTRL1_TWRNMSK. */
#define BM_CAN_CTRL1_TWRNMSK (0x00000800U) /*!< Bit mask for CAN_CTRL1_TWRNMSK. */
#define BS_CAN_CTRL1_TWRNMSK (1U)          /*!< Bit field size in bits for CAN_CTRL1_TWRNMSK. */

/*! @brief Read current value of the CAN_CTRL1_TWRNMSK field. */
#define BR_CAN_CTRL1_TWRNMSK(x) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_TWRNMSK))

/*! @brief Format value for bitfield CAN_CTRL1_TWRNMSK. */
#define BF_CAN_CTRL1_TWRNMSK(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_TWRNMSK) & BM_CAN_CTRL1_TWRNMSK)

/*! @brief Set the TWRNMSK field to a new value. */
#define BW_CAN_CTRL1_TWRNMSK(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_TWRNMSK) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LPB[12] (RW)
 *
 * This bit configures FlexCAN to operate in Loop-Back mode. In this mode,
 * FlexCAN performs an internal loop back that can be used for self test operation.
 * The bit stream output of the transmitter is fed back internally to the receiver
 * input. The Rx CAN input pin is ignored and the Tx CAN output goes to the
 * recessive state (logic 1). FlexCAN behaves as it normally does when transmitting,
 * and treats its own transmitted message as a message received from a remote
 * node. In this mode, FlexCAN ignores the bit sent during the ACK slot in the CAN
 * frame acknowledge field, generating an internal acknowledge bit to ensure proper
 * reception of its own message. Both transmit and receive interrupts are
 * generated. This bit can be written only in Freeze mode because it is blocked by
 * hardware in other modes. In this mode, the MCR[SRXDIS] cannot be asserted because
 * this will impede the self reception of a transmitted message.
 *
 * Values:
 * - 0 - Loop Back disabled.
 * - 1 - Loop Back enabled.
 */
/*@{*/
#define BP_CAN_CTRL1_LPB     (12U)         /*!< Bit position for CAN_CTRL1_LPB. */
#define BM_CAN_CTRL1_LPB     (0x00001000U) /*!< Bit mask for CAN_CTRL1_LPB. */
#define BS_CAN_CTRL1_LPB     (1U)          /*!< Bit field size in bits for CAN_CTRL1_LPB. */

/*! @brief Read current value of the CAN_CTRL1_LPB field. */
#define BR_CAN_CTRL1_LPB(x)  (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_LPB))

/*! @brief Format value for bitfield CAN_CTRL1_LPB. */
#define BF_CAN_CTRL1_LPB(v)  ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_LPB) & BM_CAN_CTRL1_LPB)

/*! @brief Set the LPB field to a new value. */
#define BW_CAN_CTRL1_LPB(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_LPB) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field CLKSRC[13] (RW)
 *
 * This bit selects the clock source to the CAN Protocol Engine (PE) to be
 * either the peripheral clock (driven by the PLL) or the crystal oscillator clock.
 * The selected clock is the one fed to the prescaler to generate the Serial Clock
 * (Sclock). In order to guarantee reliable operation, this bit can be written
 * only in Disable mode because it is blocked by hardware in other modes. See
 * Section "Protocol Timing".
 *
 * Values:
 * - 0 - The CAN engine clock source is the oscillator clock. Under this
 *     condition, the oscillator clock frequency must be lower than the bus clock.
 * - 1 - The CAN engine clock source is the peripheral clock.
 */
/*@{*/
#define BP_CAN_CTRL1_CLKSRC  (13U)         /*!< Bit position for CAN_CTRL1_CLKSRC. */
#define BM_CAN_CTRL1_CLKSRC  (0x00002000U) /*!< Bit mask for CAN_CTRL1_CLKSRC. */
#define BS_CAN_CTRL1_CLKSRC  (1U)          /*!< Bit field size in bits for CAN_CTRL1_CLKSRC. */

/*! @brief Read current value of the CAN_CTRL1_CLKSRC field. */
#define BR_CAN_CTRL1_CLKSRC(x) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_CLKSRC))

/*! @brief Format value for bitfield CAN_CTRL1_CLKSRC. */
#define BF_CAN_CTRL1_CLKSRC(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_CLKSRC) & BM_CAN_CTRL1_CLKSRC)

/*! @brief Set the CLKSRC field to a new value. */
#define BW_CAN_CTRL1_CLKSRC(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_CLKSRC) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field ERRMSK[14] (RW)
 *
 * This bit provides a mask for the Error Interrupt.
 *
 * Values:
 * - 0 - Error interrupt disabled.
 * - 1 - Error interrupt enabled.
 */
/*@{*/
#define BP_CAN_CTRL1_ERRMSK  (14U)         /*!< Bit position for CAN_CTRL1_ERRMSK. */
#define BM_CAN_CTRL1_ERRMSK  (0x00004000U) /*!< Bit mask for CAN_CTRL1_ERRMSK. */
#define BS_CAN_CTRL1_ERRMSK  (1U)          /*!< Bit field size in bits for CAN_CTRL1_ERRMSK. */

/*! @brief Read current value of the CAN_CTRL1_ERRMSK field. */
#define BR_CAN_CTRL1_ERRMSK(x) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_ERRMSK))

/*! @brief Format value for bitfield CAN_CTRL1_ERRMSK. */
#define BF_CAN_CTRL1_ERRMSK(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_ERRMSK) & BM_CAN_CTRL1_ERRMSK)

/*! @brief Set the ERRMSK field to a new value. */
#define BW_CAN_CTRL1_ERRMSK(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_ERRMSK) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field BOFFMSK[15] (RW)
 *
 * This bit provides a mask for the Bus Off Interrupt.
 *
 * Values:
 * - 0 - Bus Off interrupt disabled.
 * - 1 - Bus Off interrupt enabled.
 */
/*@{*/
#define BP_CAN_CTRL1_BOFFMSK (15U)         /*!< Bit position for CAN_CTRL1_BOFFMSK. */
#define BM_CAN_CTRL1_BOFFMSK (0x00008000U) /*!< Bit mask for CAN_CTRL1_BOFFMSK. */
#define BS_CAN_CTRL1_BOFFMSK (1U)          /*!< Bit field size in bits for CAN_CTRL1_BOFFMSK. */

/*! @brief Read current value of the CAN_CTRL1_BOFFMSK field. */
#define BR_CAN_CTRL1_BOFFMSK(x) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_BOFFMSK))

/*! @brief Format value for bitfield CAN_CTRL1_BOFFMSK. */
#define BF_CAN_CTRL1_BOFFMSK(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_BOFFMSK) & BM_CAN_CTRL1_BOFFMSK)

/*! @brief Set the BOFFMSK field to a new value. */
#define BW_CAN_CTRL1_BOFFMSK(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL1_ADDR(x), BP_CAN_CTRL1_BOFFMSK) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PSEG2[18:16] (RW)
 *
 * This 3-bit field defines the length of Phase Buffer Segment 2 in the bit
 * time. The valid programmable values are 1-7. This field can be written only in
 * Freeze mode because it is blocked by hardware in other modes. Phase Buffer
 * Segment 2 = (PSEG2 + 1) * Time-Quanta.
 */
/*@{*/
#define BP_CAN_CTRL1_PSEG2   (16U)         /*!< Bit position for CAN_CTRL1_PSEG2. */
#define BM_CAN_CTRL1_PSEG2   (0x00070000U) /*!< Bit mask for CAN_CTRL1_PSEG2. */
#define BS_CAN_CTRL1_PSEG2   (3U)          /*!< Bit field size in bits for CAN_CTRL1_PSEG2. */

/*! @brief Read current value of the CAN_CTRL1_PSEG2 field. */
#define BR_CAN_CTRL1_PSEG2(x) (HW_CAN_CTRL1(x).B.PSEG2)

/*! @brief Format value for bitfield CAN_CTRL1_PSEG2. */
#define BF_CAN_CTRL1_PSEG2(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_PSEG2) & BM_CAN_CTRL1_PSEG2)

/*! @brief Set the PSEG2 field to a new value. */
#define BW_CAN_CTRL1_PSEG2(x, v) (HW_CAN_CTRL1_WR(x, (HW_CAN_CTRL1_RD(x) & ~BM_CAN_CTRL1_PSEG2) | BF_CAN_CTRL1_PSEG2(v)))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PSEG1[21:19] (RW)
 *
 * This 3-bit field defines the length of Phase Buffer Segment 1 in the bit
 * time. The valid programmable values are 0-7. This field can be written only in
 * Freeze mode because it is blocked by hardware in other modes. Phase Buffer
 * Segment 1 = (PSEG1 + 1) * Time-Quanta.
 */
/*@{*/
#define BP_CAN_CTRL1_PSEG1   (19U)         /*!< Bit position for CAN_CTRL1_PSEG1. */
#define BM_CAN_CTRL1_PSEG1   (0x00380000U) /*!< Bit mask for CAN_CTRL1_PSEG1. */
#define BS_CAN_CTRL1_PSEG1   (3U)          /*!< Bit field size in bits for CAN_CTRL1_PSEG1. */

/*! @brief Read current value of the CAN_CTRL1_PSEG1 field. */
#define BR_CAN_CTRL1_PSEG1(x) (HW_CAN_CTRL1(x).B.PSEG1)

/*! @brief Format value for bitfield CAN_CTRL1_PSEG1. */
#define BF_CAN_CTRL1_PSEG1(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_PSEG1) & BM_CAN_CTRL1_PSEG1)

/*! @brief Set the PSEG1 field to a new value. */
#define BW_CAN_CTRL1_PSEG1(x, v) (HW_CAN_CTRL1_WR(x, (HW_CAN_CTRL1_RD(x) & ~BM_CAN_CTRL1_PSEG1) | BF_CAN_CTRL1_PSEG1(v)))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field RJW[23:22] (RW)
 *
 * This 2-bit field defines the maximum number of time quanta that a bit time
 * can be changed by one re-synchronization. One time quantum is equal to the
 * Sclock period. The valid programmable values are 0-3. This field can be written
 * only in Freeze mode because it is blocked by hardware in other modes. Resync Jump
 * Width = RJW + 1.
 */
/*@{*/
#define BP_CAN_CTRL1_RJW     (22U)         /*!< Bit position for CAN_CTRL1_RJW. */
#define BM_CAN_CTRL1_RJW     (0x00C00000U) /*!< Bit mask for CAN_CTRL1_RJW. */
#define BS_CAN_CTRL1_RJW     (2U)          /*!< Bit field size in bits for CAN_CTRL1_RJW. */

/*! @brief Read current value of the CAN_CTRL1_RJW field. */
#define BR_CAN_CTRL1_RJW(x)  (HW_CAN_CTRL1(x).B.RJW)

/*! @brief Format value for bitfield CAN_CTRL1_RJW. */
#define BF_CAN_CTRL1_RJW(v)  ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_RJW) & BM_CAN_CTRL1_RJW)

/*! @brief Set the RJW field to a new value. */
#define BW_CAN_CTRL1_RJW(x, v) (HW_CAN_CTRL1_WR(x, (HW_CAN_CTRL1_RD(x) & ~BM_CAN_CTRL1_RJW) | BF_CAN_CTRL1_RJW(v)))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PRESDIV[31:24] (RW)
 *
 * This 8-bit field defines the ratio between the PE clock frequency and the
 * Serial Clock (Sclock) frequency. The Sclock period defines the time quantum of
 * the CAN protocol. For the reset value, the Sclock frequency is equal to the PE
 * clock frequency. The Maximum value of this field is 0xFF, that gives a minimum
 * Sclock frequency equal to the PE clock frequency divided by 256. See Section
 * "Protocol Timing". This field can be written only in Freeze mode because it is
 * blocked by hardware in other modes. Sclock frequency = PE clock frequency /
 * (PRESDIV + 1)
 */
/*@{*/
#define BP_CAN_CTRL1_PRESDIV (24U)         /*!< Bit position for CAN_CTRL1_PRESDIV. */
#define BM_CAN_CTRL1_PRESDIV (0xFF000000U) /*!< Bit mask for CAN_CTRL1_PRESDIV. */
#define BS_CAN_CTRL1_PRESDIV (8U)          /*!< Bit field size in bits for CAN_CTRL1_PRESDIV. */

/*! @brief Read current value of the CAN_CTRL1_PRESDIV field. */
#define BR_CAN_CTRL1_PRESDIV(x) (HW_CAN_CTRL1(x).B.PRESDIV)

/*! @brief Format value for bitfield CAN_CTRL1_PRESDIV. */
#define BF_CAN_CTRL1_PRESDIV(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL1_PRESDIV) & BM_CAN_CTRL1_PRESDIV)

/*! @brief Set the PRESDIV field to a new value. */
#define BW_CAN_CTRL1_PRESDIV(x, v) (HW_CAN_CTRL1_WR(x, (HW_CAN_CTRL1_RD(x) & ~BM_CAN_CTRL1_PRESDIV) | BF_CAN_CTRL1_PRESDIV(v)))
/*@}*/

/*******************************************************************************
 * HW_CAN_TIMER - Free Running Timer
 ******************************************************************************/

/*!
 * @brief HW_CAN_TIMER - Free Running Timer (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register represents a 16-bit free running counter that can be read and
 * written by the CPU. The timer starts from 0x0 after Reset, counts linearly to
 * 0xFFFF, and wraps around. The timer is clocked by the FlexCAN bit-clock, which
 * defines the baud rate on the CAN bus. During a message transmission/reception,
 * it increments by one for each bit that is received or transmitted. When there
 * is no message on the bus, it counts using the previously programmed baud
 * rate. The timer is not incremented during Disable , Stop, and Freeze modes. The
 * timer value is captured when the second bit of the identifier field of any frame
 * is on the CAN bus. This captured value is written into the Time Stamp entry
 * in a message buffer after a successful reception or transmission of a message.
 * If bit CTRL1[TSYN] is asserted, the Timer is reset whenever a message is
 * received in the first available Mailbox, according to CTRL2[RFFN] setting. The CPU
 * can write to this register anytime. However, if the write occurs at the same
 * time that the Timer is being reset by a reception in the first Mailbox, then
 * the write value is discarded. Reading this register affects the Mailbox
 * Unlocking procedure; see Section "Mailbox Lock Mechanism".
 */
typedef union _hw_can_timer
{
    uint32_t U;
    struct _hw_can_timer_bitfields
    {
        uint32_t TIMER : 16;           /*!< [15:0] Timer Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_can_timer_t;

/*!
 * @name Constants and macros for entire CAN_TIMER register
 */
/*@{*/
#define HW_CAN_TIMER_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_CAN_TIMER(x)          (*(__IO hw_can_timer_t *) HW_CAN_TIMER_ADDR(x))
#define HW_CAN_TIMER_RD(x)       (HW_CAN_TIMER(x).U)
#define HW_CAN_TIMER_WR(x, v)    (HW_CAN_TIMER(x).U = (v))
#define HW_CAN_TIMER_SET(x, v)   (HW_CAN_TIMER_WR(x, HW_CAN_TIMER_RD(x) |  (v)))
#define HW_CAN_TIMER_CLR(x, v)   (HW_CAN_TIMER_WR(x, HW_CAN_TIMER_RD(x) & ~(v)))
#define HW_CAN_TIMER_TOG(x, v)   (HW_CAN_TIMER_WR(x, HW_CAN_TIMER_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_TIMER bitfields
 */

/*!
 * @name Register CAN_TIMER, field TIMER[15:0] (RW)
 *
 * Contains the free-running counter value.
 */
/*@{*/
#define BP_CAN_TIMER_TIMER   (0U)          /*!< Bit position for CAN_TIMER_TIMER. */
#define BM_CAN_TIMER_TIMER   (0x0000FFFFU) /*!< Bit mask for CAN_TIMER_TIMER. */
#define BS_CAN_TIMER_TIMER   (16U)         /*!< Bit field size in bits for CAN_TIMER_TIMER. */

/*! @brief Read current value of the CAN_TIMER_TIMER field. */
#define BR_CAN_TIMER_TIMER(x) (HW_CAN_TIMER(x).B.TIMER)

/*! @brief Format value for bitfield CAN_TIMER_TIMER. */
#define BF_CAN_TIMER_TIMER(v) ((uint32_t)((uint32_t)(v) << BP_CAN_TIMER_TIMER) & BM_CAN_TIMER_TIMER)

/*! @brief Set the TIMER field to a new value. */
#define BW_CAN_TIMER_TIMER(x, v) (HW_CAN_TIMER_WR(x, (HW_CAN_TIMER_RD(x) & ~BM_CAN_TIMER_TIMER) | BF_CAN_TIMER_TIMER(v)))
/*@}*/

/*******************************************************************************
 * HW_CAN_RXMGMASK - Rx Mailboxes Global Mask Register
 ******************************************************************************/

/*!
 * @brief HW_CAN_RXMGMASK - Rx Mailboxes Global Mask Register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register is located in RAM. RXMGMASK is provided for legacy application
 * support. When the MCR[IRMQ] bit is negated, RXMGMASK is always in effect. When
 * the MCR[IRMQ] bit is asserted, RXMGMASK has no effect. RXMGMASK is used to
 * mask the filter fields of all Rx MBs, excluding MBs 14-15, which have individual
 * mask registers. This register can only be written in Freeze mode as it is
 * blocked by hardware in other modes.
 */
typedef union _hw_can_rxmgmask
{
    uint32_t U;
    struct _hw_can_rxmgmask_bitfields
    {
        uint32_t MG : 32;              /*!< [31:0] Rx Mailboxes Global Mask Bits */
    } B;
} hw_can_rxmgmask_t;

/*!
 * @name Constants and macros for entire CAN_RXMGMASK register
 */
/*@{*/
#define HW_CAN_RXMGMASK_ADDR(x)  ((uint32_t)(x) + 0x10U)

#define HW_CAN_RXMGMASK(x)       (*(__IO hw_can_rxmgmask_t *) HW_CAN_RXMGMASK_ADDR(x))
#define HW_CAN_RXMGMASK_RD(x)    (HW_CAN_RXMGMASK(x).U)
#define HW_CAN_RXMGMASK_WR(x, v) (HW_CAN_RXMGMASK(x).U = (v))
#define HW_CAN_RXMGMASK_SET(x, v) (HW_CAN_RXMGMASK_WR(x, HW_CAN_RXMGMASK_RD(x) |  (v)))
#define HW_CAN_RXMGMASK_CLR(x, v) (HW_CAN_RXMGMASK_WR(x, HW_CAN_RXMGMASK_RD(x) & ~(v)))
#define HW_CAN_RXMGMASK_TOG(x, v) (HW_CAN_RXMGMASK_WR(x, HW_CAN_RXMGMASK_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_RXMGMASK bitfields
 */

/*!
 * @name Register CAN_RXMGMASK, field MG[31:0] (RW)
 *
 * These bits mask the Mailbox filter bits. Note that the alignment with the ID
 * word of the Mailbox is not perfect as the two most significant MG bits affect
 * the fields RTR and IDE, which are located in the Control and Status word of
 * the Mailbox. The following table shows in detail which MG bits mask each Mailbox
 * filter field. SMB[RTR] RTR bit of the Incoming Frame. It is saved into an
 * auxiliary MB called Rx Serial Message Buffer (Rx SMB). CTRL2[RRS] CTRL2[EACEN]
 * Mailbox filter fields MB[RTR] MB[IDE] MB[ID] Reserved 0 - 0 note If the
 * CTRL2[EACEN] bit is negated, the RTR bit of Mailbox is never compared with the RTR bit
 * of the incoming frame. note If the CTRL2[EACEN] bit is negated, the IDE bit
 * of Mailbox is always compared with the IDE bit of the incoming frame. MG[28:0]
 * MG[31:29] 0 - 1 MG[31] MG[30] MG[28:0] MG[29] 1 0 - - - - MG[31:0] 1 1 0 - -
 * MG[28:0] MG[31:29] 1 1 1 MG[31] MG[30] MG[28:0] MG[29]
 *
 * Values:
 * - 0 - The corresponding bit in the filter is "don't care."
 * - 1 - The corresponding bit in the filter is checked.
 */
/*@{*/
#define BP_CAN_RXMGMASK_MG   (0U)          /*!< Bit position for CAN_RXMGMASK_MG. */
#define BM_CAN_RXMGMASK_MG   (0xFFFFFFFFU) /*!< Bit mask for CAN_RXMGMASK_MG. */
#define BS_CAN_RXMGMASK_MG   (32U)         /*!< Bit field size in bits for CAN_RXMGMASK_MG. */

/*! @brief Read current value of the CAN_RXMGMASK_MG field. */
#define BR_CAN_RXMGMASK_MG(x) (HW_CAN_RXMGMASK(x).U)

/*! @brief Format value for bitfield CAN_RXMGMASK_MG. */
#define BF_CAN_RXMGMASK_MG(v) ((uint32_t)((uint32_t)(v) << BP_CAN_RXMGMASK_MG) & BM_CAN_RXMGMASK_MG)

/*! @brief Set the MG field to a new value. */
#define BW_CAN_RXMGMASK_MG(x, v) (HW_CAN_RXMGMASK_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CAN_RX14MASK - Rx 14 Mask register
 ******************************************************************************/

/*!
 * @brief HW_CAN_RX14MASK - Rx 14 Mask register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register is located in RAM. RX14MASK is provided for legacy application
 * support. When the MCR[IRMQ] bit is asserted, RX14MASK has no effect. RX14MASK
 * is used to mask the filter fields of Message Buffer 14. This register can only
 * be programmed while the module is in Freeze mode as it is blocked by hardware
 * in other modes.
 */
typedef union _hw_can_rx14mask
{
    uint32_t U;
    struct _hw_can_rx14mask_bitfields
    {
        uint32_t RX14M : 32;           /*!< [31:0] Rx Buffer 14 Mask Bits */
    } B;
} hw_can_rx14mask_t;

/*!
 * @name Constants and macros for entire CAN_RX14MASK register
 */
/*@{*/
#define HW_CAN_RX14MASK_ADDR(x)  ((uint32_t)(x) + 0x14U)

#define HW_CAN_RX14MASK(x)       (*(__IO hw_can_rx14mask_t *) HW_CAN_RX14MASK_ADDR(x))
#define HW_CAN_RX14MASK_RD(x)    (HW_CAN_RX14MASK(x).U)
#define HW_CAN_RX14MASK_WR(x, v) (HW_CAN_RX14MASK(x).U = (v))
#define HW_CAN_RX14MASK_SET(x, v) (HW_CAN_RX14MASK_WR(x, HW_CAN_RX14MASK_RD(x) |  (v)))
#define HW_CAN_RX14MASK_CLR(x, v) (HW_CAN_RX14MASK_WR(x, HW_CAN_RX14MASK_RD(x) & ~(v)))
#define HW_CAN_RX14MASK_TOG(x, v) (HW_CAN_RX14MASK_WR(x, HW_CAN_RX14MASK_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_RX14MASK bitfields
 */

/*!
 * @name Register CAN_RX14MASK, field RX14M[31:0] (RW)
 *
 * Each mask bit masks the corresponding Mailbox 14 filter field in the same way
 * that RXMGMASK masks other Mailboxes' filters. See the description of the
 * CAN_RXMGMASK register.
 *
 * Values:
 * - 0 - The corresponding bit in the filter is "don't care."
 * - 1 - The corresponding bit in the filter is checked.
 */
/*@{*/
#define BP_CAN_RX14MASK_RX14M (0U)         /*!< Bit position for CAN_RX14MASK_RX14M. */
#define BM_CAN_RX14MASK_RX14M (0xFFFFFFFFU) /*!< Bit mask for CAN_RX14MASK_RX14M. */
#define BS_CAN_RX14MASK_RX14M (32U)        /*!< Bit field size in bits for CAN_RX14MASK_RX14M. */

/*! @brief Read current value of the CAN_RX14MASK_RX14M field. */
#define BR_CAN_RX14MASK_RX14M(x) (HW_CAN_RX14MASK(x).U)

/*! @brief Format value for bitfield CAN_RX14MASK_RX14M. */
#define BF_CAN_RX14MASK_RX14M(v) ((uint32_t)((uint32_t)(v) << BP_CAN_RX14MASK_RX14M) & BM_CAN_RX14MASK_RX14M)

/*! @brief Set the RX14M field to a new value. */
#define BW_CAN_RX14MASK_RX14M(x, v) (HW_CAN_RX14MASK_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CAN_RX15MASK - Rx 15 Mask register
 ******************************************************************************/

/*!
 * @brief HW_CAN_RX15MASK - Rx 15 Mask register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register is located in RAM. RX15MASK is provided for legacy application
 * support. When the MCR[IRMQ] bit is asserted, RX15MASK has no effect. RX15MASK
 * is used to mask the filter fields of Message Buffer 15. This register can be
 * programmed only while the module is in Freeze mode because it is blocked by
 * hardware in other modes.
 */
typedef union _hw_can_rx15mask
{
    uint32_t U;
    struct _hw_can_rx15mask_bitfields
    {
        uint32_t RX15M : 32;           /*!< [31:0] Rx Buffer 15 Mask Bits */
    } B;
} hw_can_rx15mask_t;

/*!
 * @name Constants and macros for entire CAN_RX15MASK register
 */
/*@{*/
#define HW_CAN_RX15MASK_ADDR(x)  ((uint32_t)(x) + 0x18U)

#define HW_CAN_RX15MASK(x)       (*(__IO hw_can_rx15mask_t *) HW_CAN_RX15MASK_ADDR(x))
#define HW_CAN_RX15MASK_RD(x)    (HW_CAN_RX15MASK(x).U)
#define HW_CAN_RX15MASK_WR(x, v) (HW_CAN_RX15MASK(x).U = (v))
#define HW_CAN_RX15MASK_SET(x, v) (HW_CAN_RX15MASK_WR(x, HW_CAN_RX15MASK_RD(x) |  (v)))
#define HW_CAN_RX15MASK_CLR(x, v) (HW_CAN_RX15MASK_WR(x, HW_CAN_RX15MASK_RD(x) & ~(v)))
#define HW_CAN_RX15MASK_TOG(x, v) (HW_CAN_RX15MASK_WR(x, HW_CAN_RX15MASK_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_RX15MASK bitfields
 */

/*!
 * @name Register CAN_RX15MASK, field RX15M[31:0] (RW)
 *
 * Each mask bit masks the corresponding Mailbox 15 filter field in the same way
 * that RXMGMASK masks other Mailboxes' filters. See the description of the
 * CAN_RXMGMASK register.
 *
 * Values:
 * - 0 - The corresponding bit in the filter is "don't care."
 * - 1 - The corresponding bit in the filter is checked.
 */
/*@{*/
#define BP_CAN_RX15MASK_RX15M (0U)         /*!< Bit position for CAN_RX15MASK_RX15M. */
#define BM_CAN_RX15MASK_RX15M (0xFFFFFFFFU) /*!< Bit mask for CAN_RX15MASK_RX15M. */
#define BS_CAN_RX15MASK_RX15M (32U)        /*!< Bit field size in bits for CAN_RX15MASK_RX15M. */

/*! @brief Read current value of the CAN_RX15MASK_RX15M field. */
#define BR_CAN_RX15MASK_RX15M(x) (HW_CAN_RX15MASK(x).U)

/*! @brief Format value for bitfield CAN_RX15MASK_RX15M. */
#define BF_CAN_RX15MASK_RX15M(v) ((uint32_t)((uint32_t)(v) << BP_CAN_RX15MASK_RX15M) & BM_CAN_RX15MASK_RX15M)

/*! @brief Set the RX15M field to a new value. */
#define BW_CAN_RX15MASK_RX15M(x, v) (HW_CAN_RX15MASK_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CAN_ECR - Error Counter
 ******************************************************************************/

/*!
 * @brief HW_CAN_ECR - Error Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has two 8-bit fields reflecting the value of two FlexCAN error
 * counters: Transmit Error Counter (TXERRCNT field) and Receive Error Counter
 * (RXERRCNT field). The rules for increasing and decreasing these counters are
 * described in the CAN protocol and are completely implemented in the FlexCAN
 * module. Both counters are read-only except in Freeze mode, where they can be
 * written by the CPU. FlexCAN responds to any bus state as described in the protocol,
 * for example, transmit Error Active or Error Passive flag, delay its
 * transmission start time (Error Passive) and avoid any influence on the bus when in Bus
 * Off state. The following are the basic rules for FlexCAN bus state transitions:
 * If the value of TXERRCNT or RXERRCNT increases to be greater than or equal to
 * 128, the FLTCONF field in the Error and Status Register is updated to reflect
 * 'Error Passive' state. If the FlexCAN state is 'Error Passive', and either
 * TXERRCNT or RXERRCNT decrements to a value less than or equal to 127 while the
 * other already satisfies this condition, the FLTCONF field in the Error and
 * Status Register is updated to reflect 'Error Active' state. If the value of
 * TXERRCNT increases to be greater than 255, the FLTCONF field in the Error and Status
 * Register is updated to reflect 'Bus Off' state, and an interrupt may be
 * issued. The value of TXERRCNT is then reset to zero. If FlexCAN is in 'Bus Off'
 * state, then TXERRCNT is cascaded together with another internal counter to count
 * the 128th occurrences of 11 consecutive recessive bits on the bus. Hence,
 * TXERRCNT is reset to zero and counts in a manner where the internal counter counts
 * 11 such bits and then wraps around while incrementing the TXERRCNT. When
 * TXERRCNT reaches the value of 128, the FLTCONF field in the Error and Status
 * Register is updated to be 'Error Active' and both error counters are reset to zero.
 * At any instance of dominant bit following a stream of less than 11
 * consecutive recessive bits, the internal counter resets itself to zero without affecting
 * the TXERRCNT value. If during system start-up, only one node is operating,
 * then its TXERRCNT increases in each message it is trying to transmit, as a
 * result of acknowledge errors (indicated by the ACKERR bit in the Error and Status
 * Register). After the transition to 'Error Passive' state, the TXERRCNT does not
 * increment anymore by acknowledge errors. Therefore the device never goes to
 * the 'Bus Off' state. If the RXERRCNT increases to a value greater than 127, it
 * is not incremented further, even if more errors are detected while being a
 * receiver. At the next successful message reception, the counter is set to a value
 * between 119 and 127 to resume to 'Error Active' state.
 */
typedef union _hw_can_ecr
{
    uint32_t U;
    struct _hw_can_ecr_bitfields
    {
        uint32_t TXERRCNT : 8;         /*!< [7:0] Transmit Error Counter */
        uint32_t RXERRCNT : 8;         /*!< [15:8] Receive Error Counter */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_can_ecr_t;

/*!
 * @name Constants and macros for entire CAN_ECR register
 */
/*@{*/
#define HW_CAN_ECR_ADDR(x)       ((uint32_t)(x) + 0x1CU)

#define HW_CAN_ECR(x)            (*(__IO hw_can_ecr_t *) HW_CAN_ECR_ADDR(x))
#define HW_CAN_ECR_RD(x)         (HW_CAN_ECR(x).U)
#define HW_CAN_ECR_WR(x, v)      (HW_CAN_ECR(x).U = (v))
#define HW_CAN_ECR_SET(x, v)     (HW_CAN_ECR_WR(x, HW_CAN_ECR_RD(x) |  (v)))
#define HW_CAN_ECR_CLR(x, v)     (HW_CAN_ECR_WR(x, HW_CAN_ECR_RD(x) & ~(v)))
#define HW_CAN_ECR_TOG(x, v)     (HW_CAN_ECR_WR(x, HW_CAN_ECR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_ECR bitfields
 */

/*!
 * @name Register CAN_ECR, field TXERRCNT[7:0] (RW)
 */
/*@{*/
#define BP_CAN_ECR_TXERRCNT  (0U)          /*!< Bit position for CAN_ECR_TXERRCNT. */
#define BM_CAN_ECR_TXERRCNT  (0x000000FFU) /*!< Bit mask for CAN_ECR_TXERRCNT. */
#define BS_CAN_ECR_TXERRCNT  (8U)          /*!< Bit field size in bits for CAN_ECR_TXERRCNT. */

/*! @brief Read current value of the CAN_ECR_TXERRCNT field. */
#define BR_CAN_ECR_TXERRCNT(x) (HW_CAN_ECR(x).B.TXERRCNT)

/*! @brief Format value for bitfield CAN_ECR_TXERRCNT. */
#define BF_CAN_ECR_TXERRCNT(v) ((uint32_t)((uint32_t)(v) << BP_CAN_ECR_TXERRCNT) & BM_CAN_ECR_TXERRCNT)

/*! @brief Set the TXERRCNT field to a new value. */
#define BW_CAN_ECR_TXERRCNT(x, v) (HW_CAN_ECR_WR(x, (HW_CAN_ECR_RD(x) & ~BM_CAN_ECR_TXERRCNT) | BF_CAN_ECR_TXERRCNT(v)))
/*@}*/

/*!
 * @name Register CAN_ECR, field RXERRCNT[15:8] (RW)
 */
/*@{*/
#define BP_CAN_ECR_RXERRCNT  (8U)          /*!< Bit position for CAN_ECR_RXERRCNT. */
#define BM_CAN_ECR_RXERRCNT  (0x0000FF00U) /*!< Bit mask for CAN_ECR_RXERRCNT. */
#define BS_CAN_ECR_RXERRCNT  (8U)          /*!< Bit field size in bits for CAN_ECR_RXERRCNT. */

/*! @brief Read current value of the CAN_ECR_RXERRCNT field. */
#define BR_CAN_ECR_RXERRCNT(x) (HW_CAN_ECR(x).B.RXERRCNT)

/*! @brief Format value for bitfield CAN_ECR_RXERRCNT. */
#define BF_CAN_ECR_RXERRCNT(v) ((uint32_t)((uint32_t)(v) << BP_CAN_ECR_RXERRCNT) & BM_CAN_ECR_RXERRCNT)

/*! @brief Set the RXERRCNT field to a new value. */
#define BW_CAN_ECR_RXERRCNT(x, v) (HW_CAN_ECR_WR(x, (HW_CAN_ECR_RD(x) & ~BM_CAN_ECR_RXERRCNT) | BF_CAN_ECR_RXERRCNT(v)))
/*@}*/

/*******************************************************************************
 * HW_CAN_ESR1 - Error and Status 1 register
 ******************************************************************************/

/*!
 * @brief HW_CAN_ESR1 - Error and Status 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register reflects various error conditions, some general status of the
 * device and it is the source of interrupts to the CPU. The CPU read action
 * clears bits 15-10. Therefore the reported error conditions (bits 15-10) are those
 * that occurred since the last time the CPU read this register. Bits 9-3 are
 * status bits. The following table shows the FlexCAN state variables and their
 * meanings. Other combinations not shown in the table are reserved. SYNCH IDLE TX RX
 * FlexCAN State 0 0 0 0 Not synchronized to CAN bus 1 1 x x Idle 1 0 1 0
 * Transmitting 1 0 0 1 Receiving
 */
typedef union _hw_can_esr1
{
    uint32_t U;
    struct _hw_can_esr1_bitfields
    {
        uint32_t WAKINT : 1;           /*!< [0] Wake-Up Interrupt */
        uint32_t ERRINT : 1;           /*!< [1] Error Interrupt */
        uint32_t BOFFINT : 1;          /*!< [2] Bus Off Interrupt */
        uint32_t RX : 1;               /*!< [3] FlexCAN In Reception */
        uint32_t FLTCONF : 2;          /*!< [5:4] Fault Confinement State */
        uint32_t TX : 1;               /*!< [6] FlexCAN In Transmission */
        uint32_t IDLE : 1;             /*!< [7]  */
        uint32_t RXWRN : 1;            /*!< [8] Rx Error Warning */
        uint32_t TXWRN : 1;            /*!< [9] TX Error Warning */
        uint32_t STFERR : 1;           /*!< [10] Stuffing Error */
        uint32_t FRMERR : 1;           /*!< [11] Form Error */
        uint32_t CRCERR : 1;           /*!< [12] Cyclic Redundancy Check Error */
        uint32_t ACKERR : 1;           /*!< [13] Acknowledge Error */
        uint32_t BIT0ERR : 1;          /*!< [14] Bit0 Error */
        uint32_t BIT1ERR : 1;          /*!< [15] Bit1 Error */
        uint32_t RWRNINT : 1;          /*!< [16] Rx Warning Interrupt Flag */
        uint32_t TWRNINT : 1;          /*!< [17] Tx Warning Interrupt Flag */
        uint32_t SYNCH : 1;            /*!< [18] CAN Synchronization Status */
        uint32_t RESERVED0 : 13;       /*!< [31:19]  */
    } B;
} hw_can_esr1_t;

/*!
 * @name Constants and macros for entire CAN_ESR1 register
 */
/*@{*/
#define HW_CAN_ESR1_ADDR(x)      ((uint32_t)(x) + 0x20U)

#define HW_CAN_ESR1(x)           (*(__IO hw_can_esr1_t *) HW_CAN_ESR1_ADDR(x))
#define HW_CAN_ESR1_RD(x)        (HW_CAN_ESR1(x).U)
#define HW_CAN_ESR1_WR(x, v)     (HW_CAN_ESR1(x).U = (v))
#define HW_CAN_ESR1_SET(x, v)    (HW_CAN_ESR1_WR(x, HW_CAN_ESR1_RD(x) |  (v)))
#define HW_CAN_ESR1_CLR(x, v)    (HW_CAN_ESR1_WR(x, HW_CAN_ESR1_RD(x) & ~(v)))
#define HW_CAN_ESR1_TOG(x, v)    (HW_CAN_ESR1_WR(x, HW_CAN_ESR1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_ESR1 bitfields
 */

/*!
 * @name Register CAN_ESR1, field WAKINT[0] (W1C)
 *
 * This field applies when FlexCAN is in low-power mode under Self Wake Up
 * mechanism: Stop mode When a recessive-to-dominant transition is detected on the CAN
 * bus and if the MCR[WAKMSK] bit is set, an interrupt is generated to the CPU.
 * This bit is cleared by writing it to 1. When MCR[SLFWAK] is negated, this flag
 * is masked. The CPU must clear this flag before disabling the bit. Otherwise
 * it will be set when the SLFWAK is set again. Writing 0 has no effect.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - Indicates a recessive to dominant transition was received on the CAN
 *     bus.
 */
/*@{*/
#define BP_CAN_ESR1_WAKINT   (0U)          /*!< Bit position for CAN_ESR1_WAKINT. */
#define BM_CAN_ESR1_WAKINT   (0x00000001U) /*!< Bit mask for CAN_ESR1_WAKINT. */
#define BS_CAN_ESR1_WAKINT   (1U)          /*!< Bit field size in bits for CAN_ESR1_WAKINT. */

/*! @brief Read current value of the CAN_ESR1_WAKINT field. */
#define BR_CAN_ESR1_WAKINT(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_WAKINT))

/*! @brief Format value for bitfield CAN_ESR1_WAKINT. */
#define BF_CAN_ESR1_WAKINT(v) ((uint32_t)((uint32_t)(v) << BP_CAN_ESR1_WAKINT) & BM_CAN_ESR1_WAKINT)

/*! @brief Set the WAKINT field to a new value. */
#define BW_CAN_ESR1_WAKINT(x, v) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_WAKINT) = (v))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ERRINT[1] (W1C)
 *
 * This bit indicates that at least one of the Error Bits (bits 15-10) is set.
 * If the corresponding mask bit CTRL1[ERRMSK] is set, an interrupt is generated
 * to the CPU. This bit is cleared by writing it to 1. Writing 0 has no effect.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - Indicates setting of any Error Bit in the Error and Status Register.
 */
/*@{*/
#define BP_CAN_ESR1_ERRINT   (1U)          /*!< Bit position for CAN_ESR1_ERRINT. */
#define BM_CAN_ESR1_ERRINT   (0x00000002U) /*!< Bit mask for CAN_ESR1_ERRINT. */
#define BS_CAN_ESR1_ERRINT   (1U)          /*!< Bit field size in bits for CAN_ESR1_ERRINT. */

/*! @brief Read current value of the CAN_ESR1_ERRINT field. */
#define BR_CAN_ESR1_ERRINT(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_ERRINT))

/*! @brief Format value for bitfield CAN_ESR1_ERRINT. */
#define BF_CAN_ESR1_ERRINT(v) ((uint32_t)((uint32_t)(v) << BP_CAN_ESR1_ERRINT) & BM_CAN_ESR1_ERRINT)

/*! @brief Set the ERRINT field to a new value. */
#define BW_CAN_ESR1_ERRINT(x, v) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_ERRINT) = (v))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BOFFINT[2] (W1C)
 *
 * This bit is set when FlexCAN enters 'Bus Off' state. If the corresponding
 * mask bit in the Control Register (BOFFMSK) is set, an interrupt is generated to
 * the CPU. This bit is cleared by writing it to 1. Writing 0 has no effect.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - FlexCAN module entered Bus Off state.
 */
/*@{*/
#define BP_CAN_ESR1_BOFFINT  (2U)          /*!< Bit position for CAN_ESR1_BOFFINT. */
#define BM_CAN_ESR1_BOFFINT  (0x00000004U) /*!< Bit mask for CAN_ESR1_BOFFINT. */
#define BS_CAN_ESR1_BOFFINT  (1U)          /*!< Bit field size in bits for CAN_ESR1_BOFFINT. */

/*! @brief Read current value of the CAN_ESR1_BOFFINT field. */
#define BR_CAN_ESR1_BOFFINT(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_BOFFINT))

/*! @brief Format value for bitfield CAN_ESR1_BOFFINT. */
#define BF_CAN_ESR1_BOFFINT(v) ((uint32_t)((uint32_t)(v) << BP_CAN_ESR1_BOFFINT) & BM_CAN_ESR1_BOFFINT)

/*! @brief Set the BOFFINT field to a new value. */
#define BW_CAN_ESR1_BOFFINT(x, v) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_BOFFINT) = (v))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RX[3] (RO)
 *
 * This bit indicates if FlexCAN is receiving a message. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0 - FlexCAN is not receiving a message.
 * - 1 - FlexCAN is receiving a message.
 */
/*@{*/
#define BP_CAN_ESR1_RX       (3U)          /*!< Bit position for CAN_ESR1_RX. */
#define BM_CAN_ESR1_RX       (0x00000008U) /*!< Bit mask for CAN_ESR1_RX. */
#define BS_CAN_ESR1_RX       (1U)          /*!< Bit field size in bits for CAN_ESR1_RX. */

/*! @brief Read current value of the CAN_ESR1_RX field. */
#define BR_CAN_ESR1_RX(x)    (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_RX))
/*@}*/

/*!
 * @name Register CAN_ESR1, field FLTCONF[5:4] (RO)
 *
 * This 2-bit field indicates the Confinement State of the FlexCAN module. If
 * the LOM bit in the Control Register is asserted, after some delay that depends
 * on the CAN bit timing the FLTCONF field will indicate "Error Passive". The very
 * same delay affects the way how FLTCONF reflects an update to ECR register by
 * the CPU. It may be necessary up to one CAN bit time to get them coherent
 * again. Because the Control Register is not affected by soft reset, the FLTCONF
 * field will not be affected by soft reset if the LOM bit is asserted.
 *
 * Values:
 * - 00 - Error Active
 * - 01 - Error Passive
 * - 1x - Bus Off
 */
/*@{*/
#define BP_CAN_ESR1_FLTCONF  (4U)          /*!< Bit position for CAN_ESR1_FLTCONF. */
#define BM_CAN_ESR1_FLTCONF  (0x00000030U) /*!< Bit mask for CAN_ESR1_FLTCONF. */
#define BS_CAN_ESR1_FLTCONF  (2U)          /*!< Bit field size in bits for CAN_ESR1_FLTCONF. */

/*! @brief Read current value of the CAN_ESR1_FLTCONF field. */
#define BR_CAN_ESR1_FLTCONF(x) (HW_CAN_ESR1(x).B.FLTCONF)
/*@}*/

/*!
 * @name Register CAN_ESR1, field TX[6] (RO)
 *
 * This bit indicates if FlexCAN is transmitting a message. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0 - FlexCAN is not transmitting a message.
 * - 1 - FlexCAN is transmitting a message.
 */
/*@{*/
#define BP_CAN_ESR1_TX       (6U)          /*!< Bit position for CAN_ESR1_TX. */
#define BM_CAN_ESR1_TX       (0x00000040U) /*!< Bit mask for CAN_ESR1_TX. */
#define BS_CAN_ESR1_TX       (1U)          /*!< Bit field size in bits for CAN_ESR1_TX. */

/*! @brief Read current value of the CAN_ESR1_TX field. */
#define BR_CAN_ESR1_TX(x)    (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_TX))
/*@}*/

/*!
 * @name Register CAN_ESR1, field IDLE[7] (RO)
 *
 * This bit indicates when CAN bus is in IDLE state. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - CAN bus is now IDLE.
 */
/*@{*/
#define BP_CAN_ESR1_IDLE     (7U)          /*!< Bit position for CAN_ESR1_IDLE. */
#define BM_CAN_ESR1_IDLE     (0x00000080U) /*!< Bit mask for CAN_ESR1_IDLE. */
#define BS_CAN_ESR1_IDLE     (1U)          /*!< Bit field size in bits for CAN_ESR1_IDLE. */

/*! @brief Read current value of the CAN_ESR1_IDLE field. */
#define BR_CAN_ESR1_IDLE(x)  (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_IDLE))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RXWRN[8] (RO)
 *
 * This bit indicates when repetitive errors are occurring during message
 * reception. This bit is not updated during Freeze mode.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - RXERRCNT is greater than or equal to 96.
 */
/*@{*/
#define BP_CAN_ESR1_RXWRN    (8U)          /*!< Bit position for CAN_ESR1_RXWRN. */
#define BM_CAN_ESR1_RXWRN    (0x00000100U) /*!< Bit mask for CAN_ESR1_RXWRN. */
#define BS_CAN_ESR1_RXWRN    (1U)          /*!< Bit field size in bits for CAN_ESR1_RXWRN. */

/*! @brief Read current value of the CAN_ESR1_RXWRN field. */
#define BR_CAN_ESR1_RXWRN(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_RXWRN))
/*@}*/

/*!
 * @name Register CAN_ESR1, field TXWRN[9] (RO)
 *
 * This bit indicates when repetitive errors are occurring during message
 * transmission. This bit is not updated during Freeze mode.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - TXERRCNT is greater than or equal to 96.
 */
/*@{*/
#define BP_CAN_ESR1_TXWRN    (9U)          /*!< Bit position for CAN_ESR1_TXWRN. */
#define BM_CAN_ESR1_TXWRN    (0x00000200U) /*!< Bit mask for CAN_ESR1_TXWRN. */
#define BS_CAN_ESR1_TXWRN    (1U)          /*!< Bit field size in bits for CAN_ESR1_TXWRN. */

/*! @brief Read current value of the CAN_ESR1_TXWRN field. */
#define BR_CAN_ESR1_TXWRN(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_TXWRN))
/*@}*/

/*!
 * @name Register CAN_ESR1, field STFERR[10] (RO)
 *
 * This bit indicates that a Stuffing Error has been etected.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - A Stuffing Error occurred since last read of this register.
 */
/*@{*/
#define BP_CAN_ESR1_STFERR   (10U)         /*!< Bit position for CAN_ESR1_STFERR. */
#define BM_CAN_ESR1_STFERR   (0x00000400U) /*!< Bit mask for CAN_ESR1_STFERR. */
#define BS_CAN_ESR1_STFERR   (1U)          /*!< Bit field size in bits for CAN_ESR1_STFERR. */

/*! @brief Read current value of the CAN_ESR1_STFERR field. */
#define BR_CAN_ESR1_STFERR(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_STFERR))
/*@}*/

/*!
 * @name Register CAN_ESR1, field FRMERR[11] (RO)
 *
 * This bit indicates that a Form Error has been detected by the receiver node,
 * that is, a fixed-form bit field contains at least one illegal bit.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - A Form Error occurred since last read of this register.
 */
/*@{*/
#define BP_CAN_ESR1_FRMERR   (11U)         /*!< Bit position for CAN_ESR1_FRMERR. */
#define BM_CAN_ESR1_FRMERR   (0x00000800U) /*!< Bit mask for CAN_ESR1_FRMERR. */
#define BS_CAN_ESR1_FRMERR   (1U)          /*!< Bit field size in bits for CAN_ESR1_FRMERR. */

/*! @brief Read current value of the CAN_ESR1_FRMERR field. */
#define BR_CAN_ESR1_FRMERR(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_FRMERR))
/*@}*/

/*!
 * @name Register CAN_ESR1, field CRCERR[12] (RO)
 *
 * This bit indicates that a CRC Error has been detected by the receiver node,
 * that is, the calculated CRC is different from the received.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - A CRC error occurred since last read of this register.
 */
/*@{*/
#define BP_CAN_ESR1_CRCERR   (12U)         /*!< Bit position for CAN_ESR1_CRCERR. */
#define BM_CAN_ESR1_CRCERR   (0x00001000U) /*!< Bit mask for CAN_ESR1_CRCERR. */
#define BS_CAN_ESR1_CRCERR   (1U)          /*!< Bit field size in bits for CAN_ESR1_CRCERR. */

/*! @brief Read current value of the CAN_ESR1_CRCERR field. */
#define BR_CAN_ESR1_CRCERR(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_CRCERR))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ACKERR[13] (RO)
 *
 * This bit indicates that an Acknowledge Error has been detected by the
 * transmitter node, that is, a dominant bit has not been detected during the ACK SLOT.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - An ACK error occurred since last read of this register.
 */
/*@{*/
#define BP_CAN_ESR1_ACKERR   (13U)         /*!< Bit position for CAN_ESR1_ACKERR. */
#define BM_CAN_ESR1_ACKERR   (0x00002000U) /*!< Bit mask for CAN_ESR1_ACKERR. */
#define BS_CAN_ESR1_ACKERR   (1U)          /*!< Bit field size in bits for CAN_ESR1_ACKERR. */

/*! @brief Read current value of the CAN_ESR1_ACKERR field. */
#define BR_CAN_ESR1_ACKERR(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_ACKERR))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BIT0ERR[14] (RO)
 *
 * This bit indicates when an inconsistency occurs between the transmitted and
 * the received bit in a message.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - At least one bit sent as dominant is received as recessive.
 */
/*@{*/
#define BP_CAN_ESR1_BIT0ERR  (14U)         /*!< Bit position for CAN_ESR1_BIT0ERR. */
#define BM_CAN_ESR1_BIT0ERR  (0x00004000U) /*!< Bit mask for CAN_ESR1_BIT0ERR. */
#define BS_CAN_ESR1_BIT0ERR  (1U)          /*!< Bit field size in bits for CAN_ESR1_BIT0ERR. */

/*! @brief Read current value of the CAN_ESR1_BIT0ERR field. */
#define BR_CAN_ESR1_BIT0ERR(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_BIT0ERR))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BIT1ERR[15] (RO)
 *
 * This bit indicates when an inconsistency occurs between the transmitted and
 * the received bit in a message. This bit is not set by a transmitter in case of
 * arbitration field or ACK slot, or in case of a node sending a passive error
 * flag that detects dominant bits.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - At least one bit sent as recessive is received as dominant.
 */
/*@{*/
#define BP_CAN_ESR1_BIT1ERR  (15U)         /*!< Bit position for CAN_ESR1_BIT1ERR. */
#define BM_CAN_ESR1_BIT1ERR  (0x00008000U) /*!< Bit mask for CAN_ESR1_BIT1ERR. */
#define BS_CAN_ESR1_BIT1ERR  (1U)          /*!< Bit field size in bits for CAN_ESR1_BIT1ERR. */

/*! @brief Read current value of the CAN_ESR1_BIT1ERR field. */
#define BR_CAN_ESR1_BIT1ERR(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_BIT1ERR))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RWRNINT[16] (W1C)
 *
 * If the WRNEN bit in MCR is asserted, the RWRNINT bit is set when the RXWRN
 * flag transitions from 0 to 1, meaning that the Rx error counters reached 96. If
 * the corresponding mask bit in the Control Register (RWRNMSK) is set, an
 * interrupt is generated to the CPU. This bit is cleared by writing it to 1. When
 * WRNEN is negated, this flag is masked. CPU must clear this flag before disabling
 * the bit. Otherwise it will be set when the WRNEN is set again. Writing 0 has no
 * effect. This bit is not updated during Freeze mode.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - The Rx error counter transitioned from less than 96 to greater than or
 *     equal to 96.
 */
/*@{*/
#define BP_CAN_ESR1_RWRNINT  (16U)         /*!< Bit position for CAN_ESR1_RWRNINT. */
#define BM_CAN_ESR1_RWRNINT  (0x00010000U) /*!< Bit mask for CAN_ESR1_RWRNINT. */
#define BS_CAN_ESR1_RWRNINT  (1U)          /*!< Bit field size in bits for CAN_ESR1_RWRNINT. */

/*! @brief Read current value of the CAN_ESR1_RWRNINT field. */
#define BR_CAN_ESR1_RWRNINT(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_RWRNINT))

/*! @brief Format value for bitfield CAN_ESR1_RWRNINT. */
#define BF_CAN_ESR1_RWRNINT(v) ((uint32_t)((uint32_t)(v) << BP_CAN_ESR1_RWRNINT) & BM_CAN_ESR1_RWRNINT)

/*! @brief Set the RWRNINT field to a new value. */
#define BW_CAN_ESR1_RWRNINT(x, v) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_RWRNINT) = (v))
/*@}*/

/*!
 * @name Register CAN_ESR1, field TWRNINT[17] (W1C)
 *
 * If the WRNEN bit in MCR is asserted, the TWRNINT bit is set when the TXWRN
 * flag transitions from 0 to 1, meaning that the Tx error counter reached 96. If
 * the corresponding mask bit in the Control Register (TWRNMSK) is set, an
 * interrupt is generated to the CPU. This bit is cleared by writing it to 1. When WRNEN
 * is negated, this flag is masked. CPU must clear this flag before disabling
 * the bit. Otherwise it will be set when the WRNEN is set again. Writing 0 has no
 * effect. This flag is not generated during Bus Off state. This bit is not
 * updated during Freeze mode.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - The Tx error counter transitioned from less than 96 to greater than or
 *     equal to 96.
 */
/*@{*/
#define BP_CAN_ESR1_TWRNINT  (17U)         /*!< Bit position for CAN_ESR1_TWRNINT. */
#define BM_CAN_ESR1_TWRNINT  (0x00020000U) /*!< Bit mask for CAN_ESR1_TWRNINT. */
#define BS_CAN_ESR1_TWRNINT  (1U)          /*!< Bit field size in bits for CAN_ESR1_TWRNINT. */

/*! @brief Read current value of the CAN_ESR1_TWRNINT field. */
#define BR_CAN_ESR1_TWRNINT(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_TWRNINT))

/*! @brief Format value for bitfield CAN_ESR1_TWRNINT. */
#define BF_CAN_ESR1_TWRNINT(v) ((uint32_t)((uint32_t)(v) << BP_CAN_ESR1_TWRNINT) & BM_CAN_ESR1_TWRNINT)

/*! @brief Set the TWRNINT field to a new value. */
#define BW_CAN_ESR1_TWRNINT(x, v) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_TWRNINT) = (v))
/*@}*/

/*!
 * @name Register CAN_ESR1, field SYNCH[18] (RO)
 *
 * This read-only flag indicates whether the FlexCAN is synchronized to the CAN
 * bus and able to participate in the communication process. It is set and
 * cleared by the FlexCAN. See the table in the overall CAN_ESR1 register description.
 *
 * Values:
 * - 0 - FlexCAN is not synchronized to the CAN bus.
 * - 1 - FlexCAN is synchronized to the CAN bus.
 */
/*@{*/
#define BP_CAN_ESR1_SYNCH    (18U)         /*!< Bit position for CAN_ESR1_SYNCH. */
#define BM_CAN_ESR1_SYNCH    (0x00040000U) /*!< Bit mask for CAN_ESR1_SYNCH. */
#define BS_CAN_ESR1_SYNCH    (1U)          /*!< Bit field size in bits for CAN_ESR1_SYNCH. */

/*! @brief Read current value of the CAN_ESR1_SYNCH field. */
#define BR_CAN_ESR1_SYNCH(x) (BITBAND_ACCESS32(HW_CAN_ESR1_ADDR(x), BP_CAN_ESR1_SYNCH))
/*@}*/

/*******************************************************************************
 * HW_CAN_IMASK1 - Interrupt Masks 1 register
 ******************************************************************************/

/*!
 * @brief HW_CAN_IMASK1 - Interrupt Masks 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register allows any number of a range of the 32 Message Buffer
 * Interrupts to be enabled or disabled for MB31 to MB0. It contains one interrupt mask
 * bit per buffer, enabling the CPU to determine which buffer generates an
 * interrupt after a successful transmission or reception, that is, when the
 * corresponding IFLAG1 bit is set.
 */
typedef union _hw_can_imask1
{
    uint32_t U;
    struct _hw_can_imask1_bitfields
    {
        uint32_t BUFLM : 32;           /*!< [31:0] Buffer MB i Mask */
    } B;
} hw_can_imask1_t;

/*!
 * @name Constants and macros for entire CAN_IMASK1 register
 */
/*@{*/
#define HW_CAN_IMASK1_ADDR(x)    ((uint32_t)(x) + 0x28U)

#define HW_CAN_IMASK1(x)         (*(__IO hw_can_imask1_t *) HW_CAN_IMASK1_ADDR(x))
#define HW_CAN_IMASK1_RD(x)      (HW_CAN_IMASK1(x).U)
#define HW_CAN_IMASK1_WR(x, v)   (HW_CAN_IMASK1(x).U = (v))
#define HW_CAN_IMASK1_SET(x, v)  (HW_CAN_IMASK1_WR(x, HW_CAN_IMASK1_RD(x) |  (v)))
#define HW_CAN_IMASK1_CLR(x, v)  (HW_CAN_IMASK1_WR(x, HW_CAN_IMASK1_RD(x) & ~(v)))
#define HW_CAN_IMASK1_TOG(x, v)  (HW_CAN_IMASK1_WR(x, HW_CAN_IMASK1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_IMASK1 bitfields
 */

/*!
 * @name Register CAN_IMASK1, field BUFLM[31:0] (RW)
 *
 * Each bit enables or disables the corresponding FlexCAN Message Buffer
 * Interrupt for MB31 to MB0. Setting or clearing a bit in the IMASK1 Register can
 * assert or negate an interrupt request, if the corresponding IFLAG1 bit is set.
 *
 * Values:
 * - 0 - The corresponding buffer Interrupt is disabled.
 * - 1 - The corresponding buffer Interrupt is enabled.
 */
/*@{*/
#define BP_CAN_IMASK1_BUFLM  (0U)          /*!< Bit position for CAN_IMASK1_BUFLM. */
#define BM_CAN_IMASK1_BUFLM  (0xFFFFFFFFU) /*!< Bit mask for CAN_IMASK1_BUFLM. */
#define BS_CAN_IMASK1_BUFLM  (32U)         /*!< Bit field size in bits for CAN_IMASK1_BUFLM. */

/*! @brief Read current value of the CAN_IMASK1_BUFLM field. */
#define BR_CAN_IMASK1_BUFLM(x) (HW_CAN_IMASK1(x).U)

/*! @brief Format value for bitfield CAN_IMASK1_BUFLM. */
#define BF_CAN_IMASK1_BUFLM(v) ((uint32_t)((uint32_t)(v) << BP_CAN_IMASK1_BUFLM) & BM_CAN_IMASK1_BUFLM)

/*! @brief Set the BUFLM field to a new value. */
#define BW_CAN_IMASK1_BUFLM(x, v) (HW_CAN_IMASK1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CAN_IFLAG1 - Interrupt Flags 1 register
 ******************************************************************************/

/*!
 * @brief HW_CAN_IFLAG1 - Interrupt Flags 1 register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the flags for the 32 Message Buffer interrupts for MB31
 * to MB0. It contains one interrupt flag bit per buffer. Each successful
 * transmission or reception sets the corresponding IFLAG1 bit. If the corresponding
 * IMASK1 bit is set, an interrupt will be generated. The interrupt flag must be
 * cleared by writing 1 to it. Writing 0 has no effect. The BUF7I to BUF5I flags
 * are also used to represent FIFO interrupts when the Rx FIFO is enabled. When the
 * bit MCR[RFEN] is set, the function of the 8 least significant interrupt flags
 * BUF[7:0]I changes: BUF7I, BUF6I and BUF5I indicate operating conditions of
 * the FIFO, and the BUF4TO0I field is reserved. Before enabling the RFEN, the CPU
 * must service the IFLAG bits asserted in the Rx FIFO region; see Section "Rx
 * FIFO". Otherwise, these IFLAG bits will mistakenly show the related MBs now
 * belonging to FIFO as having contents to be serviced. When the RFEN bit is negated,
 * the FIFO flags must be cleared. The same care must be taken when an RFFN
 * value is selected extending Rx FIFO filters beyond MB7. For example, when RFFN is
 * 0x8, the MB0-23 range is occupied by Rx FIFO filters and related IFLAG bits
 * must be cleared. Before updating MCR[MAXMB] field, CPU must service the IFLAG1
 * bits whose MB value is greater than the MCR[MAXMB] to be updated; otherwise,
 * they will remain set and be inconsistent with the number of MBs available.
 */
typedef union _hw_can_iflag1
{
    uint32_t U;
    struct _hw_can_iflag1_bitfields
    {
        uint32_t BUF0I : 1;            /*!< [0] Buffer MB0 Interrupt Or "reserved" */
        uint32_t BUF4TO1I : 4;         /*!< [4:1] Buffer MB i Interrupt Or "reserved"
                                        * */
        uint32_t BUF5I : 1;            /*!< [5] Buffer MB5 Interrupt Or "Frames
                                        * available in Rx FIFO" */
        uint32_t BUF6I : 1;            /*!< [6] Buffer MB6 Interrupt Or "Rx FIFO
                                        * Warning" */
        uint32_t BUF7I : 1;            /*!< [7] Buffer MB7 Interrupt Or "Rx FIFO
                                        * Overflow" */
        uint32_t BUF31TO8I : 24;       /*!< [31:8] Buffer MBi Interrupt */
    } B;
} hw_can_iflag1_t;

/*!
 * @name Constants and macros for entire CAN_IFLAG1 register
 */
/*@{*/
#define HW_CAN_IFLAG1_ADDR(x)    ((uint32_t)(x) + 0x30U)

#define HW_CAN_IFLAG1(x)         (*(__IO hw_can_iflag1_t *) HW_CAN_IFLAG1_ADDR(x))
#define HW_CAN_IFLAG1_RD(x)      (HW_CAN_IFLAG1(x).U)
#define HW_CAN_IFLAG1_WR(x, v)   (HW_CAN_IFLAG1(x).U = (v))
#define HW_CAN_IFLAG1_SET(x, v)  (HW_CAN_IFLAG1_WR(x, HW_CAN_IFLAG1_RD(x) |  (v)))
#define HW_CAN_IFLAG1_CLR(x, v)  (HW_CAN_IFLAG1_WR(x, HW_CAN_IFLAG1_RD(x) & ~(v)))
#define HW_CAN_IFLAG1_TOG(x, v)  (HW_CAN_IFLAG1_WR(x, HW_CAN_IFLAG1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_IFLAG1 bitfields
 */

/*!
 * @name Register CAN_IFLAG1, field BUF0I[0] (W1C)
 *
 * When the RFEN bit in the MCR is cleared (Rx FIFO disabled), this bit flags
 * the interrupt for MB0. This flag is cleared by the FlexCAN whenever the bit
 * MCR[RFEN] is changed by CPU writes. The BUF0I flag is reserved when MCR[RFEN] is
 * set.
 *
 * Values:
 * - 0 - The corresponding buffer has no occurrence of successfully completed
 *     transmission or reception when MCR[RFEN]=0.
 * - 1 - The corresponding buffer has successfully completed transmission or
 *     reception when MCR[RFEN]=0.
 */
/*@{*/
#define BP_CAN_IFLAG1_BUF0I  (0U)          /*!< Bit position for CAN_IFLAG1_BUF0I. */
#define BM_CAN_IFLAG1_BUF0I  (0x00000001U) /*!< Bit mask for CAN_IFLAG1_BUF0I. */
#define BS_CAN_IFLAG1_BUF0I  (1U)          /*!< Bit field size in bits for CAN_IFLAG1_BUF0I. */

/*! @brief Read current value of the CAN_IFLAG1_BUF0I field. */
#define BR_CAN_IFLAG1_BUF0I(x) (BITBAND_ACCESS32(HW_CAN_IFLAG1_ADDR(x), BP_CAN_IFLAG1_BUF0I))

/*! @brief Format value for bitfield CAN_IFLAG1_BUF0I. */
#define BF_CAN_IFLAG1_BUF0I(v) ((uint32_t)((uint32_t)(v) << BP_CAN_IFLAG1_BUF0I) & BM_CAN_IFLAG1_BUF0I)

/*! @brief Set the BUF0I field to a new value. */
#define BW_CAN_IFLAG1_BUF0I(x, v) (BITBAND_ACCESS32(HW_CAN_IFLAG1_ADDR(x), BP_CAN_IFLAG1_BUF0I) = (v))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF4TO1I[4:1] (W1C)
 *
 * When the RFEN bit in the MCR is cleared (Rx FIFO disabled), these bits flag
 * the interrupts for MB4 to MB1. These flags are cleared by the FlexCAN whenever
 * the bit MCR[RFEN] is changed by CPU writes. The BUF4TO1I flags are reserved
 * when MCR[RFEN] is set.
 *
 * Values:
 * - 0 - The corresponding buffer has no occurrence of successfully completed
 *     transmission or reception when MCR[RFEN]=0.
 * - 1 - The corresponding buffer has successfully completed transmission or
 *     reception when MCR[RFEN]=0.
 */
/*@{*/
#define BP_CAN_IFLAG1_BUF4TO1I (1U)        /*!< Bit position for CAN_IFLAG1_BUF4TO1I. */
#define BM_CAN_IFLAG1_BUF4TO1I (0x0000001EU) /*!< Bit mask for CAN_IFLAG1_BUF4TO1I. */
#define BS_CAN_IFLAG1_BUF4TO1I (4U)        /*!< Bit field size in bits for CAN_IFLAG1_BUF4TO1I. */

/*! @brief Read current value of the CAN_IFLAG1_BUF4TO1I field. */
#define BR_CAN_IFLAG1_BUF4TO1I(x) (HW_CAN_IFLAG1(x).B.BUF4TO1I)

/*! @brief Format value for bitfield CAN_IFLAG1_BUF4TO1I. */
#define BF_CAN_IFLAG1_BUF4TO1I(v) ((uint32_t)((uint32_t)(v) << BP_CAN_IFLAG1_BUF4TO1I) & BM_CAN_IFLAG1_BUF4TO1I)

/*! @brief Set the BUF4TO1I field to a new value. */
#define BW_CAN_IFLAG1_BUF4TO1I(x, v) (HW_CAN_IFLAG1_WR(x, (HW_CAN_IFLAG1_RD(x) & ~BM_CAN_IFLAG1_BUF4TO1I) | BF_CAN_IFLAG1_BUF4TO1I(v)))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF5I[5] (W1C)
 *
 * When the RFEN bit in the MCR is cleared (Rx FIFO disabled), this bit flags
 * the interrupt for MB5. This flag is cleared by the FlexCAN whenever the bit
 * MCR[RFEN] is changed by CPU writes. The BUF5I flag represents "Frames available in
 * Rx FIFO" when MCR[RFEN] is set. In this case, the flag indicates that at
 * least one frame is available to be read from the Rx FIFO.
 *
 * Values:
 * - 0 - No occurrence of MB5 completing transmission/reception when
 *     MCR[RFEN]=0, or of frame(s) available in the FIFO, when MCR[RFEN]=1
 * - 1 - MB5 completed transmission/reception when MCR[RFEN]=0, or frame(s)
 *     available in the Rx FIFO when MCR[RFEN]=1
 */
/*@{*/
#define BP_CAN_IFLAG1_BUF5I  (5U)          /*!< Bit position for CAN_IFLAG1_BUF5I. */
#define BM_CAN_IFLAG1_BUF5I  (0x00000020U) /*!< Bit mask for CAN_IFLAG1_BUF5I. */
#define BS_CAN_IFLAG1_BUF5I  (1U)          /*!< Bit field size in bits for CAN_IFLAG1_BUF5I. */

/*! @brief Read current value of the CAN_IFLAG1_BUF5I field. */
#define BR_CAN_IFLAG1_BUF5I(x) (BITBAND_ACCESS32(HW_CAN_IFLAG1_ADDR(x), BP_CAN_IFLAG1_BUF5I))

/*! @brief Format value for bitfield CAN_IFLAG1_BUF5I. */
#define BF_CAN_IFLAG1_BUF5I(v) ((uint32_t)((uint32_t)(v) << BP_CAN_IFLAG1_BUF5I) & BM_CAN_IFLAG1_BUF5I)

/*! @brief Set the BUF5I field to a new value. */
#define BW_CAN_IFLAG1_BUF5I(x, v) (BITBAND_ACCESS32(HW_CAN_IFLAG1_ADDR(x), BP_CAN_IFLAG1_BUF5I) = (v))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF6I[6] (W1C)
 *
 * When the RFEN bit in the MCR is cleared (Rx FIFO disabled), this bit flags
 * the interrupt for MB6. This flag is cleared by the FlexCAN whenever the bit
 * MCR[RFEN] is changed by CPU writes. The BUF6I flag represents "Rx FIFO Warning"
 * when MCR[RFEN] is set. In this case, the flag indicates when the number of
 * unread messages within the Rx FIFO is increased to 5 from 4 due to the reception of
 * a new one, meaning that the Rx FIFO is almost full. Note that if the flag is
 * cleared while the number of unread messages is greater than 4, it does not
 * assert again until the number of unread messages within the Rx FIFO is decreased
 * to be equal to or less than 4.
 *
 * Values:
 * - 0 - No occurrence of MB6 completing transmission/reception when
 *     MCR[RFEN]=0, or of Rx FIFO almost full when MCR[RFEN]=1
 * - 1 - MB6 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO
 *     almost full when MCR[RFEN]=1
 */
/*@{*/
#define BP_CAN_IFLAG1_BUF6I  (6U)          /*!< Bit position for CAN_IFLAG1_BUF6I. */
#define BM_CAN_IFLAG1_BUF6I  (0x00000040U) /*!< Bit mask for CAN_IFLAG1_BUF6I. */
#define BS_CAN_IFLAG1_BUF6I  (1U)          /*!< Bit field size in bits for CAN_IFLAG1_BUF6I. */

/*! @brief Read current value of the CAN_IFLAG1_BUF6I field. */
#define BR_CAN_IFLAG1_BUF6I(x) (BITBAND_ACCESS32(HW_CAN_IFLAG1_ADDR(x), BP_CAN_IFLAG1_BUF6I))

/*! @brief Format value for bitfield CAN_IFLAG1_BUF6I. */
#define BF_CAN_IFLAG1_BUF6I(v) ((uint32_t)((uint32_t)(v) << BP_CAN_IFLAG1_BUF6I) & BM_CAN_IFLAG1_BUF6I)

/*! @brief Set the BUF6I field to a new value. */
#define BW_CAN_IFLAG1_BUF6I(x, v) (BITBAND_ACCESS32(HW_CAN_IFLAG1_ADDR(x), BP_CAN_IFLAG1_BUF6I) = (v))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF7I[7] (W1C)
 *
 * When the RFEN bit in the MCR is cleared (Rx FIFO disabled), this bit flags
 * the interrupt for MB7. This flag is cleared by the FlexCAN whenever the bit
 * MCR[RFEN] is changed by CPU writes. The BUF7I flag represents "Rx FIFO Overflow"
 * when MCR[RFEN] is set. In this case, the flag indicates that a message was lost
 * because the Rx FIFO is full. Note that the flag will not be asserted when the
 * Rx FIFO is full and the message was captured by a Mailbox.
 *
 * Values:
 * - 0 - No occurrence of MB7 completing transmission/reception when
 *     MCR[RFEN]=0, or of Rx FIFO overflow when MCR[RFEN]=1
 * - 1 - MB7 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO
 *     overflow when MCR[RFEN]=1
 */
/*@{*/
#define BP_CAN_IFLAG1_BUF7I  (7U)          /*!< Bit position for CAN_IFLAG1_BUF7I. */
#define BM_CAN_IFLAG1_BUF7I  (0x00000080U) /*!< Bit mask for CAN_IFLAG1_BUF7I. */
#define BS_CAN_IFLAG1_BUF7I  (1U)          /*!< Bit field size in bits for CAN_IFLAG1_BUF7I. */

/*! @brief Read current value of the CAN_IFLAG1_BUF7I field. */
#define BR_CAN_IFLAG1_BUF7I(x) (BITBAND_ACCESS32(HW_CAN_IFLAG1_ADDR(x), BP_CAN_IFLAG1_BUF7I))

/*! @brief Format value for bitfield CAN_IFLAG1_BUF7I. */
#define BF_CAN_IFLAG1_BUF7I(v) ((uint32_t)((uint32_t)(v) << BP_CAN_IFLAG1_BUF7I) & BM_CAN_IFLAG1_BUF7I)

/*! @brief Set the BUF7I field to a new value. */
#define BW_CAN_IFLAG1_BUF7I(x, v) (BITBAND_ACCESS32(HW_CAN_IFLAG1_ADDR(x), BP_CAN_IFLAG1_BUF7I) = (v))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF31TO8I[31:8] (W1C)
 *
 * Each bit flags the corresponding FlexCAN Message Buffer interrupt for MB31 to
 * MB8.
 *
 * Values:
 * - 0 - The corresponding buffer has no occurrence of successfully completed
 *     transmission or reception.
 * - 1 - The corresponding buffer has successfully completed transmission or
 *     reception.
 */
/*@{*/
#define BP_CAN_IFLAG1_BUF31TO8I (8U)       /*!< Bit position for CAN_IFLAG1_BUF31TO8I. */
#define BM_CAN_IFLAG1_BUF31TO8I (0xFFFFFF00U) /*!< Bit mask for CAN_IFLAG1_BUF31TO8I. */
#define BS_CAN_IFLAG1_BUF31TO8I (24U)      /*!< Bit field size in bits for CAN_IFLAG1_BUF31TO8I. */

/*! @brief Read current value of the CAN_IFLAG1_BUF31TO8I field. */
#define BR_CAN_IFLAG1_BUF31TO8I(x) (HW_CAN_IFLAG1(x).B.BUF31TO8I)

/*! @brief Format value for bitfield CAN_IFLAG1_BUF31TO8I. */
#define BF_CAN_IFLAG1_BUF31TO8I(v) ((uint32_t)((uint32_t)(v) << BP_CAN_IFLAG1_BUF31TO8I) & BM_CAN_IFLAG1_BUF31TO8I)

/*! @brief Set the BUF31TO8I field to a new value. */
#define BW_CAN_IFLAG1_BUF31TO8I(x, v) (HW_CAN_IFLAG1_WR(x, (HW_CAN_IFLAG1_RD(x) & ~BM_CAN_IFLAG1_BUF31TO8I) | BF_CAN_IFLAG1_BUF31TO8I(v)))
/*@}*/

/*******************************************************************************
 * HW_CAN_CTRL2 - Control 2 register
 ******************************************************************************/

/*!
 * @brief HW_CAN_CTRL2 - Control 2 register (RW)
 *
 * Reset value: 0x00B00000U
 *
 * This register contains control bits for CAN errors, FIFO features, and mode
 * selection.
 */
typedef union _hw_can_ctrl2
{
    uint32_t U;
    struct _hw_can_ctrl2_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t EACEN : 1;            /*!< [16] Entire Frame Arbitration Field
                                        * Comparison Enable For Rx Mailboxes */
        uint32_t RRS : 1;              /*!< [17] Remote Request Storing */
        uint32_t MRP : 1;              /*!< [18] Mailboxes Reception Priority */
        uint32_t TASD : 5;             /*!< [23:19] Tx Arbitration Start Delay */
        uint32_t RFFN : 4;             /*!< [27:24] Number Of Rx FIFO Filters */
        uint32_t WRMFRZ : 1;           /*!< [28] Write-Access To Memory In Freeze Mode
                                        * */
        uint32_t RESERVED1 : 3;        /*!< [31:29]  */
    } B;
} hw_can_ctrl2_t;

/*!
 * @name Constants and macros for entire CAN_CTRL2 register
 */
/*@{*/
#define HW_CAN_CTRL2_ADDR(x)     ((uint32_t)(x) + 0x34U)

#define HW_CAN_CTRL2(x)          (*(__IO hw_can_ctrl2_t *) HW_CAN_CTRL2_ADDR(x))
#define HW_CAN_CTRL2_RD(x)       (HW_CAN_CTRL2(x).U)
#define HW_CAN_CTRL2_WR(x, v)    (HW_CAN_CTRL2(x).U = (v))
#define HW_CAN_CTRL2_SET(x, v)   (HW_CAN_CTRL2_WR(x, HW_CAN_CTRL2_RD(x) |  (v)))
#define HW_CAN_CTRL2_CLR(x, v)   (HW_CAN_CTRL2_WR(x, HW_CAN_CTRL2_RD(x) & ~(v)))
#define HW_CAN_CTRL2_TOG(x, v)   (HW_CAN_CTRL2_WR(x, HW_CAN_CTRL2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_CTRL2 bitfields
 */

/*!
 * @name Register CAN_CTRL2, field EACEN[16] (RW)
 *
 * This bit controls the comparison of IDE and RTR bits whithin Rx Mailboxes
 * filters with their corresponding bits in the incoming frame by the matching
 * process. This bit does not affect matching for Rx FIFO. This bit can be written
 * only in Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Rx Mailbox filter's IDE bit is always compared and RTR is never
 *     compared despite mask bits.
 * - 1 - Enables the comparison of both Rx Mailbox filter's IDE and RTR bit with
 *     their corresponding bits within the incoming frame. Mask bits do apply.
 */
/*@{*/
#define BP_CAN_CTRL2_EACEN   (16U)         /*!< Bit position for CAN_CTRL2_EACEN. */
#define BM_CAN_CTRL2_EACEN   (0x00010000U) /*!< Bit mask for CAN_CTRL2_EACEN. */
#define BS_CAN_CTRL2_EACEN   (1U)          /*!< Bit field size in bits for CAN_CTRL2_EACEN. */

/*! @brief Read current value of the CAN_CTRL2_EACEN field. */
#define BR_CAN_CTRL2_EACEN(x) (BITBAND_ACCESS32(HW_CAN_CTRL2_ADDR(x), BP_CAN_CTRL2_EACEN))

/*! @brief Format value for bitfield CAN_CTRL2_EACEN. */
#define BF_CAN_CTRL2_EACEN(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL2_EACEN) & BM_CAN_CTRL2_EACEN)

/*! @brief Set the EACEN field to a new value. */
#define BW_CAN_CTRL2_EACEN(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL2_ADDR(x), BP_CAN_CTRL2_EACEN) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field RRS[17] (RW)
 *
 * If this bit is asserted Remote Request Frame is submitted to a matching
 * process and stored in the corresponding Message Buffer in the same fashion of a
 * Data Frame. No automatic Remote Response Frame will be generated. If this bit is
 * negated the Remote Request Frame is submitted to a matching process and an
 * automatic Remote Response Frame is generated if a Message Buffer with CODE=0b1010
 * is found with the same ID. This bit can be written only in Freeze mode
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Remote Response Frame is generated.
 * - 1 - Remote Request Frame is stored.
 */
/*@{*/
#define BP_CAN_CTRL2_RRS     (17U)         /*!< Bit position for CAN_CTRL2_RRS. */
#define BM_CAN_CTRL2_RRS     (0x00020000U) /*!< Bit mask for CAN_CTRL2_RRS. */
#define BS_CAN_CTRL2_RRS     (1U)          /*!< Bit field size in bits for CAN_CTRL2_RRS. */

/*! @brief Read current value of the CAN_CTRL2_RRS field. */
#define BR_CAN_CTRL2_RRS(x)  (BITBAND_ACCESS32(HW_CAN_CTRL2_ADDR(x), BP_CAN_CTRL2_RRS))

/*! @brief Format value for bitfield CAN_CTRL2_RRS. */
#define BF_CAN_CTRL2_RRS(v)  ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL2_RRS) & BM_CAN_CTRL2_RRS)

/*! @brief Set the RRS field to a new value. */
#define BW_CAN_CTRL2_RRS(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL2_ADDR(x), BP_CAN_CTRL2_RRS) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field MRP[18] (RW)
 *
 * If this bit is set the matching process starts from the Mailboxes and if no
 * match occurs the matching continues on the Rx FIFO. This bit can be written
 * only in Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Matching starts from Rx FIFO and continues on Mailboxes.
 * - 1 - Matching starts from Mailboxes and continues on Rx FIFO.
 */
/*@{*/
#define BP_CAN_CTRL2_MRP     (18U)         /*!< Bit position for CAN_CTRL2_MRP. */
#define BM_CAN_CTRL2_MRP     (0x00040000U) /*!< Bit mask for CAN_CTRL2_MRP. */
#define BS_CAN_CTRL2_MRP     (1U)          /*!< Bit field size in bits for CAN_CTRL2_MRP. */

/*! @brief Read current value of the CAN_CTRL2_MRP field. */
#define BR_CAN_CTRL2_MRP(x)  (BITBAND_ACCESS32(HW_CAN_CTRL2_ADDR(x), BP_CAN_CTRL2_MRP))

/*! @brief Format value for bitfield CAN_CTRL2_MRP. */
#define BF_CAN_CTRL2_MRP(v)  ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL2_MRP) & BM_CAN_CTRL2_MRP)

/*! @brief Set the MRP field to a new value. */
#define BW_CAN_CTRL2_MRP(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL2_ADDR(x), BP_CAN_CTRL2_MRP) = (v))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field TASD[23:19] (RW)
 *
 * This 5-bit field indicates how many CAN bits the Tx arbitration process start
 * point can be delayed from the first bit of CRC field on CAN bus. This field
 * can be written only in Freeze mode because it is blocked by hardware in other
 * modes. This field is useful to optimize the transmit performance based on
 * factors such as: peripheral/serial clock ratio, CAN bit timing and number of MBs.
 * The duration of an arbitration process, in terms of CAN bits, is directly
 * proportional to the number of available MBs and CAN baud rate and inversely
 * proportional to the peripheral clock frequency. The optimal arbitration timing is
 * that in which the last MB is scanned right before the first bit of the
 * Intermission field of a CAN frame. Therefore, if there are few MBs and the system/serial
 * clock ratio is high and the CAN baud rate is low then the arbitration can be
 * delayed and vice-versa. If TASD is 0 then the arbitration start is not
 * delayed, thus the CPU has less time to configure a Tx MB for the next arbitration,
 * but more time is reserved for arbitration. On the other hand, if TASD is 24 then
 * the CPU can configure a Tx MB later and less time is reserved for
 * arbitration. If too little time is reserved for arbitration the FlexCAN may be not able
 * to find winner MBs in time to compete with other nodes for the CAN bus. If the
 * arbitration ends too much time before the first bit of Intermission field then
 * there is a chance that the CPU reconfigures some Tx MBs and the winner MB is
 * not the best to be transmitted. The optimal configuration for TASD can be
 * calculated as: TASD = 25 - {f CANCLK * [MAXMB + 3 - (RFEN * 8) - (RFEN * RFFN *
 * 2)] * 2} / {f SYS * [1+(PSEG1+1)+(PSEG2+1)+(PROPSEG+1)] * (PRESDIV+1)} where: f
 * CANCLK is the Protocol Engine (PE) Clock (see section "Protocol Timing"), in
 * Hz f SYS is the peripheral clock, in Hz MAXMB is the value in CTRL1[MAXMB]
 * field RFEN is the value in CTRL1[RFEN] bit RFFN is the value in CTRL2[RFFN] field
 * PSEG1 is the value in CTRL1[PSEG1] field PSEG2 is the value in CTRL1[PSEG2]
 * field PROPSEG is the value in CTRL1[PROPSEG] field PRESDIV is the value in
 * CTRL1[PRESDIV] field See Section "Arbitration process" and Section "Protocol
 * Timing" for more details.
 */
/*@{*/
#define BP_CAN_CTRL2_TASD    (19U)         /*!< Bit position for CAN_CTRL2_TASD. */
#define BM_CAN_CTRL2_TASD    (0x00F80000U) /*!< Bit mask for CAN_CTRL2_TASD. */
#define BS_CAN_CTRL2_TASD    (5U)          /*!< Bit field size in bits for CAN_CTRL2_TASD. */

/*! @brief Read current value of the CAN_CTRL2_TASD field. */
#define BR_CAN_CTRL2_TASD(x) (HW_CAN_CTRL2(x).B.TASD)

/*! @brief Format value for bitfield CAN_CTRL2_TASD. */
#define BF_CAN_CTRL2_TASD(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL2_TASD) & BM_CAN_CTRL2_TASD)

/*! @brief Set the TASD field to a new value. */
#define BW_CAN_CTRL2_TASD(x, v) (HW_CAN_CTRL2_WR(x, (HW_CAN_CTRL2_RD(x) & ~BM_CAN_CTRL2_TASD) | BF_CAN_CTRL2_TASD(v)))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field RFFN[27:24] (RW)
 *
 * This 4-bit field defines the number of Rx FIFO filters, as shown in the
 * following table. The maximum selectable number of filters is determined by the MCU.
 * This field can only be written in Freeze mode as it is blocked by hardware in
 * other modes. This field must not be programmed with values that make the
 * number of Message Buffers occupied by Rx FIFO and ID Filter exceed the number of
 * Mailboxes present, defined by MCR[MAXMB]. Each group of eight filters occupies
 * a memory space equivalent to two Message Buffers which means that the more
 * filters are implemented the less Mailboxes will be available. Considering that
 * the Rx FIFO occupies the memory space originally reserved for MB0-5, RFFN should
 * be programmed with a value correponding to a number of filters not greater
 * than the number of available memory words which can be calculated as follows:
 * (SETUP_MB - 6) * 4 where SETUP_MB is the least between NUMBER_OF_MB and MAXMB.
 * The number of remaining Mailboxes available will be: (SETUP_MB - 8) - (RFFN *
 * 2) If the Number of Rx FIFO Filters programmed through RFFN exceeds the
 * SETUP_MB value (memory space available) the exceeding ones will not be functional.
 * RFFN[3:0] Number of Rx FIFO filters Message Buffers occupied by Rx FIFO and ID
 * Filter Table Remaining Available MailboxesThe number of the last remaining
 * available mailboxes is defined by the least value between the parameter
 * NUMBER_OF_MB minus 1 and the MCR[MAXMB] field. Rx FIFO ID Filter Table Elements Affected
 * by Rx Individual MasksIf Rx Individual Mask Registers are not enabled then
 * all Rx FIFO filters are affected by the Rx FIFO Global Mask. Rx FIFO ID Filter
 * Table Elements Affected by Rx FIFO Global Mask #rxfgmask-note 0x0 8 MB 0-7 MB
 * 8-63 Elements 0-7 none 0x1 16 MB 0-9 MB 10-63 Elements 0-9 Elements 10-15 0x2
 * 24 MB 0-11 MB 12-63 Elements 0-11 Elements 12-23 0x3 32 MB 0-13 MB 14-63
 * Elements 0-13 Elements 14-31 0x4 40 MB 0-15 MB 16-63 Elements 0-15 Elements 16-39
 * 0x5 48 MB 0-17 MB 18-63 Elements 0-17 Elements 18-47 0x6 56 MB 0-19 MB 20-63
 * Elements 0-19 Elements 20-55 0x7 64 MB 0-21 MB 22-63 Elements 0-21 Elements 22-63
 * 0x8 72 MB 0-23 MB 24-63 Elements 0-23 Elements 24-71 0x9 80 MB 0-25 MB 26-63
 * Elements 0-25 Elements 26-79 0xA 88 MB 0-27 MB 28-63 Elements 0-27 Elements
 * 28-87 0xB 96 MB 0-29 MB 30-63 Elements 0-29 Elements 30-95 0xC 104 MB 0-31 MB
 * 32-63 Elements 0-31 Elements 32-103 0xD 112 MB 0-33 MB 34-63 Elements 0-31
 * Elements 32-111 0xE 120 MB 0-35 MB 36-63 Elements 0-31 Elements 32-119 0xF 128 MB
 * 0-37 MB 38-63 Elements 0-31 Elements 32-127
 */
/*@{*/
#define BP_CAN_CTRL2_RFFN    (24U)         /*!< Bit position for CAN_CTRL2_RFFN. */
#define BM_CAN_CTRL2_RFFN    (0x0F000000U) /*!< Bit mask for CAN_CTRL2_RFFN. */
#define BS_CAN_CTRL2_RFFN    (4U)          /*!< Bit field size in bits for CAN_CTRL2_RFFN. */

/*! @brief Read current value of the CAN_CTRL2_RFFN field. */
#define BR_CAN_CTRL2_RFFN(x) (HW_CAN_CTRL2(x).B.RFFN)

/*! @brief Format value for bitfield CAN_CTRL2_RFFN. */
#define BF_CAN_CTRL2_RFFN(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL2_RFFN) & BM_CAN_CTRL2_RFFN)

/*! @brief Set the RFFN field to a new value. */
#define BW_CAN_CTRL2_RFFN(x, v) (HW_CAN_CTRL2_WR(x, (HW_CAN_CTRL2_RD(x) & ~BM_CAN_CTRL2_RFFN) | BF_CAN_CTRL2_RFFN(v)))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field WRMFRZ[28] (RW)
 *
 * Enable unrestricted write access to FlexCAN memory in Freeze mode. This bit
 * can only be written in Freeze mode and has no effect out of Freeze mode.
 *
 * Values:
 * - 0 - Maintain the write access restrictions.
 * - 1 - Enable unrestricted write access to FlexCAN memory.
 */
/*@{*/
#define BP_CAN_CTRL2_WRMFRZ  (28U)         /*!< Bit position for CAN_CTRL2_WRMFRZ. */
#define BM_CAN_CTRL2_WRMFRZ  (0x10000000U) /*!< Bit mask for CAN_CTRL2_WRMFRZ. */
#define BS_CAN_CTRL2_WRMFRZ  (1U)          /*!< Bit field size in bits for CAN_CTRL2_WRMFRZ. */

/*! @brief Read current value of the CAN_CTRL2_WRMFRZ field. */
#define BR_CAN_CTRL2_WRMFRZ(x) (BITBAND_ACCESS32(HW_CAN_CTRL2_ADDR(x), BP_CAN_CTRL2_WRMFRZ))

/*! @brief Format value for bitfield CAN_CTRL2_WRMFRZ. */
#define BF_CAN_CTRL2_WRMFRZ(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CTRL2_WRMFRZ) & BM_CAN_CTRL2_WRMFRZ)

/*! @brief Set the WRMFRZ field to a new value. */
#define BW_CAN_CTRL2_WRMFRZ(x, v) (BITBAND_ACCESS32(HW_CAN_CTRL2_ADDR(x), BP_CAN_CTRL2_WRMFRZ) = (v))
/*@}*/

/*******************************************************************************
 * HW_CAN_ESR2 - Error and Status 2 register
 ******************************************************************************/

/*!
 * @brief HW_CAN_ESR2 - Error and Status 2 register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register reflects various interrupt flags and some general status.
 */
typedef union _hw_can_esr2
{
    uint32_t U;
    struct _hw_can_esr2_bitfields
    {
        uint32_t RESERVED0 : 13;       /*!< [12:0]  */
        uint32_t IMB : 1;              /*!< [13] Inactive Mailbox */
        uint32_t VPS : 1;              /*!< [14] Valid Priority Status */
        uint32_t RESERVED1 : 1;        /*!< [15]  */
        uint32_t LPTM : 7;             /*!< [22:16] Lowest Priority Tx Mailbox */
        uint32_t RESERVED2 : 9;        /*!< [31:23]  */
    } B;
} hw_can_esr2_t;

/*!
 * @name Constants and macros for entire CAN_ESR2 register
 */
/*@{*/
#define HW_CAN_ESR2_ADDR(x)      ((uint32_t)(x) + 0x38U)

#define HW_CAN_ESR2(x)           (*(__I hw_can_esr2_t *) HW_CAN_ESR2_ADDR(x))
#define HW_CAN_ESR2_RD(x)        (HW_CAN_ESR2(x).U)
/*@}*/

/*
 * Constants & macros for individual CAN_ESR2 bitfields
 */

/*!
 * @name Register CAN_ESR2, field IMB[13] (RO)
 *
 * If ESR2[VPS] is asserted, this bit indicates whether there is any inactive
 * Mailbox (CODE field is either 0b1000 or 0b0000). This bit is asserted in the
 * following cases: During arbitration, if an LPTM is found and it is inactive. If
 * IMB is not asserted and a frame is transmitted successfully. This bit is
 * cleared in all start of arbitration (see Section "Arbitration process"). LPTM
 * mechanism have the following behavior: if an MB is successfully transmitted and
 * ESR2[IMB]=0 (no inactive Mailbox), then ESR2[VPS] and ESR2[IMB] are asserted and
 * the index related to the MB just transmitted is loaded into ESR2[LPTM].
 *
 * Values:
 * - 0 - If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive Mailbox.
 * - 1 - If ESR2[VPS] is asserted, there is at least one inactive Mailbox. LPTM
 *     content is the number of the first one.
 */
/*@{*/
#define BP_CAN_ESR2_IMB      (13U)         /*!< Bit position for CAN_ESR2_IMB. */
#define BM_CAN_ESR2_IMB      (0x00002000U) /*!< Bit mask for CAN_ESR2_IMB. */
#define BS_CAN_ESR2_IMB      (1U)          /*!< Bit field size in bits for CAN_ESR2_IMB. */

/*! @brief Read current value of the CAN_ESR2_IMB field. */
#define BR_CAN_ESR2_IMB(x)   (BITBAND_ACCESS32(HW_CAN_ESR2_ADDR(x), BP_CAN_ESR2_IMB))
/*@}*/

/*!
 * @name Register CAN_ESR2, field VPS[14] (RO)
 *
 * This bit indicates whether IMB and LPTM contents are currently valid or not.
 * VPS is asserted upon every complete Tx arbitration process unless the CPU
 * writes to Control and Status word of a Mailbox that has already been scanned, that
 * is, it is behind Tx Arbitration Pointer, during the Tx arbitration process.
 * If there is no inactive Mailbox and only one Tx Mailbox that is being
 * transmitted then VPS is not asserted. VPS is negated upon the start of every Tx
 * arbitration process or upon a write to Control and Status word of any Mailbox.
 * ESR2[VPS] is not affected by any CPU write into Control Status (C/S) of a MB that is
 * blocked by abort mechanism. When MCR[AEN] is asserted, the abort code write
 * in C/S of a MB that is being transmitted (pending abort), or any write attempt
 * into a Tx MB with IFLAG set is blocked.
 *
 * Values:
 * - 0 - Contents of IMB and LPTM are invalid.
 * - 1 - Contents of IMB and LPTM are valid.
 */
/*@{*/
#define BP_CAN_ESR2_VPS      (14U)         /*!< Bit position for CAN_ESR2_VPS. */
#define BM_CAN_ESR2_VPS      (0x00004000U) /*!< Bit mask for CAN_ESR2_VPS. */
#define BS_CAN_ESR2_VPS      (1U)          /*!< Bit field size in bits for CAN_ESR2_VPS. */

/*! @brief Read current value of the CAN_ESR2_VPS field. */
#define BR_CAN_ESR2_VPS(x)   (BITBAND_ACCESS32(HW_CAN_ESR2_ADDR(x), BP_CAN_ESR2_VPS))
/*@}*/

/*!
 * @name Register CAN_ESR2, field LPTM[22:16] (RO)
 *
 * If ESR2[VPS] is asserted, this field indicates the lowest number inactive
 * Mailbox (see the IMB bit description). If there is no inactive Mailbox then the
 * Mailbox indicated depends on CTRL1[LBUF] bit value. If CTRL1[LBUF] bit is
 * negated then the Mailbox indicated is the one that has the greatest arbitration
 * value (see the "Highest priority Mailbox first" section). If CTRL1[LBUF] bit is
 * asserted then the Mailbox indicated is the highest number active Tx Mailbox. If
 * a Tx Mailbox is being transmitted it is not considered in LPTM calculation.
 * If ESR2[IMB] is not asserted and a frame is transmitted successfully, LPTM is
 * updated with its Mailbox number.
 */
/*@{*/
#define BP_CAN_ESR2_LPTM     (16U)         /*!< Bit position for CAN_ESR2_LPTM. */
#define BM_CAN_ESR2_LPTM     (0x007F0000U) /*!< Bit mask for CAN_ESR2_LPTM. */
#define BS_CAN_ESR2_LPTM     (7U)          /*!< Bit field size in bits for CAN_ESR2_LPTM. */

/*! @brief Read current value of the CAN_ESR2_LPTM field. */
#define BR_CAN_ESR2_LPTM(x)  (HW_CAN_ESR2(x).B.LPTM)
/*@}*/

/*******************************************************************************
 * HW_CAN_CRCR - CRC Register
 ******************************************************************************/

/*!
 * @brief HW_CAN_CRCR - CRC Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register provides information about the CRC of transmitted messages.
 */
typedef union _hw_can_crcr
{
    uint32_t U;
    struct _hw_can_crcr_bitfields
    {
        uint32_t TXCRC : 15;           /*!< [14:0] CRC Transmitted */
        uint32_t RESERVED0 : 1;        /*!< [15]  */
        uint32_t MBCRC : 7;            /*!< [22:16] CRC Mailbox */
        uint32_t RESERVED1 : 9;        /*!< [31:23]  */
    } B;
} hw_can_crcr_t;

/*!
 * @name Constants and macros for entire CAN_CRCR register
 */
/*@{*/
#define HW_CAN_CRCR_ADDR(x)      ((uint32_t)(x) + 0x44U)

#define HW_CAN_CRCR(x)           (*(__I hw_can_crcr_t *) HW_CAN_CRCR_ADDR(x))
#define HW_CAN_CRCR_RD(x)        (HW_CAN_CRCR(x).U)
/*@}*/

/*
 * Constants & macros for individual CAN_CRCR bitfields
 */

/*!
 * @name Register CAN_CRCR, field TXCRC[14:0] (RO)
 *
 * This field indicates the CRC value of the last message transmitted. This
 * field is updated at the same time the Tx Interrupt Flag is asserted.
 */
/*@{*/
#define BP_CAN_CRCR_TXCRC    (0U)          /*!< Bit position for CAN_CRCR_TXCRC. */
#define BM_CAN_CRCR_TXCRC    (0x00007FFFU) /*!< Bit mask for CAN_CRCR_TXCRC. */
#define BS_CAN_CRCR_TXCRC    (15U)         /*!< Bit field size in bits for CAN_CRCR_TXCRC. */

/*! @brief Read current value of the CAN_CRCR_TXCRC field. */
#define BR_CAN_CRCR_TXCRC(x) (HW_CAN_CRCR(x).B.TXCRC)
/*@}*/

/*!
 * @name Register CAN_CRCR, field MBCRC[22:16] (RO)
 *
 * This field indicates the number of the Mailbox corresponding to the value in
 * TXCRC field.
 */
/*@{*/
#define BP_CAN_CRCR_MBCRC    (16U)         /*!< Bit position for CAN_CRCR_MBCRC. */
#define BM_CAN_CRCR_MBCRC    (0x007F0000U) /*!< Bit mask for CAN_CRCR_MBCRC. */
#define BS_CAN_CRCR_MBCRC    (7U)          /*!< Bit field size in bits for CAN_CRCR_MBCRC. */

/*! @brief Read current value of the CAN_CRCR_MBCRC field. */
#define BR_CAN_CRCR_MBCRC(x) (HW_CAN_CRCR(x).B.MBCRC)
/*@}*/

/*******************************************************************************
 * HW_CAN_RXFGMASK - Rx FIFO Global Mask register
 ******************************************************************************/

/*!
 * @brief HW_CAN_RXFGMASK - Rx FIFO Global Mask register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * This register is located in RAM. If Rx FIFO is enabled RXFGMASK is used to
 * mask the Rx FIFO ID Filter Table elements that do not have a corresponding RXIMR
 * according to CTRL2[RFFN] field setting. This register can only be written in
 * Freeze mode as it is blocked by hardware in other modes.
 */
typedef union _hw_can_rxfgmask
{
    uint32_t U;
    struct _hw_can_rxfgmask_bitfields
    {
        uint32_t FGM : 32;             /*!< [31:0] Rx FIFO Global Mask Bits */
    } B;
} hw_can_rxfgmask_t;

/*!
 * @name Constants and macros for entire CAN_RXFGMASK register
 */
/*@{*/
#define HW_CAN_RXFGMASK_ADDR(x)  ((uint32_t)(x) + 0x48U)

#define HW_CAN_RXFGMASK(x)       (*(__IO hw_can_rxfgmask_t *) HW_CAN_RXFGMASK_ADDR(x))
#define HW_CAN_RXFGMASK_RD(x)    (HW_CAN_RXFGMASK(x).U)
#define HW_CAN_RXFGMASK_WR(x, v) (HW_CAN_RXFGMASK(x).U = (v))
#define HW_CAN_RXFGMASK_SET(x, v) (HW_CAN_RXFGMASK_WR(x, HW_CAN_RXFGMASK_RD(x) |  (v)))
#define HW_CAN_RXFGMASK_CLR(x, v) (HW_CAN_RXFGMASK_WR(x, HW_CAN_RXFGMASK_RD(x) & ~(v)))
#define HW_CAN_RXFGMASK_TOG(x, v) (HW_CAN_RXFGMASK_WR(x, HW_CAN_RXFGMASK_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_RXFGMASK bitfields
 */

/*!
 * @name Register CAN_RXFGMASK, field FGM[31:0] (RW)
 *
 * These bits mask the ID Filter Table elements bits in a perfect alignment. The
 * following table shows how the FGM bits correspond to each IDAF field. Rx FIFO
 * ID Filter Table Elements Format (MCR[IDAM]) Identifier Acceptance Filter
 * Fields RTR IDE RXIDA RXIDB If MCR[IDAM] field is equivalent to the format B only
 * the fourteen most significant bits of the Identifier of the incoming frame are
 * compared with the Rx FIFO filter. RXIDC If MCR[IDAM] field is equivalent to
 * the format C only the eight most significant bits of the Identifier of the
 * incoming frame are compared with the Rx FIFO filter. Reserved A FGM[31] FGM[30]
 * FGM[29:1] - - FGM[0] B FGM[31], FGM[15] FGM[30], FGM[14] - FGM[29:16], FGM[13:0]
 * - C - - - FGM[31:24], FGM[23:16], FGM[15:8], FGM[7:0]
 *
 * Values:
 * - 0 - The corresponding bit in the filter is "don't care."
 * - 1 - The corresponding bit in the filter is checked.
 */
/*@{*/
#define BP_CAN_RXFGMASK_FGM  (0U)          /*!< Bit position for CAN_RXFGMASK_FGM. */
#define BM_CAN_RXFGMASK_FGM  (0xFFFFFFFFU) /*!< Bit mask for CAN_RXFGMASK_FGM. */
#define BS_CAN_RXFGMASK_FGM  (32U)         /*!< Bit field size in bits for CAN_RXFGMASK_FGM. */

/*! @brief Read current value of the CAN_RXFGMASK_FGM field. */
#define BR_CAN_RXFGMASK_FGM(x) (HW_CAN_RXFGMASK(x).U)

/*! @brief Format value for bitfield CAN_RXFGMASK_FGM. */
#define BF_CAN_RXFGMASK_FGM(v) ((uint32_t)((uint32_t)(v) << BP_CAN_RXFGMASK_FGM) & BM_CAN_RXFGMASK_FGM)

/*! @brief Set the FGM field to a new value. */
#define BW_CAN_RXFGMASK_FGM(x, v) (HW_CAN_RXFGMASK_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CAN_RXFIR - Rx FIFO Information Register
 ******************************************************************************/

/*!
 * @brief HW_CAN_RXFIR - Rx FIFO Information Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFIR provides information on Rx FIFO. This register is the port through
 * which the CPU accesses the output of the RXFIR FIFO located in RAM. The RXFIR FIFO
 * is written by the FlexCAN whenever a new message is moved into the Rx FIFO as
 * well as its output is updated whenever the output of the Rx FIFO is updated
 * with the next message. See Section "Rx FIFO" for instructions on reading this
 * register.
 */
typedef union _hw_can_rxfir
{
    uint32_t U;
    struct _hw_can_rxfir_bitfields
    {
        uint32_t IDHIT : 9;            /*!< [8:0] Identifier Acceptance Filter Hit
                                        * Indicator */
        uint32_t RESERVED0 : 23;       /*!< [31:9]  */
    } B;
} hw_can_rxfir_t;

/*!
 * @name Constants and macros for entire CAN_RXFIR register
 */
/*@{*/
#define HW_CAN_RXFIR_ADDR(x)     ((uint32_t)(x) + 0x4CU)

#define HW_CAN_RXFIR(x)          (*(__I hw_can_rxfir_t *) HW_CAN_RXFIR_ADDR(x))
#define HW_CAN_RXFIR_RD(x)       (HW_CAN_RXFIR(x).U)
/*@}*/

/*
 * Constants & macros for individual CAN_RXFIR bitfields
 */

/*!
 * @name Register CAN_RXFIR, field IDHIT[8:0] (RO)
 *
 * This field indicates which Identifier Acceptance Filter was hit by the
 * received message that is in the output of the Rx FIFO. If multiple filters match the
 * incoming message ID then the first matching IDAF found (lowest number) by the
 * matching process is indicated. This field is valid only while the
 * IFLAG[BUF5I] is asserted.
 */
/*@{*/
#define BP_CAN_RXFIR_IDHIT   (0U)          /*!< Bit position for CAN_RXFIR_IDHIT. */
#define BM_CAN_RXFIR_IDHIT   (0x000001FFU) /*!< Bit mask for CAN_RXFIR_IDHIT. */
#define BS_CAN_RXFIR_IDHIT   (9U)          /*!< Bit field size in bits for CAN_RXFIR_IDHIT. */

/*! @brief Read current value of the CAN_RXFIR_IDHIT field. */
#define BR_CAN_RXFIR_IDHIT(x) (HW_CAN_RXFIR(x).B.IDHIT)
/*@}*/

/*******************************************************************************
 * HW_CAN_CSn - Message Buffer 0 CS Register
 ******************************************************************************/

/*!
 * @brief HW_CAN_CSn - Message Buffer 0 CS Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_can_csn
{
    uint32_t U;
    struct _hw_can_csn_bitfields
    {
        uint32_t TIME_STAMP : 16;      /*!< [15:0] Free-Running Counter Time
                                        * stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx
                                        * and Rx frames at the time when the beginning of the Identifier field
                                        * appears on the CAN bus. */
        uint32_t DLC : 4;              /*!< [19:16] Length of the data to be
                                        * stored/transmitted. */
        uint32_t RTR : 1;              /*!< [20] Remote Transmission Request. One/zero for
                                        * remote/data frame. */
        uint32_t IDE : 1;              /*!< [21] ID Extended. One/zero for
                                        * extended/standard format frame. */
        uint32_t SRR : 1;              /*!< [22] Substitute Remote Request. Contains a
                                        * fixed recessive bit. */
        uint32_t RESERVED0 : 1;        /*!< [23] Reserved */
        uint32_t CODE : 4;             /*!< [27:24] Reserved */
        uint32_t RESERVED1 : 4;        /*!< [31:28] Reserved */
    } B;
} hw_can_csn_t;

/*!
 * @name Constants and macros for entire CAN_CSn register
 */
/*@{*/
#define HW_CAN_CSn_COUNT (16U)

#define HW_CAN_CSn_ADDR(x, n)    ((uint32_t)(x) + 0x80U + (0x10U * (n)))

#define HW_CAN_CSn(x, n)         (*(__IO hw_can_csn_t *) HW_CAN_CSn_ADDR(x, n))
#define HW_CAN_CSn_RD(x, n)      (HW_CAN_CSn(x, n).U)
#define HW_CAN_CSn_WR(x, n, v)   (HW_CAN_CSn(x, n).U = (v))
#define HW_CAN_CSn_SET(x, n, v)  (HW_CAN_CSn_WR(x, n, HW_CAN_CSn_RD(x, n) |  (v)))
#define HW_CAN_CSn_CLR(x, n, v)  (HW_CAN_CSn_WR(x, n, HW_CAN_CSn_RD(x, n) & ~(v)))
#define HW_CAN_CSn_TOG(x, n, v)  (HW_CAN_CSn_WR(x, n, HW_CAN_CSn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_CSn bitfields
 */

/*!
 * @name Register CAN_CSn, field TIME_STAMP[15:0] (RW)
 */
/*@{*/
#define BP_CAN_CSn_TIME_STAMP (0U)         /*!< Bit position for CAN_CSn_TIME_STAMP. */
#define BM_CAN_CSn_TIME_STAMP (0x0000FFFFU) /*!< Bit mask for CAN_CSn_TIME_STAMP. */
#define BS_CAN_CSn_TIME_STAMP (16U)        /*!< Bit field size in bits for CAN_CSn_TIME_STAMP. */

/*! @brief Read current value of the CAN_CSn_TIME_STAMP field. */
#define BR_CAN_CSn_TIME_STAMP(x, n) (HW_CAN_CSn(x, n).B.TIME_STAMP)

/*! @brief Format value for bitfield CAN_CSn_TIME_STAMP. */
#define BF_CAN_CSn_TIME_STAMP(v) ((uint32_t)((uint32_t)(v) << BP_CAN_CSn_TIME_STAMP) & BM_CAN_CSn_TIME_STAMP)

/*! @brief Set the TIME_STAMP field to a new value. */
#define BW_CAN_CSn_TIME_STAMP(x, n, v) (HW_CAN_CSn_WR(x, n, (HW_CAN_CSn_RD(x, n) & ~BM_CAN_CSn_TIME_STAMP) | BF_CAN_CSn_TIME_STAMP(v)))
/*@}*/

/*!
 * @name Register CAN_CSn, field DLC[19:16] (RW)
 */
/*@{*/
#define BP_CAN_CSn_DLC       (16U)         /*!< Bit position for CAN_CSn_DLC. */
#define BM_CAN_CSn_DLC       (0x000F0000U) /*!< Bit mask for CAN_CSn_DLC. */
#define BS_CAN_CSn_DLC       (4U)          /*!< Bit field size in bits for CAN_CSn_DLC. */

/*! @brief Read current value of the CAN_CSn_DLC field. */
#define BR_CAN_CSn_DLC(x, n) (HW_CAN_CSn(x, n).B.DLC)

/*! @brief Format value for bitfield CAN_CSn_DLC. */
#define BF_CAN_CSn_DLC(v)    ((uint32_t)((uint32_t)(v) << BP_CAN_CSn_DLC) & BM_CAN_CSn_DLC)

/*! @brief Set the DLC field to a new value. */
#define BW_CAN_CSn_DLC(x, n, v) (HW_CAN_CSn_WR(x, n, (HW_CAN_CSn_RD(x, n) & ~BM_CAN_CSn_DLC) | BF_CAN_CSn_DLC(v)))
/*@}*/

/*!
 * @name Register CAN_CSn, field RTR[20] (RW)
 */
/*@{*/
#define BP_CAN_CSn_RTR       (20U)         /*!< Bit position for CAN_CSn_RTR. */
#define BM_CAN_CSn_RTR       (0x00100000U) /*!< Bit mask for CAN_CSn_RTR. */
#define BS_CAN_CSn_RTR       (1U)          /*!< Bit field size in bits for CAN_CSn_RTR. */

/*! @brief Read current value of the CAN_CSn_RTR field. */
#define BR_CAN_CSn_RTR(x, n) (BITBAND_ACCESS32(HW_CAN_CSn_ADDR(x, n), BP_CAN_CSn_RTR))

/*! @brief Format value for bitfield CAN_CSn_RTR. */
#define BF_CAN_CSn_RTR(v)    ((uint32_t)((uint32_t)(v) << BP_CAN_CSn_RTR) & BM_CAN_CSn_RTR)

/*! @brief Set the RTR field to a new value. */
#define BW_CAN_CSn_RTR(x, n, v) (BITBAND_ACCESS32(HW_CAN_CSn_ADDR(x, n), BP_CAN_CSn_RTR) = (v))
/*@}*/

/*!
 * @name Register CAN_CSn, field IDE[21] (RW)
 */
/*@{*/
#define BP_CAN_CSn_IDE       (21U)         /*!< Bit position for CAN_CSn_IDE. */
#define BM_CAN_CSn_IDE       (0x00200000U) /*!< Bit mask for CAN_CSn_IDE. */
#define BS_CAN_CSn_IDE       (1U)          /*!< Bit field size in bits for CAN_CSn_IDE. */

/*! @brief Read current value of the CAN_CSn_IDE field. */
#define BR_CAN_CSn_IDE(x, n) (BITBAND_ACCESS32(HW_CAN_CSn_ADDR(x, n), BP_CAN_CSn_IDE))

/*! @brief Format value for bitfield CAN_CSn_IDE. */
#define BF_CAN_CSn_IDE(v)    ((uint32_t)((uint32_t)(v) << BP_CAN_CSn_IDE) & BM_CAN_CSn_IDE)

/*! @brief Set the IDE field to a new value. */
#define BW_CAN_CSn_IDE(x, n, v) (BITBAND_ACCESS32(HW_CAN_CSn_ADDR(x, n), BP_CAN_CSn_IDE) = (v))
/*@}*/

/*!
 * @name Register CAN_CSn, field SRR[22] (RW)
 */
/*@{*/
#define BP_CAN_CSn_SRR       (22U)         /*!< Bit position for CAN_CSn_SRR. */
#define BM_CAN_CSn_SRR       (0x00400000U) /*!< Bit mask for CAN_CSn_SRR. */
#define BS_CAN_CSn_SRR       (1U)          /*!< Bit field size in bits for CAN_CSn_SRR. */

/*! @brief Read current value of the CAN_CSn_SRR field. */
#define BR_CAN_CSn_SRR(x, n) (BITBAND_ACCESS32(HW_CAN_CSn_ADDR(x, n), BP_CAN_CSn_SRR))

/*! @brief Format value for bitfield CAN_CSn_SRR. */
#define BF_CAN_CSn_SRR(v)    ((uint32_t)((uint32_t)(v) << BP_CAN_CSn_SRR) & BM_CAN_CSn_SRR)

/*! @brief Set the SRR field to a new value. */
#define BW_CAN_CSn_SRR(x, n, v) (BITBAND_ACCESS32(HW_CAN_CSn_ADDR(x, n), BP_CAN_CSn_SRR) = (v))
/*@}*/

/*!
 * @name Register CAN_CSn, field CODE[27:24] (RW)
 */
/*@{*/
#define BP_CAN_CSn_CODE      (24U)         /*!< Bit position for CAN_CSn_CODE. */
#define BM_CAN_CSn_CODE      (0x0F000000U) /*!< Bit mask for CAN_CSn_CODE. */
#define BS_CAN_CSn_CODE      (4U)          /*!< Bit field size in bits for CAN_CSn_CODE. */

/*! @brief Read current value of the CAN_CSn_CODE field. */
#define BR_CAN_CSn_CODE(x, n) (HW_CAN_CSn(x, n).B.CODE)

/*! @brief Format value for bitfield CAN_CSn_CODE. */
#define BF_CAN_CSn_CODE(v)   ((uint32_t)((uint32_t)(v) << BP_CAN_CSn_CODE) & BM_CAN_CSn_CODE)

/*! @brief Set the CODE field to a new value. */
#define BW_CAN_CSn_CODE(x, n, v) (HW_CAN_CSn_WR(x, n, (HW_CAN_CSn_RD(x, n) & ~BM_CAN_CSn_CODE) | BF_CAN_CSn_CODE(v)))
/*@}*/
/*******************************************************************************
 * HW_CAN_IDn - Message Buffer 0 ID Register
 ******************************************************************************/

/*!
 * @brief HW_CAN_IDn - Message Buffer 0 ID Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_can_idn
{
    uint32_t U;
    struct _hw_can_idn_bitfields
    {
        uint32_t EXT : 18;             /*!< [17:0] Contains extended (LOW word)
                                        * identifier of message buffer. */
        uint32_t STD : 11;             /*!< [28:18] Contains standard/extended (HIGH
                                        * word) identifier of message buffer. */
        uint32_t PRIO : 3;             /*!< [31:29] Local priority. This 3-bit fieldis
                                        * only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx
                                        * buffers. These bits are not transmitted. They are appended to the regular
                                        * ID to define the transmission priority. */
    } B;
} hw_can_idn_t;

/*!
 * @name Constants and macros for entire CAN_IDn register
 */
/*@{*/
#define HW_CAN_IDn_COUNT (16U)

#define HW_CAN_IDn_ADDR(x, n)    ((uint32_t)(x) + 0x84U + (0x10U * (n)))

#define HW_CAN_IDn(x, n)         (*(__IO hw_can_idn_t *) HW_CAN_IDn_ADDR(x, n))
#define HW_CAN_IDn_RD(x, n)      (HW_CAN_IDn(x, n).U)
#define HW_CAN_IDn_WR(x, n, v)   (HW_CAN_IDn(x, n).U = (v))
#define HW_CAN_IDn_SET(x, n, v)  (HW_CAN_IDn_WR(x, n, HW_CAN_IDn_RD(x, n) |  (v)))
#define HW_CAN_IDn_CLR(x, n, v)  (HW_CAN_IDn_WR(x, n, HW_CAN_IDn_RD(x, n) & ~(v)))
#define HW_CAN_IDn_TOG(x, n, v)  (HW_CAN_IDn_WR(x, n, HW_CAN_IDn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_IDn bitfields
 */

/*!
 * @name Register CAN_IDn, field EXT[17:0] (RW)
 */
/*@{*/
#define BP_CAN_IDn_EXT       (0U)          /*!< Bit position for CAN_IDn_EXT. */
#define BM_CAN_IDn_EXT       (0x0003FFFFU) /*!< Bit mask for CAN_IDn_EXT. */
#define BS_CAN_IDn_EXT       (18U)         /*!< Bit field size in bits for CAN_IDn_EXT. */

/*! @brief Read current value of the CAN_IDn_EXT field. */
#define BR_CAN_IDn_EXT(x, n) (HW_CAN_IDn(x, n).B.EXT)

/*! @brief Format value for bitfield CAN_IDn_EXT. */
#define BF_CAN_IDn_EXT(v)    ((uint32_t)((uint32_t)(v) << BP_CAN_IDn_EXT) & BM_CAN_IDn_EXT)

/*! @brief Set the EXT field to a new value. */
#define BW_CAN_IDn_EXT(x, n, v) (HW_CAN_IDn_WR(x, n, (HW_CAN_IDn_RD(x, n) & ~BM_CAN_IDn_EXT) | BF_CAN_IDn_EXT(v)))
/*@}*/

/*!
 * @name Register CAN_IDn, field STD[28:18] (RW)
 */
/*@{*/
#define BP_CAN_IDn_STD       (18U)         /*!< Bit position for CAN_IDn_STD. */
#define BM_CAN_IDn_STD       (0x1FFC0000U) /*!< Bit mask for CAN_IDn_STD. */
#define BS_CAN_IDn_STD       (11U)         /*!< Bit field size in bits for CAN_IDn_STD. */

/*! @brief Read current value of the CAN_IDn_STD field. */
#define BR_CAN_IDn_STD(x, n) (HW_CAN_IDn(x, n).B.STD)

/*! @brief Format value for bitfield CAN_IDn_STD. */
#define BF_CAN_IDn_STD(v)    ((uint32_t)((uint32_t)(v) << BP_CAN_IDn_STD) & BM_CAN_IDn_STD)

/*! @brief Set the STD field to a new value. */
#define BW_CAN_IDn_STD(x, n, v) (HW_CAN_IDn_WR(x, n, (HW_CAN_IDn_RD(x, n) & ~BM_CAN_IDn_STD) | BF_CAN_IDn_STD(v)))
/*@}*/

/*!
 * @name Register CAN_IDn, field PRIO[31:29] (RW)
 */
/*@{*/
#define BP_CAN_IDn_PRIO      (29U)         /*!< Bit position for CAN_IDn_PRIO. */
#define BM_CAN_IDn_PRIO      (0xE0000000U) /*!< Bit mask for CAN_IDn_PRIO. */
#define BS_CAN_IDn_PRIO      (3U)          /*!< Bit field size in bits for CAN_IDn_PRIO. */

/*! @brief Read current value of the CAN_IDn_PRIO field. */
#define BR_CAN_IDn_PRIO(x, n) (HW_CAN_IDn(x, n).B.PRIO)

/*! @brief Format value for bitfield CAN_IDn_PRIO. */
#define BF_CAN_IDn_PRIO(v)   ((uint32_t)((uint32_t)(v) << BP_CAN_IDn_PRIO) & BM_CAN_IDn_PRIO)

/*! @brief Set the PRIO field to a new value. */
#define BW_CAN_IDn_PRIO(x, n, v) (HW_CAN_IDn_WR(x, n, (HW_CAN_IDn_RD(x, n) & ~BM_CAN_IDn_PRIO) | BF_CAN_IDn_PRIO(v)))
/*@}*/
/*******************************************************************************
 * HW_CAN_WORD0n - Message Buffer 0 WORD0 Register
 ******************************************************************************/

/*!
 * @brief HW_CAN_WORD0n - Message Buffer 0 WORD0 Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_can_word0n
{
    uint32_t U;
    struct _hw_can_word0n_bitfields
    {
        uint32_t DATA_BYTE_3 : 8;      /*!< [7:0] Data byte 3 of Rx/Tx frame. */
        uint32_t DATA_BYTE_2 : 8;      /*!< [15:8] Data byte 2 of Rx/Tx frame. */
        uint32_t DATA_BYTE_1 : 8;      /*!< [23:16] Data byte 1 of Rx/Tx frame. */
        uint32_t DATA_BYTE_0 : 8;      /*!< [31:24] Data byte 0 of Rx/Tx frame. */
    } B;
} hw_can_word0n_t;

/*!
 * @name Constants and macros for entire CAN_WORD0n register
 */
/*@{*/
#define HW_CAN_WORD0n_COUNT (16U)

#define HW_CAN_WORD0n_ADDR(x, n) ((uint32_t)(x) + 0x88U + (0x10U * (n)))

#define HW_CAN_WORD0n(x, n)      (*(__IO hw_can_word0n_t *) HW_CAN_WORD0n_ADDR(x, n))
#define HW_CAN_WORD0n_RD(x, n)   (HW_CAN_WORD0n(x, n).U)
#define HW_CAN_WORD0n_WR(x, n, v) (HW_CAN_WORD0n(x, n).U = (v))
#define HW_CAN_WORD0n_SET(x, n, v) (HW_CAN_WORD0n_WR(x, n, HW_CAN_WORD0n_RD(x, n) |  (v)))
#define HW_CAN_WORD0n_CLR(x, n, v) (HW_CAN_WORD0n_WR(x, n, HW_CAN_WORD0n_RD(x, n) & ~(v)))
#define HW_CAN_WORD0n_TOG(x, n, v) (HW_CAN_WORD0n_WR(x, n, HW_CAN_WORD0n_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_WORD0n bitfields
 */

/*!
 * @name Register CAN_WORD0n, field DATA_BYTE_3[7:0] (RW)
 */
/*@{*/
#define BP_CAN_WORD0n_DATA_BYTE_3 (0U)     /*!< Bit position for CAN_WORD0n_DATA_BYTE_3. */
#define BM_CAN_WORD0n_DATA_BYTE_3 (0x000000FFU) /*!< Bit mask for CAN_WORD0n_DATA_BYTE_3. */
#define BS_CAN_WORD0n_DATA_BYTE_3 (8U)     /*!< Bit field size in bits for CAN_WORD0n_DATA_BYTE_3. */

/*! @brief Read current value of the CAN_WORD0n_DATA_BYTE_3 field. */
#define BR_CAN_WORD0n_DATA_BYTE_3(x, n) (HW_CAN_WORD0n(x, n).B.DATA_BYTE_3)

/*! @brief Format value for bitfield CAN_WORD0n_DATA_BYTE_3. */
#define BF_CAN_WORD0n_DATA_BYTE_3(v) ((uint32_t)((uint32_t)(v) << BP_CAN_WORD0n_DATA_BYTE_3) & BM_CAN_WORD0n_DATA_BYTE_3)

/*! @brief Set the DATA_BYTE_3 field to a new value. */
#define BW_CAN_WORD0n_DATA_BYTE_3(x, n, v) (HW_CAN_WORD0n_WR(x, n, (HW_CAN_WORD0n_RD(x, n) & ~BM_CAN_WORD0n_DATA_BYTE_3) | BF_CAN_WORD0n_DATA_BYTE_3(v)))
/*@}*/

/*!
 * @name Register CAN_WORD0n, field DATA_BYTE_2[15:8] (RW)
 */
/*@{*/
#define BP_CAN_WORD0n_DATA_BYTE_2 (8U)     /*!< Bit position for CAN_WORD0n_DATA_BYTE_2. */
#define BM_CAN_WORD0n_DATA_BYTE_2 (0x0000FF00U) /*!< Bit mask for CAN_WORD0n_DATA_BYTE_2. */
#define BS_CAN_WORD0n_DATA_BYTE_2 (8U)     /*!< Bit field size in bits for CAN_WORD0n_DATA_BYTE_2. */

/*! @brief Read current value of the CAN_WORD0n_DATA_BYTE_2 field. */
#define BR_CAN_WORD0n_DATA_BYTE_2(x, n) (HW_CAN_WORD0n(x, n).B.DATA_BYTE_2)

/*! @brief Format value for bitfield CAN_WORD0n_DATA_BYTE_2. */
#define BF_CAN_WORD0n_DATA_BYTE_2(v) ((uint32_t)((uint32_t)(v) << BP_CAN_WORD0n_DATA_BYTE_2) & BM_CAN_WORD0n_DATA_BYTE_2)

/*! @brief Set the DATA_BYTE_2 field to a new value. */
#define BW_CAN_WORD0n_DATA_BYTE_2(x, n, v) (HW_CAN_WORD0n_WR(x, n, (HW_CAN_WORD0n_RD(x, n) & ~BM_CAN_WORD0n_DATA_BYTE_2) | BF_CAN_WORD0n_DATA_BYTE_2(v)))
/*@}*/

/*!
 * @name Register CAN_WORD0n, field DATA_BYTE_1[23:16] (RW)
 */
/*@{*/
#define BP_CAN_WORD0n_DATA_BYTE_1 (16U)    /*!< Bit position for CAN_WORD0n_DATA_BYTE_1. */
#define BM_CAN_WORD0n_DATA_BYTE_1 (0x00FF0000U) /*!< Bit mask for CAN_WORD0n_DATA_BYTE_1. */
#define BS_CAN_WORD0n_DATA_BYTE_1 (8U)     /*!< Bit field size in bits for CAN_WORD0n_DATA_BYTE_1. */

/*! @brief Read current value of the CAN_WORD0n_DATA_BYTE_1 field. */
#define BR_CAN_WORD0n_DATA_BYTE_1(x, n) (HW_CAN_WORD0n(x, n).B.DATA_BYTE_1)

/*! @brief Format value for bitfield CAN_WORD0n_DATA_BYTE_1. */
#define BF_CAN_WORD0n_DATA_BYTE_1(v) ((uint32_t)((uint32_t)(v) << BP_CAN_WORD0n_DATA_BYTE_1) & BM_CAN_WORD0n_DATA_BYTE_1)

/*! @brief Set the DATA_BYTE_1 field to a new value. */
#define BW_CAN_WORD0n_DATA_BYTE_1(x, n, v) (HW_CAN_WORD0n_WR(x, n, (HW_CAN_WORD0n_RD(x, n) & ~BM_CAN_WORD0n_DATA_BYTE_1) | BF_CAN_WORD0n_DATA_BYTE_1(v)))
/*@}*/

/*!
 * @name Register CAN_WORD0n, field DATA_BYTE_0[31:24] (RW)
 */
/*@{*/
#define BP_CAN_WORD0n_DATA_BYTE_0 (24U)    /*!< Bit position for CAN_WORD0n_DATA_BYTE_0. */
#define BM_CAN_WORD0n_DATA_BYTE_0 (0xFF000000U) /*!< Bit mask for CAN_WORD0n_DATA_BYTE_0. */
#define BS_CAN_WORD0n_DATA_BYTE_0 (8U)     /*!< Bit field size in bits for CAN_WORD0n_DATA_BYTE_0. */

/*! @brief Read current value of the CAN_WORD0n_DATA_BYTE_0 field. */
#define BR_CAN_WORD0n_DATA_BYTE_0(x, n) (HW_CAN_WORD0n(x, n).B.DATA_BYTE_0)

/*! @brief Format value for bitfield CAN_WORD0n_DATA_BYTE_0. */
#define BF_CAN_WORD0n_DATA_BYTE_0(v) ((uint32_t)((uint32_t)(v) << BP_CAN_WORD0n_DATA_BYTE_0) & BM_CAN_WORD0n_DATA_BYTE_0)

/*! @brief Set the DATA_BYTE_0 field to a new value. */
#define BW_CAN_WORD0n_DATA_BYTE_0(x, n, v) (HW_CAN_WORD0n_WR(x, n, (HW_CAN_WORD0n_RD(x, n) & ~BM_CAN_WORD0n_DATA_BYTE_0) | BF_CAN_WORD0n_DATA_BYTE_0(v)))
/*@}*/
/*******************************************************************************
 * HW_CAN_WORD1n - Message Buffer 0 WORD1 Register
 ******************************************************************************/

/*!
 * @brief HW_CAN_WORD1n - Message Buffer 0 WORD1 Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_can_word1n
{
    uint32_t U;
    struct _hw_can_word1n_bitfields
    {
        uint32_t DATA_BYTE_7 : 8;      /*!< [7:0] Data byte 7 of Rx/Tx frame. */
        uint32_t DATA_BYTE_6 : 8;      /*!< [15:8] Data byte 6 of Rx/Tx frame. */
        uint32_t DATA_BYTE_5 : 8;      /*!< [23:16] Data byte 5 of Rx/Tx frame. */
        uint32_t DATA_BYTE_4 : 8;      /*!< [31:24] Data byte 4 of Rx/Tx frame. */
    } B;
} hw_can_word1n_t;

/*!
 * @name Constants and macros for entire CAN_WORD1n register
 */
/*@{*/
#define HW_CAN_WORD1n_COUNT (16U)

#define HW_CAN_WORD1n_ADDR(x, n) ((uint32_t)(x) + 0x8CU + (0x10U * (n)))

#define HW_CAN_WORD1n(x, n)      (*(__IO hw_can_word1n_t *) HW_CAN_WORD1n_ADDR(x, n))
#define HW_CAN_WORD1n_RD(x, n)   (HW_CAN_WORD1n(x, n).U)
#define HW_CAN_WORD1n_WR(x, n, v) (HW_CAN_WORD1n(x, n).U = (v))
#define HW_CAN_WORD1n_SET(x, n, v) (HW_CAN_WORD1n_WR(x, n, HW_CAN_WORD1n_RD(x, n) |  (v)))
#define HW_CAN_WORD1n_CLR(x, n, v) (HW_CAN_WORD1n_WR(x, n, HW_CAN_WORD1n_RD(x, n) & ~(v)))
#define HW_CAN_WORD1n_TOG(x, n, v) (HW_CAN_WORD1n_WR(x, n, HW_CAN_WORD1n_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_WORD1n bitfields
 */

/*!
 * @name Register CAN_WORD1n, field DATA_BYTE_7[7:0] (RW)
 */
/*@{*/
#define BP_CAN_WORD1n_DATA_BYTE_7 (0U)     /*!< Bit position for CAN_WORD1n_DATA_BYTE_7. */
#define BM_CAN_WORD1n_DATA_BYTE_7 (0x000000FFU) /*!< Bit mask for CAN_WORD1n_DATA_BYTE_7. */
#define BS_CAN_WORD1n_DATA_BYTE_7 (8U)     /*!< Bit field size in bits for CAN_WORD1n_DATA_BYTE_7. */

/*! @brief Read current value of the CAN_WORD1n_DATA_BYTE_7 field. */
#define BR_CAN_WORD1n_DATA_BYTE_7(x, n) (HW_CAN_WORD1n(x, n).B.DATA_BYTE_7)

/*! @brief Format value for bitfield CAN_WORD1n_DATA_BYTE_7. */
#define BF_CAN_WORD1n_DATA_BYTE_7(v) ((uint32_t)((uint32_t)(v) << BP_CAN_WORD1n_DATA_BYTE_7) & BM_CAN_WORD1n_DATA_BYTE_7)

/*! @brief Set the DATA_BYTE_7 field to a new value. */
#define BW_CAN_WORD1n_DATA_BYTE_7(x, n, v) (HW_CAN_WORD1n_WR(x, n, (HW_CAN_WORD1n_RD(x, n) & ~BM_CAN_WORD1n_DATA_BYTE_7) | BF_CAN_WORD1n_DATA_BYTE_7(v)))
/*@}*/

/*!
 * @name Register CAN_WORD1n, field DATA_BYTE_6[15:8] (RW)
 */
/*@{*/
#define BP_CAN_WORD1n_DATA_BYTE_6 (8U)     /*!< Bit position for CAN_WORD1n_DATA_BYTE_6. */
#define BM_CAN_WORD1n_DATA_BYTE_6 (0x0000FF00U) /*!< Bit mask for CAN_WORD1n_DATA_BYTE_6. */
#define BS_CAN_WORD1n_DATA_BYTE_6 (8U)     /*!< Bit field size in bits for CAN_WORD1n_DATA_BYTE_6. */

/*! @brief Read current value of the CAN_WORD1n_DATA_BYTE_6 field. */
#define BR_CAN_WORD1n_DATA_BYTE_6(x, n) (HW_CAN_WORD1n(x, n).B.DATA_BYTE_6)

/*! @brief Format value for bitfield CAN_WORD1n_DATA_BYTE_6. */
#define BF_CAN_WORD1n_DATA_BYTE_6(v) ((uint32_t)((uint32_t)(v) << BP_CAN_WORD1n_DATA_BYTE_6) & BM_CAN_WORD1n_DATA_BYTE_6)

/*! @brief Set the DATA_BYTE_6 field to a new value. */
#define BW_CAN_WORD1n_DATA_BYTE_6(x, n, v) (HW_CAN_WORD1n_WR(x, n, (HW_CAN_WORD1n_RD(x, n) & ~BM_CAN_WORD1n_DATA_BYTE_6) | BF_CAN_WORD1n_DATA_BYTE_6(v)))
/*@}*/

/*!
 * @name Register CAN_WORD1n, field DATA_BYTE_5[23:16] (RW)
 */
/*@{*/
#define BP_CAN_WORD1n_DATA_BYTE_5 (16U)    /*!< Bit position for CAN_WORD1n_DATA_BYTE_5. */
#define BM_CAN_WORD1n_DATA_BYTE_5 (0x00FF0000U) /*!< Bit mask for CAN_WORD1n_DATA_BYTE_5. */
#define BS_CAN_WORD1n_DATA_BYTE_5 (8U)     /*!< Bit field size in bits for CAN_WORD1n_DATA_BYTE_5. */

/*! @brief Read current value of the CAN_WORD1n_DATA_BYTE_5 field. */
#define BR_CAN_WORD1n_DATA_BYTE_5(x, n) (HW_CAN_WORD1n(x, n).B.DATA_BYTE_5)

/*! @brief Format value for bitfield CAN_WORD1n_DATA_BYTE_5. */
#define BF_CAN_WORD1n_DATA_BYTE_5(v) ((uint32_t)((uint32_t)(v) << BP_CAN_WORD1n_DATA_BYTE_5) & BM_CAN_WORD1n_DATA_BYTE_5)

/*! @brief Set the DATA_BYTE_5 field to a new value. */
#define BW_CAN_WORD1n_DATA_BYTE_5(x, n, v) (HW_CAN_WORD1n_WR(x, n, (HW_CAN_WORD1n_RD(x, n) & ~BM_CAN_WORD1n_DATA_BYTE_5) | BF_CAN_WORD1n_DATA_BYTE_5(v)))
/*@}*/

/*!
 * @name Register CAN_WORD1n, field DATA_BYTE_4[31:24] (RW)
 */
/*@{*/
#define BP_CAN_WORD1n_DATA_BYTE_4 (24U)    /*!< Bit position for CAN_WORD1n_DATA_BYTE_4. */
#define BM_CAN_WORD1n_DATA_BYTE_4 (0xFF000000U) /*!< Bit mask for CAN_WORD1n_DATA_BYTE_4. */
#define BS_CAN_WORD1n_DATA_BYTE_4 (8U)     /*!< Bit field size in bits for CAN_WORD1n_DATA_BYTE_4. */

/*! @brief Read current value of the CAN_WORD1n_DATA_BYTE_4 field. */
#define BR_CAN_WORD1n_DATA_BYTE_4(x, n) (HW_CAN_WORD1n(x, n).B.DATA_BYTE_4)

/*! @brief Format value for bitfield CAN_WORD1n_DATA_BYTE_4. */
#define BF_CAN_WORD1n_DATA_BYTE_4(v) ((uint32_t)((uint32_t)(v) << BP_CAN_WORD1n_DATA_BYTE_4) & BM_CAN_WORD1n_DATA_BYTE_4)

/*! @brief Set the DATA_BYTE_4 field to a new value. */
#define BW_CAN_WORD1n_DATA_BYTE_4(x, n, v) (HW_CAN_WORD1n_WR(x, n, (HW_CAN_WORD1n_RD(x, n) & ~BM_CAN_WORD1n_DATA_BYTE_4) | BF_CAN_WORD1n_DATA_BYTE_4(v)))
/*@}*/

/*******************************************************************************
 * HW_CAN_RXIMRn - Rx Individual Mask Registers
 ******************************************************************************/

/*!
 * @brief HW_CAN_RXIMRn - Rx Individual Mask Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers are located in RAM. RXIMR are used as acceptance masks for ID
 * filtering in Rx MBs and the Rx FIFO. If the Rx FIFO is not enabled, one mask
 * register is provided for each available Mailbox, providing ID masking
 * capability on a per Mailbox basis. When the Rx FIFO is enabled (MCR[RFEN] bit is
 * asserted), up to 32 Rx Individual Mask Registers can apply to the Rx FIFO ID Filter
 * Table elements on a one-to-one correspondence depending on the setting of
 * CTRL2[RFFN]. RXIMR can only be written by the CPU while the module is in Freeze
 * mode; otherwise, they are blocked by hardware. The Individual Rx Mask Registers
 * are not affected by reset and must be explicitly initialized prior to any
 * reception.
 */
typedef union _hw_can_rximrn
{
    uint32_t U;
    struct _hw_can_rximrn_bitfields
    {
        uint32_t MI : 32;              /*!< [31:0] Individual Mask Bits */
    } B;
} hw_can_rximrn_t;

/*!
 * @name Constants and macros for entire CAN_RXIMRn register
 */
/*@{*/
#define HW_CAN_RXIMRn_COUNT (16U)

#define HW_CAN_RXIMRn_ADDR(x, n) ((uint32_t)(x) + 0x880U + (0x4U * (n)))

#define HW_CAN_RXIMRn(x, n)      (*(__IO hw_can_rximrn_t *) HW_CAN_RXIMRn_ADDR(x, n))
#define HW_CAN_RXIMRn_RD(x, n)   (HW_CAN_RXIMRn(x, n).U)
#define HW_CAN_RXIMRn_WR(x, n, v) (HW_CAN_RXIMRn(x, n).U = (v))
#define HW_CAN_RXIMRn_SET(x, n, v) (HW_CAN_RXIMRn_WR(x, n, HW_CAN_RXIMRn_RD(x, n) |  (v)))
#define HW_CAN_RXIMRn_CLR(x, n, v) (HW_CAN_RXIMRn_WR(x, n, HW_CAN_RXIMRn_RD(x, n) & ~(v)))
#define HW_CAN_RXIMRn_TOG(x, n, v) (HW_CAN_RXIMRn_WR(x, n, HW_CAN_RXIMRn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CAN_RXIMRn bitfields
 */

/*!
 * @name Register CAN_RXIMRn, field MI[31:0] (RW)
 *
 * Each Individual Mask Bit masks the corresponding bit in both the Mailbox
 * filter and Rx FIFO ID Filter Table element in distinct ways. For Mailbox filters,
 * see the RXMGMASK register description. For Rx FIFO ID Filter Table elements,
 * see the RXFGMASK register description.
 *
 * Values:
 * - 0 - The corresponding bit in the filter is "don't care."
 * - 1 - The corresponding bit in the filter is checked.
 */
/*@{*/
#define BP_CAN_RXIMRn_MI     (0U)          /*!< Bit position for CAN_RXIMRn_MI. */
#define BM_CAN_RXIMRn_MI     (0xFFFFFFFFU) /*!< Bit mask for CAN_RXIMRn_MI. */
#define BS_CAN_RXIMRn_MI     (32U)         /*!< Bit field size in bits for CAN_RXIMRn_MI. */

/*! @brief Read current value of the CAN_RXIMRn_MI field. */
#define BR_CAN_RXIMRn_MI(x, n) (HW_CAN_RXIMRn(x, n).U)

/*! @brief Format value for bitfield CAN_RXIMRn_MI. */
#define BF_CAN_RXIMRn_MI(v)  ((uint32_t)((uint32_t)(v) << BP_CAN_RXIMRn_MI) & BM_CAN_RXIMRn_MI)

/*! @brief Set the MI field to a new value. */
#define BW_CAN_RXIMRn_MI(x, n, v) (HW_CAN_RXIMRn_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * hw_can_t - module struct
 ******************************************************************************/
/*!
 * @brief All CAN module registers.
 */
#pragma pack(1)
typedef struct _hw_can
{
    __IO hw_can_mcr_t MCR;                 /*!< [0x0] Module Configuration Register */
    __IO hw_can_ctrl1_t CTRL1;             /*!< [0x4] Control 1 register */
    __IO hw_can_timer_t TIMER;             /*!< [0x8] Free Running Timer */
    uint8_t _reserved0[4];
    __IO hw_can_rxmgmask_t RXMGMASK;       /*!< [0x10] Rx Mailboxes Global Mask Register */
    __IO hw_can_rx14mask_t RX14MASK;       /*!< [0x14] Rx 14 Mask register */
    __IO hw_can_rx15mask_t RX15MASK;       /*!< [0x18] Rx 15 Mask register */
    __IO hw_can_ecr_t ECR;                 /*!< [0x1C] Error Counter */
    __IO hw_can_esr1_t ESR1;               /*!< [0x20] Error and Status 1 register */
    uint8_t _reserved1[4];
    __IO hw_can_imask1_t IMASK1;           /*!< [0x28] Interrupt Masks 1 register */
    uint8_t _reserved2[4];
    __IO hw_can_iflag1_t IFLAG1;           /*!< [0x30] Interrupt Flags 1 register */
    __IO hw_can_ctrl2_t CTRL2;             /*!< [0x34] Control 2 register */
    __I hw_can_esr2_t ESR2;                /*!< [0x38] Error and Status 2 register */
    uint8_t _reserved3[8];
    __I hw_can_crcr_t CRCR;                /*!< [0x44] CRC Register */
    __IO hw_can_rxfgmask_t RXFGMASK;       /*!< [0x48] Rx FIFO Global Mask register */
    __I hw_can_rxfir_t RXFIR;              /*!< [0x4C] Rx FIFO Information Register */
    uint8_t _reserved4[48];
    struct {
        __IO hw_can_csn_t CSn;             /*!< [0x80] Message Buffer 0 CS Register */
        __IO hw_can_idn_t IDn;             /*!< [0x84] Message Buffer 0 ID Register */
        __IO hw_can_word0n_t WORD0n;       /*!< [0x88] Message Buffer 0 WORD0 Register */
        __IO hw_can_word1n_t WORD1n;       /*!< [0x8C] Message Buffer 0 WORD1 Register */
    } MB[16];
    uint8_t _reserved5[1792];
    __IO hw_can_rximrn_t RXIMRn[16];       /*!< [0x880] Rx Individual Mask Registers */
} hw_can_t;
#pragma pack()

/*! @brief Macro to access all CAN registers. */
/*! @param x CAN module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_CAN_REGS(CAN0_BASE)</code>. */
#define HW_CAN_REGS(x) (*(hw_can_t *)(x))

/*
 * MK64F12 CAU
 *
 * Memory Mapped Cryptographic Acceleration Unit (MMCAU)
 *
 * Registers defined in this header file:
 * - HW_CAU_DIRECT0 - Direct access register 0
 * - HW_CAU_DIRECT1 - Direct access register 1
 * - HW_CAU_DIRECT2 - Direct access register 2
 * - HW_CAU_DIRECT3 - Direct access register 3
 * - HW_CAU_DIRECT4 - Direct access register 4
 * - HW_CAU_DIRECT5 - Direct access register 5
 * - HW_CAU_DIRECT6 - Direct access register 6
 * - HW_CAU_DIRECT7 - Direct access register 7
 * - HW_CAU_DIRECT8 - Direct access register 8
 * - HW_CAU_DIRECT9 - Direct access register 9
 * - HW_CAU_DIRECT10 - Direct access register 10
 * - HW_CAU_DIRECT11 - Direct access register 11
 * - HW_CAU_DIRECT12 - Direct access register 12
 * - HW_CAU_DIRECT13 - Direct access register 13
 * - HW_CAU_DIRECT14 - Direct access register 14
 * - HW_CAU_DIRECT15 - Direct access register 15
 * - HW_CAU_LDR_CASR - Status register  - Load Register command
 * - HW_CAU_LDR_CAA - Accumulator register - Load Register command
 * - HW_CAU_LDR_CA0 - General Purpose Register 0 - Load Register command
 * - HW_CAU_LDR_CA1 - General Purpose Register 1 - Load Register command
 * - HW_CAU_LDR_CA2 - General Purpose Register 2 - Load Register command
 * - HW_CAU_LDR_CA3 - General Purpose Register 3 - Load Register command
 * - HW_CAU_LDR_CA4 - General Purpose Register 4 - Load Register command
 * - HW_CAU_LDR_CA5 - General Purpose Register 5 - Load Register command
 * - HW_CAU_LDR_CA6 - General Purpose Register 6 - Load Register command
 * - HW_CAU_LDR_CA7 - General Purpose Register 7 - Load Register command
 * - HW_CAU_LDR_CA8 - General Purpose Register 8 - Load Register command
 * - HW_CAU_STR_CASR - Status register  - Store Register command
 * - HW_CAU_STR_CAA - Accumulator register - Store Register command
 * - HW_CAU_STR_CA0 - General Purpose Register 0 - Store Register command
 * - HW_CAU_STR_CA1 - General Purpose Register 1 - Store Register command
 * - HW_CAU_STR_CA2 - General Purpose Register 2 - Store Register command
 * - HW_CAU_STR_CA3 - General Purpose Register 3 - Store Register command
 * - HW_CAU_STR_CA4 - General Purpose Register 4 - Store Register command
 * - HW_CAU_STR_CA5 - General Purpose Register 5 - Store Register command
 * - HW_CAU_STR_CA6 - General Purpose Register 6 - Store Register command
 * - HW_CAU_STR_CA7 - General Purpose Register 7 - Store Register command
 * - HW_CAU_STR_CA8 - General Purpose Register 8 - Store Register command
 * - HW_CAU_ADR_CASR - Status register  - Add Register command
 * - HW_CAU_ADR_CAA - Accumulator register - Add to register command
 * - HW_CAU_ADR_CA0 - General Purpose Register 0 - Add to register command
 * - HW_CAU_ADR_CA1 - General Purpose Register 1 - Add to register command
 * - HW_CAU_ADR_CA2 - General Purpose Register 2 - Add to register command
 * - HW_CAU_ADR_CA3 - General Purpose Register 3 - Add to register command
 * - HW_CAU_ADR_CA4 - General Purpose Register 4 - Add to register command
 * - HW_CAU_ADR_CA5 - General Purpose Register 5 - Add to register command
 * - HW_CAU_ADR_CA6 - General Purpose Register 6 - Add to register command
 * - HW_CAU_ADR_CA7 - General Purpose Register 7 - Add to register command
 * - HW_CAU_ADR_CA8 - General Purpose Register 8 - Add to register command
 * - HW_CAU_RADR_CASR - Status register  - Reverse and Add to Register command
 * - HW_CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command
 * - HW_CAU_RADR_CA0 - General Purpose Register 0 - Reverse and Add to Register command
 * - HW_CAU_RADR_CA1 - General Purpose Register 1 - Reverse and Add to Register command
 * - HW_CAU_RADR_CA2 - General Purpose Register 2 - Reverse and Add to Register command
 * - HW_CAU_RADR_CA3 - General Purpose Register 3 - Reverse and Add to Register command
 * - HW_CAU_RADR_CA4 - General Purpose Register 4 - Reverse and Add to Register command
 * - HW_CAU_RADR_CA5 - General Purpose Register 5 - Reverse and Add to Register command
 * - HW_CAU_RADR_CA6 - General Purpose Register 6 - Reverse and Add to Register command
 * - HW_CAU_RADR_CA7 - General Purpose Register 7 - Reverse and Add to Register command
 * - HW_CAU_RADR_CA8 - General Purpose Register 8 - Reverse and Add to Register command
 * - HW_CAU_XOR_CASR - Status register  - Exclusive Or command
 * - HW_CAU_XOR_CAA - Accumulator register - Exclusive Or command
 * - HW_CAU_XOR_CA0 - General Purpose Register 0 - Exclusive Or command
 * - HW_CAU_XOR_CA1 - General Purpose Register 1 - Exclusive Or command
 * - HW_CAU_XOR_CA2 - General Purpose Register 2 - Exclusive Or command
 * - HW_CAU_XOR_CA3 - General Purpose Register 3 - Exclusive Or command
 * - HW_CAU_XOR_CA4 - General Purpose Register 4 - Exclusive Or command
 * - HW_CAU_XOR_CA5 - General Purpose Register 5 - Exclusive Or command
 * - HW_CAU_XOR_CA6 - General Purpose Register 6 - Exclusive Or command
 * - HW_CAU_XOR_CA7 - General Purpose Register 7 - Exclusive Or command
 * - HW_CAU_XOR_CA8 - General Purpose Register 8 - Exclusive Or command
 * - HW_CAU_ROTL_CASR - Status register  - Rotate Left command
 * - HW_CAU_ROTL_CAA - Accumulator register - Rotate Left command
 * - HW_CAU_ROTL_CA0 - General Purpose Register 0 - Rotate Left command
 * - HW_CAU_ROTL_CA1 - General Purpose Register 1 - Rotate Left command
 * - HW_CAU_ROTL_CA2 - General Purpose Register 2 - Rotate Left command
 * - HW_CAU_ROTL_CA3 - General Purpose Register 3 - Rotate Left command
 * - HW_CAU_ROTL_CA4 - General Purpose Register 4 - Rotate Left command
 * - HW_CAU_ROTL_CA5 - General Purpose Register 5 - Rotate Left command
 * - HW_CAU_ROTL_CA6 - General Purpose Register 6 - Rotate Left command
 * - HW_CAU_ROTL_CA7 - General Purpose Register 7 - Rotate Left command
 * - HW_CAU_ROTL_CA8 - General Purpose Register 8 - Rotate Left command
 * - HW_CAU_AESC_CASR - Status register  - AES Column Operation command
 * - HW_CAU_AESC_CAA - Accumulator register - AES Column Operation command
 * - HW_CAU_AESC_CA0 - General Purpose Register 0 - AES Column Operation command
 * - HW_CAU_AESC_CA1 - General Purpose Register 1 - AES Column Operation command
 * - HW_CAU_AESC_CA2 - General Purpose Register 2 - AES Column Operation command
 * - HW_CAU_AESC_CA3 - General Purpose Register 3 - AES Column Operation command
 * - HW_CAU_AESC_CA4 - General Purpose Register 4 - AES Column Operation command
 * - HW_CAU_AESC_CA5 - General Purpose Register 5 - AES Column Operation command
 * - HW_CAU_AESC_CA6 - General Purpose Register 6 - AES Column Operation command
 * - HW_CAU_AESC_CA7 - General Purpose Register 7 - AES Column Operation command
 * - HW_CAU_AESC_CA8 - General Purpose Register 8 - AES Column Operation command
 * - HW_CAU_AESIC_CASR - Status register  - AES Inverse Column Operation command
 * - HW_CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command
 * - HW_CAU_AESIC_CA0 - General Purpose Register 0 - AES Inverse Column Operation command
 * - HW_CAU_AESIC_CA1 - General Purpose Register 1 - AES Inverse Column Operation command
 * - HW_CAU_AESIC_CA2 - General Purpose Register 2 - AES Inverse Column Operation command
 * - HW_CAU_AESIC_CA3 - General Purpose Register 3 - AES Inverse Column Operation command
 * - HW_CAU_AESIC_CA4 - General Purpose Register 4 - AES Inverse Column Operation command
 * - HW_CAU_AESIC_CA5 - General Purpose Register 5 - AES Inverse Column Operation command
 * - HW_CAU_AESIC_CA6 - General Purpose Register 6 - AES Inverse Column Operation command
 * - HW_CAU_AESIC_CA7 - General Purpose Register 7 - AES Inverse Column Operation command
 * - HW_CAU_AESIC_CA8 - General Purpose Register 8 - AES Inverse Column Operation command
 *
 * - hw_cau_t - Struct containing all module registers.
 */

#define HW_CAU_INSTANCE_COUNT (1U) /*!< Number of instances of the CAU module. */
#define HW_CAU (0U) /*!< Instance number for CAU. */

/*******************************************************************************
 * HW_CAU_DIRECT0 - Direct access register 0
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT0 - Direct access register 0 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct0
{
    uint32_t U;
    struct _hw_cau_direct0_bitfields
    {
        uint32_t CAU_DIRECT0b : 32;    /*!< [31:0] Direct register 0 */
    } B;
} hw_cau_direct0_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT0 register
 */
/*@{*/
#define HW_CAU_DIRECT0_ADDR(x)   ((uint32_t)(x) + 0x0U)

#define HW_CAU_DIRECT0(x)        (*(__O hw_cau_direct0_t *) HW_CAU_DIRECT0_ADDR(x))
#define HW_CAU_DIRECT0_WR(x, v)  (HW_CAU_DIRECT0(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT0 bitfields
 */

/*!
 * @name Register CAU_DIRECT0, field CAU_DIRECT0[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT0_CAU_DIRECT0 (0U)    /*!< Bit position for CAU_DIRECT0_CAU_DIRECT0. */
#define BM_CAU_DIRECT0_CAU_DIRECT0 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT0_CAU_DIRECT0. */
#define BS_CAU_DIRECT0_CAU_DIRECT0 (32U)   /*!< Bit field size in bits for CAU_DIRECT0_CAU_DIRECT0. */

/*! @brief Format value for bitfield CAU_DIRECT0_CAU_DIRECT0. */
#define BF_CAU_DIRECT0_CAU_DIRECT0(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT0_CAU_DIRECT0) & BM_CAU_DIRECT0_CAU_DIRECT0)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT1 - Direct access register 1
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT1 - Direct access register 1 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct1
{
    uint32_t U;
    struct _hw_cau_direct1_bitfields
    {
        uint32_t CAU_DIRECT1b : 32;    /*!< [31:0] Direct register 1 */
    } B;
} hw_cau_direct1_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT1 register
 */
/*@{*/
#define HW_CAU_DIRECT1_ADDR(x)   ((uint32_t)(x) + 0x4U)

#define HW_CAU_DIRECT1(x)        (*(__O hw_cau_direct1_t *) HW_CAU_DIRECT1_ADDR(x))
#define HW_CAU_DIRECT1_WR(x, v)  (HW_CAU_DIRECT1(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT1 bitfields
 */

/*!
 * @name Register CAU_DIRECT1, field CAU_DIRECT1[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT1_CAU_DIRECT1 (0U)    /*!< Bit position for CAU_DIRECT1_CAU_DIRECT1. */
#define BM_CAU_DIRECT1_CAU_DIRECT1 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT1_CAU_DIRECT1. */
#define BS_CAU_DIRECT1_CAU_DIRECT1 (32U)   /*!< Bit field size in bits for CAU_DIRECT1_CAU_DIRECT1. */

/*! @brief Format value for bitfield CAU_DIRECT1_CAU_DIRECT1. */
#define BF_CAU_DIRECT1_CAU_DIRECT1(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT1_CAU_DIRECT1) & BM_CAU_DIRECT1_CAU_DIRECT1)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT2 - Direct access register 2
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT2 - Direct access register 2 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct2
{
    uint32_t U;
    struct _hw_cau_direct2_bitfields
    {
        uint32_t CAU_DIRECT2b : 32;    /*!< [31:0] Direct register 2 */
    } B;
} hw_cau_direct2_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT2 register
 */
/*@{*/
#define HW_CAU_DIRECT2_ADDR(x)   ((uint32_t)(x) + 0x8U)

#define HW_CAU_DIRECT2(x)        (*(__O hw_cau_direct2_t *) HW_CAU_DIRECT2_ADDR(x))
#define HW_CAU_DIRECT2_WR(x, v)  (HW_CAU_DIRECT2(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT2 bitfields
 */

/*!
 * @name Register CAU_DIRECT2, field CAU_DIRECT2[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT2_CAU_DIRECT2 (0U)    /*!< Bit position for CAU_DIRECT2_CAU_DIRECT2. */
#define BM_CAU_DIRECT2_CAU_DIRECT2 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT2_CAU_DIRECT2. */
#define BS_CAU_DIRECT2_CAU_DIRECT2 (32U)   /*!< Bit field size in bits for CAU_DIRECT2_CAU_DIRECT2. */

/*! @brief Format value for bitfield CAU_DIRECT2_CAU_DIRECT2. */
#define BF_CAU_DIRECT2_CAU_DIRECT2(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT2_CAU_DIRECT2) & BM_CAU_DIRECT2_CAU_DIRECT2)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT3 - Direct access register 3
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT3 - Direct access register 3 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct3
{
    uint32_t U;
    struct _hw_cau_direct3_bitfields
    {
        uint32_t CAU_DIRECT3b : 32;    /*!< [31:0] Direct register 3 */
    } B;
} hw_cau_direct3_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT3 register
 */
/*@{*/
#define HW_CAU_DIRECT3_ADDR(x)   ((uint32_t)(x) + 0xCU)

#define HW_CAU_DIRECT3(x)        (*(__O hw_cau_direct3_t *) HW_CAU_DIRECT3_ADDR(x))
#define HW_CAU_DIRECT3_WR(x, v)  (HW_CAU_DIRECT3(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT3 bitfields
 */

/*!
 * @name Register CAU_DIRECT3, field CAU_DIRECT3[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT3_CAU_DIRECT3 (0U)    /*!< Bit position for CAU_DIRECT3_CAU_DIRECT3. */
#define BM_CAU_DIRECT3_CAU_DIRECT3 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT3_CAU_DIRECT3. */
#define BS_CAU_DIRECT3_CAU_DIRECT3 (32U)   /*!< Bit field size in bits for CAU_DIRECT3_CAU_DIRECT3. */

/*! @brief Format value for bitfield CAU_DIRECT3_CAU_DIRECT3. */
#define BF_CAU_DIRECT3_CAU_DIRECT3(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT3_CAU_DIRECT3) & BM_CAU_DIRECT3_CAU_DIRECT3)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT4 - Direct access register 4
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT4 - Direct access register 4 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct4
{
    uint32_t U;
    struct _hw_cau_direct4_bitfields
    {
        uint32_t CAU_DIRECT4b : 32;    /*!< [31:0] Direct register 4 */
    } B;
} hw_cau_direct4_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT4 register
 */
/*@{*/
#define HW_CAU_DIRECT4_ADDR(x)   ((uint32_t)(x) + 0x10U)

#define HW_CAU_DIRECT4(x)        (*(__O hw_cau_direct4_t *) HW_CAU_DIRECT4_ADDR(x))
#define HW_CAU_DIRECT4_WR(x, v)  (HW_CAU_DIRECT4(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT4 bitfields
 */

/*!
 * @name Register CAU_DIRECT4, field CAU_DIRECT4[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT4_CAU_DIRECT4 (0U)    /*!< Bit position for CAU_DIRECT4_CAU_DIRECT4. */
#define BM_CAU_DIRECT4_CAU_DIRECT4 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT4_CAU_DIRECT4. */
#define BS_CAU_DIRECT4_CAU_DIRECT4 (32U)   /*!< Bit field size in bits for CAU_DIRECT4_CAU_DIRECT4. */

/*! @brief Format value for bitfield CAU_DIRECT4_CAU_DIRECT4. */
#define BF_CAU_DIRECT4_CAU_DIRECT4(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT4_CAU_DIRECT4) & BM_CAU_DIRECT4_CAU_DIRECT4)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT5 - Direct access register 5
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT5 - Direct access register 5 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct5
{
    uint32_t U;
    struct _hw_cau_direct5_bitfields
    {
        uint32_t CAU_DIRECT5b : 32;    /*!< [31:0] Direct register 5 */
    } B;
} hw_cau_direct5_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT5 register
 */
/*@{*/
#define HW_CAU_DIRECT5_ADDR(x)   ((uint32_t)(x) + 0x14U)

#define HW_CAU_DIRECT5(x)        (*(__O hw_cau_direct5_t *) HW_CAU_DIRECT5_ADDR(x))
#define HW_CAU_DIRECT5_WR(x, v)  (HW_CAU_DIRECT5(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT5 bitfields
 */

/*!
 * @name Register CAU_DIRECT5, field CAU_DIRECT5[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT5_CAU_DIRECT5 (0U)    /*!< Bit position for CAU_DIRECT5_CAU_DIRECT5. */
#define BM_CAU_DIRECT5_CAU_DIRECT5 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT5_CAU_DIRECT5. */
#define BS_CAU_DIRECT5_CAU_DIRECT5 (32U)   /*!< Bit field size in bits for CAU_DIRECT5_CAU_DIRECT5. */

/*! @brief Format value for bitfield CAU_DIRECT5_CAU_DIRECT5. */
#define BF_CAU_DIRECT5_CAU_DIRECT5(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT5_CAU_DIRECT5) & BM_CAU_DIRECT5_CAU_DIRECT5)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT6 - Direct access register 6
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT6 - Direct access register 6 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct6
{
    uint32_t U;
    struct _hw_cau_direct6_bitfields
    {
        uint32_t CAU_DIRECT6b : 32;    /*!< [31:0] Direct register 6 */
    } B;
} hw_cau_direct6_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT6 register
 */
/*@{*/
#define HW_CAU_DIRECT6_ADDR(x)   ((uint32_t)(x) + 0x18U)

#define HW_CAU_DIRECT6(x)        (*(__O hw_cau_direct6_t *) HW_CAU_DIRECT6_ADDR(x))
#define HW_CAU_DIRECT6_WR(x, v)  (HW_CAU_DIRECT6(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT6 bitfields
 */

/*!
 * @name Register CAU_DIRECT6, field CAU_DIRECT6[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT6_CAU_DIRECT6 (0U)    /*!< Bit position for CAU_DIRECT6_CAU_DIRECT6. */
#define BM_CAU_DIRECT6_CAU_DIRECT6 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT6_CAU_DIRECT6. */
#define BS_CAU_DIRECT6_CAU_DIRECT6 (32U)   /*!< Bit field size in bits for CAU_DIRECT6_CAU_DIRECT6. */

/*! @brief Format value for bitfield CAU_DIRECT6_CAU_DIRECT6. */
#define BF_CAU_DIRECT6_CAU_DIRECT6(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT6_CAU_DIRECT6) & BM_CAU_DIRECT6_CAU_DIRECT6)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT7 - Direct access register 7
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT7 - Direct access register 7 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct7
{
    uint32_t U;
    struct _hw_cau_direct7_bitfields
    {
        uint32_t CAU_DIRECT7b : 32;    /*!< [31:0] Direct register 7 */
    } B;
} hw_cau_direct7_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT7 register
 */
/*@{*/
#define HW_CAU_DIRECT7_ADDR(x)   ((uint32_t)(x) + 0x1CU)

#define HW_CAU_DIRECT7(x)        (*(__O hw_cau_direct7_t *) HW_CAU_DIRECT7_ADDR(x))
#define HW_CAU_DIRECT7_WR(x, v)  (HW_CAU_DIRECT7(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT7 bitfields
 */

/*!
 * @name Register CAU_DIRECT7, field CAU_DIRECT7[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT7_CAU_DIRECT7 (0U)    /*!< Bit position for CAU_DIRECT7_CAU_DIRECT7. */
#define BM_CAU_DIRECT7_CAU_DIRECT7 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT7_CAU_DIRECT7. */
#define BS_CAU_DIRECT7_CAU_DIRECT7 (32U)   /*!< Bit field size in bits for CAU_DIRECT7_CAU_DIRECT7. */

/*! @brief Format value for bitfield CAU_DIRECT7_CAU_DIRECT7. */
#define BF_CAU_DIRECT7_CAU_DIRECT7(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT7_CAU_DIRECT7) & BM_CAU_DIRECT7_CAU_DIRECT7)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT8 - Direct access register 8
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT8 - Direct access register 8 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct8
{
    uint32_t U;
    struct _hw_cau_direct8_bitfields
    {
        uint32_t CAU_DIRECT8b : 32;    /*!< [31:0] Direct register 8 */
    } B;
} hw_cau_direct8_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT8 register
 */
/*@{*/
#define HW_CAU_DIRECT8_ADDR(x)   ((uint32_t)(x) + 0x20U)

#define HW_CAU_DIRECT8(x)        (*(__O hw_cau_direct8_t *) HW_CAU_DIRECT8_ADDR(x))
#define HW_CAU_DIRECT8_WR(x, v)  (HW_CAU_DIRECT8(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT8 bitfields
 */

/*!
 * @name Register CAU_DIRECT8, field CAU_DIRECT8[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT8_CAU_DIRECT8 (0U)    /*!< Bit position for CAU_DIRECT8_CAU_DIRECT8. */
#define BM_CAU_DIRECT8_CAU_DIRECT8 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT8_CAU_DIRECT8. */
#define BS_CAU_DIRECT8_CAU_DIRECT8 (32U)   /*!< Bit field size in bits for CAU_DIRECT8_CAU_DIRECT8. */

/*! @brief Format value for bitfield CAU_DIRECT8_CAU_DIRECT8. */
#define BF_CAU_DIRECT8_CAU_DIRECT8(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT8_CAU_DIRECT8) & BM_CAU_DIRECT8_CAU_DIRECT8)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT9 - Direct access register 9
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT9 - Direct access register 9 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct9
{
    uint32_t U;
    struct _hw_cau_direct9_bitfields
    {
        uint32_t CAU_DIRECT9b : 32;    /*!< [31:0] Direct register 9 */
    } B;
} hw_cau_direct9_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT9 register
 */
/*@{*/
#define HW_CAU_DIRECT9_ADDR(x)   ((uint32_t)(x) + 0x24U)

#define HW_CAU_DIRECT9(x)        (*(__O hw_cau_direct9_t *) HW_CAU_DIRECT9_ADDR(x))
#define HW_CAU_DIRECT9_WR(x, v)  (HW_CAU_DIRECT9(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT9 bitfields
 */

/*!
 * @name Register CAU_DIRECT9, field CAU_DIRECT9[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT9_CAU_DIRECT9 (0U)    /*!< Bit position for CAU_DIRECT9_CAU_DIRECT9. */
#define BM_CAU_DIRECT9_CAU_DIRECT9 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT9_CAU_DIRECT9. */
#define BS_CAU_DIRECT9_CAU_DIRECT9 (32U)   /*!< Bit field size in bits for CAU_DIRECT9_CAU_DIRECT9. */

/*! @brief Format value for bitfield CAU_DIRECT9_CAU_DIRECT9. */
#define BF_CAU_DIRECT9_CAU_DIRECT9(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT9_CAU_DIRECT9) & BM_CAU_DIRECT9_CAU_DIRECT9)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT10 - Direct access register 10
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT10 - Direct access register 10 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct10
{
    uint32_t U;
    struct _hw_cau_direct10_bitfields
    {
        uint32_t CAU_DIRECT10b : 32;   /*!< [31:0] Direct register 10 */
    } B;
} hw_cau_direct10_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT10 register
 */
/*@{*/
#define HW_CAU_DIRECT10_ADDR(x)  ((uint32_t)(x) + 0x28U)

#define HW_CAU_DIRECT10(x)       (*(__O hw_cau_direct10_t *) HW_CAU_DIRECT10_ADDR(x))
#define HW_CAU_DIRECT10_WR(x, v) (HW_CAU_DIRECT10(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT10 bitfields
 */

/*!
 * @name Register CAU_DIRECT10, field CAU_DIRECT10[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT10_CAU_DIRECT10 (0U)  /*!< Bit position for CAU_DIRECT10_CAU_DIRECT10. */
#define BM_CAU_DIRECT10_CAU_DIRECT10 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT10_CAU_DIRECT10. */
#define BS_CAU_DIRECT10_CAU_DIRECT10 (32U) /*!< Bit field size in bits for CAU_DIRECT10_CAU_DIRECT10. */

/*! @brief Format value for bitfield CAU_DIRECT10_CAU_DIRECT10. */
#define BF_CAU_DIRECT10_CAU_DIRECT10(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT10_CAU_DIRECT10) & BM_CAU_DIRECT10_CAU_DIRECT10)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT11 - Direct access register 11
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT11 - Direct access register 11 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct11
{
    uint32_t U;
    struct _hw_cau_direct11_bitfields
    {
        uint32_t CAU_DIRECT11b : 32;   /*!< [31:0] Direct register 11 */
    } B;
} hw_cau_direct11_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT11 register
 */
/*@{*/
#define HW_CAU_DIRECT11_ADDR(x)  ((uint32_t)(x) + 0x2CU)

#define HW_CAU_DIRECT11(x)       (*(__O hw_cau_direct11_t *) HW_CAU_DIRECT11_ADDR(x))
#define HW_CAU_DIRECT11_WR(x, v) (HW_CAU_DIRECT11(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT11 bitfields
 */

/*!
 * @name Register CAU_DIRECT11, field CAU_DIRECT11[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT11_CAU_DIRECT11 (0U)  /*!< Bit position for CAU_DIRECT11_CAU_DIRECT11. */
#define BM_CAU_DIRECT11_CAU_DIRECT11 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT11_CAU_DIRECT11. */
#define BS_CAU_DIRECT11_CAU_DIRECT11 (32U) /*!< Bit field size in bits for CAU_DIRECT11_CAU_DIRECT11. */

/*! @brief Format value for bitfield CAU_DIRECT11_CAU_DIRECT11. */
#define BF_CAU_DIRECT11_CAU_DIRECT11(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT11_CAU_DIRECT11) & BM_CAU_DIRECT11_CAU_DIRECT11)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT12 - Direct access register 12
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT12 - Direct access register 12 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct12
{
    uint32_t U;
    struct _hw_cau_direct12_bitfields
    {
        uint32_t CAU_DIRECT12b : 32;   /*!< [31:0] Direct register 12 */
    } B;
} hw_cau_direct12_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT12 register
 */
/*@{*/
#define HW_CAU_DIRECT12_ADDR(x)  ((uint32_t)(x) + 0x30U)

#define HW_CAU_DIRECT12(x)       (*(__O hw_cau_direct12_t *) HW_CAU_DIRECT12_ADDR(x))
#define HW_CAU_DIRECT12_WR(x, v) (HW_CAU_DIRECT12(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT12 bitfields
 */

/*!
 * @name Register CAU_DIRECT12, field CAU_DIRECT12[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT12_CAU_DIRECT12 (0U)  /*!< Bit position for CAU_DIRECT12_CAU_DIRECT12. */
#define BM_CAU_DIRECT12_CAU_DIRECT12 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT12_CAU_DIRECT12. */
#define BS_CAU_DIRECT12_CAU_DIRECT12 (32U) /*!< Bit field size in bits for CAU_DIRECT12_CAU_DIRECT12. */

/*! @brief Format value for bitfield CAU_DIRECT12_CAU_DIRECT12. */
#define BF_CAU_DIRECT12_CAU_DIRECT12(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT12_CAU_DIRECT12) & BM_CAU_DIRECT12_CAU_DIRECT12)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT13 - Direct access register 13
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT13 - Direct access register 13 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct13
{
    uint32_t U;
    struct _hw_cau_direct13_bitfields
    {
        uint32_t CAU_DIRECT13b : 32;   /*!< [31:0] Direct register 13 */
    } B;
} hw_cau_direct13_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT13 register
 */
/*@{*/
#define HW_CAU_DIRECT13_ADDR(x)  ((uint32_t)(x) + 0x34U)

#define HW_CAU_DIRECT13(x)       (*(__O hw_cau_direct13_t *) HW_CAU_DIRECT13_ADDR(x))
#define HW_CAU_DIRECT13_WR(x, v) (HW_CAU_DIRECT13(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT13 bitfields
 */

/*!
 * @name Register CAU_DIRECT13, field CAU_DIRECT13[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT13_CAU_DIRECT13 (0U)  /*!< Bit position for CAU_DIRECT13_CAU_DIRECT13. */
#define BM_CAU_DIRECT13_CAU_DIRECT13 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT13_CAU_DIRECT13. */
#define BS_CAU_DIRECT13_CAU_DIRECT13 (32U) /*!< Bit field size in bits for CAU_DIRECT13_CAU_DIRECT13. */

/*! @brief Format value for bitfield CAU_DIRECT13_CAU_DIRECT13. */
#define BF_CAU_DIRECT13_CAU_DIRECT13(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT13_CAU_DIRECT13) & BM_CAU_DIRECT13_CAU_DIRECT13)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT14 - Direct access register 14
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT14 - Direct access register 14 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct14
{
    uint32_t U;
    struct _hw_cau_direct14_bitfields
    {
        uint32_t CAU_DIRECT14b : 32;   /*!< [31:0] Direct register 14 */
    } B;
} hw_cau_direct14_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT14 register
 */
/*@{*/
#define HW_CAU_DIRECT14_ADDR(x)  ((uint32_t)(x) + 0x38U)

#define HW_CAU_DIRECT14(x)       (*(__O hw_cau_direct14_t *) HW_CAU_DIRECT14_ADDR(x))
#define HW_CAU_DIRECT14_WR(x, v) (HW_CAU_DIRECT14(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT14 bitfields
 */

/*!
 * @name Register CAU_DIRECT14, field CAU_DIRECT14[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT14_CAU_DIRECT14 (0U)  /*!< Bit position for CAU_DIRECT14_CAU_DIRECT14. */
#define BM_CAU_DIRECT14_CAU_DIRECT14 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT14_CAU_DIRECT14. */
#define BS_CAU_DIRECT14_CAU_DIRECT14 (32U) /*!< Bit field size in bits for CAU_DIRECT14_CAU_DIRECT14. */

/*! @brief Format value for bitfield CAU_DIRECT14_CAU_DIRECT14. */
#define BF_CAU_DIRECT14_CAU_DIRECT14(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT14_CAU_DIRECT14) & BM_CAU_DIRECT14_CAU_DIRECT14)
/*@}*/

/*******************************************************************************
 * HW_CAU_DIRECT15 - Direct access register 15
 ******************************************************************************/

/*!
 * @brief HW_CAU_DIRECT15 - Direct access register 15 (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_direct15
{
    uint32_t U;
    struct _hw_cau_direct15_bitfields
    {
        uint32_t CAU_DIRECT15b : 32;   /*!< [31:0] Direct register 15 */
    } B;
} hw_cau_direct15_t;

/*!
 * @name Constants and macros for entire CAU_DIRECT15 register
 */
/*@{*/
#define HW_CAU_DIRECT15_ADDR(x)  ((uint32_t)(x) + 0x3CU)

#define HW_CAU_DIRECT15(x)       (*(__O hw_cau_direct15_t *) HW_CAU_DIRECT15_ADDR(x))
#define HW_CAU_DIRECT15_WR(x, v) (HW_CAU_DIRECT15(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_DIRECT15 bitfields
 */

/*!
 * @name Register CAU_DIRECT15, field CAU_DIRECT15[31:0] (WO)
 */
/*@{*/
#define BP_CAU_DIRECT15_CAU_DIRECT15 (0U)  /*!< Bit position for CAU_DIRECT15_CAU_DIRECT15. */
#define BM_CAU_DIRECT15_CAU_DIRECT15 (0xFFFFFFFFU) /*!< Bit mask for CAU_DIRECT15_CAU_DIRECT15. */
#define BS_CAU_DIRECT15_CAU_DIRECT15 (32U) /*!< Bit field size in bits for CAU_DIRECT15_CAU_DIRECT15. */

/*! @brief Format value for bitfield CAU_DIRECT15_CAU_DIRECT15. */
#define BF_CAU_DIRECT15_CAU_DIRECT15(v) ((uint32_t)((uint32_t)(v) << BP_CAU_DIRECT15_CAU_DIRECT15) & BM_CAU_DIRECT15_CAU_DIRECT15)
/*@}*/

/*******************************************************************************
 * HW_CAU_LDR_CASR - Status register  - Load Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_LDR_CASR - Status register  - Load Register command (WO)
 *
 * Reset value: 0x20000000U
 */
typedef union _hw_cau_ldr_casr
{
    uint32_t U;
    struct _hw_cau_ldr_casr_bitfields
    {
        uint32_t IC : 1;               /*!< [0]  */
        uint32_t DPE : 1;              /*!< [1]  */
        uint32_t RESERVED0 : 26;       /*!< [27:2]  */
        uint32_t VER : 4;              /*!< [31:28] CAU version */
    } B;
} hw_cau_ldr_casr_t;

/*!
 * @name Constants and macros for entire CAU_LDR_CASR register
 */
/*@{*/
#define HW_CAU_LDR_CASR_ADDR(x)  ((uint32_t)(x) + 0x840U)

#define HW_CAU_LDR_CASR(x)       (*(__O hw_cau_ldr_casr_t *) HW_CAU_LDR_CASR_ADDR(x))
#define HW_CAU_LDR_CASR_WR(x, v) (HW_CAU_LDR_CASR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CASR bitfields
 */

/*!
 * @name Register CAU_LDR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0 - No illegal commands issued
 * - 1 - Illegal command issued
 */
/*@{*/
#define BP_CAU_LDR_CASR_IC   (0U)          /*!< Bit position for CAU_LDR_CASR_IC. */
#define BM_CAU_LDR_CASR_IC   (0x00000001U) /*!< Bit mask for CAU_LDR_CASR_IC. */
#define BS_CAU_LDR_CASR_IC   (1U)          /*!< Bit field size in bits for CAU_LDR_CASR_IC. */

/*! @brief Format value for bitfield CAU_LDR_CASR_IC. */
#define BF_CAU_LDR_CASR_IC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CASR_IC) & BM_CAU_LDR_CASR_IC)
/*@}*/

/*!
 * @name Register CAU_LDR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0 - No error detected
 * - 1 - DES key parity error detected
 */
/*@{*/
#define BP_CAU_LDR_CASR_DPE  (1U)          /*!< Bit position for CAU_LDR_CASR_DPE. */
#define BM_CAU_LDR_CASR_DPE  (0x00000002U) /*!< Bit mask for CAU_LDR_CASR_DPE. */
#define BS_CAU_LDR_CASR_DPE  (1U)          /*!< Bit field size in bits for CAU_LDR_CASR_DPE. */

/*! @brief Format value for bitfield CAU_LDR_CASR_DPE. */
#define BF_CAU_LDR_CASR_DPE(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CASR_DPE) & BM_CAU_LDR_CASR_DPE)
/*@}*/

/*!
 * @name Register CAU_LDR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0001 - Initial CAU version
 * - 0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
#define BP_CAU_LDR_CASR_VER  (28U)         /*!< Bit position for CAU_LDR_CASR_VER. */
#define BM_CAU_LDR_CASR_VER  (0xF0000000U) /*!< Bit mask for CAU_LDR_CASR_VER. */
#define BS_CAU_LDR_CASR_VER  (4U)          /*!< Bit field size in bits for CAU_LDR_CASR_VER. */

/*! @brief Format value for bitfield CAU_LDR_CASR_VER. */
#define BF_CAU_LDR_CASR_VER(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CASR_VER) & BM_CAU_LDR_CASR_VER)
/*@}*/

/*******************************************************************************
 * HW_CAU_LDR_CAA - Accumulator register - Load Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_LDR_CAA - Accumulator register - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_ldr_caa
{
    uint32_t U;
    struct _hw_cau_ldr_caa_bitfields
    {
        uint32_t ACC : 32;             /*!< [31:0] ACC */
    } B;
} hw_cau_ldr_caa_t;

/*!
 * @name Constants and macros for entire CAU_LDR_CAA register
 */
/*@{*/
#define HW_CAU_LDR_CAA_ADDR(x)   ((uint32_t)(x) + 0x844U)

#define HW_CAU_LDR_CAA(x)        (*(__O hw_cau_ldr_caa_t *) HW_CAU_LDR_CAA_ADDR(x))
#define HW_CAU_LDR_CAA_WR(x, v)  (HW_CAU_LDR_CAA(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CAA bitfields
 */

/*!
 * @name Register CAU_LDR_CAA, field ACC[31:0] (WO)
 */
/*@{*/
#define BP_CAU_LDR_CAA_ACC   (0U)          /*!< Bit position for CAU_LDR_CAA_ACC. */
#define BM_CAU_LDR_CAA_ACC   (0xFFFFFFFFU) /*!< Bit mask for CAU_LDR_CAA_ACC. */
#define BS_CAU_LDR_CAA_ACC   (32U)         /*!< Bit field size in bits for CAU_LDR_CAA_ACC. */

/*! @brief Format value for bitfield CAU_LDR_CAA_ACC. */
#define BF_CAU_LDR_CAA_ACC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CAA_ACC) & BM_CAU_LDR_CAA_ACC)
/*@}*/

/*******************************************************************************
 * HW_CAU_LDR_CA0 - General Purpose Register 0 - Load Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_LDR_CA0 - General Purpose Register 0 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_ldr_ca0
{
    uint32_t U;
    struct _hw_cau_ldr_ca0_bitfields
    {
        uint32_t CA0 : 32;             /*!< [31:0] CA0 */
    } B;
} hw_cau_ldr_ca0_t;

/*!
 * @name Constants and macros for entire CAU_LDR_CA0 register
 */
/*@{*/
#define HW_CAU_LDR_CA0_ADDR(x)   ((uint32_t)(x) + 0x848U)

#define HW_CAU_LDR_CA0(x)        (*(__O hw_cau_ldr_ca0_t *) HW_CAU_LDR_CA0_ADDR(x))
#define HW_CAU_LDR_CA0_WR(x, v)  (HW_CAU_LDR_CA0(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CA0 bitfields
 */

/*!
 * @name Register CAU_LDR_CA0, field CA0[31:0] (WO)
 */
/*@{*/
#define BP_CAU_LDR_CA0_CA0   (0U)          /*!< Bit position for CAU_LDR_CA0_CA0. */
#define BM_CAU_LDR_CA0_CA0   (0xFFFFFFFFU) /*!< Bit mask for CAU_LDR_CA0_CA0. */
#define BS_CAU_LDR_CA0_CA0   (32U)         /*!< Bit field size in bits for CAU_LDR_CA0_CA0. */

/*! @brief Format value for bitfield CAU_LDR_CA0_CA0. */
#define BF_CAU_LDR_CA0_CA0(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CA0_CA0) & BM_CAU_LDR_CA0_CA0)
/*@}*/

/*******************************************************************************
 * HW_CAU_LDR_CA1 - General Purpose Register 1 - Load Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_LDR_CA1 - General Purpose Register 1 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_ldr_ca1
{
    uint32_t U;
    struct _hw_cau_ldr_ca1_bitfields
    {
        uint32_t CA1 : 32;             /*!< [31:0] CA1 */
    } B;
} hw_cau_ldr_ca1_t;

/*!
 * @name Constants and macros for entire CAU_LDR_CA1 register
 */
/*@{*/
#define HW_CAU_LDR_CA1_ADDR(x)   ((uint32_t)(x) + 0x84CU)

#define HW_CAU_LDR_CA1(x)        (*(__O hw_cau_ldr_ca1_t *) HW_CAU_LDR_CA1_ADDR(x))
#define HW_CAU_LDR_CA1_WR(x, v)  (HW_CAU_LDR_CA1(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CA1 bitfields
 */

/*!
 * @name Register CAU_LDR_CA1, field CA1[31:0] (WO)
 */
/*@{*/
#define BP_CAU_LDR_CA1_CA1   (0U)          /*!< Bit position for CAU_LDR_CA1_CA1. */
#define BM_CAU_LDR_CA1_CA1   (0xFFFFFFFFU) /*!< Bit mask for CAU_LDR_CA1_CA1. */
#define BS_CAU_LDR_CA1_CA1   (32U)         /*!< Bit field size in bits for CAU_LDR_CA1_CA1. */

/*! @brief Format value for bitfield CAU_LDR_CA1_CA1. */
#define BF_CAU_LDR_CA1_CA1(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CA1_CA1) & BM_CAU_LDR_CA1_CA1)
/*@}*/

/*******************************************************************************
 * HW_CAU_LDR_CA2 - General Purpose Register 2 - Load Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_LDR_CA2 - General Purpose Register 2 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_ldr_ca2
{
    uint32_t U;
    struct _hw_cau_ldr_ca2_bitfields
    {
        uint32_t CA2 : 32;             /*!< [31:0] CA2 */
    } B;
} hw_cau_ldr_ca2_t;

/*!
 * @name Constants and macros for entire CAU_LDR_CA2 register
 */
/*@{*/
#define HW_CAU_LDR_CA2_ADDR(x)   ((uint32_t)(x) + 0x850U)

#define HW_CAU_LDR_CA2(x)        (*(__O hw_cau_ldr_ca2_t *) HW_CAU_LDR_CA2_ADDR(x))
#define HW_CAU_LDR_CA2_WR(x, v)  (HW_CAU_LDR_CA2(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CA2 bitfields
 */

/*!
 * @name Register CAU_LDR_CA2, field CA2[31:0] (WO)
 */
/*@{*/
#define BP_CAU_LDR_CA2_CA2   (0U)          /*!< Bit position for CAU_LDR_CA2_CA2. */
#define BM_CAU_LDR_CA2_CA2   (0xFFFFFFFFU) /*!< Bit mask for CAU_LDR_CA2_CA2. */
#define BS_CAU_LDR_CA2_CA2   (32U)         /*!< Bit field size in bits for CAU_LDR_CA2_CA2. */

/*! @brief Format value for bitfield CAU_LDR_CA2_CA2. */
#define BF_CAU_LDR_CA2_CA2(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CA2_CA2) & BM_CAU_LDR_CA2_CA2)
/*@}*/

/*******************************************************************************
 * HW_CAU_LDR_CA3 - General Purpose Register 3 - Load Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_LDR_CA3 - General Purpose Register 3 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_ldr_ca3
{
    uint32_t U;
    struct _hw_cau_ldr_ca3_bitfields
    {
        uint32_t CA3 : 32;             /*!< [31:0] CA3 */
    } B;
} hw_cau_ldr_ca3_t;

/*!
 * @name Constants and macros for entire CAU_LDR_CA3 register
 */
/*@{*/
#define HW_CAU_LDR_CA3_ADDR(x)   ((uint32_t)(x) + 0x854U)

#define HW_CAU_LDR_CA3(x)        (*(__O hw_cau_ldr_ca3_t *) HW_CAU_LDR_CA3_ADDR(x))
#define HW_CAU_LDR_CA3_WR(x, v)  (HW_CAU_LDR_CA3(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CA3 bitfields
 */

/*!
 * @name Register CAU_LDR_CA3, field CA3[31:0] (WO)
 */
/*@{*/
#define BP_CAU_LDR_CA3_CA3   (0U)          /*!< Bit position for CAU_LDR_CA3_CA3. */
#define BM_CAU_LDR_CA3_CA3   (0xFFFFFFFFU) /*!< Bit mask for CAU_LDR_CA3_CA3. */
#define BS_CAU_LDR_CA3_CA3   (32U)         /*!< Bit field size in bits for CAU_LDR_CA3_CA3. */

/*! @brief Format value for bitfield CAU_LDR_CA3_CA3. */
#define BF_CAU_LDR_CA3_CA3(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CA3_CA3) & BM_CAU_LDR_CA3_CA3)
/*@}*/

/*******************************************************************************
 * HW_CAU_LDR_CA4 - General Purpose Register 4 - Load Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_LDR_CA4 - General Purpose Register 4 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_ldr_ca4
{
    uint32_t U;
    struct _hw_cau_ldr_ca4_bitfields
    {
        uint32_t CA4 : 32;             /*!< [31:0] CA4 */
    } B;
} hw_cau_ldr_ca4_t;

/*!
 * @name Constants and macros for entire CAU_LDR_CA4 register
 */
/*@{*/
#define HW_CAU_LDR_CA4_ADDR(x)   ((uint32_t)(x) + 0x858U)

#define HW_CAU_LDR_CA4(x)        (*(__O hw_cau_ldr_ca4_t *) HW_CAU_LDR_CA4_ADDR(x))
#define HW_CAU_LDR_CA4_WR(x, v)  (HW_CAU_LDR_CA4(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CA4 bitfields
 */

/*!
 * @name Register CAU_LDR_CA4, field CA4[31:0] (WO)
 */
/*@{*/
#define BP_CAU_LDR_CA4_CA4   (0U)          /*!< Bit position for CAU_LDR_CA4_CA4. */
#define BM_CAU_LDR_CA4_CA4   (0xFFFFFFFFU) /*!< Bit mask for CAU_LDR_CA4_CA4. */
#define BS_CAU_LDR_CA4_CA4   (32U)         /*!< Bit field size in bits for CAU_LDR_CA4_CA4. */

/*! @brief Format value for bitfield CAU_LDR_CA4_CA4. */
#define BF_CAU_LDR_CA4_CA4(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CA4_CA4) & BM_CAU_LDR_CA4_CA4)
/*@}*/

/*******************************************************************************
 * HW_CAU_LDR_CA5 - General Purpose Register 5 - Load Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_LDR_CA5 - General Purpose Register 5 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_ldr_ca5
{
    uint32_t U;
    struct _hw_cau_ldr_ca5_bitfields
    {
        uint32_t CA5 : 32;             /*!< [31:0] CA5 */
    } B;
} hw_cau_ldr_ca5_t;

/*!
 * @name Constants and macros for entire CAU_LDR_CA5 register
 */
/*@{*/
#define HW_CAU_LDR_CA5_ADDR(x)   ((uint32_t)(x) + 0x85CU)

#define HW_CAU_LDR_CA5(x)        (*(__O hw_cau_ldr_ca5_t *) HW_CAU_LDR_CA5_ADDR(x))
#define HW_CAU_LDR_CA5_WR(x, v)  (HW_CAU_LDR_CA5(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CA5 bitfields
 */

/*!
 * @name Register CAU_LDR_CA5, field CA5[31:0] (WO)
 */
/*@{*/
#define BP_CAU_LDR_CA5_CA5   (0U)          /*!< Bit position for CAU_LDR_CA5_CA5. */
#define BM_CAU_LDR_CA5_CA5   (0xFFFFFFFFU) /*!< Bit mask for CAU_LDR_CA5_CA5. */
#define BS_CAU_LDR_CA5_CA5   (32U)         /*!< Bit field size in bits for CAU_LDR_CA5_CA5. */

/*! @brief Format value for bitfield CAU_LDR_CA5_CA5. */
#define BF_CAU_LDR_CA5_CA5(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CA5_CA5) & BM_CAU_LDR_CA5_CA5)
/*@}*/

/*******************************************************************************
 * HW_CAU_LDR_CA6 - General Purpose Register 6 - Load Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_LDR_CA6 - General Purpose Register 6 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_ldr_ca6
{
    uint32_t U;
    struct _hw_cau_ldr_ca6_bitfields
    {
        uint32_t CA6 : 32;             /*!< [31:0] CA6 */
    } B;
} hw_cau_ldr_ca6_t;

/*!
 * @name Constants and macros for entire CAU_LDR_CA6 register
 */
/*@{*/
#define HW_CAU_LDR_CA6_ADDR(x)   ((uint32_t)(x) + 0x860U)

#define HW_CAU_LDR_CA6(x)        (*(__O hw_cau_ldr_ca6_t *) HW_CAU_LDR_CA6_ADDR(x))
#define HW_CAU_LDR_CA6_WR(x, v)  (HW_CAU_LDR_CA6(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CA6 bitfields
 */

/*!
 * @name Register CAU_LDR_CA6, field CA6[31:0] (WO)
 */
/*@{*/
#define BP_CAU_LDR_CA6_CA6   (0U)          /*!< Bit position for CAU_LDR_CA6_CA6. */
#define BM_CAU_LDR_CA6_CA6   (0xFFFFFFFFU) /*!< Bit mask for CAU_LDR_CA6_CA6. */
#define BS_CAU_LDR_CA6_CA6   (32U)         /*!< Bit field size in bits for CAU_LDR_CA6_CA6. */

/*! @brief Format value for bitfield CAU_LDR_CA6_CA6. */
#define BF_CAU_LDR_CA6_CA6(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CA6_CA6) & BM_CAU_LDR_CA6_CA6)
/*@}*/

/*******************************************************************************
 * HW_CAU_LDR_CA7 - General Purpose Register 7 - Load Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_LDR_CA7 - General Purpose Register 7 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_ldr_ca7
{
    uint32_t U;
    struct _hw_cau_ldr_ca7_bitfields
    {
        uint32_t CA7 : 32;             /*!< [31:0] CA7 */
    } B;
} hw_cau_ldr_ca7_t;

/*!
 * @name Constants and macros for entire CAU_LDR_CA7 register
 */
/*@{*/
#define HW_CAU_LDR_CA7_ADDR(x)   ((uint32_t)(x) + 0x864U)

#define HW_CAU_LDR_CA7(x)        (*(__O hw_cau_ldr_ca7_t *) HW_CAU_LDR_CA7_ADDR(x))
#define HW_CAU_LDR_CA7_WR(x, v)  (HW_CAU_LDR_CA7(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CA7 bitfields
 */

/*!
 * @name Register CAU_LDR_CA7, field CA7[31:0] (WO)
 */
/*@{*/
#define BP_CAU_LDR_CA7_CA7   (0U)          /*!< Bit position for CAU_LDR_CA7_CA7. */
#define BM_CAU_LDR_CA7_CA7   (0xFFFFFFFFU) /*!< Bit mask for CAU_LDR_CA7_CA7. */
#define BS_CAU_LDR_CA7_CA7   (32U)         /*!< Bit field size in bits for CAU_LDR_CA7_CA7. */

/*! @brief Format value for bitfield CAU_LDR_CA7_CA7. */
#define BF_CAU_LDR_CA7_CA7(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CA7_CA7) & BM_CAU_LDR_CA7_CA7)
/*@}*/

/*******************************************************************************
 * HW_CAU_LDR_CA8 - General Purpose Register 8 - Load Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_LDR_CA8 - General Purpose Register 8 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_ldr_ca8
{
    uint32_t U;
    struct _hw_cau_ldr_ca8_bitfields
    {
        uint32_t CA8 : 32;             /*!< [31:0] CA8 */
    } B;
} hw_cau_ldr_ca8_t;

/*!
 * @name Constants and macros for entire CAU_LDR_CA8 register
 */
/*@{*/
#define HW_CAU_LDR_CA8_ADDR(x)   ((uint32_t)(x) + 0x868U)

#define HW_CAU_LDR_CA8(x)        (*(__O hw_cau_ldr_ca8_t *) HW_CAU_LDR_CA8_ADDR(x))
#define HW_CAU_LDR_CA8_WR(x, v)  (HW_CAU_LDR_CA8(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CA8 bitfields
 */

/*!
 * @name Register CAU_LDR_CA8, field CA8[31:0] (WO)
 */
/*@{*/
#define BP_CAU_LDR_CA8_CA8   (0U)          /*!< Bit position for CAU_LDR_CA8_CA8. */
#define BM_CAU_LDR_CA8_CA8   (0xFFFFFFFFU) /*!< Bit mask for CAU_LDR_CA8_CA8. */
#define BS_CAU_LDR_CA8_CA8   (32U)         /*!< Bit field size in bits for CAU_LDR_CA8_CA8. */

/*! @brief Format value for bitfield CAU_LDR_CA8_CA8. */
#define BF_CAU_LDR_CA8_CA8(v) ((uint32_t)((uint32_t)(v) << BP_CAU_LDR_CA8_CA8) & BM_CAU_LDR_CA8_CA8)
/*@}*/

/*******************************************************************************
 * HW_CAU_STR_CASR - Status register  - Store Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_STR_CASR - Status register  - Store Register command (RO)
 *
 * Reset value: 0x20000000U
 */
typedef union _hw_cau_str_casr
{
    uint32_t U;
    struct _hw_cau_str_casr_bitfields
    {
        uint32_t IC : 1;               /*!< [0]  */
        uint32_t DPE : 1;              /*!< [1]  */
        uint32_t RESERVED0 : 26;       /*!< [27:2]  */
        uint32_t VER : 4;              /*!< [31:28] CAU version */
    } B;
} hw_cau_str_casr_t;

/*!
 * @name Constants and macros for entire CAU_STR_CASR register
 */
/*@{*/
#define HW_CAU_STR_CASR_ADDR(x)  ((uint32_t)(x) + 0x880U)

#define HW_CAU_STR_CASR(x)       (*(__I hw_cau_str_casr_t *) HW_CAU_STR_CASR_ADDR(x))
#define HW_CAU_STR_CASR_RD(x)    (HW_CAU_STR_CASR(x).U)
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CASR bitfields
 */

/*!
 * @name Register CAU_STR_CASR, field IC[0] (RO)
 *
 * Values:
 * - 0 - No illegal commands issued
 * - 1 - Illegal command issued
 */
/*@{*/
#define BP_CAU_STR_CASR_IC   (0U)          /*!< Bit position for CAU_STR_CASR_IC. */
#define BM_CAU_STR_CASR_IC   (0x00000001U) /*!< Bit mask for CAU_STR_CASR_IC. */
#define BS_CAU_STR_CASR_IC   (1U)          /*!< Bit field size in bits for CAU_STR_CASR_IC. */

/*! @brief Read current value of the CAU_STR_CASR_IC field. */
#define BR_CAU_STR_CASR_IC(x) (HW_CAU_STR_CASR(x).B.IC)
/*@}*/

/*!
 * @name Register CAU_STR_CASR, field DPE[1] (RO)
 *
 * Values:
 * - 0 - No error detected
 * - 1 - DES key parity error detected
 */
/*@{*/
#define BP_CAU_STR_CASR_DPE  (1U)          /*!< Bit position for CAU_STR_CASR_DPE. */
#define BM_CAU_STR_CASR_DPE  (0x00000002U) /*!< Bit mask for CAU_STR_CASR_DPE. */
#define BS_CAU_STR_CASR_DPE  (1U)          /*!< Bit field size in bits for CAU_STR_CASR_DPE. */

/*! @brief Read current value of the CAU_STR_CASR_DPE field. */
#define BR_CAU_STR_CASR_DPE(x) (HW_CAU_STR_CASR(x).B.DPE)
/*@}*/

/*!
 * @name Register CAU_STR_CASR, field VER[31:28] (RO)
 *
 * Values:
 * - 0001 - Initial CAU version
 * - 0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
#define BP_CAU_STR_CASR_VER  (28U)         /*!< Bit position for CAU_STR_CASR_VER. */
#define BM_CAU_STR_CASR_VER  (0xF0000000U) /*!< Bit mask for CAU_STR_CASR_VER. */
#define BS_CAU_STR_CASR_VER  (4U)          /*!< Bit field size in bits for CAU_STR_CASR_VER. */

/*! @brief Read current value of the CAU_STR_CASR_VER field. */
#define BR_CAU_STR_CASR_VER(x) (HW_CAU_STR_CASR(x).B.VER)
/*@}*/

/*******************************************************************************
 * HW_CAU_STR_CAA - Accumulator register - Store Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_STR_CAA - Accumulator register - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_str_caa
{
    uint32_t U;
    struct _hw_cau_str_caa_bitfields
    {
        uint32_t ACC : 32;             /*!< [31:0] ACC */
    } B;
} hw_cau_str_caa_t;

/*!
 * @name Constants and macros for entire CAU_STR_CAA register
 */
/*@{*/
#define HW_CAU_STR_CAA_ADDR(x)   ((uint32_t)(x) + 0x884U)

#define HW_CAU_STR_CAA(x)        (*(__I hw_cau_str_caa_t *) HW_CAU_STR_CAA_ADDR(x))
#define HW_CAU_STR_CAA_RD(x)     (HW_CAU_STR_CAA(x).U)
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CAA bitfields
 */

/*!
 * @name Register CAU_STR_CAA, field ACC[31:0] (RO)
 */
/*@{*/
#define BP_CAU_STR_CAA_ACC   (0U)          /*!< Bit position for CAU_STR_CAA_ACC. */
#define BM_CAU_STR_CAA_ACC   (0xFFFFFFFFU) /*!< Bit mask for CAU_STR_CAA_ACC. */
#define BS_CAU_STR_CAA_ACC   (32U)         /*!< Bit field size in bits for CAU_STR_CAA_ACC. */

/*! @brief Read current value of the CAU_STR_CAA_ACC field. */
#define BR_CAU_STR_CAA_ACC(x) (HW_CAU_STR_CAA(x).U)
/*@}*/

/*******************************************************************************
 * HW_CAU_STR_CA0 - General Purpose Register 0 - Store Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_STR_CA0 - General Purpose Register 0 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_str_ca0
{
    uint32_t U;
    struct _hw_cau_str_ca0_bitfields
    {
        uint32_t CA0 : 32;             /*!< [31:0] CA0 */
    } B;
} hw_cau_str_ca0_t;

/*!
 * @name Constants and macros for entire CAU_STR_CA0 register
 */
/*@{*/
#define HW_CAU_STR_CA0_ADDR(x)   ((uint32_t)(x) + 0x888U)

#define HW_CAU_STR_CA0(x)        (*(__I hw_cau_str_ca0_t *) HW_CAU_STR_CA0_ADDR(x))
#define HW_CAU_STR_CA0_RD(x)     (HW_CAU_STR_CA0(x).U)
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CA0 bitfields
 */

/*!
 * @name Register CAU_STR_CA0, field CA0[31:0] (RO)
 */
/*@{*/
#define BP_CAU_STR_CA0_CA0   (0U)          /*!< Bit position for CAU_STR_CA0_CA0. */
#define BM_CAU_STR_CA0_CA0   (0xFFFFFFFFU) /*!< Bit mask for CAU_STR_CA0_CA0. */
#define BS_CAU_STR_CA0_CA0   (32U)         /*!< Bit field size in bits for CAU_STR_CA0_CA0. */

/*! @brief Read current value of the CAU_STR_CA0_CA0 field. */
#define BR_CAU_STR_CA0_CA0(x) (HW_CAU_STR_CA0(x).U)
/*@}*/

/*******************************************************************************
 * HW_CAU_STR_CA1 - General Purpose Register 1 - Store Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_STR_CA1 - General Purpose Register 1 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_str_ca1
{
    uint32_t U;
    struct _hw_cau_str_ca1_bitfields
    {
        uint32_t CA1 : 32;             /*!< [31:0] CA1 */
    } B;
} hw_cau_str_ca1_t;

/*!
 * @name Constants and macros for entire CAU_STR_CA1 register
 */
/*@{*/
#define HW_CAU_STR_CA1_ADDR(x)   ((uint32_t)(x) + 0x88CU)

#define HW_CAU_STR_CA1(x)        (*(__I hw_cau_str_ca1_t *) HW_CAU_STR_CA1_ADDR(x))
#define HW_CAU_STR_CA1_RD(x)     (HW_CAU_STR_CA1(x).U)
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CA1 bitfields
 */

/*!
 * @name Register CAU_STR_CA1, field CA1[31:0] (RO)
 */
/*@{*/
#define BP_CAU_STR_CA1_CA1   (0U)          /*!< Bit position for CAU_STR_CA1_CA1. */
#define BM_CAU_STR_CA1_CA1   (0xFFFFFFFFU) /*!< Bit mask for CAU_STR_CA1_CA1. */
#define BS_CAU_STR_CA1_CA1   (32U)         /*!< Bit field size in bits for CAU_STR_CA1_CA1. */

/*! @brief Read current value of the CAU_STR_CA1_CA1 field. */
#define BR_CAU_STR_CA1_CA1(x) (HW_CAU_STR_CA1(x).U)
/*@}*/

/*******************************************************************************
 * HW_CAU_STR_CA2 - General Purpose Register 2 - Store Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_STR_CA2 - General Purpose Register 2 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_str_ca2
{
    uint32_t U;
    struct _hw_cau_str_ca2_bitfields
    {
        uint32_t CA2 : 32;             /*!< [31:0] CA2 */
    } B;
} hw_cau_str_ca2_t;

/*!
 * @name Constants and macros for entire CAU_STR_CA2 register
 */
/*@{*/
#define HW_CAU_STR_CA2_ADDR(x)   ((uint32_t)(x) + 0x890U)

#define HW_CAU_STR_CA2(x)        (*(__I hw_cau_str_ca2_t *) HW_CAU_STR_CA2_ADDR(x))
#define HW_CAU_STR_CA2_RD(x)     (HW_CAU_STR_CA2(x).U)
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CA2 bitfields
 */

/*!
 * @name Register CAU_STR_CA2, field CA2[31:0] (RO)
 */
/*@{*/
#define BP_CAU_STR_CA2_CA2   (0U)          /*!< Bit position for CAU_STR_CA2_CA2. */
#define BM_CAU_STR_CA2_CA2   (0xFFFFFFFFU) /*!< Bit mask for CAU_STR_CA2_CA2. */
#define BS_CAU_STR_CA2_CA2   (32U)         /*!< Bit field size in bits for CAU_STR_CA2_CA2. */

/*! @brief Read current value of the CAU_STR_CA2_CA2 field. */
#define BR_CAU_STR_CA2_CA2(x) (HW_CAU_STR_CA2(x).U)
/*@}*/

/*******************************************************************************
 * HW_CAU_STR_CA3 - General Purpose Register 3 - Store Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_STR_CA3 - General Purpose Register 3 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_str_ca3
{
    uint32_t U;
    struct _hw_cau_str_ca3_bitfields
    {
        uint32_t CA3 : 32;             /*!< [31:0] CA3 */
    } B;
} hw_cau_str_ca3_t;

/*!
 * @name Constants and macros for entire CAU_STR_CA3 register
 */
/*@{*/
#define HW_CAU_STR_CA3_ADDR(x)   ((uint32_t)(x) + 0x894U)

#define HW_CAU_STR_CA3(x)        (*(__I hw_cau_str_ca3_t *) HW_CAU_STR_CA3_ADDR(x))
#define HW_CAU_STR_CA3_RD(x)     (HW_CAU_STR_CA3(x).U)
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CA3 bitfields
 */

/*!
 * @name Register CAU_STR_CA3, field CA3[31:0] (RO)
 */
/*@{*/
#define BP_CAU_STR_CA3_CA3   (0U)          /*!< Bit position for CAU_STR_CA3_CA3. */
#define BM_CAU_STR_CA3_CA3   (0xFFFFFFFFU) /*!< Bit mask for CAU_STR_CA3_CA3. */
#define BS_CAU_STR_CA3_CA3   (32U)         /*!< Bit field size in bits for CAU_STR_CA3_CA3. */

/*! @brief Read current value of the CAU_STR_CA3_CA3 field. */
#define BR_CAU_STR_CA3_CA3(x) (HW_CAU_STR_CA3(x).U)
/*@}*/

/*******************************************************************************
 * HW_CAU_STR_CA4 - General Purpose Register 4 - Store Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_STR_CA4 - General Purpose Register 4 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_str_ca4
{
    uint32_t U;
    struct _hw_cau_str_ca4_bitfields
    {
        uint32_t CA4 : 32;             /*!< [31:0] CA4 */
    } B;
} hw_cau_str_ca4_t;

/*!
 * @name Constants and macros for entire CAU_STR_CA4 register
 */
/*@{*/
#define HW_CAU_STR_CA4_ADDR(x)   ((uint32_t)(x) + 0x898U)

#define HW_CAU_STR_CA4(x)        (*(__I hw_cau_str_ca4_t *) HW_CAU_STR_CA4_ADDR(x))
#define HW_CAU_STR_CA4_RD(x)     (HW_CAU_STR_CA4(x).U)
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CA4 bitfields
 */

/*!
 * @name Register CAU_STR_CA4, field CA4[31:0] (RO)
 */
/*@{*/
#define BP_CAU_STR_CA4_CA4   (0U)          /*!< Bit position for CAU_STR_CA4_CA4. */
#define BM_CAU_STR_CA4_CA4   (0xFFFFFFFFU) /*!< Bit mask for CAU_STR_CA4_CA4. */
#define BS_CAU_STR_CA4_CA4   (32U)         /*!< Bit field size in bits for CAU_STR_CA4_CA4. */

/*! @brief Read current value of the CAU_STR_CA4_CA4 field. */
#define BR_CAU_STR_CA4_CA4(x) (HW_CAU_STR_CA4(x).U)
/*@}*/

/*******************************************************************************
 * HW_CAU_STR_CA5 - General Purpose Register 5 - Store Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_STR_CA5 - General Purpose Register 5 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_str_ca5
{
    uint32_t U;
    struct _hw_cau_str_ca5_bitfields
    {
        uint32_t CA5 : 32;             /*!< [31:0] CA5 */
    } B;
} hw_cau_str_ca5_t;

/*!
 * @name Constants and macros for entire CAU_STR_CA5 register
 */
/*@{*/
#define HW_CAU_STR_CA5_ADDR(x)   ((uint32_t)(x) + 0x89CU)

#define HW_CAU_STR_CA5(x)        (*(__I hw_cau_str_ca5_t *) HW_CAU_STR_CA5_ADDR(x))
#define HW_CAU_STR_CA5_RD(x)     (HW_CAU_STR_CA5(x).U)
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CA5 bitfields
 */

/*!
 * @name Register CAU_STR_CA5, field CA5[31:0] (RO)
 */
/*@{*/
#define BP_CAU_STR_CA5_CA5   (0U)          /*!< Bit position for CAU_STR_CA5_CA5. */
#define BM_CAU_STR_CA5_CA5   (0xFFFFFFFFU) /*!< Bit mask for CAU_STR_CA5_CA5. */
#define BS_CAU_STR_CA5_CA5   (32U)         /*!< Bit field size in bits for CAU_STR_CA5_CA5. */

/*! @brief Read current value of the CAU_STR_CA5_CA5 field. */
#define BR_CAU_STR_CA5_CA5(x) (HW_CAU_STR_CA5(x).U)
/*@}*/

/*******************************************************************************
 * HW_CAU_STR_CA6 - General Purpose Register 6 - Store Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_STR_CA6 - General Purpose Register 6 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_str_ca6
{
    uint32_t U;
    struct _hw_cau_str_ca6_bitfields
    {
        uint32_t CA6 : 32;             /*!< [31:0] CA6 */
    } B;
} hw_cau_str_ca6_t;

/*!
 * @name Constants and macros for entire CAU_STR_CA6 register
 */
/*@{*/
#define HW_CAU_STR_CA6_ADDR(x)   ((uint32_t)(x) + 0x8A0U)

#define HW_CAU_STR_CA6(x)        (*(__I hw_cau_str_ca6_t *) HW_CAU_STR_CA6_ADDR(x))
#define HW_CAU_STR_CA6_RD(x)     (HW_CAU_STR_CA6(x).U)
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CA6 bitfields
 */

/*!
 * @name Register CAU_STR_CA6, field CA6[31:0] (RO)
 */
/*@{*/
#define BP_CAU_STR_CA6_CA6   (0U)          /*!< Bit position for CAU_STR_CA6_CA6. */
#define BM_CAU_STR_CA6_CA6   (0xFFFFFFFFU) /*!< Bit mask for CAU_STR_CA6_CA6. */
#define BS_CAU_STR_CA6_CA6   (32U)         /*!< Bit field size in bits for CAU_STR_CA6_CA6. */

/*! @brief Read current value of the CAU_STR_CA6_CA6 field. */
#define BR_CAU_STR_CA6_CA6(x) (HW_CAU_STR_CA6(x).U)
/*@}*/

/*******************************************************************************
 * HW_CAU_STR_CA7 - General Purpose Register 7 - Store Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_STR_CA7 - General Purpose Register 7 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_str_ca7
{
    uint32_t U;
    struct _hw_cau_str_ca7_bitfields
    {
        uint32_t CA7 : 32;             /*!< [31:0] CA7 */
    } B;
} hw_cau_str_ca7_t;

/*!
 * @name Constants and macros for entire CAU_STR_CA7 register
 */
/*@{*/
#define HW_CAU_STR_CA7_ADDR(x)   ((uint32_t)(x) + 0x8A4U)

#define HW_CAU_STR_CA7(x)        (*(__I hw_cau_str_ca7_t *) HW_CAU_STR_CA7_ADDR(x))
#define HW_CAU_STR_CA7_RD(x)     (HW_CAU_STR_CA7(x).U)
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CA7 bitfields
 */

/*!
 * @name Register CAU_STR_CA7, field CA7[31:0] (RO)
 */
/*@{*/
#define BP_CAU_STR_CA7_CA7   (0U)          /*!< Bit position for CAU_STR_CA7_CA7. */
#define BM_CAU_STR_CA7_CA7   (0xFFFFFFFFU) /*!< Bit mask for CAU_STR_CA7_CA7. */
#define BS_CAU_STR_CA7_CA7   (32U)         /*!< Bit field size in bits for CAU_STR_CA7_CA7. */

/*! @brief Read current value of the CAU_STR_CA7_CA7 field. */
#define BR_CAU_STR_CA7_CA7(x) (HW_CAU_STR_CA7(x).U)
/*@}*/

/*******************************************************************************
 * HW_CAU_STR_CA8 - General Purpose Register 8 - Store Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_STR_CA8 - General Purpose Register 8 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_str_ca8
{
    uint32_t U;
    struct _hw_cau_str_ca8_bitfields
    {
        uint32_t CA8 : 32;             /*!< [31:0] CA8 */
    } B;
} hw_cau_str_ca8_t;

/*!
 * @name Constants and macros for entire CAU_STR_CA8 register
 */
/*@{*/
#define HW_CAU_STR_CA8_ADDR(x)   ((uint32_t)(x) + 0x8A8U)

#define HW_CAU_STR_CA8(x)        (*(__I hw_cau_str_ca8_t *) HW_CAU_STR_CA8_ADDR(x))
#define HW_CAU_STR_CA8_RD(x)     (HW_CAU_STR_CA8(x).U)
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CA8 bitfields
 */

/*!
 * @name Register CAU_STR_CA8, field CA8[31:0] (RO)
 */
/*@{*/
#define BP_CAU_STR_CA8_CA8   (0U)          /*!< Bit position for CAU_STR_CA8_CA8. */
#define BM_CAU_STR_CA8_CA8   (0xFFFFFFFFU) /*!< Bit mask for CAU_STR_CA8_CA8. */
#define BS_CAU_STR_CA8_CA8   (32U)         /*!< Bit field size in bits for CAU_STR_CA8_CA8. */

/*! @brief Read current value of the CAU_STR_CA8_CA8 field. */
#define BR_CAU_STR_CA8_CA8(x) (HW_CAU_STR_CA8(x).U)
/*@}*/

/*******************************************************************************
 * HW_CAU_ADR_CASR - Status register  - Add Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ADR_CASR - Status register  - Add Register command (WO)
 *
 * Reset value: 0x20000000U
 */
typedef union _hw_cau_adr_casr
{
    uint32_t U;
    struct _hw_cau_adr_casr_bitfields
    {
        uint32_t IC : 1;               /*!< [0]  */
        uint32_t DPE : 1;              /*!< [1]  */
        uint32_t RESERVED0 : 26;       /*!< [27:2]  */
        uint32_t VER : 4;              /*!< [31:28] CAU version */
    } B;
} hw_cau_adr_casr_t;

/*!
 * @name Constants and macros for entire CAU_ADR_CASR register
 */
/*@{*/
#define HW_CAU_ADR_CASR_ADDR(x)  ((uint32_t)(x) + 0x8C0U)

#define HW_CAU_ADR_CASR(x)       (*(__O hw_cau_adr_casr_t *) HW_CAU_ADR_CASR_ADDR(x))
#define HW_CAU_ADR_CASR_WR(x, v) (HW_CAU_ADR_CASR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CASR bitfields
 */

/*!
 * @name Register CAU_ADR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0 - No illegal commands issued
 * - 1 - Illegal command issued
 */
/*@{*/
#define BP_CAU_ADR_CASR_IC   (0U)          /*!< Bit position for CAU_ADR_CASR_IC. */
#define BM_CAU_ADR_CASR_IC   (0x00000001U) /*!< Bit mask for CAU_ADR_CASR_IC. */
#define BS_CAU_ADR_CASR_IC   (1U)          /*!< Bit field size in bits for CAU_ADR_CASR_IC. */

/*! @brief Format value for bitfield CAU_ADR_CASR_IC. */
#define BF_CAU_ADR_CASR_IC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CASR_IC) & BM_CAU_ADR_CASR_IC)
/*@}*/

/*!
 * @name Register CAU_ADR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0 - No error detected
 * - 1 - DES key parity error detected
 */
/*@{*/
#define BP_CAU_ADR_CASR_DPE  (1U)          /*!< Bit position for CAU_ADR_CASR_DPE. */
#define BM_CAU_ADR_CASR_DPE  (0x00000002U) /*!< Bit mask for CAU_ADR_CASR_DPE. */
#define BS_CAU_ADR_CASR_DPE  (1U)          /*!< Bit field size in bits for CAU_ADR_CASR_DPE. */

/*! @brief Format value for bitfield CAU_ADR_CASR_DPE. */
#define BF_CAU_ADR_CASR_DPE(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CASR_DPE) & BM_CAU_ADR_CASR_DPE)
/*@}*/

/*!
 * @name Register CAU_ADR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0001 - Initial CAU version
 * - 0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
#define BP_CAU_ADR_CASR_VER  (28U)         /*!< Bit position for CAU_ADR_CASR_VER. */
#define BM_CAU_ADR_CASR_VER  (0xF0000000U) /*!< Bit mask for CAU_ADR_CASR_VER. */
#define BS_CAU_ADR_CASR_VER  (4U)          /*!< Bit field size in bits for CAU_ADR_CASR_VER. */

/*! @brief Format value for bitfield CAU_ADR_CASR_VER. */
#define BF_CAU_ADR_CASR_VER(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CASR_VER) & BM_CAU_ADR_CASR_VER)
/*@}*/

/*******************************************************************************
 * HW_CAU_ADR_CAA - Accumulator register - Add to register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ADR_CAA - Accumulator register - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_adr_caa
{
    uint32_t U;
    struct _hw_cau_adr_caa_bitfields
    {
        uint32_t ACC : 32;             /*!< [31:0] ACC */
    } B;
} hw_cau_adr_caa_t;

/*!
 * @name Constants and macros for entire CAU_ADR_CAA register
 */
/*@{*/
#define HW_CAU_ADR_CAA_ADDR(x)   ((uint32_t)(x) + 0x8C4U)

#define HW_CAU_ADR_CAA(x)        (*(__O hw_cau_adr_caa_t *) HW_CAU_ADR_CAA_ADDR(x))
#define HW_CAU_ADR_CAA_WR(x, v)  (HW_CAU_ADR_CAA(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CAA bitfields
 */

/*!
 * @name Register CAU_ADR_CAA, field ACC[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ADR_CAA_ACC   (0U)          /*!< Bit position for CAU_ADR_CAA_ACC. */
#define BM_CAU_ADR_CAA_ACC   (0xFFFFFFFFU) /*!< Bit mask for CAU_ADR_CAA_ACC. */
#define BS_CAU_ADR_CAA_ACC   (32U)         /*!< Bit field size in bits for CAU_ADR_CAA_ACC. */

/*! @brief Format value for bitfield CAU_ADR_CAA_ACC. */
#define BF_CAU_ADR_CAA_ACC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CAA_ACC) & BM_CAU_ADR_CAA_ACC)
/*@}*/

/*******************************************************************************
 * HW_CAU_ADR_CA0 - General Purpose Register 0 - Add to register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ADR_CA0 - General Purpose Register 0 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_adr_ca0
{
    uint32_t U;
    struct _hw_cau_adr_ca0_bitfields
    {
        uint32_t CA0 : 32;             /*!< [31:0] CA0 */
    } B;
} hw_cau_adr_ca0_t;

/*!
 * @name Constants and macros for entire CAU_ADR_CA0 register
 */
/*@{*/
#define HW_CAU_ADR_CA0_ADDR(x)   ((uint32_t)(x) + 0x8C8U)

#define HW_CAU_ADR_CA0(x)        (*(__O hw_cau_adr_ca0_t *) HW_CAU_ADR_CA0_ADDR(x))
#define HW_CAU_ADR_CA0_WR(x, v)  (HW_CAU_ADR_CA0(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CA0 bitfields
 */

/*!
 * @name Register CAU_ADR_CA0, field CA0[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ADR_CA0_CA0   (0U)          /*!< Bit position for CAU_ADR_CA0_CA0. */
#define BM_CAU_ADR_CA0_CA0   (0xFFFFFFFFU) /*!< Bit mask for CAU_ADR_CA0_CA0. */
#define BS_CAU_ADR_CA0_CA0   (32U)         /*!< Bit field size in bits for CAU_ADR_CA0_CA0. */

/*! @brief Format value for bitfield CAU_ADR_CA0_CA0. */
#define BF_CAU_ADR_CA0_CA0(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CA0_CA0) & BM_CAU_ADR_CA0_CA0)
/*@}*/

/*******************************************************************************
 * HW_CAU_ADR_CA1 - General Purpose Register 1 - Add to register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ADR_CA1 - General Purpose Register 1 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_adr_ca1
{
    uint32_t U;
    struct _hw_cau_adr_ca1_bitfields
    {
        uint32_t CA1 : 32;             /*!< [31:0] CA1 */
    } B;
} hw_cau_adr_ca1_t;

/*!
 * @name Constants and macros for entire CAU_ADR_CA1 register
 */
/*@{*/
#define HW_CAU_ADR_CA1_ADDR(x)   ((uint32_t)(x) + 0x8CCU)

#define HW_CAU_ADR_CA1(x)        (*(__O hw_cau_adr_ca1_t *) HW_CAU_ADR_CA1_ADDR(x))
#define HW_CAU_ADR_CA1_WR(x, v)  (HW_CAU_ADR_CA1(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CA1 bitfields
 */

/*!
 * @name Register CAU_ADR_CA1, field CA1[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ADR_CA1_CA1   (0U)          /*!< Bit position for CAU_ADR_CA1_CA1. */
#define BM_CAU_ADR_CA1_CA1   (0xFFFFFFFFU) /*!< Bit mask for CAU_ADR_CA1_CA1. */
#define BS_CAU_ADR_CA1_CA1   (32U)         /*!< Bit field size in bits for CAU_ADR_CA1_CA1. */

/*! @brief Format value for bitfield CAU_ADR_CA1_CA1. */
#define BF_CAU_ADR_CA1_CA1(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CA1_CA1) & BM_CAU_ADR_CA1_CA1)
/*@}*/

/*******************************************************************************
 * HW_CAU_ADR_CA2 - General Purpose Register 2 - Add to register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ADR_CA2 - General Purpose Register 2 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_adr_ca2
{
    uint32_t U;
    struct _hw_cau_adr_ca2_bitfields
    {
        uint32_t CA2 : 32;             /*!< [31:0] CA2 */
    } B;
} hw_cau_adr_ca2_t;

/*!
 * @name Constants and macros for entire CAU_ADR_CA2 register
 */
/*@{*/
#define HW_CAU_ADR_CA2_ADDR(x)   ((uint32_t)(x) + 0x8D0U)

#define HW_CAU_ADR_CA2(x)        (*(__O hw_cau_adr_ca2_t *) HW_CAU_ADR_CA2_ADDR(x))
#define HW_CAU_ADR_CA2_WR(x, v)  (HW_CAU_ADR_CA2(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CA2 bitfields
 */

/*!
 * @name Register CAU_ADR_CA2, field CA2[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ADR_CA2_CA2   (0U)          /*!< Bit position for CAU_ADR_CA2_CA2. */
#define BM_CAU_ADR_CA2_CA2   (0xFFFFFFFFU) /*!< Bit mask for CAU_ADR_CA2_CA2. */
#define BS_CAU_ADR_CA2_CA2   (32U)         /*!< Bit field size in bits for CAU_ADR_CA2_CA2. */

/*! @brief Format value for bitfield CAU_ADR_CA2_CA2. */
#define BF_CAU_ADR_CA2_CA2(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CA2_CA2) & BM_CAU_ADR_CA2_CA2)
/*@}*/

/*******************************************************************************
 * HW_CAU_ADR_CA3 - General Purpose Register 3 - Add to register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ADR_CA3 - General Purpose Register 3 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_adr_ca3
{
    uint32_t U;
    struct _hw_cau_adr_ca3_bitfields
    {
        uint32_t CA3 : 32;             /*!< [31:0] CA3 */
    } B;
} hw_cau_adr_ca3_t;

/*!
 * @name Constants and macros for entire CAU_ADR_CA3 register
 */
/*@{*/
#define HW_CAU_ADR_CA3_ADDR(x)   ((uint32_t)(x) + 0x8D4U)

#define HW_CAU_ADR_CA3(x)        (*(__O hw_cau_adr_ca3_t *) HW_CAU_ADR_CA3_ADDR(x))
#define HW_CAU_ADR_CA3_WR(x, v)  (HW_CAU_ADR_CA3(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CA3 bitfields
 */

/*!
 * @name Register CAU_ADR_CA3, field CA3[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ADR_CA3_CA3   (0U)          /*!< Bit position for CAU_ADR_CA3_CA3. */
#define BM_CAU_ADR_CA3_CA3   (0xFFFFFFFFU) /*!< Bit mask for CAU_ADR_CA3_CA3. */
#define BS_CAU_ADR_CA3_CA3   (32U)         /*!< Bit field size in bits for CAU_ADR_CA3_CA3. */

/*! @brief Format value for bitfield CAU_ADR_CA3_CA3. */
#define BF_CAU_ADR_CA3_CA3(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CA3_CA3) & BM_CAU_ADR_CA3_CA3)
/*@}*/

/*******************************************************************************
 * HW_CAU_ADR_CA4 - General Purpose Register 4 - Add to register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ADR_CA4 - General Purpose Register 4 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_adr_ca4
{
    uint32_t U;
    struct _hw_cau_adr_ca4_bitfields
    {
        uint32_t CA4 : 32;             /*!< [31:0] CA4 */
    } B;
} hw_cau_adr_ca4_t;

/*!
 * @name Constants and macros for entire CAU_ADR_CA4 register
 */
/*@{*/
#define HW_CAU_ADR_CA4_ADDR(x)   ((uint32_t)(x) + 0x8D8U)

#define HW_CAU_ADR_CA4(x)        (*(__O hw_cau_adr_ca4_t *) HW_CAU_ADR_CA4_ADDR(x))
#define HW_CAU_ADR_CA4_WR(x, v)  (HW_CAU_ADR_CA4(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CA4 bitfields
 */

/*!
 * @name Register CAU_ADR_CA4, field CA4[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ADR_CA4_CA4   (0U)          /*!< Bit position for CAU_ADR_CA4_CA4. */
#define BM_CAU_ADR_CA4_CA4   (0xFFFFFFFFU) /*!< Bit mask for CAU_ADR_CA4_CA4. */
#define BS_CAU_ADR_CA4_CA4   (32U)         /*!< Bit field size in bits for CAU_ADR_CA4_CA4. */

/*! @brief Format value for bitfield CAU_ADR_CA4_CA4. */
#define BF_CAU_ADR_CA4_CA4(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CA4_CA4) & BM_CAU_ADR_CA4_CA4)
/*@}*/

/*******************************************************************************
 * HW_CAU_ADR_CA5 - General Purpose Register 5 - Add to register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ADR_CA5 - General Purpose Register 5 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_adr_ca5
{
    uint32_t U;
    struct _hw_cau_adr_ca5_bitfields
    {
        uint32_t CA5 : 32;             /*!< [31:0] CA5 */
    } B;
} hw_cau_adr_ca5_t;

/*!
 * @name Constants and macros for entire CAU_ADR_CA5 register
 */
/*@{*/
#define HW_CAU_ADR_CA5_ADDR(x)   ((uint32_t)(x) + 0x8DCU)

#define HW_CAU_ADR_CA5(x)        (*(__O hw_cau_adr_ca5_t *) HW_CAU_ADR_CA5_ADDR(x))
#define HW_CAU_ADR_CA5_WR(x, v)  (HW_CAU_ADR_CA5(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CA5 bitfields
 */

/*!
 * @name Register CAU_ADR_CA5, field CA5[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ADR_CA5_CA5   (0U)          /*!< Bit position for CAU_ADR_CA5_CA5. */
#define BM_CAU_ADR_CA5_CA5   (0xFFFFFFFFU) /*!< Bit mask for CAU_ADR_CA5_CA5. */
#define BS_CAU_ADR_CA5_CA5   (32U)         /*!< Bit field size in bits for CAU_ADR_CA5_CA5. */

/*! @brief Format value for bitfield CAU_ADR_CA5_CA5. */
#define BF_CAU_ADR_CA5_CA5(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CA5_CA5) & BM_CAU_ADR_CA5_CA5)
/*@}*/

/*******************************************************************************
 * HW_CAU_ADR_CA6 - General Purpose Register 6 - Add to register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ADR_CA6 - General Purpose Register 6 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_adr_ca6
{
    uint32_t U;
    struct _hw_cau_adr_ca6_bitfields
    {
        uint32_t CA6 : 32;             /*!< [31:0] CA6 */
    } B;
} hw_cau_adr_ca6_t;

/*!
 * @name Constants and macros for entire CAU_ADR_CA6 register
 */
/*@{*/
#define HW_CAU_ADR_CA6_ADDR(x)   ((uint32_t)(x) + 0x8E0U)

#define HW_CAU_ADR_CA6(x)        (*(__O hw_cau_adr_ca6_t *) HW_CAU_ADR_CA6_ADDR(x))
#define HW_CAU_ADR_CA6_WR(x, v)  (HW_CAU_ADR_CA6(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CA6 bitfields
 */

/*!
 * @name Register CAU_ADR_CA6, field CA6[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ADR_CA6_CA6   (0U)          /*!< Bit position for CAU_ADR_CA6_CA6. */
#define BM_CAU_ADR_CA6_CA6   (0xFFFFFFFFU) /*!< Bit mask for CAU_ADR_CA6_CA6. */
#define BS_CAU_ADR_CA6_CA6   (32U)         /*!< Bit field size in bits for CAU_ADR_CA6_CA6. */

/*! @brief Format value for bitfield CAU_ADR_CA6_CA6. */
#define BF_CAU_ADR_CA6_CA6(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CA6_CA6) & BM_CAU_ADR_CA6_CA6)
/*@}*/

/*******************************************************************************
 * HW_CAU_ADR_CA7 - General Purpose Register 7 - Add to register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ADR_CA7 - General Purpose Register 7 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_adr_ca7
{
    uint32_t U;
    struct _hw_cau_adr_ca7_bitfields
    {
        uint32_t CA7 : 32;             /*!< [31:0] CA7 */
    } B;
} hw_cau_adr_ca7_t;

/*!
 * @name Constants and macros for entire CAU_ADR_CA7 register
 */
/*@{*/
#define HW_CAU_ADR_CA7_ADDR(x)   ((uint32_t)(x) + 0x8E4U)

#define HW_CAU_ADR_CA7(x)        (*(__O hw_cau_adr_ca7_t *) HW_CAU_ADR_CA7_ADDR(x))
#define HW_CAU_ADR_CA7_WR(x, v)  (HW_CAU_ADR_CA7(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CA7 bitfields
 */

/*!
 * @name Register CAU_ADR_CA7, field CA7[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ADR_CA7_CA7   (0U)          /*!< Bit position for CAU_ADR_CA7_CA7. */
#define BM_CAU_ADR_CA7_CA7   (0xFFFFFFFFU) /*!< Bit mask for CAU_ADR_CA7_CA7. */
#define BS_CAU_ADR_CA7_CA7   (32U)         /*!< Bit field size in bits for CAU_ADR_CA7_CA7. */

/*! @brief Format value for bitfield CAU_ADR_CA7_CA7. */
#define BF_CAU_ADR_CA7_CA7(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CA7_CA7) & BM_CAU_ADR_CA7_CA7)
/*@}*/

/*******************************************************************************
 * HW_CAU_ADR_CA8 - General Purpose Register 8 - Add to register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ADR_CA8 - General Purpose Register 8 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_adr_ca8
{
    uint32_t U;
    struct _hw_cau_adr_ca8_bitfields
    {
        uint32_t CA8 : 32;             /*!< [31:0] CA8 */
    } B;
} hw_cau_adr_ca8_t;

/*!
 * @name Constants and macros for entire CAU_ADR_CA8 register
 */
/*@{*/
#define HW_CAU_ADR_CA8_ADDR(x)   ((uint32_t)(x) + 0x8E8U)

#define HW_CAU_ADR_CA8(x)        (*(__O hw_cau_adr_ca8_t *) HW_CAU_ADR_CA8_ADDR(x))
#define HW_CAU_ADR_CA8_WR(x, v)  (HW_CAU_ADR_CA8(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CA8 bitfields
 */

/*!
 * @name Register CAU_ADR_CA8, field CA8[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ADR_CA8_CA8   (0U)          /*!< Bit position for CAU_ADR_CA8_CA8. */
#define BM_CAU_ADR_CA8_CA8   (0xFFFFFFFFU) /*!< Bit mask for CAU_ADR_CA8_CA8. */
#define BS_CAU_ADR_CA8_CA8   (32U)         /*!< Bit field size in bits for CAU_ADR_CA8_CA8. */

/*! @brief Format value for bitfield CAU_ADR_CA8_CA8. */
#define BF_CAU_ADR_CA8_CA8(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ADR_CA8_CA8) & BM_CAU_ADR_CA8_CA8)
/*@}*/

/*******************************************************************************
 * HW_CAU_RADR_CASR - Status register  - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_RADR_CASR - Status register  - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x20000000U
 */
typedef union _hw_cau_radr_casr
{
    uint32_t U;
    struct _hw_cau_radr_casr_bitfields
    {
        uint32_t IC : 1;               /*!< [0]  */
        uint32_t DPE : 1;              /*!< [1]  */
        uint32_t RESERVED0 : 26;       /*!< [27:2]  */
        uint32_t VER : 4;              /*!< [31:28] CAU version */
    } B;
} hw_cau_radr_casr_t;

/*!
 * @name Constants and macros for entire CAU_RADR_CASR register
 */
/*@{*/
#define HW_CAU_RADR_CASR_ADDR(x) ((uint32_t)(x) + 0x900U)

#define HW_CAU_RADR_CASR(x)      (*(__O hw_cau_radr_casr_t *) HW_CAU_RADR_CASR_ADDR(x))
#define HW_CAU_RADR_CASR_WR(x, v) (HW_CAU_RADR_CASR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CASR bitfields
 */

/*!
 * @name Register CAU_RADR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0 - No illegal commands issued
 * - 1 - Illegal command issued
 */
/*@{*/
#define BP_CAU_RADR_CASR_IC  (0U)          /*!< Bit position for CAU_RADR_CASR_IC. */
#define BM_CAU_RADR_CASR_IC  (0x00000001U) /*!< Bit mask for CAU_RADR_CASR_IC. */
#define BS_CAU_RADR_CASR_IC  (1U)          /*!< Bit field size in bits for CAU_RADR_CASR_IC. */

/*! @brief Format value for bitfield CAU_RADR_CASR_IC. */
#define BF_CAU_RADR_CASR_IC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CASR_IC) & BM_CAU_RADR_CASR_IC)
/*@}*/

/*!
 * @name Register CAU_RADR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0 - No error detected
 * - 1 - DES key parity error detected
 */
/*@{*/
#define BP_CAU_RADR_CASR_DPE (1U)          /*!< Bit position for CAU_RADR_CASR_DPE. */
#define BM_CAU_RADR_CASR_DPE (0x00000002U) /*!< Bit mask for CAU_RADR_CASR_DPE. */
#define BS_CAU_RADR_CASR_DPE (1U)          /*!< Bit field size in bits for CAU_RADR_CASR_DPE. */

/*! @brief Format value for bitfield CAU_RADR_CASR_DPE. */
#define BF_CAU_RADR_CASR_DPE(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CASR_DPE) & BM_CAU_RADR_CASR_DPE)
/*@}*/

/*!
 * @name Register CAU_RADR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0001 - Initial CAU version
 * - 0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
#define BP_CAU_RADR_CASR_VER (28U)         /*!< Bit position for CAU_RADR_CASR_VER. */
#define BM_CAU_RADR_CASR_VER (0xF0000000U) /*!< Bit mask for CAU_RADR_CASR_VER. */
#define BS_CAU_RADR_CASR_VER (4U)          /*!< Bit field size in bits for CAU_RADR_CASR_VER. */

/*! @brief Format value for bitfield CAU_RADR_CASR_VER. */
#define BF_CAU_RADR_CASR_VER(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CASR_VER) & BM_CAU_RADR_CASR_VER)
/*@}*/

/*******************************************************************************
 * HW_CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_radr_caa
{
    uint32_t U;
    struct _hw_cau_radr_caa_bitfields
    {
        uint32_t ACC : 32;             /*!< [31:0] ACC */
    } B;
} hw_cau_radr_caa_t;

/*!
 * @name Constants and macros for entire CAU_RADR_CAA register
 */
/*@{*/
#define HW_CAU_RADR_CAA_ADDR(x)  ((uint32_t)(x) + 0x904U)

#define HW_CAU_RADR_CAA(x)       (*(__O hw_cau_radr_caa_t *) HW_CAU_RADR_CAA_ADDR(x))
#define HW_CAU_RADR_CAA_WR(x, v) (HW_CAU_RADR_CAA(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CAA bitfields
 */

/*!
 * @name Register CAU_RADR_CAA, field ACC[31:0] (WO)
 */
/*@{*/
#define BP_CAU_RADR_CAA_ACC  (0U)          /*!< Bit position for CAU_RADR_CAA_ACC. */
#define BM_CAU_RADR_CAA_ACC  (0xFFFFFFFFU) /*!< Bit mask for CAU_RADR_CAA_ACC. */
#define BS_CAU_RADR_CAA_ACC  (32U)         /*!< Bit field size in bits for CAU_RADR_CAA_ACC. */

/*! @brief Format value for bitfield CAU_RADR_CAA_ACC. */
#define BF_CAU_RADR_CAA_ACC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CAA_ACC) & BM_CAU_RADR_CAA_ACC)
/*@}*/

/*******************************************************************************
 * HW_CAU_RADR_CA0 - General Purpose Register 0 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_RADR_CA0 - General Purpose Register 0 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_radr_ca0
{
    uint32_t U;
    struct _hw_cau_radr_ca0_bitfields
    {
        uint32_t CA0 : 32;             /*!< [31:0] CA0 */
    } B;
} hw_cau_radr_ca0_t;

/*!
 * @name Constants and macros for entire CAU_RADR_CA0 register
 */
/*@{*/
#define HW_CAU_RADR_CA0_ADDR(x)  ((uint32_t)(x) + 0x908U)

#define HW_CAU_RADR_CA0(x)       (*(__O hw_cau_radr_ca0_t *) HW_CAU_RADR_CA0_ADDR(x))
#define HW_CAU_RADR_CA0_WR(x, v) (HW_CAU_RADR_CA0(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CA0 bitfields
 */

/*!
 * @name Register CAU_RADR_CA0, field CA0[31:0] (WO)
 */
/*@{*/
#define BP_CAU_RADR_CA0_CA0  (0U)          /*!< Bit position for CAU_RADR_CA0_CA0. */
#define BM_CAU_RADR_CA0_CA0  (0xFFFFFFFFU) /*!< Bit mask for CAU_RADR_CA0_CA0. */
#define BS_CAU_RADR_CA0_CA0  (32U)         /*!< Bit field size in bits for CAU_RADR_CA0_CA0. */

/*! @brief Format value for bitfield CAU_RADR_CA0_CA0. */
#define BF_CAU_RADR_CA0_CA0(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CA0_CA0) & BM_CAU_RADR_CA0_CA0)
/*@}*/

/*******************************************************************************
 * HW_CAU_RADR_CA1 - General Purpose Register 1 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_RADR_CA1 - General Purpose Register 1 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_radr_ca1
{
    uint32_t U;
    struct _hw_cau_radr_ca1_bitfields
    {
        uint32_t CA1 : 32;             /*!< [31:0] CA1 */
    } B;
} hw_cau_radr_ca1_t;

/*!
 * @name Constants and macros for entire CAU_RADR_CA1 register
 */
/*@{*/
#define HW_CAU_RADR_CA1_ADDR(x)  ((uint32_t)(x) + 0x90CU)

#define HW_CAU_RADR_CA1(x)       (*(__O hw_cau_radr_ca1_t *) HW_CAU_RADR_CA1_ADDR(x))
#define HW_CAU_RADR_CA1_WR(x, v) (HW_CAU_RADR_CA1(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CA1 bitfields
 */

/*!
 * @name Register CAU_RADR_CA1, field CA1[31:0] (WO)
 */
/*@{*/
#define BP_CAU_RADR_CA1_CA1  (0U)          /*!< Bit position for CAU_RADR_CA1_CA1. */
#define BM_CAU_RADR_CA1_CA1  (0xFFFFFFFFU) /*!< Bit mask for CAU_RADR_CA1_CA1. */
#define BS_CAU_RADR_CA1_CA1  (32U)         /*!< Bit field size in bits for CAU_RADR_CA1_CA1. */

/*! @brief Format value for bitfield CAU_RADR_CA1_CA1. */
#define BF_CAU_RADR_CA1_CA1(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CA1_CA1) & BM_CAU_RADR_CA1_CA1)
/*@}*/

/*******************************************************************************
 * HW_CAU_RADR_CA2 - General Purpose Register 2 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_RADR_CA2 - General Purpose Register 2 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_radr_ca2
{
    uint32_t U;
    struct _hw_cau_radr_ca2_bitfields
    {
        uint32_t CA2 : 32;             /*!< [31:0] CA2 */
    } B;
} hw_cau_radr_ca2_t;

/*!
 * @name Constants and macros for entire CAU_RADR_CA2 register
 */
/*@{*/
#define HW_CAU_RADR_CA2_ADDR(x)  ((uint32_t)(x) + 0x910U)

#define HW_CAU_RADR_CA2(x)       (*(__O hw_cau_radr_ca2_t *) HW_CAU_RADR_CA2_ADDR(x))
#define HW_CAU_RADR_CA2_WR(x, v) (HW_CAU_RADR_CA2(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CA2 bitfields
 */

/*!
 * @name Register CAU_RADR_CA2, field CA2[31:0] (WO)
 */
/*@{*/
#define BP_CAU_RADR_CA2_CA2  (0U)          /*!< Bit position for CAU_RADR_CA2_CA2. */
#define BM_CAU_RADR_CA2_CA2  (0xFFFFFFFFU) /*!< Bit mask for CAU_RADR_CA2_CA2. */
#define BS_CAU_RADR_CA2_CA2  (32U)         /*!< Bit field size in bits for CAU_RADR_CA2_CA2. */

/*! @brief Format value for bitfield CAU_RADR_CA2_CA2. */
#define BF_CAU_RADR_CA2_CA2(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CA2_CA2) & BM_CAU_RADR_CA2_CA2)
/*@}*/

/*******************************************************************************
 * HW_CAU_RADR_CA3 - General Purpose Register 3 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_RADR_CA3 - General Purpose Register 3 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_radr_ca3
{
    uint32_t U;
    struct _hw_cau_radr_ca3_bitfields
    {
        uint32_t CA3 : 32;             /*!< [31:0] CA3 */
    } B;
} hw_cau_radr_ca3_t;

/*!
 * @name Constants and macros for entire CAU_RADR_CA3 register
 */
/*@{*/
#define HW_CAU_RADR_CA3_ADDR(x)  ((uint32_t)(x) + 0x914U)

#define HW_CAU_RADR_CA3(x)       (*(__O hw_cau_radr_ca3_t *) HW_CAU_RADR_CA3_ADDR(x))
#define HW_CAU_RADR_CA3_WR(x, v) (HW_CAU_RADR_CA3(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CA3 bitfields
 */

/*!
 * @name Register CAU_RADR_CA3, field CA3[31:0] (WO)
 */
/*@{*/
#define BP_CAU_RADR_CA3_CA3  (0U)          /*!< Bit position for CAU_RADR_CA3_CA3. */
#define BM_CAU_RADR_CA3_CA3  (0xFFFFFFFFU) /*!< Bit mask for CAU_RADR_CA3_CA3. */
#define BS_CAU_RADR_CA3_CA3  (32U)         /*!< Bit field size in bits for CAU_RADR_CA3_CA3. */

/*! @brief Format value for bitfield CAU_RADR_CA3_CA3. */
#define BF_CAU_RADR_CA3_CA3(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CA3_CA3) & BM_CAU_RADR_CA3_CA3)
/*@}*/

/*******************************************************************************
 * HW_CAU_RADR_CA4 - General Purpose Register 4 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_RADR_CA4 - General Purpose Register 4 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_radr_ca4
{
    uint32_t U;
    struct _hw_cau_radr_ca4_bitfields
    {
        uint32_t CA4 : 32;             /*!< [31:0] CA4 */
    } B;
} hw_cau_radr_ca4_t;

/*!
 * @name Constants and macros for entire CAU_RADR_CA4 register
 */
/*@{*/
#define HW_CAU_RADR_CA4_ADDR(x)  ((uint32_t)(x) + 0x918U)

#define HW_CAU_RADR_CA4(x)       (*(__O hw_cau_radr_ca4_t *) HW_CAU_RADR_CA4_ADDR(x))
#define HW_CAU_RADR_CA4_WR(x, v) (HW_CAU_RADR_CA4(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CA4 bitfields
 */

/*!
 * @name Register CAU_RADR_CA4, field CA4[31:0] (WO)
 */
/*@{*/
#define BP_CAU_RADR_CA4_CA4  (0U)          /*!< Bit position for CAU_RADR_CA4_CA4. */
#define BM_CAU_RADR_CA4_CA4  (0xFFFFFFFFU) /*!< Bit mask for CAU_RADR_CA4_CA4. */
#define BS_CAU_RADR_CA4_CA4  (32U)         /*!< Bit field size in bits for CAU_RADR_CA4_CA4. */

/*! @brief Format value for bitfield CAU_RADR_CA4_CA4. */
#define BF_CAU_RADR_CA4_CA4(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CA4_CA4) & BM_CAU_RADR_CA4_CA4)
/*@}*/

/*******************************************************************************
 * HW_CAU_RADR_CA5 - General Purpose Register 5 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_RADR_CA5 - General Purpose Register 5 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_radr_ca5
{
    uint32_t U;
    struct _hw_cau_radr_ca5_bitfields
    {
        uint32_t CA5 : 32;             /*!< [31:0] CA5 */
    } B;
} hw_cau_radr_ca5_t;

/*!
 * @name Constants and macros for entire CAU_RADR_CA5 register
 */
/*@{*/
#define HW_CAU_RADR_CA5_ADDR(x)  ((uint32_t)(x) + 0x91CU)

#define HW_CAU_RADR_CA5(x)       (*(__O hw_cau_radr_ca5_t *) HW_CAU_RADR_CA5_ADDR(x))
#define HW_CAU_RADR_CA5_WR(x, v) (HW_CAU_RADR_CA5(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CA5 bitfields
 */

/*!
 * @name Register CAU_RADR_CA5, field CA5[31:0] (WO)
 */
/*@{*/
#define BP_CAU_RADR_CA5_CA5  (0U)          /*!< Bit position for CAU_RADR_CA5_CA5. */
#define BM_CAU_RADR_CA5_CA5  (0xFFFFFFFFU) /*!< Bit mask for CAU_RADR_CA5_CA5. */
#define BS_CAU_RADR_CA5_CA5  (32U)         /*!< Bit field size in bits for CAU_RADR_CA5_CA5. */

/*! @brief Format value for bitfield CAU_RADR_CA5_CA5. */
#define BF_CAU_RADR_CA5_CA5(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CA5_CA5) & BM_CAU_RADR_CA5_CA5)
/*@}*/

/*******************************************************************************
 * HW_CAU_RADR_CA6 - General Purpose Register 6 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_RADR_CA6 - General Purpose Register 6 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_radr_ca6
{
    uint32_t U;
    struct _hw_cau_radr_ca6_bitfields
    {
        uint32_t CA6 : 32;             /*!< [31:0] CA6 */
    } B;
} hw_cau_radr_ca6_t;

/*!
 * @name Constants and macros for entire CAU_RADR_CA6 register
 */
/*@{*/
#define HW_CAU_RADR_CA6_ADDR(x)  ((uint32_t)(x) + 0x920U)

#define HW_CAU_RADR_CA6(x)       (*(__O hw_cau_radr_ca6_t *) HW_CAU_RADR_CA6_ADDR(x))
#define HW_CAU_RADR_CA6_WR(x, v) (HW_CAU_RADR_CA6(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CA6 bitfields
 */

/*!
 * @name Register CAU_RADR_CA6, field CA6[31:0] (WO)
 */
/*@{*/
#define BP_CAU_RADR_CA6_CA6  (0U)          /*!< Bit position for CAU_RADR_CA6_CA6. */
#define BM_CAU_RADR_CA6_CA6  (0xFFFFFFFFU) /*!< Bit mask for CAU_RADR_CA6_CA6. */
#define BS_CAU_RADR_CA6_CA6  (32U)         /*!< Bit field size in bits for CAU_RADR_CA6_CA6. */

/*! @brief Format value for bitfield CAU_RADR_CA6_CA6. */
#define BF_CAU_RADR_CA6_CA6(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CA6_CA6) & BM_CAU_RADR_CA6_CA6)
/*@}*/

/*******************************************************************************
 * HW_CAU_RADR_CA7 - General Purpose Register 7 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_RADR_CA7 - General Purpose Register 7 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_radr_ca7
{
    uint32_t U;
    struct _hw_cau_radr_ca7_bitfields
    {
        uint32_t CA7 : 32;             /*!< [31:0] CA7 */
    } B;
} hw_cau_radr_ca7_t;

/*!
 * @name Constants and macros for entire CAU_RADR_CA7 register
 */
/*@{*/
#define HW_CAU_RADR_CA7_ADDR(x)  ((uint32_t)(x) + 0x924U)

#define HW_CAU_RADR_CA7(x)       (*(__O hw_cau_radr_ca7_t *) HW_CAU_RADR_CA7_ADDR(x))
#define HW_CAU_RADR_CA7_WR(x, v) (HW_CAU_RADR_CA7(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CA7 bitfields
 */

/*!
 * @name Register CAU_RADR_CA7, field CA7[31:0] (WO)
 */
/*@{*/
#define BP_CAU_RADR_CA7_CA7  (0U)          /*!< Bit position for CAU_RADR_CA7_CA7. */
#define BM_CAU_RADR_CA7_CA7  (0xFFFFFFFFU) /*!< Bit mask for CAU_RADR_CA7_CA7. */
#define BS_CAU_RADR_CA7_CA7  (32U)         /*!< Bit field size in bits for CAU_RADR_CA7_CA7. */

/*! @brief Format value for bitfield CAU_RADR_CA7_CA7. */
#define BF_CAU_RADR_CA7_CA7(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CA7_CA7) & BM_CAU_RADR_CA7_CA7)
/*@}*/

/*******************************************************************************
 * HW_CAU_RADR_CA8 - General Purpose Register 8 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief HW_CAU_RADR_CA8 - General Purpose Register 8 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_radr_ca8
{
    uint32_t U;
    struct _hw_cau_radr_ca8_bitfields
    {
        uint32_t CA8 : 32;             /*!< [31:0] CA8 */
    } B;
} hw_cau_radr_ca8_t;

/*!
 * @name Constants and macros for entire CAU_RADR_CA8 register
 */
/*@{*/
#define HW_CAU_RADR_CA8_ADDR(x)  ((uint32_t)(x) + 0x928U)

#define HW_CAU_RADR_CA8(x)       (*(__O hw_cau_radr_ca8_t *) HW_CAU_RADR_CA8_ADDR(x))
#define HW_CAU_RADR_CA8_WR(x, v) (HW_CAU_RADR_CA8(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CA8 bitfields
 */

/*!
 * @name Register CAU_RADR_CA8, field CA8[31:0] (WO)
 */
/*@{*/
#define BP_CAU_RADR_CA8_CA8  (0U)          /*!< Bit position for CAU_RADR_CA8_CA8. */
#define BM_CAU_RADR_CA8_CA8  (0xFFFFFFFFU) /*!< Bit mask for CAU_RADR_CA8_CA8. */
#define BS_CAU_RADR_CA8_CA8  (32U)         /*!< Bit field size in bits for CAU_RADR_CA8_CA8. */

/*! @brief Format value for bitfield CAU_RADR_CA8_CA8. */
#define BF_CAU_RADR_CA8_CA8(v) ((uint32_t)((uint32_t)(v) << BP_CAU_RADR_CA8_CA8) & BM_CAU_RADR_CA8_CA8)
/*@}*/

/*******************************************************************************
 * HW_CAU_XOR_CASR - Status register  - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief HW_CAU_XOR_CASR - Status register  - Exclusive Or command (WO)
 *
 * Reset value: 0x20000000U
 */
typedef union _hw_cau_xor_casr
{
    uint32_t U;
    struct _hw_cau_xor_casr_bitfields
    {
        uint32_t IC : 1;               /*!< [0]  */
        uint32_t DPE : 1;              /*!< [1]  */
        uint32_t RESERVED0 : 26;       /*!< [27:2]  */
        uint32_t VER : 4;              /*!< [31:28] CAU version */
    } B;
} hw_cau_xor_casr_t;

/*!
 * @name Constants and macros for entire CAU_XOR_CASR register
 */
/*@{*/
#define HW_CAU_XOR_CASR_ADDR(x)  ((uint32_t)(x) + 0x980U)

#define HW_CAU_XOR_CASR(x)       (*(__O hw_cau_xor_casr_t *) HW_CAU_XOR_CASR_ADDR(x))
#define HW_CAU_XOR_CASR_WR(x, v) (HW_CAU_XOR_CASR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CASR bitfields
 */

/*!
 * @name Register CAU_XOR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0 - No illegal commands issued
 * - 1 - Illegal command issued
 */
/*@{*/
#define BP_CAU_XOR_CASR_IC   (0U)          /*!< Bit position for CAU_XOR_CASR_IC. */
#define BM_CAU_XOR_CASR_IC   (0x00000001U) /*!< Bit mask for CAU_XOR_CASR_IC. */
#define BS_CAU_XOR_CASR_IC   (1U)          /*!< Bit field size in bits for CAU_XOR_CASR_IC. */

/*! @brief Format value for bitfield CAU_XOR_CASR_IC. */
#define BF_CAU_XOR_CASR_IC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CASR_IC) & BM_CAU_XOR_CASR_IC)
/*@}*/

/*!
 * @name Register CAU_XOR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0 - No error detected
 * - 1 - DES key parity error detected
 */
/*@{*/
#define BP_CAU_XOR_CASR_DPE  (1U)          /*!< Bit position for CAU_XOR_CASR_DPE. */
#define BM_CAU_XOR_CASR_DPE  (0x00000002U) /*!< Bit mask for CAU_XOR_CASR_DPE. */
#define BS_CAU_XOR_CASR_DPE  (1U)          /*!< Bit field size in bits for CAU_XOR_CASR_DPE. */

/*! @brief Format value for bitfield CAU_XOR_CASR_DPE. */
#define BF_CAU_XOR_CASR_DPE(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CASR_DPE) & BM_CAU_XOR_CASR_DPE)
/*@}*/

/*!
 * @name Register CAU_XOR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0001 - Initial CAU version
 * - 0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
#define BP_CAU_XOR_CASR_VER  (28U)         /*!< Bit position for CAU_XOR_CASR_VER. */
#define BM_CAU_XOR_CASR_VER  (0xF0000000U) /*!< Bit mask for CAU_XOR_CASR_VER. */
#define BS_CAU_XOR_CASR_VER  (4U)          /*!< Bit field size in bits for CAU_XOR_CASR_VER. */

/*! @brief Format value for bitfield CAU_XOR_CASR_VER. */
#define BF_CAU_XOR_CASR_VER(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CASR_VER) & BM_CAU_XOR_CASR_VER)
/*@}*/

/*******************************************************************************
 * HW_CAU_XOR_CAA - Accumulator register - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief HW_CAU_XOR_CAA - Accumulator register - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_xor_caa
{
    uint32_t U;
    struct _hw_cau_xor_caa_bitfields
    {
        uint32_t ACC : 32;             /*!< [31:0] ACC */
    } B;
} hw_cau_xor_caa_t;

/*!
 * @name Constants and macros for entire CAU_XOR_CAA register
 */
/*@{*/
#define HW_CAU_XOR_CAA_ADDR(x)   ((uint32_t)(x) + 0x984U)

#define HW_CAU_XOR_CAA(x)        (*(__O hw_cau_xor_caa_t *) HW_CAU_XOR_CAA_ADDR(x))
#define HW_CAU_XOR_CAA_WR(x, v)  (HW_CAU_XOR_CAA(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CAA bitfields
 */

/*!
 * @name Register CAU_XOR_CAA, field ACC[31:0] (WO)
 */
/*@{*/
#define BP_CAU_XOR_CAA_ACC   (0U)          /*!< Bit position for CAU_XOR_CAA_ACC. */
#define BM_CAU_XOR_CAA_ACC   (0xFFFFFFFFU) /*!< Bit mask for CAU_XOR_CAA_ACC. */
#define BS_CAU_XOR_CAA_ACC   (32U)         /*!< Bit field size in bits for CAU_XOR_CAA_ACC. */

/*! @brief Format value for bitfield CAU_XOR_CAA_ACC. */
#define BF_CAU_XOR_CAA_ACC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CAA_ACC) & BM_CAU_XOR_CAA_ACC)
/*@}*/

/*******************************************************************************
 * HW_CAU_XOR_CA0 - General Purpose Register 0 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief HW_CAU_XOR_CA0 - General Purpose Register 0 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_xor_ca0
{
    uint32_t U;
    struct _hw_cau_xor_ca0_bitfields
    {
        uint32_t CA0 : 32;             /*!< [31:0] CA0 */
    } B;
} hw_cau_xor_ca0_t;

/*!
 * @name Constants and macros for entire CAU_XOR_CA0 register
 */
/*@{*/
#define HW_CAU_XOR_CA0_ADDR(x)   ((uint32_t)(x) + 0x988U)

#define HW_CAU_XOR_CA0(x)        (*(__O hw_cau_xor_ca0_t *) HW_CAU_XOR_CA0_ADDR(x))
#define HW_CAU_XOR_CA0_WR(x, v)  (HW_CAU_XOR_CA0(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CA0 bitfields
 */

/*!
 * @name Register CAU_XOR_CA0, field CA0[31:0] (WO)
 */
/*@{*/
#define BP_CAU_XOR_CA0_CA0   (0U)          /*!< Bit position for CAU_XOR_CA0_CA0. */
#define BM_CAU_XOR_CA0_CA0   (0xFFFFFFFFU) /*!< Bit mask for CAU_XOR_CA0_CA0. */
#define BS_CAU_XOR_CA0_CA0   (32U)         /*!< Bit field size in bits for CAU_XOR_CA0_CA0. */

/*! @brief Format value for bitfield CAU_XOR_CA0_CA0. */
#define BF_CAU_XOR_CA0_CA0(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CA0_CA0) & BM_CAU_XOR_CA0_CA0)
/*@}*/

/*******************************************************************************
 * HW_CAU_XOR_CA1 - General Purpose Register 1 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief HW_CAU_XOR_CA1 - General Purpose Register 1 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_xor_ca1
{
    uint32_t U;
    struct _hw_cau_xor_ca1_bitfields
    {
        uint32_t CA1 : 32;             /*!< [31:0] CA1 */
    } B;
} hw_cau_xor_ca1_t;

/*!
 * @name Constants and macros for entire CAU_XOR_CA1 register
 */
/*@{*/
#define HW_CAU_XOR_CA1_ADDR(x)   ((uint32_t)(x) + 0x98CU)

#define HW_CAU_XOR_CA1(x)        (*(__O hw_cau_xor_ca1_t *) HW_CAU_XOR_CA1_ADDR(x))
#define HW_CAU_XOR_CA1_WR(x, v)  (HW_CAU_XOR_CA1(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CA1 bitfields
 */

/*!
 * @name Register CAU_XOR_CA1, field CA1[31:0] (WO)
 */
/*@{*/
#define BP_CAU_XOR_CA1_CA1   (0U)          /*!< Bit position for CAU_XOR_CA1_CA1. */
#define BM_CAU_XOR_CA1_CA1   (0xFFFFFFFFU) /*!< Bit mask for CAU_XOR_CA1_CA1. */
#define BS_CAU_XOR_CA1_CA1   (32U)         /*!< Bit field size in bits for CAU_XOR_CA1_CA1. */

/*! @brief Format value for bitfield CAU_XOR_CA1_CA1. */
#define BF_CAU_XOR_CA1_CA1(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CA1_CA1) & BM_CAU_XOR_CA1_CA1)
/*@}*/

/*******************************************************************************
 * HW_CAU_XOR_CA2 - General Purpose Register 2 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief HW_CAU_XOR_CA2 - General Purpose Register 2 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_xor_ca2
{
    uint32_t U;
    struct _hw_cau_xor_ca2_bitfields
    {
        uint32_t CA2 : 32;             /*!< [31:0] CA2 */
    } B;
} hw_cau_xor_ca2_t;

/*!
 * @name Constants and macros for entire CAU_XOR_CA2 register
 */
/*@{*/
#define HW_CAU_XOR_CA2_ADDR(x)   ((uint32_t)(x) + 0x990U)

#define HW_CAU_XOR_CA2(x)        (*(__O hw_cau_xor_ca2_t *) HW_CAU_XOR_CA2_ADDR(x))
#define HW_CAU_XOR_CA2_WR(x, v)  (HW_CAU_XOR_CA2(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CA2 bitfields
 */

/*!
 * @name Register CAU_XOR_CA2, field CA2[31:0] (WO)
 */
/*@{*/
#define BP_CAU_XOR_CA2_CA2   (0U)          /*!< Bit position for CAU_XOR_CA2_CA2. */
#define BM_CAU_XOR_CA2_CA2   (0xFFFFFFFFU) /*!< Bit mask for CAU_XOR_CA2_CA2. */
#define BS_CAU_XOR_CA2_CA2   (32U)         /*!< Bit field size in bits for CAU_XOR_CA2_CA2. */

/*! @brief Format value for bitfield CAU_XOR_CA2_CA2. */
#define BF_CAU_XOR_CA2_CA2(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CA2_CA2) & BM_CAU_XOR_CA2_CA2)
/*@}*/

/*******************************************************************************
 * HW_CAU_XOR_CA3 - General Purpose Register 3 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief HW_CAU_XOR_CA3 - General Purpose Register 3 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_xor_ca3
{
    uint32_t U;
    struct _hw_cau_xor_ca3_bitfields
    {
        uint32_t CA3 : 32;             /*!< [31:0] CA3 */
    } B;
} hw_cau_xor_ca3_t;

/*!
 * @name Constants and macros for entire CAU_XOR_CA3 register
 */
/*@{*/
#define HW_CAU_XOR_CA3_ADDR(x)   ((uint32_t)(x) + 0x994U)

#define HW_CAU_XOR_CA3(x)        (*(__O hw_cau_xor_ca3_t *) HW_CAU_XOR_CA3_ADDR(x))
#define HW_CAU_XOR_CA3_WR(x, v)  (HW_CAU_XOR_CA3(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CA3 bitfields
 */

/*!
 * @name Register CAU_XOR_CA3, field CA3[31:0] (WO)
 */
/*@{*/
#define BP_CAU_XOR_CA3_CA3   (0U)          /*!< Bit position for CAU_XOR_CA3_CA3. */
#define BM_CAU_XOR_CA3_CA3   (0xFFFFFFFFU) /*!< Bit mask for CAU_XOR_CA3_CA3. */
#define BS_CAU_XOR_CA3_CA3   (32U)         /*!< Bit field size in bits for CAU_XOR_CA3_CA3. */

/*! @brief Format value for bitfield CAU_XOR_CA3_CA3. */
#define BF_CAU_XOR_CA3_CA3(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CA3_CA3) & BM_CAU_XOR_CA3_CA3)
/*@}*/

/*******************************************************************************
 * HW_CAU_XOR_CA4 - General Purpose Register 4 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief HW_CAU_XOR_CA4 - General Purpose Register 4 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_xor_ca4
{
    uint32_t U;
    struct _hw_cau_xor_ca4_bitfields
    {
        uint32_t CA4 : 32;             /*!< [31:0] CA4 */
    } B;
} hw_cau_xor_ca4_t;

/*!
 * @name Constants and macros for entire CAU_XOR_CA4 register
 */
/*@{*/
#define HW_CAU_XOR_CA4_ADDR(x)   ((uint32_t)(x) + 0x998U)

#define HW_CAU_XOR_CA4(x)        (*(__O hw_cau_xor_ca4_t *) HW_CAU_XOR_CA4_ADDR(x))
#define HW_CAU_XOR_CA4_WR(x, v)  (HW_CAU_XOR_CA4(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CA4 bitfields
 */

/*!
 * @name Register CAU_XOR_CA4, field CA4[31:0] (WO)
 */
/*@{*/
#define BP_CAU_XOR_CA4_CA4   (0U)          /*!< Bit position for CAU_XOR_CA4_CA4. */
#define BM_CAU_XOR_CA4_CA4   (0xFFFFFFFFU) /*!< Bit mask for CAU_XOR_CA4_CA4. */
#define BS_CAU_XOR_CA4_CA4   (32U)         /*!< Bit field size in bits for CAU_XOR_CA4_CA4. */

/*! @brief Format value for bitfield CAU_XOR_CA4_CA4. */
#define BF_CAU_XOR_CA4_CA4(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CA4_CA4) & BM_CAU_XOR_CA4_CA4)
/*@}*/

/*******************************************************************************
 * HW_CAU_XOR_CA5 - General Purpose Register 5 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief HW_CAU_XOR_CA5 - General Purpose Register 5 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_xor_ca5
{
    uint32_t U;
    struct _hw_cau_xor_ca5_bitfields
    {
        uint32_t CA5 : 32;             /*!< [31:0] CA5 */
    } B;
} hw_cau_xor_ca5_t;

/*!
 * @name Constants and macros for entire CAU_XOR_CA5 register
 */
/*@{*/
#define HW_CAU_XOR_CA5_ADDR(x)   ((uint32_t)(x) + 0x99CU)

#define HW_CAU_XOR_CA5(x)        (*(__O hw_cau_xor_ca5_t *) HW_CAU_XOR_CA5_ADDR(x))
#define HW_CAU_XOR_CA5_WR(x, v)  (HW_CAU_XOR_CA5(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CA5 bitfields
 */

/*!
 * @name Register CAU_XOR_CA5, field CA5[31:0] (WO)
 */
/*@{*/
#define BP_CAU_XOR_CA5_CA5   (0U)          /*!< Bit position for CAU_XOR_CA5_CA5. */
#define BM_CAU_XOR_CA5_CA5   (0xFFFFFFFFU) /*!< Bit mask for CAU_XOR_CA5_CA5. */
#define BS_CAU_XOR_CA5_CA5   (32U)         /*!< Bit field size in bits for CAU_XOR_CA5_CA5. */

/*! @brief Format value for bitfield CAU_XOR_CA5_CA5. */
#define BF_CAU_XOR_CA5_CA5(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CA5_CA5) & BM_CAU_XOR_CA5_CA5)
/*@}*/

/*******************************************************************************
 * HW_CAU_XOR_CA6 - General Purpose Register 6 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief HW_CAU_XOR_CA6 - General Purpose Register 6 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_xor_ca6
{
    uint32_t U;
    struct _hw_cau_xor_ca6_bitfields
    {
        uint32_t CA6 : 32;             /*!< [31:0] CA6 */
    } B;
} hw_cau_xor_ca6_t;

/*!
 * @name Constants and macros for entire CAU_XOR_CA6 register
 */
/*@{*/
#define HW_CAU_XOR_CA6_ADDR(x)   ((uint32_t)(x) + 0x9A0U)

#define HW_CAU_XOR_CA6(x)        (*(__O hw_cau_xor_ca6_t *) HW_CAU_XOR_CA6_ADDR(x))
#define HW_CAU_XOR_CA6_WR(x, v)  (HW_CAU_XOR_CA6(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CA6 bitfields
 */

/*!
 * @name Register CAU_XOR_CA6, field CA6[31:0] (WO)
 */
/*@{*/
#define BP_CAU_XOR_CA6_CA6   (0U)          /*!< Bit position for CAU_XOR_CA6_CA6. */
#define BM_CAU_XOR_CA6_CA6   (0xFFFFFFFFU) /*!< Bit mask for CAU_XOR_CA6_CA6. */
#define BS_CAU_XOR_CA6_CA6   (32U)         /*!< Bit field size in bits for CAU_XOR_CA6_CA6. */

/*! @brief Format value for bitfield CAU_XOR_CA6_CA6. */
#define BF_CAU_XOR_CA6_CA6(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CA6_CA6) & BM_CAU_XOR_CA6_CA6)
/*@}*/

/*******************************************************************************
 * HW_CAU_XOR_CA7 - General Purpose Register 7 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief HW_CAU_XOR_CA7 - General Purpose Register 7 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_xor_ca7
{
    uint32_t U;
    struct _hw_cau_xor_ca7_bitfields
    {
        uint32_t CA7 : 32;             /*!< [31:0] CA7 */
    } B;
} hw_cau_xor_ca7_t;

/*!
 * @name Constants and macros for entire CAU_XOR_CA7 register
 */
/*@{*/
#define HW_CAU_XOR_CA7_ADDR(x)   ((uint32_t)(x) + 0x9A4U)

#define HW_CAU_XOR_CA7(x)        (*(__O hw_cau_xor_ca7_t *) HW_CAU_XOR_CA7_ADDR(x))
#define HW_CAU_XOR_CA7_WR(x, v)  (HW_CAU_XOR_CA7(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CA7 bitfields
 */

/*!
 * @name Register CAU_XOR_CA7, field CA7[31:0] (WO)
 */
/*@{*/
#define BP_CAU_XOR_CA7_CA7   (0U)          /*!< Bit position for CAU_XOR_CA7_CA7. */
#define BM_CAU_XOR_CA7_CA7   (0xFFFFFFFFU) /*!< Bit mask for CAU_XOR_CA7_CA7. */
#define BS_CAU_XOR_CA7_CA7   (32U)         /*!< Bit field size in bits for CAU_XOR_CA7_CA7. */

/*! @brief Format value for bitfield CAU_XOR_CA7_CA7. */
#define BF_CAU_XOR_CA7_CA7(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CA7_CA7) & BM_CAU_XOR_CA7_CA7)
/*@}*/

/*******************************************************************************
 * HW_CAU_XOR_CA8 - General Purpose Register 8 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief HW_CAU_XOR_CA8 - General Purpose Register 8 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_xor_ca8
{
    uint32_t U;
    struct _hw_cau_xor_ca8_bitfields
    {
        uint32_t CA8 : 32;             /*!< [31:0] CA8 */
    } B;
} hw_cau_xor_ca8_t;

/*!
 * @name Constants and macros for entire CAU_XOR_CA8 register
 */
/*@{*/
#define HW_CAU_XOR_CA8_ADDR(x)   ((uint32_t)(x) + 0x9A8U)

#define HW_CAU_XOR_CA8(x)        (*(__O hw_cau_xor_ca8_t *) HW_CAU_XOR_CA8_ADDR(x))
#define HW_CAU_XOR_CA8_WR(x, v)  (HW_CAU_XOR_CA8(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CA8 bitfields
 */

/*!
 * @name Register CAU_XOR_CA8, field CA8[31:0] (WO)
 */
/*@{*/
#define BP_CAU_XOR_CA8_CA8   (0U)          /*!< Bit position for CAU_XOR_CA8_CA8. */
#define BM_CAU_XOR_CA8_CA8   (0xFFFFFFFFU) /*!< Bit mask for CAU_XOR_CA8_CA8. */
#define BS_CAU_XOR_CA8_CA8   (32U)         /*!< Bit field size in bits for CAU_XOR_CA8_CA8. */

/*! @brief Format value for bitfield CAU_XOR_CA8_CA8. */
#define BF_CAU_XOR_CA8_CA8(v) ((uint32_t)((uint32_t)(v) << BP_CAU_XOR_CA8_CA8) & BM_CAU_XOR_CA8_CA8)
/*@}*/

/*******************************************************************************
 * HW_CAU_ROTL_CASR - Status register  - Rotate Left command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ROTL_CASR - Status register  - Rotate Left command (WO)
 *
 * Reset value: 0x20000000U
 */
typedef union _hw_cau_rotl_casr
{
    uint32_t U;
    struct _hw_cau_rotl_casr_bitfields
    {
        uint32_t IC : 1;               /*!< [0]  */
        uint32_t DPE : 1;              /*!< [1]  */
        uint32_t RESERVED0 : 26;       /*!< [27:2]  */
        uint32_t VER : 4;              /*!< [31:28] CAU version */
    } B;
} hw_cau_rotl_casr_t;

/*!
 * @name Constants and macros for entire CAU_ROTL_CASR register
 */
/*@{*/
#define HW_CAU_ROTL_CASR_ADDR(x) ((uint32_t)(x) + 0x9C0U)

#define HW_CAU_ROTL_CASR(x)      (*(__O hw_cau_rotl_casr_t *) HW_CAU_ROTL_CASR_ADDR(x))
#define HW_CAU_ROTL_CASR_WR(x, v) (HW_CAU_ROTL_CASR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CASR bitfields
 */

/*!
 * @name Register CAU_ROTL_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0 - No illegal commands issued
 * - 1 - Illegal command issued
 */
/*@{*/
#define BP_CAU_ROTL_CASR_IC  (0U)          /*!< Bit position for CAU_ROTL_CASR_IC. */
#define BM_CAU_ROTL_CASR_IC  (0x00000001U) /*!< Bit mask for CAU_ROTL_CASR_IC. */
#define BS_CAU_ROTL_CASR_IC  (1U)          /*!< Bit field size in bits for CAU_ROTL_CASR_IC. */

/*! @brief Format value for bitfield CAU_ROTL_CASR_IC. */
#define BF_CAU_ROTL_CASR_IC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CASR_IC) & BM_CAU_ROTL_CASR_IC)
/*@}*/

/*!
 * @name Register CAU_ROTL_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0 - No error detected
 * - 1 - DES key parity error detected
 */
/*@{*/
#define BP_CAU_ROTL_CASR_DPE (1U)          /*!< Bit position for CAU_ROTL_CASR_DPE. */
#define BM_CAU_ROTL_CASR_DPE (0x00000002U) /*!< Bit mask for CAU_ROTL_CASR_DPE. */
#define BS_CAU_ROTL_CASR_DPE (1U)          /*!< Bit field size in bits for CAU_ROTL_CASR_DPE. */

/*! @brief Format value for bitfield CAU_ROTL_CASR_DPE. */
#define BF_CAU_ROTL_CASR_DPE(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CASR_DPE) & BM_CAU_ROTL_CASR_DPE)
/*@}*/

/*!
 * @name Register CAU_ROTL_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0001 - Initial CAU version
 * - 0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
#define BP_CAU_ROTL_CASR_VER (28U)         /*!< Bit position for CAU_ROTL_CASR_VER. */
#define BM_CAU_ROTL_CASR_VER (0xF0000000U) /*!< Bit mask for CAU_ROTL_CASR_VER. */
#define BS_CAU_ROTL_CASR_VER (4U)          /*!< Bit field size in bits for CAU_ROTL_CASR_VER. */

/*! @brief Format value for bitfield CAU_ROTL_CASR_VER. */
#define BF_CAU_ROTL_CASR_VER(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CASR_VER) & BM_CAU_ROTL_CASR_VER)
/*@}*/

/*******************************************************************************
 * HW_CAU_ROTL_CAA - Accumulator register - Rotate Left command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ROTL_CAA - Accumulator register - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_rotl_caa
{
    uint32_t U;
    struct _hw_cau_rotl_caa_bitfields
    {
        uint32_t ACC : 32;             /*!< [31:0] ACC */
    } B;
} hw_cau_rotl_caa_t;

/*!
 * @name Constants and macros for entire CAU_ROTL_CAA register
 */
/*@{*/
#define HW_CAU_ROTL_CAA_ADDR(x)  ((uint32_t)(x) + 0x9C4U)

#define HW_CAU_ROTL_CAA(x)       (*(__O hw_cau_rotl_caa_t *) HW_CAU_ROTL_CAA_ADDR(x))
#define HW_CAU_ROTL_CAA_WR(x, v) (HW_CAU_ROTL_CAA(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CAA bitfields
 */

/*!
 * @name Register CAU_ROTL_CAA, field ACC[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ROTL_CAA_ACC  (0U)          /*!< Bit position for CAU_ROTL_CAA_ACC. */
#define BM_CAU_ROTL_CAA_ACC  (0xFFFFFFFFU) /*!< Bit mask for CAU_ROTL_CAA_ACC. */
#define BS_CAU_ROTL_CAA_ACC  (32U)         /*!< Bit field size in bits for CAU_ROTL_CAA_ACC. */

/*! @brief Format value for bitfield CAU_ROTL_CAA_ACC. */
#define BF_CAU_ROTL_CAA_ACC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CAA_ACC) & BM_CAU_ROTL_CAA_ACC)
/*@}*/

/*******************************************************************************
 * HW_CAU_ROTL_CA0 - General Purpose Register 0 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ROTL_CA0 - General Purpose Register 0 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_rotl_ca0
{
    uint32_t U;
    struct _hw_cau_rotl_ca0_bitfields
    {
        uint32_t CA0 : 32;             /*!< [31:0] CA0 */
    } B;
} hw_cau_rotl_ca0_t;

/*!
 * @name Constants and macros for entire CAU_ROTL_CA0 register
 */
/*@{*/
#define HW_CAU_ROTL_CA0_ADDR(x)  ((uint32_t)(x) + 0x9C8U)

#define HW_CAU_ROTL_CA0(x)       (*(__O hw_cau_rotl_ca0_t *) HW_CAU_ROTL_CA0_ADDR(x))
#define HW_CAU_ROTL_CA0_WR(x, v) (HW_CAU_ROTL_CA0(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CA0 bitfields
 */

/*!
 * @name Register CAU_ROTL_CA0, field CA0[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ROTL_CA0_CA0  (0U)          /*!< Bit position for CAU_ROTL_CA0_CA0. */
#define BM_CAU_ROTL_CA0_CA0  (0xFFFFFFFFU) /*!< Bit mask for CAU_ROTL_CA0_CA0. */
#define BS_CAU_ROTL_CA0_CA0  (32U)         /*!< Bit field size in bits for CAU_ROTL_CA0_CA0. */

/*! @brief Format value for bitfield CAU_ROTL_CA0_CA0. */
#define BF_CAU_ROTL_CA0_CA0(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CA0_CA0) & BM_CAU_ROTL_CA0_CA0)
/*@}*/

/*******************************************************************************
 * HW_CAU_ROTL_CA1 - General Purpose Register 1 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ROTL_CA1 - General Purpose Register 1 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_rotl_ca1
{
    uint32_t U;
    struct _hw_cau_rotl_ca1_bitfields
    {
        uint32_t CA1 : 32;             /*!< [31:0] CA1 */
    } B;
} hw_cau_rotl_ca1_t;

/*!
 * @name Constants and macros for entire CAU_ROTL_CA1 register
 */
/*@{*/
#define HW_CAU_ROTL_CA1_ADDR(x)  ((uint32_t)(x) + 0x9CCU)

#define HW_CAU_ROTL_CA1(x)       (*(__O hw_cau_rotl_ca1_t *) HW_CAU_ROTL_CA1_ADDR(x))
#define HW_CAU_ROTL_CA1_WR(x, v) (HW_CAU_ROTL_CA1(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CA1 bitfields
 */

/*!
 * @name Register CAU_ROTL_CA1, field CA1[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ROTL_CA1_CA1  (0U)          /*!< Bit position for CAU_ROTL_CA1_CA1. */
#define BM_CAU_ROTL_CA1_CA1  (0xFFFFFFFFU) /*!< Bit mask for CAU_ROTL_CA1_CA1. */
#define BS_CAU_ROTL_CA1_CA1  (32U)         /*!< Bit field size in bits for CAU_ROTL_CA1_CA1. */

/*! @brief Format value for bitfield CAU_ROTL_CA1_CA1. */
#define BF_CAU_ROTL_CA1_CA1(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CA1_CA1) & BM_CAU_ROTL_CA1_CA1)
/*@}*/

/*******************************************************************************
 * HW_CAU_ROTL_CA2 - General Purpose Register 2 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ROTL_CA2 - General Purpose Register 2 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_rotl_ca2
{
    uint32_t U;
    struct _hw_cau_rotl_ca2_bitfields
    {
        uint32_t CA2 : 32;             /*!< [31:0] CA2 */
    } B;
} hw_cau_rotl_ca2_t;

/*!
 * @name Constants and macros for entire CAU_ROTL_CA2 register
 */
/*@{*/
#define HW_CAU_ROTL_CA2_ADDR(x)  ((uint32_t)(x) + 0x9D0U)

#define HW_CAU_ROTL_CA2(x)       (*(__O hw_cau_rotl_ca2_t *) HW_CAU_ROTL_CA2_ADDR(x))
#define HW_CAU_ROTL_CA2_WR(x, v) (HW_CAU_ROTL_CA2(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CA2 bitfields
 */

/*!
 * @name Register CAU_ROTL_CA2, field CA2[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ROTL_CA2_CA2  (0U)          /*!< Bit position for CAU_ROTL_CA2_CA2. */
#define BM_CAU_ROTL_CA2_CA2  (0xFFFFFFFFU) /*!< Bit mask for CAU_ROTL_CA2_CA2. */
#define BS_CAU_ROTL_CA2_CA2  (32U)         /*!< Bit field size in bits for CAU_ROTL_CA2_CA2. */

/*! @brief Format value for bitfield CAU_ROTL_CA2_CA2. */
#define BF_CAU_ROTL_CA2_CA2(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CA2_CA2) & BM_CAU_ROTL_CA2_CA2)
/*@}*/

/*******************************************************************************
 * HW_CAU_ROTL_CA3 - General Purpose Register 3 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ROTL_CA3 - General Purpose Register 3 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_rotl_ca3
{
    uint32_t U;
    struct _hw_cau_rotl_ca3_bitfields
    {
        uint32_t CA3 : 32;             /*!< [31:0] CA3 */
    } B;
} hw_cau_rotl_ca3_t;

/*!
 * @name Constants and macros for entire CAU_ROTL_CA3 register
 */
/*@{*/
#define HW_CAU_ROTL_CA3_ADDR(x)  ((uint32_t)(x) + 0x9D4U)

#define HW_CAU_ROTL_CA3(x)       (*(__O hw_cau_rotl_ca3_t *) HW_CAU_ROTL_CA3_ADDR(x))
#define HW_CAU_ROTL_CA3_WR(x, v) (HW_CAU_ROTL_CA3(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CA3 bitfields
 */

/*!
 * @name Register CAU_ROTL_CA3, field CA3[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ROTL_CA3_CA3  (0U)          /*!< Bit position for CAU_ROTL_CA3_CA3. */
#define BM_CAU_ROTL_CA3_CA3  (0xFFFFFFFFU) /*!< Bit mask for CAU_ROTL_CA3_CA3. */
#define BS_CAU_ROTL_CA3_CA3  (32U)         /*!< Bit field size in bits for CAU_ROTL_CA3_CA3. */

/*! @brief Format value for bitfield CAU_ROTL_CA3_CA3. */
#define BF_CAU_ROTL_CA3_CA3(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CA3_CA3) & BM_CAU_ROTL_CA3_CA3)
/*@}*/

/*******************************************************************************
 * HW_CAU_ROTL_CA4 - General Purpose Register 4 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ROTL_CA4 - General Purpose Register 4 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_rotl_ca4
{
    uint32_t U;
    struct _hw_cau_rotl_ca4_bitfields
    {
        uint32_t CA4 : 32;             /*!< [31:0] CA4 */
    } B;
} hw_cau_rotl_ca4_t;

/*!
 * @name Constants and macros for entire CAU_ROTL_CA4 register
 */
/*@{*/
#define HW_CAU_ROTL_CA4_ADDR(x)  ((uint32_t)(x) + 0x9D8U)

#define HW_CAU_ROTL_CA4(x)       (*(__O hw_cau_rotl_ca4_t *) HW_CAU_ROTL_CA4_ADDR(x))
#define HW_CAU_ROTL_CA4_WR(x, v) (HW_CAU_ROTL_CA4(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CA4 bitfields
 */

/*!
 * @name Register CAU_ROTL_CA4, field CA4[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ROTL_CA4_CA4  (0U)          /*!< Bit position for CAU_ROTL_CA4_CA4. */
#define BM_CAU_ROTL_CA4_CA4  (0xFFFFFFFFU) /*!< Bit mask for CAU_ROTL_CA4_CA4. */
#define BS_CAU_ROTL_CA4_CA4  (32U)         /*!< Bit field size in bits for CAU_ROTL_CA4_CA4. */

/*! @brief Format value for bitfield CAU_ROTL_CA4_CA4. */
#define BF_CAU_ROTL_CA4_CA4(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CA4_CA4) & BM_CAU_ROTL_CA4_CA4)
/*@}*/

/*******************************************************************************
 * HW_CAU_ROTL_CA5 - General Purpose Register 5 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ROTL_CA5 - General Purpose Register 5 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_rotl_ca5
{
    uint32_t U;
    struct _hw_cau_rotl_ca5_bitfields
    {
        uint32_t CA5 : 32;             /*!< [31:0] CA5 */
    } B;
} hw_cau_rotl_ca5_t;

/*!
 * @name Constants and macros for entire CAU_ROTL_CA5 register
 */
/*@{*/
#define HW_CAU_ROTL_CA5_ADDR(x)  ((uint32_t)(x) + 0x9DCU)

#define HW_CAU_ROTL_CA5(x)       (*(__O hw_cau_rotl_ca5_t *) HW_CAU_ROTL_CA5_ADDR(x))
#define HW_CAU_ROTL_CA5_WR(x, v) (HW_CAU_ROTL_CA5(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CA5 bitfields
 */

/*!
 * @name Register CAU_ROTL_CA5, field CA5[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ROTL_CA5_CA5  (0U)          /*!< Bit position for CAU_ROTL_CA5_CA5. */
#define BM_CAU_ROTL_CA5_CA5  (0xFFFFFFFFU) /*!< Bit mask for CAU_ROTL_CA5_CA5. */
#define BS_CAU_ROTL_CA5_CA5  (32U)         /*!< Bit field size in bits for CAU_ROTL_CA5_CA5. */

/*! @brief Format value for bitfield CAU_ROTL_CA5_CA5. */
#define BF_CAU_ROTL_CA5_CA5(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CA5_CA5) & BM_CAU_ROTL_CA5_CA5)
/*@}*/

/*******************************************************************************
 * HW_CAU_ROTL_CA6 - General Purpose Register 6 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ROTL_CA6 - General Purpose Register 6 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_rotl_ca6
{
    uint32_t U;
    struct _hw_cau_rotl_ca6_bitfields
    {
        uint32_t CA6 : 32;             /*!< [31:0] CA6 */
    } B;
} hw_cau_rotl_ca6_t;

/*!
 * @name Constants and macros for entire CAU_ROTL_CA6 register
 */
/*@{*/
#define HW_CAU_ROTL_CA6_ADDR(x)  ((uint32_t)(x) + 0x9E0U)

#define HW_CAU_ROTL_CA6(x)       (*(__O hw_cau_rotl_ca6_t *) HW_CAU_ROTL_CA6_ADDR(x))
#define HW_CAU_ROTL_CA6_WR(x, v) (HW_CAU_ROTL_CA6(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CA6 bitfields
 */

/*!
 * @name Register CAU_ROTL_CA6, field CA6[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ROTL_CA6_CA6  (0U)          /*!< Bit position for CAU_ROTL_CA6_CA6. */
#define BM_CAU_ROTL_CA6_CA6  (0xFFFFFFFFU) /*!< Bit mask for CAU_ROTL_CA6_CA6. */
#define BS_CAU_ROTL_CA6_CA6  (32U)         /*!< Bit field size in bits for CAU_ROTL_CA6_CA6. */

/*! @brief Format value for bitfield CAU_ROTL_CA6_CA6. */
#define BF_CAU_ROTL_CA6_CA6(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CA6_CA6) & BM_CAU_ROTL_CA6_CA6)
/*@}*/

/*******************************************************************************
 * HW_CAU_ROTL_CA7 - General Purpose Register 7 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ROTL_CA7 - General Purpose Register 7 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_rotl_ca7
{
    uint32_t U;
    struct _hw_cau_rotl_ca7_bitfields
    {
        uint32_t CA7 : 32;             /*!< [31:0] CA7 */
    } B;
} hw_cau_rotl_ca7_t;

/*!
 * @name Constants and macros for entire CAU_ROTL_CA7 register
 */
/*@{*/
#define HW_CAU_ROTL_CA7_ADDR(x)  ((uint32_t)(x) + 0x9E4U)

#define HW_CAU_ROTL_CA7(x)       (*(__O hw_cau_rotl_ca7_t *) HW_CAU_ROTL_CA7_ADDR(x))
#define HW_CAU_ROTL_CA7_WR(x, v) (HW_CAU_ROTL_CA7(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CA7 bitfields
 */

/*!
 * @name Register CAU_ROTL_CA7, field CA7[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ROTL_CA7_CA7  (0U)          /*!< Bit position for CAU_ROTL_CA7_CA7. */
#define BM_CAU_ROTL_CA7_CA7  (0xFFFFFFFFU) /*!< Bit mask for CAU_ROTL_CA7_CA7. */
#define BS_CAU_ROTL_CA7_CA7  (32U)         /*!< Bit field size in bits for CAU_ROTL_CA7_CA7. */

/*! @brief Format value for bitfield CAU_ROTL_CA7_CA7. */
#define BF_CAU_ROTL_CA7_CA7(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CA7_CA7) & BM_CAU_ROTL_CA7_CA7)
/*@}*/

/*******************************************************************************
 * HW_CAU_ROTL_CA8 - General Purpose Register 8 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief HW_CAU_ROTL_CA8 - General Purpose Register 8 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_rotl_ca8
{
    uint32_t U;
    struct _hw_cau_rotl_ca8_bitfields
    {
        uint32_t CA8 : 32;             /*!< [31:0] CA8 */
    } B;
} hw_cau_rotl_ca8_t;

/*!
 * @name Constants and macros for entire CAU_ROTL_CA8 register
 */
/*@{*/
#define HW_CAU_ROTL_CA8_ADDR(x)  ((uint32_t)(x) + 0x9E8U)

#define HW_CAU_ROTL_CA8(x)       (*(__O hw_cau_rotl_ca8_t *) HW_CAU_ROTL_CA8_ADDR(x))
#define HW_CAU_ROTL_CA8_WR(x, v) (HW_CAU_ROTL_CA8(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CA8 bitfields
 */

/*!
 * @name Register CAU_ROTL_CA8, field CA8[31:0] (WO)
 */
/*@{*/
#define BP_CAU_ROTL_CA8_CA8  (0U)          /*!< Bit position for CAU_ROTL_CA8_CA8. */
#define BM_CAU_ROTL_CA8_CA8  (0xFFFFFFFFU) /*!< Bit mask for CAU_ROTL_CA8_CA8. */
#define BS_CAU_ROTL_CA8_CA8  (32U)         /*!< Bit field size in bits for CAU_ROTL_CA8_CA8. */

/*! @brief Format value for bitfield CAU_ROTL_CA8_CA8. */
#define BF_CAU_ROTL_CA8_CA8(v) ((uint32_t)((uint32_t)(v) << BP_CAU_ROTL_CA8_CA8) & BM_CAU_ROTL_CA8_CA8)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESC_CASR - Status register  - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESC_CASR - Status register  - AES Column Operation command (WO)
 *
 * Reset value: 0x20000000U
 */
typedef union _hw_cau_aesc_casr
{
    uint32_t U;
    struct _hw_cau_aesc_casr_bitfields
    {
        uint32_t IC : 1;               /*!< [0]  */
        uint32_t DPE : 1;              /*!< [1]  */
        uint32_t RESERVED0 : 26;       /*!< [27:2]  */
        uint32_t VER : 4;              /*!< [31:28] CAU version */
    } B;
} hw_cau_aesc_casr_t;

/*!
 * @name Constants and macros for entire CAU_AESC_CASR register
 */
/*@{*/
#define HW_CAU_AESC_CASR_ADDR(x) ((uint32_t)(x) + 0xB00U)

#define HW_CAU_AESC_CASR(x)      (*(__O hw_cau_aesc_casr_t *) HW_CAU_AESC_CASR_ADDR(x))
#define HW_CAU_AESC_CASR_WR(x, v) (HW_CAU_AESC_CASR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CASR bitfields
 */

/*!
 * @name Register CAU_AESC_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0 - No illegal commands issued
 * - 1 - Illegal command issued
 */
/*@{*/
#define BP_CAU_AESC_CASR_IC  (0U)          /*!< Bit position for CAU_AESC_CASR_IC. */
#define BM_CAU_AESC_CASR_IC  (0x00000001U) /*!< Bit mask for CAU_AESC_CASR_IC. */
#define BS_CAU_AESC_CASR_IC  (1U)          /*!< Bit field size in bits for CAU_AESC_CASR_IC. */

/*! @brief Format value for bitfield CAU_AESC_CASR_IC. */
#define BF_CAU_AESC_CASR_IC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CASR_IC) & BM_CAU_AESC_CASR_IC)
/*@}*/

/*!
 * @name Register CAU_AESC_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0 - No error detected
 * - 1 - DES key parity error detected
 */
/*@{*/
#define BP_CAU_AESC_CASR_DPE (1U)          /*!< Bit position for CAU_AESC_CASR_DPE. */
#define BM_CAU_AESC_CASR_DPE (0x00000002U) /*!< Bit mask for CAU_AESC_CASR_DPE. */
#define BS_CAU_AESC_CASR_DPE (1U)          /*!< Bit field size in bits for CAU_AESC_CASR_DPE. */

/*! @brief Format value for bitfield CAU_AESC_CASR_DPE. */
#define BF_CAU_AESC_CASR_DPE(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CASR_DPE) & BM_CAU_AESC_CASR_DPE)
/*@}*/

/*!
 * @name Register CAU_AESC_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0001 - Initial CAU version
 * - 0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
#define BP_CAU_AESC_CASR_VER (28U)         /*!< Bit position for CAU_AESC_CASR_VER. */
#define BM_CAU_AESC_CASR_VER (0xF0000000U) /*!< Bit mask for CAU_AESC_CASR_VER. */
#define BS_CAU_AESC_CASR_VER (4U)          /*!< Bit field size in bits for CAU_AESC_CASR_VER. */

/*! @brief Format value for bitfield CAU_AESC_CASR_VER. */
#define BF_CAU_AESC_CASR_VER(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CASR_VER) & BM_CAU_AESC_CASR_VER)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESC_CAA - Accumulator register - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESC_CAA - Accumulator register - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesc_caa
{
    uint32_t U;
    struct _hw_cau_aesc_caa_bitfields
    {
        uint32_t ACC : 32;             /*!< [31:0] ACC */
    } B;
} hw_cau_aesc_caa_t;

/*!
 * @name Constants and macros for entire CAU_AESC_CAA register
 */
/*@{*/
#define HW_CAU_AESC_CAA_ADDR(x)  ((uint32_t)(x) + 0xB04U)

#define HW_CAU_AESC_CAA(x)       (*(__O hw_cau_aesc_caa_t *) HW_CAU_AESC_CAA_ADDR(x))
#define HW_CAU_AESC_CAA_WR(x, v) (HW_CAU_AESC_CAA(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CAA bitfields
 */

/*!
 * @name Register CAU_AESC_CAA, field ACC[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESC_CAA_ACC  (0U)          /*!< Bit position for CAU_AESC_CAA_ACC. */
#define BM_CAU_AESC_CAA_ACC  (0xFFFFFFFFU) /*!< Bit mask for CAU_AESC_CAA_ACC. */
#define BS_CAU_AESC_CAA_ACC  (32U)         /*!< Bit field size in bits for CAU_AESC_CAA_ACC. */

/*! @brief Format value for bitfield CAU_AESC_CAA_ACC. */
#define BF_CAU_AESC_CAA_ACC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CAA_ACC) & BM_CAU_AESC_CAA_ACC)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESC_CA0 - General Purpose Register 0 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESC_CA0 - General Purpose Register 0 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesc_ca0
{
    uint32_t U;
    struct _hw_cau_aesc_ca0_bitfields
    {
        uint32_t CA0 : 32;             /*!< [31:0] CA0 */
    } B;
} hw_cau_aesc_ca0_t;

/*!
 * @name Constants and macros for entire CAU_AESC_CA0 register
 */
/*@{*/
#define HW_CAU_AESC_CA0_ADDR(x)  ((uint32_t)(x) + 0xB08U)

#define HW_CAU_AESC_CA0(x)       (*(__O hw_cau_aesc_ca0_t *) HW_CAU_AESC_CA0_ADDR(x))
#define HW_CAU_AESC_CA0_WR(x, v) (HW_CAU_AESC_CA0(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CA0 bitfields
 */

/*!
 * @name Register CAU_AESC_CA0, field CA0[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESC_CA0_CA0  (0U)          /*!< Bit position for CAU_AESC_CA0_CA0. */
#define BM_CAU_AESC_CA0_CA0  (0xFFFFFFFFU) /*!< Bit mask for CAU_AESC_CA0_CA0. */
#define BS_CAU_AESC_CA0_CA0  (32U)         /*!< Bit field size in bits for CAU_AESC_CA0_CA0. */

/*! @brief Format value for bitfield CAU_AESC_CA0_CA0. */
#define BF_CAU_AESC_CA0_CA0(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CA0_CA0) & BM_CAU_AESC_CA0_CA0)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESC_CA1 - General Purpose Register 1 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESC_CA1 - General Purpose Register 1 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesc_ca1
{
    uint32_t U;
    struct _hw_cau_aesc_ca1_bitfields
    {
        uint32_t CA1 : 32;             /*!< [31:0] CA1 */
    } B;
} hw_cau_aesc_ca1_t;

/*!
 * @name Constants and macros for entire CAU_AESC_CA1 register
 */
/*@{*/
#define HW_CAU_AESC_CA1_ADDR(x)  ((uint32_t)(x) + 0xB0CU)

#define HW_CAU_AESC_CA1(x)       (*(__O hw_cau_aesc_ca1_t *) HW_CAU_AESC_CA1_ADDR(x))
#define HW_CAU_AESC_CA1_WR(x, v) (HW_CAU_AESC_CA1(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CA1 bitfields
 */

/*!
 * @name Register CAU_AESC_CA1, field CA1[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESC_CA1_CA1  (0U)          /*!< Bit position for CAU_AESC_CA1_CA1. */
#define BM_CAU_AESC_CA1_CA1  (0xFFFFFFFFU) /*!< Bit mask for CAU_AESC_CA1_CA1. */
#define BS_CAU_AESC_CA1_CA1  (32U)         /*!< Bit field size in bits for CAU_AESC_CA1_CA1. */

/*! @brief Format value for bitfield CAU_AESC_CA1_CA1. */
#define BF_CAU_AESC_CA1_CA1(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CA1_CA1) & BM_CAU_AESC_CA1_CA1)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESC_CA2 - General Purpose Register 2 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESC_CA2 - General Purpose Register 2 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesc_ca2
{
    uint32_t U;
    struct _hw_cau_aesc_ca2_bitfields
    {
        uint32_t CA2 : 32;             /*!< [31:0] CA2 */
    } B;
} hw_cau_aesc_ca2_t;

/*!
 * @name Constants and macros for entire CAU_AESC_CA2 register
 */
/*@{*/
#define HW_CAU_AESC_CA2_ADDR(x)  ((uint32_t)(x) + 0xB10U)

#define HW_CAU_AESC_CA2(x)       (*(__O hw_cau_aesc_ca2_t *) HW_CAU_AESC_CA2_ADDR(x))
#define HW_CAU_AESC_CA2_WR(x, v) (HW_CAU_AESC_CA2(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CA2 bitfields
 */

/*!
 * @name Register CAU_AESC_CA2, field CA2[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESC_CA2_CA2  (0U)          /*!< Bit position for CAU_AESC_CA2_CA2. */
#define BM_CAU_AESC_CA2_CA2  (0xFFFFFFFFU) /*!< Bit mask for CAU_AESC_CA2_CA2. */
#define BS_CAU_AESC_CA2_CA2  (32U)         /*!< Bit field size in bits for CAU_AESC_CA2_CA2. */

/*! @brief Format value for bitfield CAU_AESC_CA2_CA2. */
#define BF_CAU_AESC_CA2_CA2(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CA2_CA2) & BM_CAU_AESC_CA2_CA2)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESC_CA3 - General Purpose Register 3 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESC_CA3 - General Purpose Register 3 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesc_ca3
{
    uint32_t U;
    struct _hw_cau_aesc_ca3_bitfields
    {
        uint32_t CA3 : 32;             /*!< [31:0] CA3 */
    } B;
} hw_cau_aesc_ca3_t;

/*!
 * @name Constants and macros for entire CAU_AESC_CA3 register
 */
/*@{*/
#define HW_CAU_AESC_CA3_ADDR(x)  ((uint32_t)(x) + 0xB14U)

#define HW_CAU_AESC_CA3(x)       (*(__O hw_cau_aesc_ca3_t *) HW_CAU_AESC_CA3_ADDR(x))
#define HW_CAU_AESC_CA3_WR(x, v) (HW_CAU_AESC_CA3(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CA3 bitfields
 */

/*!
 * @name Register CAU_AESC_CA3, field CA3[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESC_CA3_CA3  (0U)          /*!< Bit position for CAU_AESC_CA3_CA3. */
#define BM_CAU_AESC_CA3_CA3  (0xFFFFFFFFU) /*!< Bit mask for CAU_AESC_CA3_CA3. */
#define BS_CAU_AESC_CA3_CA3  (32U)         /*!< Bit field size in bits for CAU_AESC_CA3_CA3. */

/*! @brief Format value for bitfield CAU_AESC_CA3_CA3. */
#define BF_CAU_AESC_CA3_CA3(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CA3_CA3) & BM_CAU_AESC_CA3_CA3)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESC_CA4 - General Purpose Register 4 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESC_CA4 - General Purpose Register 4 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesc_ca4
{
    uint32_t U;
    struct _hw_cau_aesc_ca4_bitfields
    {
        uint32_t CA4 : 32;             /*!< [31:0] CA4 */
    } B;
} hw_cau_aesc_ca4_t;

/*!
 * @name Constants and macros for entire CAU_AESC_CA4 register
 */
/*@{*/
#define HW_CAU_AESC_CA4_ADDR(x)  ((uint32_t)(x) + 0xB18U)

#define HW_CAU_AESC_CA4(x)       (*(__O hw_cau_aesc_ca4_t *) HW_CAU_AESC_CA4_ADDR(x))
#define HW_CAU_AESC_CA4_WR(x, v) (HW_CAU_AESC_CA4(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CA4 bitfields
 */

/*!
 * @name Register CAU_AESC_CA4, field CA4[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESC_CA4_CA4  (0U)          /*!< Bit position for CAU_AESC_CA4_CA4. */
#define BM_CAU_AESC_CA4_CA4  (0xFFFFFFFFU) /*!< Bit mask for CAU_AESC_CA4_CA4. */
#define BS_CAU_AESC_CA4_CA4  (32U)         /*!< Bit field size in bits for CAU_AESC_CA4_CA4. */

/*! @brief Format value for bitfield CAU_AESC_CA4_CA4. */
#define BF_CAU_AESC_CA4_CA4(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CA4_CA4) & BM_CAU_AESC_CA4_CA4)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESC_CA5 - General Purpose Register 5 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESC_CA5 - General Purpose Register 5 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesc_ca5
{
    uint32_t U;
    struct _hw_cau_aesc_ca5_bitfields
    {
        uint32_t CA5 : 32;             /*!< [31:0] CA5 */
    } B;
} hw_cau_aesc_ca5_t;

/*!
 * @name Constants and macros for entire CAU_AESC_CA5 register
 */
/*@{*/
#define HW_CAU_AESC_CA5_ADDR(x)  ((uint32_t)(x) + 0xB1CU)

#define HW_CAU_AESC_CA5(x)       (*(__O hw_cau_aesc_ca5_t *) HW_CAU_AESC_CA5_ADDR(x))
#define HW_CAU_AESC_CA5_WR(x, v) (HW_CAU_AESC_CA5(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CA5 bitfields
 */

/*!
 * @name Register CAU_AESC_CA5, field CA5[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESC_CA5_CA5  (0U)          /*!< Bit position for CAU_AESC_CA5_CA5. */
#define BM_CAU_AESC_CA5_CA5  (0xFFFFFFFFU) /*!< Bit mask for CAU_AESC_CA5_CA5. */
#define BS_CAU_AESC_CA5_CA5  (32U)         /*!< Bit field size in bits for CAU_AESC_CA5_CA5. */

/*! @brief Format value for bitfield CAU_AESC_CA5_CA5. */
#define BF_CAU_AESC_CA5_CA5(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CA5_CA5) & BM_CAU_AESC_CA5_CA5)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESC_CA6 - General Purpose Register 6 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESC_CA6 - General Purpose Register 6 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesc_ca6
{
    uint32_t U;
    struct _hw_cau_aesc_ca6_bitfields
    {
        uint32_t CA6 : 32;             /*!< [31:0] CA6 */
    } B;
} hw_cau_aesc_ca6_t;

/*!
 * @name Constants and macros for entire CAU_AESC_CA6 register
 */
/*@{*/
#define HW_CAU_AESC_CA6_ADDR(x)  ((uint32_t)(x) + 0xB20U)

#define HW_CAU_AESC_CA6(x)       (*(__O hw_cau_aesc_ca6_t *) HW_CAU_AESC_CA6_ADDR(x))
#define HW_CAU_AESC_CA6_WR(x, v) (HW_CAU_AESC_CA6(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CA6 bitfields
 */

/*!
 * @name Register CAU_AESC_CA6, field CA6[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESC_CA6_CA6  (0U)          /*!< Bit position for CAU_AESC_CA6_CA6. */
#define BM_CAU_AESC_CA6_CA6  (0xFFFFFFFFU) /*!< Bit mask for CAU_AESC_CA6_CA6. */
#define BS_CAU_AESC_CA6_CA6  (32U)         /*!< Bit field size in bits for CAU_AESC_CA6_CA6. */

/*! @brief Format value for bitfield CAU_AESC_CA6_CA6. */
#define BF_CAU_AESC_CA6_CA6(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CA6_CA6) & BM_CAU_AESC_CA6_CA6)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESC_CA7 - General Purpose Register 7 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESC_CA7 - General Purpose Register 7 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesc_ca7
{
    uint32_t U;
    struct _hw_cau_aesc_ca7_bitfields
    {
        uint32_t CA7 : 32;             /*!< [31:0] CA7 */
    } B;
} hw_cau_aesc_ca7_t;

/*!
 * @name Constants and macros for entire CAU_AESC_CA7 register
 */
/*@{*/
#define HW_CAU_AESC_CA7_ADDR(x)  ((uint32_t)(x) + 0xB24U)

#define HW_CAU_AESC_CA7(x)       (*(__O hw_cau_aesc_ca7_t *) HW_CAU_AESC_CA7_ADDR(x))
#define HW_CAU_AESC_CA7_WR(x, v) (HW_CAU_AESC_CA7(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CA7 bitfields
 */

/*!
 * @name Register CAU_AESC_CA7, field CA7[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESC_CA7_CA7  (0U)          /*!< Bit position for CAU_AESC_CA7_CA7. */
#define BM_CAU_AESC_CA7_CA7  (0xFFFFFFFFU) /*!< Bit mask for CAU_AESC_CA7_CA7. */
#define BS_CAU_AESC_CA7_CA7  (32U)         /*!< Bit field size in bits for CAU_AESC_CA7_CA7. */

/*! @brief Format value for bitfield CAU_AESC_CA7_CA7. */
#define BF_CAU_AESC_CA7_CA7(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CA7_CA7) & BM_CAU_AESC_CA7_CA7)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESC_CA8 - General Purpose Register 8 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESC_CA8 - General Purpose Register 8 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesc_ca8
{
    uint32_t U;
    struct _hw_cau_aesc_ca8_bitfields
    {
        uint32_t CA8 : 32;             /*!< [31:0] CA8 */
    } B;
} hw_cau_aesc_ca8_t;

/*!
 * @name Constants and macros for entire CAU_AESC_CA8 register
 */
/*@{*/
#define HW_CAU_AESC_CA8_ADDR(x)  ((uint32_t)(x) + 0xB28U)

#define HW_CAU_AESC_CA8(x)       (*(__O hw_cau_aesc_ca8_t *) HW_CAU_AESC_CA8_ADDR(x))
#define HW_CAU_AESC_CA8_WR(x, v) (HW_CAU_AESC_CA8(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CA8 bitfields
 */

/*!
 * @name Register CAU_AESC_CA8, field CA8[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESC_CA8_CA8  (0U)          /*!< Bit position for CAU_AESC_CA8_CA8. */
#define BM_CAU_AESC_CA8_CA8  (0xFFFFFFFFU) /*!< Bit mask for CAU_AESC_CA8_CA8. */
#define BS_CAU_AESC_CA8_CA8  (32U)         /*!< Bit field size in bits for CAU_AESC_CA8_CA8. */

/*! @brief Format value for bitfield CAU_AESC_CA8_CA8. */
#define BF_CAU_AESC_CA8_CA8(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESC_CA8_CA8) & BM_CAU_AESC_CA8_CA8)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESIC_CASR - Status register  - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESIC_CASR - Status register  - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x20000000U
 */
typedef union _hw_cau_aesic_casr
{
    uint32_t U;
    struct _hw_cau_aesic_casr_bitfields
    {
        uint32_t IC : 1;               /*!< [0]  */
        uint32_t DPE : 1;              /*!< [1]  */
        uint32_t RESERVED0 : 26;       /*!< [27:2]  */
        uint32_t VER : 4;              /*!< [31:28] CAU version */
    } B;
} hw_cau_aesic_casr_t;

/*!
 * @name Constants and macros for entire CAU_AESIC_CASR register
 */
/*@{*/
#define HW_CAU_AESIC_CASR_ADDR(x) ((uint32_t)(x) + 0xB40U)

#define HW_CAU_AESIC_CASR(x)     (*(__O hw_cau_aesic_casr_t *) HW_CAU_AESIC_CASR_ADDR(x))
#define HW_CAU_AESIC_CASR_WR(x, v) (HW_CAU_AESIC_CASR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CASR bitfields
 */

/*!
 * @name Register CAU_AESIC_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0 - No illegal commands issued
 * - 1 - Illegal command issued
 */
/*@{*/
#define BP_CAU_AESIC_CASR_IC (0U)          /*!< Bit position for CAU_AESIC_CASR_IC. */
#define BM_CAU_AESIC_CASR_IC (0x00000001U) /*!< Bit mask for CAU_AESIC_CASR_IC. */
#define BS_CAU_AESIC_CASR_IC (1U)          /*!< Bit field size in bits for CAU_AESIC_CASR_IC. */

/*! @brief Format value for bitfield CAU_AESIC_CASR_IC. */
#define BF_CAU_AESIC_CASR_IC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CASR_IC) & BM_CAU_AESIC_CASR_IC)
/*@}*/

/*!
 * @name Register CAU_AESIC_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0 - No error detected
 * - 1 - DES key parity error detected
 */
/*@{*/
#define BP_CAU_AESIC_CASR_DPE (1U)         /*!< Bit position for CAU_AESIC_CASR_DPE. */
#define BM_CAU_AESIC_CASR_DPE (0x00000002U) /*!< Bit mask for CAU_AESIC_CASR_DPE. */
#define BS_CAU_AESIC_CASR_DPE (1U)         /*!< Bit field size in bits for CAU_AESIC_CASR_DPE. */

/*! @brief Format value for bitfield CAU_AESIC_CASR_DPE. */
#define BF_CAU_AESIC_CASR_DPE(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CASR_DPE) & BM_CAU_AESIC_CASR_DPE)
/*@}*/

/*!
 * @name Register CAU_AESIC_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0001 - Initial CAU version
 * - 0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
#define BP_CAU_AESIC_CASR_VER (28U)        /*!< Bit position for CAU_AESIC_CASR_VER. */
#define BM_CAU_AESIC_CASR_VER (0xF0000000U) /*!< Bit mask for CAU_AESIC_CASR_VER. */
#define BS_CAU_AESIC_CASR_VER (4U)         /*!< Bit field size in bits for CAU_AESIC_CASR_VER. */

/*! @brief Format value for bitfield CAU_AESIC_CASR_VER. */
#define BF_CAU_AESIC_CASR_VER(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CASR_VER) & BM_CAU_AESIC_CASR_VER)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesic_caa
{
    uint32_t U;
    struct _hw_cau_aesic_caa_bitfields
    {
        uint32_t ACC : 32;             /*!< [31:0] ACC */
    } B;
} hw_cau_aesic_caa_t;

/*!
 * @name Constants and macros for entire CAU_AESIC_CAA register
 */
/*@{*/
#define HW_CAU_AESIC_CAA_ADDR(x) ((uint32_t)(x) + 0xB44U)

#define HW_CAU_AESIC_CAA(x)      (*(__O hw_cau_aesic_caa_t *) HW_CAU_AESIC_CAA_ADDR(x))
#define HW_CAU_AESIC_CAA_WR(x, v) (HW_CAU_AESIC_CAA(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CAA bitfields
 */

/*!
 * @name Register CAU_AESIC_CAA, field ACC[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESIC_CAA_ACC (0U)          /*!< Bit position for CAU_AESIC_CAA_ACC. */
#define BM_CAU_AESIC_CAA_ACC (0xFFFFFFFFU) /*!< Bit mask for CAU_AESIC_CAA_ACC. */
#define BS_CAU_AESIC_CAA_ACC (32U)         /*!< Bit field size in bits for CAU_AESIC_CAA_ACC. */

/*! @brief Format value for bitfield CAU_AESIC_CAA_ACC. */
#define BF_CAU_AESIC_CAA_ACC(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CAA_ACC) & BM_CAU_AESIC_CAA_ACC)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESIC_CA0 - General Purpose Register 0 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESIC_CA0 - General Purpose Register 0 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesic_ca0
{
    uint32_t U;
    struct _hw_cau_aesic_ca0_bitfields
    {
        uint32_t CA0 : 32;             /*!< [31:0] CA0 */
    } B;
} hw_cau_aesic_ca0_t;

/*!
 * @name Constants and macros for entire CAU_AESIC_CA0 register
 */
/*@{*/
#define HW_CAU_AESIC_CA0_ADDR(x) ((uint32_t)(x) + 0xB48U)

#define HW_CAU_AESIC_CA0(x)      (*(__O hw_cau_aesic_ca0_t *) HW_CAU_AESIC_CA0_ADDR(x))
#define HW_CAU_AESIC_CA0_WR(x, v) (HW_CAU_AESIC_CA0(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CA0 bitfields
 */

/*!
 * @name Register CAU_AESIC_CA0, field CA0[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESIC_CA0_CA0 (0U)          /*!< Bit position for CAU_AESIC_CA0_CA0. */
#define BM_CAU_AESIC_CA0_CA0 (0xFFFFFFFFU) /*!< Bit mask for CAU_AESIC_CA0_CA0. */
#define BS_CAU_AESIC_CA0_CA0 (32U)         /*!< Bit field size in bits for CAU_AESIC_CA0_CA0. */

/*! @brief Format value for bitfield CAU_AESIC_CA0_CA0. */
#define BF_CAU_AESIC_CA0_CA0(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CA0_CA0) & BM_CAU_AESIC_CA0_CA0)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESIC_CA1 - General Purpose Register 1 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESIC_CA1 - General Purpose Register 1 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesic_ca1
{
    uint32_t U;
    struct _hw_cau_aesic_ca1_bitfields
    {
        uint32_t CA1 : 32;             /*!< [31:0] CA1 */
    } B;
} hw_cau_aesic_ca1_t;

/*!
 * @name Constants and macros for entire CAU_AESIC_CA1 register
 */
/*@{*/
#define HW_CAU_AESIC_CA1_ADDR(x) ((uint32_t)(x) + 0xB4CU)

#define HW_CAU_AESIC_CA1(x)      (*(__O hw_cau_aesic_ca1_t *) HW_CAU_AESIC_CA1_ADDR(x))
#define HW_CAU_AESIC_CA1_WR(x, v) (HW_CAU_AESIC_CA1(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CA1 bitfields
 */

/*!
 * @name Register CAU_AESIC_CA1, field CA1[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESIC_CA1_CA1 (0U)          /*!< Bit position for CAU_AESIC_CA1_CA1. */
#define BM_CAU_AESIC_CA1_CA1 (0xFFFFFFFFU) /*!< Bit mask for CAU_AESIC_CA1_CA1. */
#define BS_CAU_AESIC_CA1_CA1 (32U)         /*!< Bit field size in bits for CAU_AESIC_CA1_CA1. */

/*! @brief Format value for bitfield CAU_AESIC_CA1_CA1. */
#define BF_CAU_AESIC_CA1_CA1(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CA1_CA1) & BM_CAU_AESIC_CA1_CA1)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESIC_CA2 - General Purpose Register 2 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESIC_CA2 - General Purpose Register 2 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesic_ca2
{
    uint32_t U;
    struct _hw_cau_aesic_ca2_bitfields
    {
        uint32_t CA2 : 32;             /*!< [31:0] CA2 */
    } B;
} hw_cau_aesic_ca2_t;

/*!
 * @name Constants and macros for entire CAU_AESIC_CA2 register
 */
/*@{*/
#define HW_CAU_AESIC_CA2_ADDR(x) ((uint32_t)(x) + 0xB50U)

#define HW_CAU_AESIC_CA2(x)      (*(__O hw_cau_aesic_ca2_t *) HW_CAU_AESIC_CA2_ADDR(x))
#define HW_CAU_AESIC_CA2_WR(x, v) (HW_CAU_AESIC_CA2(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CA2 bitfields
 */

/*!
 * @name Register CAU_AESIC_CA2, field CA2[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESIC_CA2_CA2 (0U)          /*!< Bit position for CAU_AESIC_CA2_CA2. */
#define BM_CAU_AESIC_CA2_CA2 (0xFFFFFFFFU) /*!< Bit mask for CAU_AESIC_CA2_CA2. */
#define BS_CAU_AESIC_CA2_CA2 (32U)         /*!< Bit field size in bits for CAU_AESIC_CA2_CA2. */

/*! @brief Format value for bitfield CAU_AESIC_CA2_CA2. */
#define BF_CAU_AESIC_CA2_CA2(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CA2_CA2) & BM_CAU_AESIC_CA2_CA2)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESIC_CA3 - General Purpose Register 3 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESIC_CA3 - General Purpose Register 3 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesic_ca3
{
    uint32_t U;
    struct _hw_cau_aesic_ca3_bitfields
    {
        uint32_t CA3 : 32;             /*!< [31:0] CA3 */
    } B;
} hw_cau_aesic_ca3_t;

/*!
 * @name Constants and macros for entire CAU_AESIC_CA3 register
 */
/*@{*/
#define HW_CAU_AESIC_CA3_ADDR(x) ((uint32_t)(x) + 0xB54U)

#define HW_CAU_AESIC_CA3(x)      (*(__O hw_cau_aesic_ca3_t *) HW_CAU_AESIC_CA3_ADDR(x))
#define HW_CAU_AESIC_CA3_WR(x, v) (HW_CAU_AESIC_CA3(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CA3 bitfields
 */

/*!
 * @name Register CAU_AESIC_CA3, field CA3[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESIC_CA3_CA3 (0U)          /*!< Bit position for CAU_AESIC_CA3_CA3. */
#define BM_CAU_AESIC_CA3_CA3 (0xFFFFFFFFU) /*!< Bit mask for CAU_AESIC_CA3_CA3. */
#define BS_CAU_AESIC_CA3_CA3 (32U)         /*!< Bit field size in bits for CAU_AESIC_CA3_CA3. */

/*! @brief Format value for bitfield CAU_AESIC_CA3_CA3. */
#define BF_CAU_AESIC_CA3_CA3(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CA3_CA3) & BM_CAU_AESIC_CA3_CA3)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESIC_CA4 - General Purpose Register 4 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESIC_CA4 - General Purpose Register 4 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesic_ca4
{
    uint32_t U;
    struct _hw_cau_aesic_ca4_bitfields
    {
        uint32_t CA4 : 32;             /*!< [31:0] CA4 */
    } B;
} hw_cau_aesic_ca4_t;

/*!
 * @name Constants and macros for entire CAU_AESIC_CA4 register
 */
/*@{*/
#define HW_CAU_AESIC_CA4_ADDR(x) ((uint32_t)(x) + 0xB58U)

#define HW_CAU_AESIC_CA4(x)      (*(__O hw_cau_aesic_ca4_t *) HW_CAU_AESIC_CA4_ADDR(x))
#define HW_CAU_AESIC_CA4_WR(x, v) (HW_CAU_AESIC_CA4(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CA4 bitfields
 */

/*!
 * @name Register CAU_AESIC_CA4, field CA4[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESIC_CA4_CA4 (0U)          /*!< Bit position for CAU_AESIC_CA4_CA4. */
#define BM_CAU_AESIC_CA4_CA4 (0xFFFFFFFFU) /*!< Bit mask for CAU_AESIC_CA4_CA4. */
#define BS_CAU_AESIC_CA4_CA4 (32U)         /*!< Bit field size in bits for CAU_AESIC_CA4_CA4. */

/*! @brief Format value for bitfield CAU_AESIC_CA4_CA4. */
#define BF_CAU_AESIC_CA4_CA4(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CA4_CA4) & BM_CAU_AESIC_CA4_CA4)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESIC_CA5 - General Purpose Register 5 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESIC_CA5 - General Purpose Register 5 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesic_ca5
{
    uint32_t U;
    struct _hw_cau_aesic_ca5_bitfields
    {
        uint32_t CA5 : 32;             /*!< [31:0] CA5 */
    } B;
} hw_cau_aesic_ca5_t;

/*!
 * @name Constants and macros for entire CAU_AESIC_CA5 register
 */
/*@{*/
#define HW_CAU_AESIC_CA5_ADDR(x) ((uint32_t)(x) + 0xB5CU)

#define HW_CAU_AESIC_CA5(x)      (*(__O hw_cau_aesic_ca5_t *) HW_CAU_AESIC_CA5_ADDR(x))
#define HW_CAU_AESIC_CA5_WR(x, v) (HW_CAU_AESIC_CA5(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CA5 bitfields
 */

/*!
 * @name Register CAU_AESIC_CA5, field CA5[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESIC_CA5_CA5 (0U)          /*!< Bit position for CAU_AESIC_CA5_CA5. */
#define BM_CAU_AESIC_CA5_CA5 (0xFFFFFFFFU) /*!< Bit mask for CAU_AESIC_CA5_CA5. */
#define BS_CAU_AESIC_CA5_CA5 (32U)         /*!< Bit field size in bits for CAU_AESIC_CA5_CA5. */

/*! @brief Format value for bitfield CAU_AESIC_CA5_CA5. */
#define BF_CAU_AESIC_CA5_CA5(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CA5_CA5) & BM_CAU_AESIC_CA5_CA5)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESIC_CA6 - General Purpose Register 6 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESIC_CA6 - General Purpose Register 6 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesic_ca6
{
    uint32_t U;
    struct _hw_cau_aesic_ca6_bitfields
    {
        uint32_t CA6 : 32;             /*!< [31:0] CA6 */
    } B;
} hw_cau_aesic_ca6_t;

/*!
 * @name Constants and macros for entire CAU_AESIC_CA6 register
 */
/*@{*/
#define HW_CAU_AESIC_CA6_ADDR(x) ((uint32_t)(x) + 0xB60U)

#define HW_CAU_AESIC_CA6(x)      (*(__O hw_cau_aesic_ca6_t *) HW_CAU_AESIC_CA6_ADDR(x))
#define HW_CAU_AESIC_CA6_WR(x, v) (HW_CAU_AESIC_CA6(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CA6 bitfields
 */

/*!
 * @name Register CAU_AESIC_CA6, field CA6[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESIC_CA6_CA6 (0U)          /*!< Bit position for CAU_AESIC_CA6_CA6. */
#define BM_CAU_AESIC_CA6_CA6 (0xFFFFFFFFU) /*!< Bit mask for CAU_AESIC_CA6_CA6. */
#define BS_CAU_AESIC_CA6_CA6 (32U)         /*!< Bit field size in bits for CAU_AESIC_CA6_CA6. */

/*! @brief Format value for bitfield CAU_AESIC_CA6_CA6. */
#define BF_CAU_AESIC_CA6_CA6(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CA6_CA6) & BM_CAU_AESIC_CA6_CA6)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESIC_CA7 - General Purpose Register 7 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESIC_CA7 - General Purpose Register 7 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesic_ca7
{
    uint32_t U;
    struct _hw_cau_aesic_ca7_bitfields
    {
        uint32_t CA7 : 32;             /*!< [31:0] CA7 */
    } B;
} hw_cau_aesic_ca7_t;

/*!
 * @name Constants and macros for entire CAU_AESIC_CA7 register
 */
/*@{*/
#define HW_CAU_AESIC_CA7_ADDR(x) ((uint32_t)(x) + 0xB64U)

#define HW_CAU_AESIC_CA7(x)      (*(__O hw_cau_aesic_ca7_t *) HW_CAU_AESIC_CA7_ADDR(x))
#define HW_CAU_AESIC_CA7_WR(x, v) (HW_CAU_AESIC_CA7(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CA7 bitfields
 */

/*!
 * @name Register CAU_AESIC_CA7, field CA7[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESIC_CA7_CA7 (0U)          /*!< Bit position for CAU_AESIC_CA7_CA7. */
#define BM_CAU_AESIC_CA7_CA7 (0xFFFFFFFFU) /*!< Bit mask for CAU_AESIC_CA7_CA7. */
#define BS_CAU_AESIC_CA7_CA7 (32U)         /*!< Bit field size in bits for CAU_AESIC_CA7_CA7. */

/*! @brief Format value for bitfield CAU_AESIC_CA7_CA7. */
#define BF_CAU_AESIC_CA7_CA7(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CA7_CA7) & BM_CAU_AESIC_CA7_CA7)
/*@}*/

/*******************************************************************************
 * HW_CAU_AESIC_CA8 - General Purpose Register 8 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief HW_CAU_AESIC_CA8 - General Purpose Register 8 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_cau_aesic_ca8
{
    uint32_t U;
    struct _hw_cau_aesic_ca8_bitfields
    {
        uint32_t CA8 : 32;             /*!< [31:0] CA8 */
    } B;
} hw_cau_aesic_ca8_t;

/*!
 * @name Constants and macros for entire CAU_AESIC_CA8 register
 */
/*@{*/
#define HW_CAU_AESIC_CA8_ADDR(x) ((uint32_t)(x) + 0xB68U)

#define HW_CAU_AESIC_CA8(x)      (*(__O hw_cau_aesic_ca8_t *) HW_CAU_AESIC_CA8_ADDR(x))
#define HW_CAU_AESIC_CA8_WR(x, v) (HW_CAU_AESIC_CA8(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CA8 bitfields
 */

/*!
 * @name Register CAU_AESIC_CA8, field CA8[31:0] (WO)
 */
/*@{*/
#define BP_CAU_AESIC_CA8_CA8 (0U)          /*!< Bit position for CAU_AESIC_CA8_CA8. */
#define BM_CAU_AESIC_CA8_CA8 (0xFFFFFFFFU) /*!< Bit mask for CAU_AESIC_CA8_CA8. */
#define BS_CAU_AESIC_CA8_CA8 (32U)         /*!< Bit field size in bits for CAU_AESIC_CA8_CA8. */

/*! @brief Format value for bitfield CAU_AESIC_CA8_CA8. */
#define BF_CAU_AESIC_CA8_CA8(v) ((uint32_t)((uint32_t)(v) << BP_CAU_AESIC_CA8_CA8) & BM_CAU_AESIC_CA8_CA8)
/*@}*/

/*******************************************************************************
 * hw_cau_t - module struct
 ******************************************************************************/
/*!
 * @brief All CAU module registers.
 */
#pragma pack(1)
typedef struct _hw_cau
{
    __O hw_cau_direct0_t DIRECT0;          /*!< [0x0] Direct access register 0 */
    __O hw_cau_direct1_t DIRECT1;          /*!< [0x4] Direct access register 1 */
    __O hw_cau_direct2_t DIRECT2;          /*!< [0x8] Direct access register 2 */
    __O hw_cau_direct3_t DIRECT3;          /*!< [0xC] Direct access register 3 */
    __O hw_cau_direct4_t DIRECT4;          /*!< [0x10] Direct access register 4 */
    __O hw_cau_direct5_t DIRECT5;          /*!< [0x14] Direct access register 5 */
    __O hw_cau_direct6_t DIRECT6;          /*!< [0x18] Direct access register 6 */
    __O hw_cau_direct7_t DIRECT7;          /*!< [0x1C] Direct access register 7 */
    __O hw_cau_direct8_t DIRECT8;          /*!< [0x20] Direct access register 8 */
    __O hw_cau_direct9_t DIRECT9;          /*!< [0x24] Direct access register 9 */
    __O hw_cau_direct10_t DIRECT10;        /*!< [0x28] Direct access register 10 */
    __O hw_cau_direct11_t DIRECT11;        /*!< [0x2C] Direct access register 11 */
    __O hw_cau_direct12_t DIRECT12;        /*!< [0x30] Direct access register 12 */
    __O hw_cau_direct13_t DIRECT13;        /*!< [0x34] Direct access register 13 */
    __O hw_cau_direct14_t DIRECT14;        /*!< [0x38] Direct access register 14 */
    __O hw_cau_direct15_t DIRECT15;        /*!< [0x3C] Direct access register 15 */
    uint8_t _reserved0[2048];
    __O hw_cau_ldr_casr_t LDR_CASR;        /*!< [0x840] Status register  - Load Register command */
    __O hw_cau_ldr_caa_t LDR_CAA;          /*!< [0x844] Accumulator register - Load Register command */
    __O hw_cau_ldr_ca0_t LDR_CA0;          /*!< [0x848] General Purpose Register 0 - Load Register command */
    __O hw_cau_ldr_ca1_t LDR_CA1;          /*!< [0x84C] General Purpose Register 1 - Load Register command */
    __O hw_cau_ldr_ca2_t LDR_CA2;          /*!< [0x850] General Purpose Register 2 - Load Register command */
    __O hw_cau_ldr_ca3_t LDR_CA3;          /*!< [0x854] General Purpose Register 3 - Load Register command */
    __O hw_cau_ldr_ca4_t LDR_CA4;          /*!< [0x858] General Purpose Register 4 - Load Register command */
    __O hw_cau_ldr_ca5_t LDR_CA5;          /*!< [0x85C] General Purpose Register 5 - Load Register command */
    __O hw_cau_ldr_ca6_t LDR_CA6;          /*!< [0x860] General Purpose Register 6 - Load Register command */
    __O hw_cau_ldr_ca7_t LDR_CA7;          /*!< [0x864] General Purpose Register 7 - Load Register command */
    __O hw_cau_ldr_ca8_t LDR_CA8;          /*!< [0x868] General Purpose Register 8 - Load Register command */
    uint8_t _reserved1[20];
    __I hw_cau_str_casr_t STR_CASR;        /*!< [0x880] Status register  - Store Register command */
    __I hw_cau_str_caa_t STR_CAA;          /*!< [0x884] Accumulator register - Store Register command */
    __I hw_cau_str_ca0_t STR_CA0;          /*!< [0x888] General Purpose Register 0 - Store Register command */
    __I hw_cau_str_ca1_t STR_CA1;          /*!< [0x88C] General Purpose Register 1 - Store Register command */
    __I hw_cau_str_ca2_t STR_CA2;          /*!< [0x890] General Purpose Register 2 - Store Register command */
    __I hw_cau_str_ca3_t STR_CA3;          /*!< [0x894] General Purpose Register 3 - Store Register command */
    __I hw_cau_str_ca4_t STR_CA4;          /*!< [0x898] General Purpose Register 4 - Store Register command */
    __I hw_cau_str_ca5_t STR_CA5;          /*!< [0x89C] General Purpose Register 5 - Store Register command */
    __I hw_cau_str_ca6_t STR_CA6;          /*!< [0x8A0] General Purpose Register 6 - Store Register command */
    __I hw_cau_str_ca7_t STR_CA7;          /*!< [0x8A4] General Purpose Register 7 - Store Register command */
    __I hw_cau_str_ca8_t STR_CA8;          /*!< [0x8A8] General Purpose Register 8 - Store Register command */
    uint8_t _reserved2[20];
    __O hw_cau_adr_casr_t ADR_CASR;        /*!< [0x8C0] Status register  - Add Register command */
    __O hw_cau_adr_caa_t ADR_CAA;          /*!< [0x8C4] Accumulator register - Add to register command */
    __O hw_cau_adr_ca0_t ADR_CA0;          /*!< [0x8C8] General Purpose Register 0 - Add to register command */
    __O hw_cau_adr_ca1_t ADR_CA1;          /*!< [0x8CC] General Purpose Register 1 - Add to register command */
    __O hw_cau_adr_ca2_t ADR_CA2;          /*!< [0x8D0] General Purpose Register 2 - Add to register command */
    __O hw_cau_adr_ca3_t ADR_CA3;          /*!< [0x8D4] General Purpose Register 3 - Add to register command */
    __O hw_cau_adr_ca4_t ADR_CA4;          /*!< [0x8D8] General Purpose Register 4 - Add to register command */
    __O hw_cau_adr_ca5_t ADR_CA5;          /*!< [0x8DC] General Purpose Register 5 - Add to register command */
    __O hw_cau_adr_ca6_t ADR_CA6;          /*!< [0x8E0] General Purpose Register 6 - Add to register command */
    __O hw_cau_adr_ca7_t ADR_CA7;          /*!< [0x8E4] General Purpose Register 7 - Add to register command */
    __O hw_cau_adr_ca8_t ADR_CA8;          /*!< [0x8E8] General Purpose Register 8 - Add to register command */
    uint8_t _reserved3[20];
    __O hw_cau_radr_casr_t RADR_CASR;      /*!< [0x900] Status register  - Reverse and Add to Register command */
    __O hw_cau_radr_caa_t RADR_CAA;        /*!< [0x904] Accumulator register - Reverse and Add to Register command */
    __O hw_cau_radr_ca0_t RADR_CA0;        /*!< [0x908] General Purpose Register 0 - Reverse and Add to Register command */
    __O hw_cau_radr_ca1_t RADR_CA1;        /*!< [0x90C] General Purpose Register 1 - Reverse and Add to Register command */
    __O hw_cau_radr_ca2_t RADR_CA2;        /*!< [0x910] General Purpose Register 2 - Reverse and Add to Register command */
    __O hw_cau_radr_ca3_t RADR_CA3;        /*!< [0x914] General Purpose Register 3 - Reverse and Add to Register command */
    __O hw_cau_radr_ca4_t RADR_CA4;        /*!< [0x918] General Purpose Register 4 - Reverse and Add to Register command */
    __O hw_cau_radr_ca5_t RADR_CA5;        /*!< [0x91C] General Purpose Register 5 - Reverse and Add to Register command */
    __O hw_cau_radr_ca6_t RADR_CA6;        /*!< [0x920] General Purpose Register 6 - Reverse and Add to Register command */
    __O hw_cau_radr_ca7_t RADR_CA7;        /*!< [0x924] General Purpose Register 7 - Reverse and Add to Register command */
    __O hw_cau_radr_ca8_t RADR_CA8;        /*!< [0x928] General Purpose Register 8 - Reverse and Add to Register command */
    uint8_t _reserved4[84];
    __O hw_cau_xor_casr_t XOR_CASR;        /*!< [0x980] Status register  - Exclusive Or command */
    __O hw_cau_xor_caa_t XOR_CAA;          /*!< [0x984] Accumulator register - Exclusive Or command */
    __O hw_cau_xor_ca0_t XOR_CA0;          /*!< [0x988] General Purpose Register 0 - Exclusive Or command */
    __O hw_cau_xor_ca1_t XOR_CA1;          /*!< [0x98C] General Purpose Register 1 - Exclusive Or command */
    __O hw_cau_xor_ca2_t XOR_CA2;          /*!< [0x990] General Purpose Register 2 - Exclusive Or command */
    __O hw_cau_xor_ca3_t XOR_CA3;          /*!< [0x994] General Purpose Register 3 - Exclusive Or command */
    __O hw_cau_xor_ca4_t XOR_CA4;          /*!< [0x998] General Purpose Register 4 - Exclusive Or command */
    __O hw_cau_xor_ca5_t XOR_CA5;          /*!< [0x99C] General Purpose Register 5 - Exclusive Or command */
    __O hw_cau_xor_ca6_t XOR_CA6;          /*!< [0x9A0] General Purpose Register 6 - Exclusive Or command */
    __O hw_cau_xor_ca7_t XOR_CA7;          /*!< [0x9A4] General Purpose Register 7 - Exclusive Or command */
    __O hw_cau_xor_ca8_t XOR_CA8;          /*!< [0x9A8] General Purpose Register 8 - Exclusive Or command */
    uint8_t _reserved5[20];
    __O hw_cau_rotl_casr_t ROTL_CASR;      /*!< [0x9C0] Status register  - Rotate Left command */
    __O hw_cau_rotl_caa_t ROTL_CAA;        /*!< [0x9C4] Accumulator register - Rotate Left command */
    __O hw_cau_rotl_ca0_t ROTL_CA0;        /*!< [0x9C8] General Purpose Register 0 - Rotate Left command */
    __O hw_cau_rotl_ca1_t ROTL_CA1;        /*!< [0x9CC] General Purpose Register 1 - Rotate Left command */
    __O hw_cau_rotl_ca2_t ROTL_CA2;        /*!< [0x9D0] General Purpose Register 2 - Rotate Left command */
    __O hw_cau_rotl_ca3_t ROTL_CA3;        /*!< [0x9D4] General Purpose Register 3 - Rotate Left command */
    __O hw_cau_rotl_ca4_t ROTL_CA4;        /*!< [0x9D8] General Purpose Register 4 - Rotate Left command */
    __O hw_cau_rotl_ca5_t ROTL_CA5;        /*!< [0x9DC] General Purpose Register 5 - Rotate Left command */
    __O hw_cau_rotl_ca6_t ROTL_CA6;        /*!< [0x9E0] General Purpose Register 6 - Rotate Left command */
    __O hw_cau_rotl_ca7_t ROTL_CA7;        /*!< [0x9E4] General Purpose Register 7 - Rotate Left command */
    __O hw_cau_rotl_ca8_t ROTL_CA8;        /*!< [0x9E8] General Purpose Register 8 - Rotate Left command */
    uint8_t _reserved6[276];
    __O hw_cau_aesc_casr_t AESC_CASR;      /*!< [0xB00] Status register  - AES Column Operation command */
    __O hw_cau_aesc_caa_t AESC_CAA;        /*!< [0xB04] Accumulator register - AES Column Operation command */
    __O hw_cau_aesc_ca0_t AESC_CA0;        /*!< [0xB08] General Purpose Register 0 - AES Column Operation command */
    __O hw_cau_aesc_ca1_t AESC_CA1;        /*!< [0xB0C] General Purpose Register 1 - AES Column Operation command */
    __O hw_cau_aesc_ca2_t AESC_CA2;        /*!< [0xB10] General Purpose Register 2 - AES Column Operation command */
    __O hw_cau_aesc_ca3_t AESC_CA3;        /*!< [0xB14] General Purpose Register 3 - AES Column Operation command */
    __O hw_cau_aesc_ca4_t AESC_CA4;        /*!< [0xB18] General Purpose Register 4 - AES Column Operation command */
    __O hw_cau_aesc_ca5_t AESC_CA5;        /*!< [0xB1C] General Purpose Register 5 - AES Column Operation command */
    __O hw_cau_aesc_ca6_t AESC_CA6;        /*!< [0xB20] General Purpose Register 6 - AES Column Operation command */
    __O hw_cau_aesc_ca7_t AESC_CA7;        /*!< [0xB24] General Purpose Register 7 - AES Column Operation command */
    __O hw_cau_aesc_ca8_t AESC_CA8;        /*!< [0xB28] General Purpose Register 8 - AES Column Operation command */
    uint8_t _reserved7[20];
    __O hw_cau_aesic_casr_t AESIC_CASR;    /*!< [0xB40] Status register  - AES Inverse Column Operation command */
    __O hw_cau_aesic_caa_t AESIC_CAA;      /*!< [0xB44] Accumulator register - AES Inverse Column Operation command */
    __O hw_cau_aesic_ca0_t AESIC_CA0;      /*!< [0xB48] General Purpose Register 0 - AES Inverse Column Operation command */
    __O hw_cau_aesic_ca1_t AESIC_CA1;      /*!< [0xB4C] General Purpose Register 1 - AES Inverse Column Operation command */
    __O hw_cau_aesic_ca2_t AESIC_CA2;      /*!< [0xB50] General Purpose Register 2 - AES Inverse Column Operation command */
    __O hw_cau_aesic_ca3_t AESIC_CA3;      /*!< [0xB54] General Purpose Register 3 - AES Inverse Column Operation command */
    __O hw_cau_aesic_ca4_t AESIC_CA4;      /*!< [0xB58] General Purpose Register 4 - AES Inverse Column Operation command */
    __O hw_cau_aesic_ca5_t AESIC_CA5;      /*!< [0xB5C] General Purpose Register 5 - AES Inverse Column Operation command */
    __O hw_cau_aesic_ca6_t AESIC_CA6;      /*!< [0xB60] General Purpose Register 6 - AES Inverse Column Operation command */
    __O hw_cau_aesic_ca7_t AESIC_CA7;      /*!< [0xB64] General Purpose Register 7 - AES Inverse Column Operation command */
    __O hw_cau_aesic_ca8_t AESIC_CA8;      /*!< [0xB68] General Purpose Register 8 - AES Inverse Column Operation command */
} hw_cau_t;
#pragma pack()

/*! @brief Macro to access all CAU registers. */
/*! @param x CAU module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_CAU_REGS(CAU_BASE)</code>. */
#define HW_CAU_REGS(x) (*(hw_cau_t *)(x))

/*
 * MK64F12 CMP
 *
 * High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
 *
 * Registers defined in this header file:
 * - HW_CMP_CR0 - CMP Control Register 0
 * - HW_CMP_CR1 - CMP Control Register 1
 * - HW_CMP_FPR - CMP Filter Period Register
 * - HW_CMP_SCR - CMP Status and Control Register
 * - HW_CMP_DACCR - DAC Control Register
 * - HW_CMP_MUXCR - MUX Control Register
 *
 * - hw_cmp_t - Struct containing all module registers.
 */

#define HW_CMP_INSTANCE_COUNT (3U) /*!< Number of instances of the CMP module. */
#define HW_CMP0 (0U) /*!< Instance number for CMP0. */
#define HW_CMP1 (1U) /*!< Instance number for CMP1. */
#define HW_CMP2 (2U) /*!< Instance number for CMP2. */

/*******************************************************************************
 * HW_CMP_CR0 - CMP Control Register 0
 ******************************************************************************/

/*!
 * @brief HW_CMP_CR0 - CMP Control Register 0 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_cr0
{
    uint8_t U;
    struct _hw_cmp_cr0_bitfields
    {
        uint8_t HYSTCTR : 2;           /*!< [1:0] Comparator hard block hysteresis
                                        * control */
        uint8_t RESERVED0 : 2;         /*!< [3:2]  */
        uint8_t FILTER_CNT : 3;        /*!< [6:4] Filter Sample Count */
        uint8_t RESERVED1 : 1;         /*!< [7]  */
    } B;
} hw_cmp_cr0_t;

/*!
 * @name Constants and macros for entire CMP_CR0 register
 */
/*@{*/
#define HW_CMP_CR0_ADDR(x)       ((uint32_t)(x) + 0x0U)

#define HW_CMP_CR0(x)            (*(__IO hw_cmp_cr0_t *) HW_CMP_CR0_ADDR(x))
#define HW_CMP_CR0_RD(x)         (HW_CMP_CR0(x).U)
#define HW_CMP_CR0_WR(x, v)      (HW_CMP_CR0(x).U = (v))
#define HW_CMP_CR0_SET(x, v)     (HW_CMP_CR0_WR(x, HW_CMP_CR0_RD(x) |  (v)))
#define HW_CMP_CR0_CLR(x, v)     (HW_CMP_CR0_WR(x, HW_CMP_CR0_RD(x) & ~(v)))
#define HW_CMP_CR0_TOG(x, v)     (HW_CMP_CR0_WR(x, HW_CMP_CR0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR0 bitfields
 */

/*!
 * @name Register CMP_CR0, field HYSTCTR[1:0] (RW)
 *
 * Defines the programmable hysteresis level. The hysteresis values associated
 * with each level are device-specific. See the Data Sheet of the device for the
 * exact values.
 *
 * Values:
 * - 00 - Level 0
 * - 01 - Level 1
 * - 10 - Level 2
 * - 11 - Level 3
 */
/*@{*/
#define BP_CMP_CR0_HYSTCTR   (0U)          /*!< Bit position for CMP_CR0_HYSTCTR. */
#define BM_CMP_CR0_HYSTCTR   (0x03U)       /*!< Bit mask for CMP_CR0_HYSTCTR. */
#define BS_CMP_CR0_HYSTCTR   (2U)          /*!< Bit field size in bits for CMP_CR0_HYSTCTR. */

/*! @brief Read current value of the CMP_CR0_HYSTCTR field. */
#define BR_CMP_CR0_HYSTCTR(x) (HW_CMP_CR0(x).B.HYSTCTR)

/*! @brief Format value for bitfield CMP_CR0_HYSTCTR. */
#define BF_CMP_CR0_HYSTCTR(v) ((uint8_t)((uint8_t)(v) << BP_CMP_CR0_HYSTCTR) & BM_CMP_CR0_HYSTCTR)

/*! @brief Set the HYSTCTR field to a new value. */
#define BW_CMP_CR0_HYSTCTR(x, v) (HW_CMP_CR0_WR(x, (HW_CMP_CR0_RD(x) & ~BM_CMP_CR0_HYSTCTR) | BF_CMP_CR0_HYSTCTR(v)))
/*@}*/

/*!
 * @name Register CMP_CR0, field FILTER_CNT[6:4] (RW)
 *
 * Represents the number of consecutive samples that must agree prior to the
 * comparator ouput filter accepting a new output state. For information regarding
 * filter programming and latency, see the Functional descriptionThe CMP module
 * can be used to compare two analog input voltages applied to INP and INM. .
 *
 * Values:
 * - 000 - Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a
 *     legal state, and is not recommended. If SE = 0, COUT = COUTA.
 * - 001 - One sample must agree. The comparator output is simply sampled.
 * - 010 - 2 consecutive samples must agree.
 * - 011 - 3 consecutive samples must agree.
 * - 100 - 4 consecutive samples must agree.
 * - 101 - 5 consecutive samples must agree.
 * - 110 - 6 consecutive samples must agree.
 * - 111 - 7 consecutive samples must agree.
 */
/*@{*/
#define BP_CMP_CR0_FILTER_CNT (4U)         /*!< Bit position for CMP_CR0_FILTER_CNT. */
#define BM_CMP_CR0_FILTER_CNT (0x70U)      /*!< Bit mask for CMP_CR0_FILTER_CNT. */
#define BS_CMP_CR0_FILTER_CNT (3U)         /*!< Bit field size in bits for CMP_CR0_FILTER_CNT. */

/*! @brief Read current value of the CMP_CR0_FILTER_CNT field. */
#define BR_CMP_CR0_FILTER_CNT(x) (HW_CMP_CR0(x).B.FILTER_CNT)

/*! @brief Format value for bitfield CMP_CR0_FILTER_CNT. */
#define BF_CMP_CR0_FILTER_CNT(v) ((uint8_t)((uint8_t)(v) << BP_CMP_CR0_FILTER_CNT) & BM_CMP_CR0_FILTER_CNT)

/*! @brief Set the FILTER_CNT field to a new value. */
#define BW_CMP_CR0_FILTER_CNT(x, v) (HW_CMP_CR0_WR(x, (HW_CMP_CR0_RD(x) & ~BM_CMP_CR0_FILTER_CNT) | BF_CMP_CR0_FILTER_CNT(v)))
/*@}*/

/*******************************************************************************
 * HW_CMP_CR1 - CMP Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_CMP_CR1 - CMP Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_cr1
{
    uint8_t U;
    struct _hw_cmp_cr1_bitfields
    {
        uint8_t EN : 1;                /*!< [0] Comparator Module Enable */
        uint8_t OPE : 1;               /*!< [1] Comparator Output Pin Enable */
        uint8_t COS : 1;               /*!< [2] Comparator Output Select */
        uint8_t INV : 1;               /*!< [3] Comparator INVERT */
        uint8_t PMODE : 1;             /*!< [4] Power Mode Select */
        uint8_t RESERVED0 : 1;         /*!< [5]  */
        uint8_t WE : 1;                /*!< [6] Windowing Enable */
        uint8_t SE : 1;                /*!< [7] Sample Enable */
    } B;
} hw_cmp_cr1_t;

/*!
 * @name Constants and macros for entire CMP_CR1 register
 */
/*@{*/
#define HW_CMP_CR1_ADDR(x)       ((uint32_t)(x) + 0x1U)

#define HW_CMP_CR1(x)            (*(__IO hw_cmp_cr1_t *) HW_CMP_CR1_ADDR(x))
#define HW_CMP_CR1_RD(x)         (HW_CMP_CR1(x).U)
#define HW_CMP_CR1_WR(x, v)      (HW_CMP_CR1(x).U = (v))
#define HW_CMP_CR1_SET(x, v)     (HW_CMP_CR1_WR(x, HW_CMP_CR1_RD(x) |  (v)))
#define HW_CMP_CR1_CLR(x, v)     (HW_CMP_CR1_WR(x, HW_CMP_CR1_RD(x) & ~(v)))
#define HW_CMP_CR1_TOG(x, v)     (HW_CMP_CR1_WR(x, HW_CMP_CR1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR1 bitfields
 */

/*!
 * @name Register CMP_CR1, field EN[0] (RW)
 *
 * Enables the Analog Comparator module. When the module is not enabled, it
 * remains in the off state, and consumes no power. When the user selects the same
 * input from analog mux to the positive and negative port, the comparator is
 * disabled automatically.
 *
 * Values:
 * - 0 - Analog Comparator is disabled.
 * - 1 - Analog Comparator is enabled.
 */
/*@{*/
#define BP_CMP_CR1_EN        (0U)          /*!< Bit position for CMP_CR1_EN. */
#define BM_CMP_CR1_EN        (0x01U)       /*!< Bit mask for CMP_CR1_EN. */
#define BS_CMP_CR1_EN        (1U)          /*!< Bit field size in bits for CMP_CR1_EN. */

/*! @brief Read current value of the CMP_CR1_EN field. */
#define BR_CMP_CR1_EN(x)     (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_EN))

/*! @brief Format value for bitfield CMP_CR1_EN. */
#define BF_CMP_CR1_EN(v)     ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_EN) & BM_CMP_CR1_EN)

/*! @brief Set the EN field to a new value. */
#define BW_CMP_CR1_EN(x, v)  (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_EN) = (v))
/*@}*/

/*!
 * @name Register CMP_CR1, field OPE[1] (RW)
 *
 * Values:
 * - 0 - CMPO is not available on the associated CMPO output pin. If the
 *     comparator does not own the pin, this field has no effect.
 * - 1 - CMPO is available on the associated CMPO output pin. The comparator
 *     output (CMPO) is driven out on the associated CMPO output pin if the
 *     comparator owns the pin. If the comparator does not own the field, this bit has no
 *     effect.
 */
/*@{*/
#define BP_CMP_CR1_OPE       (1U)          /*!< Bit position for CMP_CR1_OPE. */
#define BM_CMP_CR1_OPE       (0x02U)       /*!< Bit mask for CMP_CR1_OPE. */
#define BS_CMP_CR1_OPE       (1U)          /*!< Bit field size in bits for CMP_CR1_OPE. */

/*! @brief Read current value of the CMP_CR1_OPE field. */
#define BR_CMP_CR1_OPE(x)    (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_OPE))

/*! @brief Format value for bitfield CMP_CR1_OPE. */
#define BF_CMP_CR1_OPE(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_OPE) & BM_CMP_CR1_OPE)

/*! @brief Set the OPE field to a new value. */
#define BW_CMP_CR1_OPE(x, v) (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_OPE) = (v))
/*@}*/

/*!
 * @name Register CMP_CR1, field COS[2] (RW)
 *
 * Values:
 * - 0 - Set the filtered comparator output (CMPO) to equal COUT.
 * - 1 - Set the unfiltered comparator output (CMPO) to equal COUTA.
 */
/*@{*/
#define BP_CMP_CR1_COS       (2U)          /*!< Bit position for CMP_CR1_COS. */
#define BM_CMP_CR1_COS       (0x04U)       /*!< Bit mask for CMP_CR1_COS. */
#define BS_CMP_CR1_COS       (1U)          /*!< Bit field size in bits for CMP_CR1_COS. */

/*! @brief Read current value of the CMP_CR1_COS field. */
#define BR_CMP_CR1_COS(x)    (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_COS))

/*! @brief Format value for bitfield CMP_CR1_COS. */
#define BF_CMP_CR1_COS(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_COS) & BM_CMP_CR1_COS)

/*! @brief Set the COS field to a new value. */
#define BW_CMP_CR1_COS(x, v) (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_COS) = (v))
/*@}*/

/*!
 * @name Register CMP_CR1, field INV[3] (RW)
 *
 * Allows selection of the polarity of the analog comparator function. It is
 * also driven to the COUT output, on both the device pin and as SCR[COUT], when
 * OPE=0.
 *
 * Values:
 * - 0 - Does not invert the comparator output.
 * - 1 - Inverts the comparator output.
 */
/*@{*/
#define BP_CMP_CR1_INV       (3U)          /*!< Bit position for CMP_CR1_INV. */
#define BM_CMP_CR1_INV       (0x08U)       /*!< Bit mask for CMP_CR1_INV. */
#define BS_CMP_CR1_INV       (1U)          /*!< Bit field size in bits for CMP_CR1_INV. */

/*! @brief Read current value of the CMP_CR1_INV field. */
#define BR_CMP_CR1_INV(x)    (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_INV))

/*! @brief Format value for bitfield CMP_CR1_INV. */
#define BF_CMP_CR1_INV(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_INV) & BM_CMP_CR1_INV)

/*! @brief Set the INV field to a new value. */
#define BW_CMP_CR1_INV(x, v) (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_INV) = (v))
/*@}*/

/*!
 * @name Register CMP_CR1, field PMODE[4] (RW)
 *
 * See the electrical specifications table in the device Data Sheet for details.
 *
 * Values:
 * - 0 - Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower
 *     output propagation delay and lower current consumption.
 * - 1 - High-Speed (HS) Comparison mode selected. In this mode, CMP has faster
 *     output propagation delay and higher current consumption.
 */
/*@{*/
#define BP_CMP_CR1_PMODE     (4U)          /*!< Bit position for CMP_CR1_PMODE. */
#define BM_CMP_CR1_PMODE     (0x10U)       /*!< Bit mask for CMP_CR1_PMODE. */
#define BS_CMP_CR1_PMODE     (1U)          /*!< Bit field size in bits for CMP_CR1_PMODE. */

/*! @brief Read current value of the CMP_CR1_PMODE field. */
#define BR_CMP_CR1_PMODE(x)  (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_PMODE))

/*! @brief Format value for bitfield CMP_CR1_PMODE. */
#define BF_CMP_CR1_PMODE(v)  ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_PMODE) & BM_CMP_CR1_PMODE)

/*! @brief Set the PMODE field to a new value. */
#define BW_CMP_CR1_PMODE(x, v) (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_PMODE) = (v))
/*@}*/

/*!
 * @name Register CMP_CR1, field WE[6] (RW)
 *
 * At any given time, either SE or WE can be set. If a write to this register
 * attempts to set both, then SE is set and WE is cleared. However, avoid writing
 * 1s to both field locations because this "11" case is reserved and may change in
 * future implementations.
 *
 * Values:
 * - 0 - Windowing mode is not selected.
 * - 1 - Windowing mode is selected.
 */
/*@{*/
#define BP_CMP_CR1_WE        (6U)          /*!< Bit position for CMP_CR1_WE. */
#define BM_CMP_CR1_WE        (0x40U)       /*!< Bit mask for CMP_CR1_WE. */
#define BS_CMP_CR1_WE        (1U)          /*!< Bit field size in bits for CMP_CR1_WE. */

/*! @brief Read current value of the CMP_CR1_WE field. */
#define BR_CMP_CR1_WE(x)     (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_WE))

/*! @brief Format value for bitfield CMP_CR1_WE. */
#define BF_CMP_CR1_WE(v)     ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_WE) & BM_CMP_CR1_WE)

/*! @brief Set the WE field to a new value. */
#define BW_CMP_CR1_WE(x, v)  (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_WE) = (v))
/*@}*/

/*!
 * @name Register CMP_CR1, field SE[7] (RW)
 *
 * At any given time, either SE or WE can be set. If a write to this register
 * attempts to set both, then SE is set and WE is cleared. However, avoid writing
 * 1s to both field locations because this "11" case is reserved and may change in
 * future implementations.
 *
 * Values:
 * - 0 - Sampling mode is not selected.
 * - 1 - Sampling mode is selected.
 */
/*@{*/
#define BP_CMP_CR1_SE        (7U)          /*!< Bit position for CMP_CR1_SE. */
#define BM_CMP_CR1_SE        (0x80U)       /*!< Bit mask for CMP_CR1_SE. */
#define BS_CMP_CR1_SE        (1U)          /*!< Bit field size in bits for CMP_CR1_SE. */

/*! @brief Read current value of the CMP_CR1_SE field. */
#define BR_CMP_CR1_SE(x)     (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_SE))

/*! @brief Format value for bitfield CMP_CR1_SE. */
#define BF_CMP_CR1_SE(v)     ((uint8_t)((uint8_t)(v) << BP_CMP_CR1_SE) & BM_CMP_CR1_SE)

/*! @brief Set the SE field to a new value. */
#define BW_CMP_CR1_SE(x, v)  (BITBAND_ACCESS8(HW_CMP_CR1_ADDR(x), BP_CMP_CR1_SE) = (v))
/*@}*/

/*******************************************************************************
 * HW_CMP_FPR - CMP Filter Period Register
 ******************************************************************************/

/*!
 * @brief HW_CMP_FPR - CMP Filter Period Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_fpr
{
    uint8_t U;
    struct _hw_cmp_fpr_bitfields
    {
        uint8_t FILT_PER : 8;          /*!< [7:0] Filter Sample Period */
    } B;
} hw_cmp_fpr_t;

/*!
 * @name Constants and macros for entire CMP_FPR register
 */
/*@{*/
#define HW_CMP_FPR_ADDR(x)       ((uint32_t)(x) + 0x2U)

#define HW_CMP_FPR(x)            (*(__IO hw_cmp_fpr_t *) HW_CMP_FPR_ADDR(x))
#define HW_CMP_FPR_RD(x)         (HW_CMP_FPR(x).U)
#define HW_CMP_FPR_WR(x, v)      (HW_CMP_FPR(x).U = (v))
#define HW_CMP_FPR_SET(x, v)     (HW_CMP_FPR_WR(x, HW_CMP_FPR_RD(x) |  (v)))
#define HW_CMP_FPR_CLR(x, v)     (HW_CMP_FPR_WR(x, HW_CMP_FPR_RD(x) & ~(v)))
#define HW_CMP_FPR_TOG(x, v)     (HW_CMP_FPR_WR(x, HW_CMP_FPR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMP_FPR bitfields
 */

/*!
 * @name Register CMP_FPR, field FILT_PER[7:0] (RW)
 *
 * Specifies the sampling period, in bus clock cycles, of the comparator output
 * filter, when CR1[SE]=0. Setting FILT_PER to 0x0 disables the filter. Filter
 * programming and latency details appear in the Functional descriptionThe CMP
 * module can be used to compare two analog input voltages applied to INP and INM. .
 * This field has no effect when CR1[SE]=1. In that case, the external SAMPLE
 * signal is used to determine the sampling period.
 */
/*@{*/
#define BP_CMP_FPR_FILT_PER  (0U)          /*!< Bit position for CMP_FPR_FILT_PER. */
#define BM_CMP_FPR_FILT_PER  (0xFFU)       /*!< Bit mask for CMP_FPR_FILT_PER. */
#define BS_CMP_FPR_FILT_PER  (8U)          /*!< Bit field size in bits for CMP_FPR_FILT_PER. */

/*! @brief Read current value of the CMP_FPR_FILT_PER field. */
#define BR_CMP_FPR_FILT_PER(x) (HW_CMP_FPR(x).U)

/*! @brief Format value for bitfield CMP_FPR_FILT_PER. */
#define BF_CMP_FPR_FILT_PER(v) ((uint8_t)((uint8_t)(v) << BP_CMP_FPR_FILT_PER) & BM_CMP_FPR_FILT_PER)

/*! @brief Set the FILT_PER field to a new value. */
#define BW_CMP_FPR_FILT_PER(x, v) (HW_CMP_FPR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CMP_SCR - CMP Status and Control Register
 ******************************************************************************/

/*!
 * @brief HW_CMP_SCR - CMP Status and Control Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_scr
{
    uint8_t U;
    struct _hw_cmp_scr_bitfields
    {
        uint8_t COUT : 1;              /*!< [0] Analog Comparator Output */
        uint8_t CFF : 1;               /*!< [1] Analog Comparator Flag Falling */
        uint8_t CFR : 1;               /*!< [2] Analog Comparator Flag Rising */
        uint8_t IEF : 1;               /*!< [3] Comparator Interrupt Enable Falling */
        uint8_t IER : 1;               /*!< [4] Comparator Interrupt Enable Rising */
        uint8_t RESERVED0 : 1;         /*!< [5]  */
        uint8_t DMAEN : 1;             /*!< [6] DMA Enable Control */
        uint8_t RESERVED1 : 1;         /*!< [7]  */
    } B;
} hw_cmp_scr_t;

/*!
 * @name Constants and macros for entire CMP_SCR register
 */
/*@{*/
#define HW_CMP_SCR_ADDR(x)       ((uint32_t)(x) + 0x3U)

#define HW_CMP_SCR(x)            (*(__IO hw_cmp_scr_t *) HW_CMP_SCR_ADDR(x))
#define HW_CMP_SCR_RD(x)         (HW_CMP_SCR(x).U)
#define HW_CMP_SCR_WR(x, v)      (HW_CMP_SCR(x).U = (v))
#define HW_CMP_SCR_SET(x, v)     (HW_CMP_SCR_WR(x, HW_CMP_SCR_RD(x) |  (v)))
#define HW_CMP_SCR_CLR(x, v)     (HW_CMP_SCR_WR(x, HW_CMP_SCR_RD(x) & ~(v)))
#define HW_CMP_SCR_TOG(x, v)     (HW_CMP_SCR_WR(x, HW_CMP_SCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMP_SCR bitfields
 */

/*!
 * @name Register CMP_SCR, field COUT[0] (RO)
 *
 * Returns the current value of the Analog Comparator output, when read. The
 * field is reset to 0 and will read as CR1[INV] when the Analog Comparator module
 * is disabled, that is, when CR1[EN] = 0. Writes to this field are ignored.
 */
/*@{*/
#define BP_CMP_SCR_COUT      (0U)          /*!< Bit position for CMP_SCR_COUT. */
#define BM_CMP_SCR_COUT      (0x01U)       /*!< Bit mask for CMP_SCR_COUT. */
#define BS_CMP_SCR_COUT      (1U)          /*!< Bit field size in bits for CMP_SCR_COUT. */

/*! @brief Read current value of the CMP_SCR_COUT field. */
#define BR_CMP_SCR_COUT(x)   (BITBAND_ACCESS8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_COUT))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFF[1] (W1C)
 *
 * Detects a falling-edge on COUT, when set, during normal operation. CFF is
 * cleared by writing 1 to it. During Stop modes, CFF is level sensitive is edge
 * sensitive .
 *
 * Values:
 * - 0 - Falling-edge on COUT has not been detected.
 * - 1 - Falling-edge on COUT has occurred.
 */
/*@{*/
#define BP_CMP_SCR_CFF       (1U)          /*!< Bit position for CMP_SCR_CFF. */
#define BM_CMP_SCR_CFF       (0x02U)       /*!< Bit mask for CMP_SCR_CFF. */
#define BS_CMP_SCR_CFF       (1U)          /*!< Bit field size in bits for CMP_SCR_CFF. */

/*! @brief Read current value of the CMP_SCR_CFF field. */
#define BR_CMP_SCR_CFF(x)    (BITBAND_ACCESS8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_CFF))

/*! @brief Format value for bitfield CMP_SCR_CFF. */
#define BF_CMP_SCR_CFF(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_SCR_CFF) & BM_CMP_SCR_CFF)

/*! @brief Set the CFF field to a new value. */
#define BW_CMP_SCR_CFF(x, v) (BITBAND_ACCESS8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_CFF) = (v))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFR[2] (W1C)
 *
 * Detects a rising-edge on COUT, when set, during normal operation. CFR is
 * cleared by writing 1 to it. During Stop modes, CFR is level sensitive is edge
 * sensitive .
 *
 * Values:
 * - 0 - Rising-edge on COUT has not been detected.
 * - 1 - Rising-edge on COUT has occurred.
 */
/*@{*/
#define BP_CMP_SCR_CFR       (2U)          /*!< Bit position for CMP_SCR_CFR. */
#define BM_CMP_SCR_CFR       (0x04U)       /*!< Bit mask for CMP_SCR_CFR. */
#define BS_CMP_SCR_CFR       (1U)          /*!< Bit field size in bits for CMP_SCR_CFR. */

/*! @brief Read current value of the CMP_SCR_CFR field. */
#define BR_CMP_SCR_CFR(x)    (BITBAND_ACCESS8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_CFR))

/*! @brief Format value for bitfield CMP_SCR_CFR. */
#define BF_CMP_SCR_CFR(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_SCR_CFR) & BM_CMP_SCR_CFR)

/*! @brief Set the CFR field to a new value. */
#define BW_CMP_SCR_CFR(x, v) (BITBAND_ACCESS8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_CFR) = (v))
/*@}*/

/*!
 * @name Register CMP_SCR, field IEF[3] (RW)
 *
 * Enables the CFF interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFF is set.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
#define BP_CMP_SCR_IEF       (3U)          /*!< Bit position for CMP_SCR_IEF. */
#define BM_CMP_SCR_IEF       (0x08U)       /*!< Bit mask for CMP_SCR_IEF. */
#define BS_CMP_SCR_IEF       (1U)          /*!< Bit field size in bits for CMP_SCR_IEF. */

/*! @brief Read current value of the CMP_SCR_IEF field. */
#define BR_CMP_SCR_IEF(x)    (BITBAND_ACCESS8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_IEF))

/*! @brief Format value for bitfield CMP_SCR_IEF. */
#define BF_CMP_SCR_IEF(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_SCR_IEF) & BM_CMP_SCR_IEF)

/*! @brief Set the IEF field to a new value. */
#define BW_CMP_SCR_IEF(x, v) (BITBAND_ACCESS8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_IEF) = (v))
/*@}*/

/*!
 * @name Register CMP_SCR, field IER[4] (RW)
 *
 * Enables the CFR interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFR is set.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
#define BP_CMP_SCR_IER       (4U)          /*!< Bit position for CMP_SCR_IER. */
#define BM_CMP_SCR_IER       (0x10U)       /*!< Bit mask for CMP_SCR_IER. */
#define BS_CMP_SCR_IER       (1U)          /*!< Bit field size in bits for CMP_SCR_IER. */

/*! @brief Read current value of the CMP_SCR_IER field. */
#define BR_CMP_SCR_IER(x)    (BITBAND_ACCESS8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_IER))

/*! @brief Format value for bitfield CMP_SCR_IER. */
#define BF_CMP_SCR_IER(v)    ((uint8_t)((uint8_t)(v) << BP_CMP_SCR_IER) & BM_CMP_SCR_IER)

/*! @brief Set the IER field to a new value. */
#define BW_CMP_SCR_IER(x, v) (BITBAND_ACCESS8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_IER) = (v))
/*@}*/

/*!
 * @name Register CMP_SCR, field DMAEN[6] (RW)
 *
 * Enables the DMA transfer triggered from the CMP module. When this field is
 * set, a DMA request is asserted when CFR or CFF is set.
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled.
 */
/*@{*/
#define BP_CMP_SCR_DMAEN     (6U)          /*!< Bit position for CMP_SCR_DMAEN. */
#define BM_CMP_SCR_DMAEN     (0x40U)       /*!< Bit mask for CMP_SCR_DMAEN. */
#define BS_CMP_SCR_DMAEN     (1U)          /*!< Bit field size in bits for CMP_SCR_DMAEN. */

/*! @brief Read current value of the CMP_SCR_DMAEN field. */
#define BR_CMP_SCR_DMAEN(x)  (BITBAND_ACCESS8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_DMAEN))

/*! @brief Format value for bitfield CMP_SCR_DMAEN. */
#define BF_CMP_SCR_DMAEN(v)  ((uint8_t)((uint8_t)(v) << BP_CMP_SCR_DMAEN) & BM_CMP_SCR_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_CMP_SCR_DMAEN(x, v) (BITBAND_ACCESS8(HW_CMP_SCR_ADDR(x), BP_CMP_SCR_DMAEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_CMP_DACCR - DAC Control Register
 ******************************************************************************/

/*!
 * @brief HW_CMP_DACCR - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_daccr
{
    uint8_t U;
    struct _hw_cmp_daccr_bitfields
    {
        uint8_t VOSEL : 6;             /*!< [5:0] DAC Output Voltage Select */
        uint8_t VRSEL : 1;             /*!< [6] Supply Voltage Reference Source Select */
        uint8_t DACEN : 1;             /*!< [7] DAC Enable */
    } B;
} hw_cmp_daccr_t;

/*!
 * @name Constants and macros for entire CMP_DACCR register
 */
/*@{*/
#define HW_CMP_DACCR_ADDR(x)     ((uint32_t)(x) + 0x4U)

#define HW_CMP_DACCR(x)          (*(__IO hw_cmp_daccr_t *) HW_CMP_DACCR_ADDR(x))
#define HW_CMP_DACCR_RD(x)       (HW_CMP_DACCR(x).U)
#define HW_CMP_DACCR_WR(x, v)    (HW_CMP_DACCR(x).U = (v))
#define HW_CMP_DACCR_SET(x, v)   (HW_CMP_DACCR_WR(x, HW_CMP_DACCR_RD(x) |  (v)))
#define HW_CMP_DACCR_CLR(x, v)   (HW_CMP_DACCR_WR(x, HW_CMP_DACCR_RD(x) & ~(v)))
#define HW_CMP_DACCR_TOG(x, v)   (HW_CMP_DACCR_WR(x, HW_CMP_DACCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMP_DACCR bitfields
 */

/*!
 * @name Register CMP_DACCR, field VOSEL[5:0] (RW)
 *
 * Selects an output voltage from one of 64 distinct levels. DACO = (V in /64) *
 * (VOSEL[5:0] + 1) , so the DACO range is from V in /64 to V in .
 */
/*@{*/
#define BP_CMP_DACCR_VOSEL   (0U)          /*!< Bit position for CMP_DACCR_VOSEL. */
#define BM_CMP_DACCR_VOSEL   (0x3FU)       /*!< Bit mask for CMP_DACCR_VOSEL. */
#define BS_CMP_DACCR_VOSEL   (6U)          /*!< Bit field size in bits for CMP_DACCR_VOSEL. */

/*! @brief Read current value of the CMP_DACCR_VOSEL field. */
#define BR_CMP_DACCR_VOSEL(x) (HW_CMP_DACCR(x).B.VOSEL)

/*! @brief Format value for bitfield CMP_DACCR_VOSEL. */
#define BF_CMP_DACCR_VOSEL(v) ((uint8_t)((uint8_t)(v) << BP_CMP_DACCR_VOSEL) & BM_CMP_DACCR_VOSEL)

/*! @brief Set the VOSEL field to a new value. */
#define BW_CMP_DACCR_VOSEL(x, v) (HW_CMP_DACCR_WR(x, (HW_CMP_DACCR_RD(x) & ~BM_CMP_DACCR_VOSEL) | BF_CMP_DACCR_VOSEL(v)))
/*@}*/

/*!
 * @name Register CMP_DACCR, field VRSEL[6] (RW)
 *
 * Values:
 * - 0 - V is selected as resistor ladder network supply reference V. in1 in
 * - 1 - V is selected as resistor ladder network supply reference V. in2 in
 */
/*@{*/
#define BP_CMP_DACCR_VRSEL   (6U)          /*!< Bit position for CMP_DACCR_VRSEL. */
#define BM_CMP_DACCR_VRSEL   (0x40U)       /*!< Bit mask for CMP_DACCR_VRSEL. */
#define BS_CMP_DACCR_VRSEL   (1U)          /*!< Bit field size in bits for CMP_DACCR_VRSEL. */

/*! @brief Read current value of the CMP_DACCR_VRSEL field. */
#define BR_CMP_DACCR_VRSEL(x) (BITBAND_ACCESS8(HW_CMP_DACCR_ADDR(x), BP_CMP_DACCR_VRSEL))

/*! @brief Format value for bitfield CMP_DACCR_VRSEL. */
#define BF_CMP_DACCR_VRSEL(v) ((uint8_t)((uint8_t)(v) << BP_CMP_DACCR_VRSEL) & BM_CMP_DACCR_VRSEL)

/*! @brief Set the VRSEL field to a new value. */
#define BW_CMP_DACCR_VRSEL(x, v) (BITBAND_ACCESS8(HW_CMP_DACCR_ADDR(x), BP_CMP_DACCR_VRSEL) = (v))
/*@}*/

/*!
 * @name Register CMP_DACCR, field DACEN[7] (RW)
 *
 * Enables the DAC. When the DAC is disabled, it is powered down to conserve
 * power.
 *
 * Values:
 * - 0 - DAC is disabled.
 * - 1 - DAC is enabled.
 */
/*@{*/
#define BP_CMP_DACCR_DACEN   (7U)          /*!< Bit position for CMP_DACCR_DACEN. */
#define BM_CMP_DACCR_DACEN   (0x80U)       /*!< Bit mask for CMP_DACCR_DACEN. */
#define BS_CMP_DACCR_DACEN   (1U)          /*!< Bit field size in bits for CMP_DACCR_DACEN. */

/*! @brief Read current value of the CMP_DACCR_DACEN field. */
#define BR_CMP_DACCR_DACEN(x) (BITBAND_ACCESS8(HW_CMP_DACCR_ADDR(x), BP_CMP_DACCR_DACEN))

/*! @brief Format value for bitfield CMP_DACCR_DACEN. */
#define BF_CMP_DACCR_DACEN(v) ((uint8_t)((uint8_t)(v) << BP_CMP_DACCR_DACEN) & BM_CMP_DACCR_DACEN)

/*! @brief Set the DACEN field to a new value. */
#define BW_CMP_DACCR_DACEN(x, v) (BITBAND_ACCESS8(HW_CMP_DACCR_ADDR(x), BP_CMP_DACCR_DACEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_CMP_MUXCR - MUX Control Register
 ******************************************************************************/

/*!
 * @brief HW_CMP_MUXCR - MUX Control Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_cmp_muxcr
{
    uint8_t U;
    struct _hw_cmp_muxcr_bitfields
    {
        uint8_t MSEL : 3;              /*!< [2:0] Minus Input Mux Control */
        uint8_t PSEL : 3;              /*!< [5:3] Plus Input Mux Control */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t PSTM : 1;              /*!< [7] Pass Through Mode Enable */
    } B;
} hw_cmp_muxcr_t;

/*!
 * @name Constants and macros for entire CMP_MUXCR register
 */
/*@{*/
#define HW_CMP_MUXCR_ADDR(x)     ((uint32_t)(x) + 0x5U)

#define HW_CMP_MUXCR(x)          (*(__IO hw_cmp_muxcr_t *) HW_CMP_MUXCR_ADDR(x))
#define HW_CMP_MUXCR_RD(x)       (HW_CMP_MUXCR(x).U)
#define HW_CMP_MUXCR_WR(x, v)    (HW_CMP_MUXCR(x).U = (v))
#define HW_CMP_MUXCR_SET(x, v)   (HW_CMP_MUXCR_WR(x, HW_CMP_MUXCR_RD(x) |  (v)))
#define HW_CMP_MUXCR_CLR(x, v)   (HW_CMP_MUXCR_WR(x, HW_CMP_MUXCR_RD(x) & ~(v)))
#define HW_CMP_MUXCR_TOG(x, v)   (HW_CMP_MUXCR_WR(x, HW_CMP_MUXCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMP_MUXCR bitfields
 */

/*!
 * @name Register CMP_MUXCR, field MSEL[2:0] (RW)
 *
 * Determines which input is selected for the minus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 000 - IN0
 * - 001 - IN1
 * - 010 - IN2
 * - 011 - IN3
 * - 100 - IN4
 * - 101 - IN5
 * - 110 - IN6
 * - 111 - IN7
 */
/*@{*/
#define BP_CMP_MUXCR_MSEL    (0U)          /*!< Bit position for CMP_MUXCR_MSEL. */
#define BM_CMP_MUXCR_MSEL    (0x07U)       /*!< Bit mask for CMP_MUXCR_MSEL. */
#define BS_CMP_MUXCR_MSEL    (3U)          /*!< Bit field size in bits for CMP_MUXCR_MSEL. */

/*! @brief Read current value of the CMP_MUXCR_MSEL field. */
#define BR_CMP_MUXCR_MSEL(x) (HW_CMP_MUXCR(x).B.MSEL)

/*! @brief Format value for bitfield CMP_MUXCR_MSEL. */
#define BF_CMP_MUXCR_MSEL(v) ((uint8_t)((uint8_t)(v) << BP_CMP_MUXCR_MSEL) & BM_CMP_MUXCR_MSEL)

/*! @brief Set the MSEL field to a new value. */
#define BW_CMP_MUXCR_MSEL(x, v) (HW_CMP_MUXCR_WR(x, (HW_CMP_MUXCR_RD(x) & ~BM_CMP_MUXCR_MSEL) | BF_CMP_MUXCR_MSEL(v)))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSEL[5:3] (RW)
 *
 * Determines which input is selected for the plus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 000 - IN0
 * - 001 - IN1
 * - 010 - IN2
 * - 011 - IN3
 * - 100 - IN4
 * - 101 - IN5
 * - 110 - IN6
 * - 111 - IN7
 */
/*@{*/
#define BP_CMP_MUXCR_PSEL    (3U)          /*!< Bit position for CMP_MUXCR_PSEL. */
#define BM_CMP_MUXCR_PSEL    (0x38U)       /*!< Bit mask for CMP_MUXCR_PSEL. */
#define BS_CMP_MUXCR_PSEL    (3U)          /*!< Bit field size in bits for CMP_MUXCR_PSEL. */

/*! @brief Read current value of the CMP_MUXCR_PSEL field. */
#define BR_CMP_MUXCR_PSEL(x) (HW_CMP_MUXCR(x).B.PSEL)

/*! @brief Format value for bitfield CMP_MUXCR_PSEL. */
#define BF_CMP_MUXCR_PSEL(v) ((uint8_t)((uint8_t)(v) << BP_CMP_MUXCR_PSEL) & BM_CMP_MUXCR_PSEL)

/*! @brief Set the PSEL field to a new value. */
#define BW_CMP_MUXCR_PSEL(x, v) (HW_CMP_MUXCR_WR(x, (HW_CMP_MUXCR_RD(x) & ~BM_CMP_MUXCR_PSEL) | BF_CMP_MUXCR_PSEL(v)))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSTM[7] (RW)
 *
 * This bit is used to enable to MUX pass through mode. Pass through mode is
 * always available but for some devices this feature must be always disabled due to
 * the lack of package pins.
 *
 * Values:
 * - 0 - Pass Through Mode is disabled.
 * - 1 - Pass Through Mode is enabled.
 */
/*@{*/
#define BP_CMP_MUXCR_PSTM    (7U)          /*!< Bit position for CMP_MUXCR_PSTM. */
#define BM_CMP_MUXCR_PSTM    (0x80U)       /*!< Bit mask for CMP_MUXCR_PSTM. */
#define BS_CMP_MUXCR_PSTM    (1U)          /*!< Bit field size in bits for CMP_MUXCR_PSTM. */

/*! @brief Read current value of the CMP_MUXCR_PSTM field. */
#define BR_CMP_MUXCR_PSTM(x) (BITBAND_ACCESS8(HW_CMP_MUXCR_ADDR(x), BP_CMP_MUXCR_PSTM))

/*! @brief Format value for bitfield CMP_MUXCR_PSTM. */
#define BF_CMP_MUXCR_PSTM(v) ((uint8_t)((uint8_t)(v) << BP_CMP_MUXCR_PSTM) & BM_CMP_MUXCR_PSTM)

/*! @brief Set the PSTM field to a new value. */
#define BW_CMP_MUXCR_PSTM(x, v) (BITBAND_ACCESS8(HW_CMP_MUXCR_ADDR(x), BP_CMP_MUXCR_PSTM) = (v))
/*@}*/

/*******************************************************************************
 * hw_cmp_t - module struct
 ******************************************************************************/
/*!
 * @brief All CMP module registers.
 */
#pragma pack(1)
typedef struct _hw_cmp
{
    __IO hw_cmp_cr0_t CR0;                 /*!< [0x0] CMP Control Register 0 */
    __IO hw_cmp_cr1_t CR1;                 /*!< [0x1] CMP Control Register 1 */
    __IO hw_cmp_fpr_t FPR;                 /*!< [0x2] CMP Filter Period Register */
    __IO hw_cmp_scr_t SCR;                 /*!< [0x3] CMP Status and Control Register */
    __IO hw_cmp_daccr_t DACCR;             /*!< [0x4] DAC Control Register */
    __IO hw_cmp_muxcr_t MUXCR;             /*!< [0x5] MUX Control Register */
} hw_cmp_t;
#pragma pack()

/*! @brief Macro to access all CMP registers. */
/*! @param x CMP module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_CMP_REGS(CMP0_BASE)</code>. */
#define HW_CMP_REGS(x) (*(hw_cmp_t *)(x))

/*
 * MK64F12 CMT
 *
 * Carrier Modulator Transmitter
 *
 * Registers defined in this header file:
 * - HW_CMT_CGH1 - CMT Carrier Generator High Data Register 1
 * - HW_CMT_CGL1 - CMT Carrier Generator Low Data Register 1
 * - HW_CMT_CGH2 - CMT Carrier Generator High Data Register 2
 * - HW_CMT_CGL2 - CMT Carrier Generator Low Data Register 2
 * - HW_CMT_OC - CMT Output Control Register
 * - HW_CMT_MSC - CMT Modulator Status and Control Register
 * - HW_CMT_CMD1 - CMT Modulator Data Register Mark High
 * - HW_CMT_CMD2 - CMT Modulator Data Register Mark Low
 * - HW_CMT_CMD3 - CMT Modulator Data Register Space High
 * - HW_CMT_CMD4 - CMT Modulator Data Register Space Low
 * - HW_CMT_PPS - CMT Primary Prescaler Register
 * - HW_CMT_DMA - CMT Direct Memory Access Register
 *
 * - hw_cmt_t - Struct containing all module registers.
 */

#define HW_CMT_INSTANCE_COUNT (1U) /*!< Number of instances of the CMT module. */
#define HW_CMT (0U) /*!< Instance number for CMT. */

/*******************************************************************************
 * HW_CMT_CGH1 - CMT Carrier Generator High Data Register 1
 ******************************************************************************/

/*!
 * @brief HW_CMT_CGH1 - CMT Carrier Generator High Data Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contains the primary high value for generating the carrier
 * output.
 */
typedef union _hw_cmt_cgh1
{
    uint8_t U;
    struct _hw_cmt_cgh1_bitfields
    {
        uint8_t PH : 8;                /*!< [7:0] Primary Carrier High Time Data Value */
    } B;
} hw_cmt_cgh1_t;

/*!
 * @name Constants and macros for entire CMT_CGH1 register
 */
/*@{*/
#define HW_CMT_CGH1_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_CMT_CGH1(x)           (*(__IO hw_cmt_cgh1_t *) HW_CMT_CGH1_ADDR(x))
#define HW_CMT_CGH1_RD(x)        (HW_CMT_CGH1(x).U)
#define HW_CMT_CGH1_WR(x, v)     (HW_CMT_CGH1(x).U = (v))
#define HW_CMT_CGH1_SET(x, v)    (HW_CMT_CGH1_WR(x, HW_CMT_CGH1_RD(x) |  (v)))
#define HW_CMT_CGH1_CLR(x, v)    (HW_CMT_CGH1_WR(x, HW_CMT_CGH1_RD(x) & ~(v)))
#define HW_CMT_CGH1_TOG(x, v)    (HW_CMT_CGH1_WR(x, HW_CMT_CGH1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_CGH1 bitfields
 */

/*!
 * @name Register CMT_CGH1, field PH[7:0] (RW)
 *
 * Contains the number of input clocks required to generate the carrier high
 * time period. When operating in Time mode, this register is always selected. When
 * operating in FSK mode, this register and the secondary register pair are
 * alternately selected under the control of the modulator. The primary carrier high
 * time value is undefined out of reset. This register must be written to nonzero
 * values before the carrier generator is enabled to avoid spurious results.
 */
/*@{*/
#define BP_CMT_CGH1_PH       (0U)          /*!< Bit position for CMT_CGH1_PH. */
#define BM_CMT_CGH1_PH       (0xFFU)       /*!< Bit mask for CMT_CGH1_PH. */
#define BS_CMT_CGH1_PH       (8U)          /*!< Bit field size in bits for CMT_CGH1_PH. */

/*! @brief Read current value of the CMT_CGH1_PH field. */
#define BR_CMT_CGH1_PH(x)    (HW_CMT_CGH1(x).U)

/*! @brief Format value for bitfield CMT_CGH1_PH. */
#define BF_CMT_CGH1_PH(v)    ((uint8_t)((uint8_t)(v) << BP_CMT_CGH1_PH) & BM_CMT_CGH1_PH)

/*! @brief Set the PH field to a new value. */
#define BW_CMT_CGH1_PH(x, v) (HW_CMT_CGH1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CMT_CGL1 - CMT Carrier Generator Low Data Register 1
 ******************************************************************************/

/*!
 * @brief HW_CMT_CGL1 - CMT Carrier Generator Low Data Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contains the primary low value for generating the carrier
 * output.
 */
typedef union _hw_cmt_cgl1
{
    uint8_t U;
    struct _hw_cmt_cgl1_bitfields
    {
        uint8_t PL : 8;                /*!< [7:0] Primary Carrier Low Time Data Value */
    } B;
} hw_cmt_cgl1_t;

/*!
 * @name Constants and macros for entire CMT_CGL1 register
 */
/*@{*/
#define HW_CMT_CGL1_ADDR(x)      ((uint32_t)(x) + 0x1U)

#define HW_CMT_CGL1(x)           (*(__IO hw_cmt_cgl1_t *) HW_CMT_CGL1_ADDR(x))
#define HW_CMT_CGL1_RD(x)        (HW_CMT_CGL1(x).U)
#define HW_CMT_CGL1_WR(x, v)     (HW_CMT_CGL1(x).U = (v))
#define HW_CMT_CGL1_SET(x, v)    (HW_CMT_CGL1_WR(x, HW_CMT_CGL1_RD(x) |  (v)))
#define HW_CMT_CGL1_CLR(x, v)    (HW_CMT_CGL1_WR(x, HW_CMT_CGL1_RD(x) & ~(v)))
#define HW_CMT_CGL1_TOG(x, v)    (HW_CMT_CGL1_WR(x, HW_CMT_CGL1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_CGL1 bitfields
 */

/*!
 * @name Register CMT_CGL1, field PL[7:0] (RW)
 *
 * Contains the number of input clocks required to generate the carrier low time
 * period. When operating in Time mode, this register is always selected. When
 * operating in FSK mode, this register and the secondary register pair are
 * alternately selected under the control of the modulator. The primary carrier low
 * time value is undefined out of reset. This register must be written to nonzero
 * values before the carrier generator is enabled to avoid spurious results.
 */
/*@{*/
#define BP_CMT_CGL1_PL       (0U)          /*!< Bit position for CMT_CGL1_PL. */
#define BM_CMT_CGL1_PL       (0xFFU)       /*!< Bit mask for CMT_CGL1_PL. */
#define BS_CMT_CGL1_PL       (8U)          /*!< Bit field size in bits for CMT_CGL1_PL. */

/*! @brief Read current value of the CMT_CGL1_PL field. */
#define BR_CMT_CGL1_PL(x)    (HW_CMT_CGL1(x).U)

/*! @brief Format value for bitfield CMT_CGL1_PL. */
#define BF_CMT_CGL1_PL(v)    ((uint8_t)((uint8_t)(v) << BP_CMT_CGL1_PL) & BM_CMT_CGL1_PL)

/*! @brief Set the PL field to a new value. */
#define BW_CMT_CGL1_PL(x, v) (HW_CMT_CGL1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CMT_CGH2 - CMT Carrier Generator High Data Register 2
 ******************************************************************************/

/*!
 * @brief HW_CMT_CGH2 - CMT Carrier Generator High Data Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contains the secondary high value for generating the
 * carrier output.
 */
typedef union _hw_cmt_cgh2
{
    uint8_t U;
    struct _hw_cmt_cgh2_bitfields
    {
        uint8_t SH : 8;                /*!< [7:0] Secondary Carrier High Time Data Value */
    } B;
} hw_cmt_cgh2_t;

/*!
 * @name Constants and macros for entire CMT_CGH2 register
 */
/*@{*/
#define HW_CMT_CGH2_ADDR(x)      ((uint32_t)(x) + 0x2U)

#define HW_CMT_CGH2(x)           (*(__IO hw_cmt_cgh2_t *) HW_CMT_CGH2_ADDR(x))
#define HW_CMT_CGH2_RD(x)        (HW_CMT_CGH2(x).U)
#define HW_CMT_CGH2_WR(x, v)     (HW_CMT_CGH2(x).U = (v))
#define HW_CMT_CGH2_SET(x, v)    (HW_CMT_CGH2_WR(x, HW_CMT_CGH2_RD(x) |  (v)))
#define HW_CMT_CGH2_CLR(x, v)    (HW_CMT_CGH2_WR(x, HW_CMT_CGH2_RD(x) & ~(v)))
#define HW_CMT_CGH2_TOG(x, v)    (HW_CMT_CGH2_WR(x, HW_CMT_CGH2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_CGH2 bitfields
 */

/*!
 * @name Register CMT_CGH2, field SH[7:0] (RW)
 *
 * Contains the number of input clocks required to generate the carrier high
 * time period. When operating in Time mode, this register is never selected. When
 * operating in FSK mode, this register and the primary register pair are
 * alternately selected under control of the modulator. The secondary carrier high time
 * value is undefined out of reset. This register must be written to nonzero
 * values before the carrier generator is enabled when operating in FSK mode.
 */
/*@{*/
#define BP_CMT_CGH2_SH       (0U)          /*!< Bit position for CMT_CGH2_SH. */
#define BM_CMT_CGH2_SH       (0xFFU)       /*!< Bit mask for CMT_CGH2_SH. */
#define BS_CMT_CGH2_SH       (8U)          /*!< Bit field size in bits for CMT_CGH2_SH. */

/*! @brief Read current value of the CMT_CGH2_SH field. */
#define BR_CMT_CGH2_SH(x)    (HW_CMT_CGH2(x).U)

/*! @brief Format value for bitfield CMT_CGH2_SH. */
#define BF_CMT_CGH2_SH(v)    ((uint8_t)((uint8_t)(v) << BP_CMT_CGH2_SH) & BM_CMT_CGH2_SH)

/*! @brief Set the SH field to a new value. */
#define BW_CMT_CGH2_SH(x, v) (HW_CMT_CGH2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CMT_CGL2 - CMT Carrier Generator Low Data Register 2
 ******************************************************************************/

/*!
 * @brief HW_CMT_CGL2 - CMT Carrier Generator Low Data Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This data register contains the secondary low value for generating the
 * carrier output.
 */
typedef union _hw_cmt_cgl2
{
    uint8_t U;
    struct _hw_cmt_cgl2_bitfields
    {
        uint8_t SL : 8;                /*!< [7:0] Secondary Carrier Low Time Data Value */
    } B;
} hw_cmt_cgl2_t;

/*!
 * @name Constants and macros for entire CMT_CGL2 register
 */
/*@{*/
#define HW_CMT_CGL2_ADDR(x)      ((uint32_t)(x) + 0x3U)

#define HW_CMT_CGL2(x)           (*(__IO hw_cmt_cgl2_t *) HW_CMT_CGL2_ADDR(x))
#define HW_CMT_CGL2_RD(x)        (HW_CMT_CGL2(x).U)
#define HW_CMT_CGL2_WR(x, v)     (HW_CMT_CGL2(x).U = (v))
#define HW_CMT_CGL2_SET(x, v)    (HW_CMT_CGL2_WR(x, HW_CMT_CGL2_RD(x) |  (v)))
#define HW_CMT_CGL2_CLR(x, v)    (HW_CMT_CGL2_WR(x, HW_CMT_CGL2_RD(x) & ~(v)))
#define HW_CMT_CGL2_TOG(x, v)    (HW_CMT_CGL2_WR(x, HW_CMT_CGL2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_CGL2 bitfields
 */

/*!
 * @name Register CMT_CGL2, field SL[7:0] (RW)
 *
 * Contains the number of input clocks required to generate the carrier low time
 * period. When operating in Time mode, this register is never selected. When
 * operating in FSK mode, this register and the primary register pair are
 * alternately selected under the control of the modulator. The secondary carrier low time
 * value is undefined out of reset. This register must be written to nonzero
 * values before the carrier generator is enabled when operating in FSK mode.
 */
/*@{*/
#define BP_CMT_CGL2_SL       (0U)          /*!< Bit position for CMT_CGL2_SL. */
#define BM_CMT_CGL2_SL       (0xFFU)       /*!< Bit mask for CMT_CGL2_SL. */
#define BS_CMT_CGL2_SL       (8U)          /*!< Bit field size in bits for CMT_CGL2_SL. */

/*! @brief Read current value of the CMT_CGL2_SL field. */
#define BR_CMT_CGL2_SL(x)    (HW_CMT_CGL2(x).U)

/*! @brief Format value for bitfield CMT_CGL2_SL. */
#define BF_CMT_CGL2_SL(v)    ((uint8_t)((uint8_t)(v) << BP_CMT_CGL2_SL) & BM_CMT_CGL2_SL)

/*! @brief Set the SL field to a new value. */
#define BW_CMT_CGL2_SL(x, v) (HW_CMT_CGL2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CMT_OC - CMT Output Control Register
 ******************************************************************************/

/*!
 * @brief HW_CMT_OC - CMT Output Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is used to control the IRO signal of the CMT module.
 */
typedef union _hw_cmt_oc
{
    uint8_t U;
    struct _hw_cmt_oc_bitfields
    {
        uint8_t RESERVED0 : 5;         /*!< [4:0]  */
        uint8_t IROPEN : 1;            /*!< [5] IRO Pin Enable */
        uint8_t CMTPOL : 1;            /*!< [6] CMT Output Polarity */
        uint8_t IROL : 1;              /*!< [7] IRO Latch Control */
    } B;
} hw_cmt_oc_t;

/*!
 * @name Constants and macros for entire CMT_OC register
 */
/*@{*/
#define HW_CMT_OC_ADDR(x)        ((uint32_t)(x) + 0x4U)

#define HW_CMT_OC(x)             (*(__IO hw_cmt_oc_t *) HW_CMT_OC_ADDR(x))
#define HW_CMT_OC_RD(x)          (HW_CMT_OC(x).U)
#define HW_CMT_OC_WR(x, v)       (HW_CMT_OC(x).U = (v))
#define HW_CMT_OC_SET(x, v)      (HW_CMT_OC_WR(x, HW_CMT_OC_RD(x) |  (v)))
#define HW_CMT_OC_CLR(x, v)      (HW_CMT_OC_WR(x, HW_CMT_OC_RD(x) & ~(v)))
#define HW_CMT_OC_TOG(x, v)      (HW_CMT_OC_WR(x, HW_CMT_OC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_OC bitfields
 */

/*!
 * @name Register CMT_OC, field IROPEN[5] (RW)
 *
 * Enables and disables the IRO signal. When the IRO signal is enabled, it is an
 * output that drives out either the CMT transmitter output or the state of IROL
 * depending on whether MSC[MCGEN] is set or not. Also, the state of output is
 * either inverted or non-inverted, depending on the state of CMTPOL. When the IRO
 * signal is disabled, it is in a high-impedance state and is unable to draw any
 * current. This signal is disabled during reset.
 *
 * Values:
 * - 0 - The IRO signal is disabled.
 * - 1 - The IRO signal is enabled as output.
 */
/*@{*/
#define BP_CMT_OC_IROPEN     (5U)          /*!< Bit position for CMT_OC_IROPEN. */
#define BM_CMT_OC_IROPEN     (0x20U)       /*!< Bit mask for CMT_OC_IROPEN. */
#define BS_CMT_OC_IROPEN     (1U)          /*!< Bit field size in bits for CMT_OC_IROPEN. */

/*! @brief Read current value of the CMT_OC_IROPEN field. */
#define BR_CMT_OC_IROPEN(x)  (BITBAND_ACCESS8(HW_CMT_OC_ADDR(x), BP_CMT_OC_IROPEN))

/*! @brief Format value for bitfield CMT_OC_IROPEN. */
#define BF_CMT_OC_IROPEN(v)  ((uint8_t)((uint8_t)(v) << BP_CMT_OC_IROPEN) & BM_CMT_OC_IROPEN)

/*! @brief Set the IROPEN field to a new value. */
#define BW_CMT_OC_IROPEN(x, v) (BITBAND_ACCESS8(HW_CMT_OC_ADDR(x), BP_CMT_OC_IROPEN) = (v))
/*@}*/

/*!
 * @name Register CMT_OC, field CMTPOL[6] (RW)
 *
 * Controls the polarity of the IRO signal.
 *
 * Values:
 * - 0 - The IRO signal is active-low.
 * - 1 - The IRO signal is active-high.
 */
/*@{*/
#define BP_CMT_OC_CMTPOL     (6U)          /*!< Bit position for CMT_OC_CMTPOL. */
#define BM_CMT_OC_CMTPOL     (0x40U)       /*!< Bit mask for CMT_OC_CMTPOL. */
#define BS_CMT_OC_CMTPOL     (1U)          /*!< Bit field size in bits for CMT_OC_CMTPOL. */

/*! @brief Read current value of the CMT_OC_CMTPOL field. */
#define BR_CMT_OC_CMTPOL(x)  (BITBAND_ACCESS8(HW_CMT_OC_ADDR(x), BP_CMT_OC_CMTPOL))

/*! @brief Format value for bitfield CMT_OC_CMTPOL. */
#define BF_CMT_OC_CMTPOL(v)  ((uint8_t)((uint8_t)(v) << BP_CMT_OC_CMTPOL) & BM_CMT_OC_CMTPOL)

/*! @brief Set the CMTPOL field to a new value. */
#define BW_CMT_OC_CMTPOL(x, v) (BITBAND_ACCESS8(HW_CMT_OC_ADDR(x), BP_CMT_OC_CMTPOL) = (v))
/*@}*/

/*!
 * @name Register CMT_OC, field IROL[7] (RW)
 *
 * Reads the state of the IRO latch. Writing to IROL changes the state of the
 * IRO signal when MSC[MCGEN] is cleared and IROPEN is set.
 */
/*@{*/
#define BP_CMT_OC_IROL       (7U)          /*!< Bit position for CMT_OC_IROL. */
#define BM_CMT_OC_IROL       (0x80U)       /*!< Bit mask for CMT_OC_IROL. */
#define BS_CMT_OC_IROL       (1U)          /*!< Bit field size in bits for CMT_OC_IROL. */

/*! @brief Read current value of the CMT_OC_IROL field. */
#define BR_CMT_OC_IROL(x)    (BITBAND_ACCESS8(HW_CMT_OC_ADDR(x), BP_CMT_OC_IROL))

/*! @brief Format value for bitfield CMT_OC_IROL. */
#define BF_CMT_OC_IROL(v)    ((uint8_t)((uint8_t)(v) << BP_CMT_OC_IROL) & BM_CMT_OC_IROL)

/*! @brief Set the IROL field to a new value. */
#define BW_CMT_OC_IROL(x, v) (BITBAND_ACCESS8(HW_CMT_OC_ADDR(x), BP_CMT_OC_IROL) = (v))
/*@}*/

/*******************************************************************************
 * HW_CMT_MSC - CMT Modulator Status and Control Register
 ******************************************************************************/

/*!
 * @brief HW_CMT_MSC - CMT Modulator Status and Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the modulator and carrier generator enable (MCGEN),
 * end of cycle interrupt enable (EOCIE), FSK mode select (FSK), baseband enable
 * (BASE), extended space (EXSPC), prescaler (CMTDIV) bits, and the end of cycle
 * (EOCF) status bit.
 */
typedef union _hw_cmt_msc
{
    uint8_t U;
    struct _hw_cmt_msc_bitfields
    {
        uint8_t MCGEN : 1;             /*!< [0] Modulator and Carrier Generator Enable */
        uint8_t EOCIE : 1;             /*!< [1] End of Cycle Interrupt Enable */
        uint8_t FSK : 1;               /*!< [2] FSK Mode Select */
        uint8_t BASE : 1;              /*!< [3] Baseband Enable */
        uint8_t EXSPC : 1;             /*!< [4] Extended Space Enable */
        uint8_t CMTDIV : 2;            /*!< [6:5] CMT Clock Divide Prescaler */
        uint8_t EOCF : 1;              /*!< [7] End Of Cycle Status Flag */
    } B;
} hw_cmt_msc_t;

/*!
 * @name Constants and macros for entire CMT_MSC register
 */
/*@{*/
#define HW_CMT_MSC_ADDR(x)       ((uint32_t)(x) + 0x5U)

#define HW_CMT_MSC(x)            (*(__IO hw_cmt_msc_t *) HW_CMT_MSC_ADDR(x))
#define HW_CMT_MSC_RD(x)         (HW_CMT_MSC(x).U)
#define HW_CMT_MSC_WR(x, v)      (HW_CMT_MSC(x).U = (v))
#define HW_CMT_MSC_SET(x, v)     (HW_CMT_MSC_WR(x, HW_CMT_MSC_RD(x) |  (v)))
#define HW_CMT_MSC_CLR(x, v)     (HW_CMT_MSC_WR(x, HW_CMT_MSC_RD(x) & ~(v)))
#define HW_CMT_MSC_TOG(x, v)     (HW_CMT_MSC_WR(x, HW_CMT_MSC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_MSC bitfields
 */

/*!
 * @name Register CMT_MSC, field MCGEN[0] (RW)
 *
 * Setting MCGEN will initialize the carrier generator and modulator and will
 * enable all clocks. When enabled, the carrier generator and modulator will
 * function continuously. When MCGEN is cleared, the current modulator cycle will be
 * allowed to expire before all carrier and modulator clocks are disabled to save
 * power and the modulator output is forced low. To prevent spurious operation,
 * the user should initialize all data and control registers before enabling the
 * system.
 *
 * Values:
 * - 0 - Modulator and carrier generator disabled
 * - 1 - Modulator and carrier generator enabled
 */
/*@{*/
#define BP_CMT_MSC_MCGEN     (0U)          /*!< Bit position for CMT_MSC_MCGEN. */
#define BM_CMT_MSC_MCGEN     (0x01U)       /*!< Bit mask for CMT_MSC_MCGEN. */
#define BS_CMT_MSC_MCGEN     (1U)          /*!< Bit field size in bits for CMT_MSC_MCGEN. */

/*! @brief Read current value of the CMT_MSC_MCGEN field. */
#define BR_CMT_MSC_MCGEN(x)  (BITBAND_ACCESS8(HW_CMT_MSC_ADDR(x), BP_CMT_MSC_MCGEN))

/*! @brief Format value for bitfield CMT_MSC_MCGEN. */
#define BF_CMT_MSC_MCGEN(v)  ((uint8_t)((uint8_t)(v) << BP_CMT_MSC_MCGEN) & BM_CMT_MSC_MCGEN)

/*! @brief Set the MCGEN field to a new value. */
#define BW_CMT_MSC_MCGEN(x, v) (BITBAND_ACCESS8(HW_CMT_MSC_ADDR(x), BP_CMT_MSC_MCGEN) = (v))
/*@}*/

/*!
 * @name Register CMT_MSC, field EOCIE[1] (RW)
 *
 * Requests to enable a CPU interrupt when EOCF is set if EOCIE is high.
 *
 * Values:
 * - 0 - CPU interrupt is disabled.
 * - 1 - CPU interrupt is enabled.
 */
/*@{*/
#define BP_CMT_MSC_EOCIE     (1U)          /*!< Bit position for CMT_MSC_EOCIE. */
#define BM_CMT_MSC_EOCIE     (0x02U)       /*!< Bit mask for CMT_MSC_EOCIE. */
#define BS_CMT_MSC_EOCIE     (1U)          /*!< Bit field size in bits for CMT_MSC_EOCIE. */

/*! @brief Read current value of the CMT_MSC_EOCIE field. */
#define BR_CMT_MSC_EOCIE(x)  (BITBAND_ACCESS8(HW_CMT_MSC_ADDR(x), BP_CMT_MSC_EOCIE))

/*! @brief Format value for bitfield CMT_MSC_EOCIE. */
#define BF_CMT_MSC_EOCIE(v)  ((uint8_t)((uint8_t)(v) << BP_CMT_MSC_EOCIE) & BM_CMT_MSC_EOCIE)

/*! @brief Set the EOCIE field to a new value. */
#define BW_CMT_MSC_EOCIE(x, v) (BITBAND_ACCESS8(HW_CMT_MSC_ADDR(x), BP_CMT_MSC_EOCIE) = (v))
/*@}*/

/*!
 * @name Register CMT_MSC, field FSK[2] (RW)
 *
 * Enables FSK operation.
 *
 * Values:
 * - 0 - The CMT operates in Time or Baseband mode.
 * - 1 - The CMT operates in FSK mode.
 */
/*@{*/
#define BP_CMT_MSC_FSK       (2U)          /*!< Bit position for CMT_MSC_FSK. */
#define BM_CMT_MSC_FSK       (0x04U)       /*!< Bit mask for CMT_MSC_FSK. */
#define BS_CMT_MSC_FSK       (1U)          /*!< Bit field size in bits for CMT_MSC_FSK. */

/*! @brief Read current value of the CMT_MSC_FSK field. */
#define BR_CMT_MSC_FSK(x)    (BITBAND_ACCESS8(HW_CMT_MSC_ADDR(x), BP_CMT_MSC_FSK))

/*! @brief Format value for bitfield CMT_MSC_FSK. */
#define BF_CMT_MSC_FSK(v)    ((uint8_t)((uint8_t)(v) << BP_CMT_MSC_FSK) & BM_CMT_MSC_FSK)

/*! @brief Set the FSK field to a new value. */
#define BW_CMT_MSC_FSK(x, v) (BITBAND_ACCESS8(HW_CMT_MSC_ADDR(x), BP_CMT_MSC_FSK) = (v))
/*@}*/

/*!
 * @name Register CMT_MSC, field BASE[3] (RW)
 *
 * When set, BASE disables the carrier generator and forces the carrier output
 * high for generation of baseband protocols. When BASE is cleared, the carrier
 * generator is enabled and the carrier output toggles at the frequency determined
 * by values stored in the carrier data registers. This field is cleared by
 * reset. This field is not double-buffered and must not be written to during a
 * transmission.
 *
 * Values:
 * - 0 - Baseband mode is disabled.
 * - 1 - Baseband mode is enabled.
 */
/*@{*/
#define BP_CMT_MSC_BASE      (3U)          /*!< Bit position for CMT_MSC_BASE. */
#define BM_CMT_MSC_BASE      (0x08U)       /*!< Bit mask for CMT_MSC_BASE. */
#define BS_CMT_MSC_BASE      (1U)          /*!< Bit field size in bits for CMT_MSC_BASE. */

/*! @brief Read current value of the CMT_MSC_BASE field. */
#define BR_CMT_MSC_BASE(x)   (BITBAND_ACCESS8(HW_CMT_MSC_ADDR(x), BP_CMT_MSC_BASE))

/*! @brief Format value for bitfield CMT_MSC_BASE. */
#define BF_CMT_MSC_BASE(v)   ((uint8_t)((uint8_t)(v) << BP_CMT_MSC_BASE) & BM_CMT_MSC_BASE)

/*! @brief Set the BASE field to a new value. */
#define BW_CMT_MSC_BASE(x, v) (BITBAND_ACCESS8(HW_CMT_MSC_ADDR(x), BP_CMT_MSC_BASE) = (v))
/*@}*/

/*!
 * @name Register CMT_MSC, field EXSPC[4] (RW)
 *
 * Enables the extended space operation.
 *
 * Values:
 * - 0 - Extended space is disabled.
 * - 1 - Extended space is enabled.
 */
/*@{*/
#define BP_CMT_MSC_EXSPC     (4U)          /*!< Bit position for CMT_MSC_EXSPC. */
#define BM_CMT_MSC_EXSPC     (0x10U)       /*!< Bit mask for CMT_MSC_EXSPC. */
#define BS_CMT_MSC_EXSPC     (1U)          /*!< Bit field size in bits for CMT_MSC_EXSPC. */

/*! @brief Read current value of the CMT_MSC_EXSPC field. */
#define BR_CMT_MSC_EXSPC(x)  (BITBAND_ACCESS8(HW_CMT_MSC_ADDR(x), BP_CMT_MSC_EXSPC))

/*! @brief Format value for bitfield CMT_MSC_EXSPC. */
#define BF_CMT_MSC_EXSPC(v)  ((uint8_t)((uint8_t)(v) << BP_CMT_MSC_EXSPC) & BM_CMT_MSC_EXSPC)

/*! @brief Set the EXSPC field to a new value. */
#define BW_CMT_MSC_EXSPC(x, v) (BITBAND_ACCESS8(HW_CMT_MSC_ADDR(x), BP_CMT_MSC_EXSPC) = (v))
/*@}*/

/*!
 * @name Register CMT_MSC, field CMTDIV[6:5] (RW)
 *
 * Causes the CMT to be clocked at the IF signal frequency, or the IF frequency
 * divided by 2 ,4, or 8 . This field must not be changed during a transmission
 * because it is not double-buffered.
 *
 * Values:
 * - 00 - IF * 1
 * - 01 - IF * 2
 * - 10 - IF * 4
 * - 11 - IF * 8
 */
/*@{*/
#define BP_CMT_MSC_CMTDIV    (5U)          /*!< Bit position for CMT_MSC_CMTDIV. */
#define BM_CMT_MSC_CMTDIV    (0x60U)       /*!< Bit mask for CMT_MSC_CMTDIV. */
#define BS_CMT_MSC_CMTDIV    (2U)          /*!< Bit field size in bits for CMT_MSC_CMTDIV. */

/*! @brief Read current value of the CMT_MSC_CMTDIV field. */
#define BR_CMT_MSC_CMTDIV(x) (HW_CMT_MSC(x).B.CMTDIV)

/*! @brief Format value for bitfield CMT_MSC_CMTDIV. */
#define BF_CMT_MSC_CMTDIV(v) ((uint8_t)((uint8_t)(v) << BP_CMT_MSC_CMTDIV) & BM_CMT_MSC_CMTDIV)

/*! @brief Set the CMTDIV field to a new value. */
#define BW_CMT_MSC_CMTDIV(x, v) (HW_CMT_MSC_WR(x, (HW_CMT_MSC_RD(x) & ~BM_CMT_MSC_CMTDIV) | BF_CMT_MSC_CMTDIV(v)))
/*@}*/

/*!
 * @name Register CMT_MSC, field EOCF[7] (RO)
 *
 * Sets when: The modulator is not currently active and MCGEN is set to begin
 * the initial CMT transmission. At the end of each modulation cycle while MCGEN is
 * set. This is recognized when a match occurs between the contents of the space
 * period register and the down counter. At this time, the counter is
 * initialized with, possibly new contents of the mark period buffer, CMD1 and CMD2, and
 * the space period register is loaded with, possibly new contents of the space
 * period buffer, CMD3 and CMD4. This flag is cleared by reading MSC followed by an
 * access of CMD2 or CMD4, or by the DMA transfer.
 *
 * Values:
 * - 0 - End of modulation cycle has not occured since the flag last cleared.
 * - 1 - End of modulator cycle has occurred.
 */
/*@{*/
#define BP_CMT_MSC_EOCF      (7U)          /*!< Bit position for CMT_MSC_EOCF. */
#define BM_CMT_MSC_EOCF      (0x80U)       /*!< Bit mask for CMT_MSC_EOCF. */
#define BS_CMT_MSC_EOCF      (1U)          /*!< Bit field size in bits for CMT_MSC_EOCF. */

/*! @brief Read current value of the CMT_MSC_EOCF field. */
#define BR_CMT_MSC_EOCF(x)   (BITBAND_ACCESS8(HW_CMT_MSC_ADDR(x), BP_CMT_MSC_EOCF))
/*@}*/

/*******************************************************************************
 * HW_CMT_CMD1 - CMT Modulator Data Register Mark High
 ******************************************************************************/

/*!
 * @brief HW_CMT_CMD1 - CMT Modulator Data Register Mark High (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the modulator down counter
 * upon the completion of a modulation period.
 */
typedef union _hw_cmt_cmd1
{
    uint8_t U;
    struct _hw_cmt_cmd1_bitfields
    {
        uint8_t MB : 8;                /*!< [7:0]  */
    } B;
} hw_cmt_cmd1_t;

/*!
 * @name Constants and macros for entire CMT_CMD1 register
 */
/*@{*/
#define HW_CMT_CMD1_ADDR(x)      ((uint32_t)(x) + 0x6U)

#define HW_CMT_CMD1(x)           (*(__IO hw_cmt_cmd1_t *) HW_CMT_CMD1_ADDR(x))
#define HW_CMT_CMD1_RD(x)        (HW_CMT_CMD1(x).U)
#define HW_CMT_CMD1_WR(x, v)     (HW_CMT_CMD1(x).U = (v))
#define HW_CMT_CMD1_SET(x, v)    (HW_CMT_CMD1_WR(x, HW_CMT_CMD1_RD(x) |  (v)))
#define HW_CMT_CMD1_CLR(x, v)    (HW_CMT_CMD1_WR(x, HW_CMT_CMD1_RD(x) & ~(v)))
#define HW_CMT_CMD1_TOG(x, v)    (HW_CMT_CMD1_WR(x, HW_CMT_CMD1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_CMD1 bitfields
 */

/*!
 * @name Register CMT_CMD1, field MB[7:0] (RW)
 *
 * Controls the upper mark periods of the modulator for all modes.
 */
/*@{*/
#define BP_CMT_CMD1_MB       (0U)          /*!< Bit position for CMT_CMD1_MB. */
#define BM_CMT_CMD1_MB       (0xFFU)       /*!< Bit mask for CMT_CMD1_MB. */
#define BS_CMT_CMD1_MB       (8U)          /*!< Bit field size in bits for CMT_CMD1_MB. */

/*! @brief Read current value of the CMT_CMD1_MB field. */
#define BR_CMT_CMD1_MB(x)    (HW_CMT_CMD1(x).U)

/*! @brief Format value for bitfield CMT_CMD1_MB. */
#define BF_CMT_CMD1_MB(v)    ((uint8_t)((uint8_t)(v) << BP_CMT_CMD1_MB) & BM_CMT_CMD1_MB)

/*! @brief Set the MB field to a new value. */
#define BW_CMT_CMD1_MB(x, v) (HW_CMT_CMD1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CMT_CMD2 - CMT Modulator Data Register Mark Low
 ******************************************************************************/

/*!
 * @brief HW_CMT_CMD2 - CMT Modulator Data Register Mark Low (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the modulator down counter
 * upon the completion of a modulation period.
 */
typedef union _hw_cmt_cmd2
{
    uint8_t U;
    struct _hw_cmt_cmd2_bitfields
    {
        uint8_t MB : 8;                /*!< [7:0]  */
    } B;
} hw_cmt_cmd2_t;

/*!
 * @name Constants and macros for entire CMT_CMD2 register
 */
/*@{*/
#define HW_CMT_CMD2_ADDR(x)      ((uint32_t)(x) + 0x7U)

#define HW_CMT_CMD2(x)           (*(__IO hw_cmt_cmd2_t *) HW_CMT_CMD2_ADDR(x))
#define HW_CMT_CMD2_RD(x)        (HW_CMT_CMD2(x).U)
#define HW_CMT_CMD2_WR(x, v)     (HW_CMT_CMD2(x).U = (v))
#define HW_CMT_CMD2_SET(x, v)    (HW_CMT_CMD2_WR(x, HW_CMT_CMD2_RD(x) |  (v)))
#define HW_CMT_CMD2_CLR(x, v)    (HW_CMT_CMD2_WR(x, HW_CMT_CMD2_RD(x) & ~(v)))
#define HW_CMT_CMD2_TOG(x, v)    (HW_CMT_CMD2_WR(x, HW_CMT_CMD2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_CMD2 bitfields
 */

/*!
 * @name Register CMT_CMD2, field MB[7:0] (RW)
 *
 * Controls the lower mark periods of the modulator for all modes.
 */
/*@{*/
#define BP_CMT_CMD2_MB       (0U)          /*!< Bit position for CMT_CMD2_MB. */
#define BM_CMT_CMD2_MB       (0xFFU)       /*!< Bit mask for CMT_CMD2_MB. */
#define BS_CMT_CMD2_MB       (8U)          /*!< Bit field size in bits for CMT_CMD2_MB. */

/*! @brief Read current value of the CMT_CMD2_MB field. */
#define BR_CMT_CMD2_MB(x)    (HW_CMT_CMD2(x).U)

/*! @brief Format value for bitfield CMT_CMD2_MB. */
#define BF_CMT_CMD2_MB(v)    ((uint8_t)((uint8_t)(v) << BP_CMT_CMD2_MB) & BM_CMT_CMD2_MB)

/*! @brief Set the MB field to a new value. */
#define BW_CMT_CMD2_MB(x, v) (HW_CMT_CMD2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CMT_CMD3 - CMT Modulator Data Register Space High
 ******************************************************************************/

/*!
 * @brief HW_CMT_CMD3 - CMT Modulator Data Register Space High (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the space period register
 * upon the completion of a modulation period.
 */
typedef union _hw_cmt_cmd3
{
    uint8_t U;
    struct _hw_cmt_cmd3_bitfields
    {
        uint8_t SB : 8;                /*!< [7:0]  */
    } B;
} hw_cmt_cmd3_t;

/*!
 * @name Constants and macros for entire CMT_CMD3 register
 */
/*@{*/
#define HW_CMT_CMD3_ADDR(x)      ((uint32_t)(x) + 0x8U)

#define HW_CMT_CMD3(x)           (*(__IO hw_cmt_cmd3_t *) HW_CMT_CMD3_ADDR(x))
#define HW_CMT_CMD3_RD(x)        (HW_CMT_CMD3(x).U)
#define HW_CMT_CMD3_WR(x, v)     (HW_CMT_CMD3(x).U = (v))
#define HW_CMT_CMD3_SET(x, v)    (HW_CMT_CMD3_WR(x, HW_CMT_CMD3_RD(x) |  (v)))
#define HW_CMT_CMD3_CLR(x, v)    (HW_CMT_CMD3_WR(x, HW_CMT_CMD3_RD(x) & ~(v)))
#define HW_CMT_CMD3_TOG(x, v)    (HW_CMT_CMD3_WR(x, HW_CMT_CMD3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_CMD3 bitfields
 */

/*!
 * @name Register CMT_CMD3, field SB[7:0] (RW)
 *
 * Controls the upper space periods of the modulator for all modes.
 */
/*@{*/
#define BP_CMT_CMD3_SB       (0U)          /*!< Bit position for CMT_CMD3_SB. */
#define BM_CMT_CMD3_SB       (0xFFU)       /*!< Bit mask for CMT_CMD3_SB. */
#define BS_CMT_CMD3_SB       (8U)          /*!< Bit field size in bits for CMT_CMD3_SB. */

/*! @brief Read current value of the CMT_CMD3_SB field. */
#define BR_CMT_CMD3_SB(x)    (HW_CMT_CMD3(x).U)

/*! @brief Format value for bitfield CMT_CMD3_SB. */
#define BF_CMT_CMD3_SB(v)    ((uint8_t)((uint8_t)(v) << BP_CMT_CMD3_SB) & BM_CMT_CMD3_SB)

/*! @brief Set the SB field to a new value. */
#define BW_CMT_CMD3_SB(x, v) (HW_CMT_CMD3_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CMT_CMD4 - CMT Modulator Data Register Space Low
 ******************************************************************************/

/*!
 * @brief HW_CMT_CMD4 - CMT Modulator Data Register Space Low (RW)
 *
 * Reset value: 0x00U
 *
 * The contents of this register are transferred to the space period register
 * upon the completion of a modulation period.
 */
typedef union _hw_cmt_cmd4
{
    uint8_t U;
    struct _hw_cmt_cmd4_bitfields
    {
        uint8_t SB : 8;                /*!< [7:0]  */
    } B;
} hw_cmt_cmd4_t;

/*!
 * @name Constants and macros for entire CMT_CMD4 register
 */
/*@{*/
#define HW_CMT_CMD4_ADDR(x)      ((uint32_t)(x) + 0x9U)

#define HW_CMT_CMD4(x)           (*(__IO hw_cmt_cmd4_t *) HW_CMT_CMD4_ADDR(x))
#define HW_CMT_CMD4_RD(x)        (HW_CMT_CMD4(x).U)
#define HW_CMT_CMD4_WR(x, v)     (HW_CMT_CMD4(x).U = (v))
#define HW_CMT_CMD4_SET(x, v)    (HW_CMT_CMD4_WR(x, HW_CMT_CMD4_RD(x) |  (v)))
#define HW_CMT_CMD4_CLR(x, v)    (HW_CMT_CMD4_WR(x, HW_CMT_CMD4_RD(x) & ~(v)))
#define HW_CMT_CMD4_TOG(x, v)    (HW_CMT_CMD4_WR(x, HW_CMT_CMD4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_CMD4 bitfields
 */

/*!
 * @name Register CMT_CMD4, field SB[7:0] (RW)
 *
 * Controls the lower space periods of the modulator for all modes.
 */
/*@{*/
#define BP_CMT_CMD4_SB       (0U)          /*!< Bit position for CMT_CMD4_SB. */
#define BM_CMT_CMD4_SB       (0xFFU)       /*!< Bit mask for CMT_CMD4_SB. */
#define BS_CMT_CMD4_SB       (8U)          /*!< Bit field size in bits for CMT_CMD4_SB. */

/*! @brief Read current value of the CMT_CMD4_SB field. */
#define BR_CMT_CMD4_SB(x)    (HW_CMT_CMD4(x).U)

/*! @brief Format value for bitfield CMT_CMD4_SB. */
#define BF_CMT_CMD4_SB(v)    ((uint8_t)((uint8_t)(v) << BP_CMT_CMD4_SB) & BM_CMT_CMD4_SB)

/*! @brief Set the SB field to a new value. */
#define BW_CMT_CMD4_SB(x, v) (HW_CMT_CMD4_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CMT_PPS - CMT Primary Prescaler Register
 ******************************************************************************/

/*!
 * @brief HW_CMT_PPS - CMT Primary Prescaler Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is used to set the Primary Prescaler Divider field (PPSDIV).
 */
typedef union _hw_cmt_pps
{
    uint8_t U;
    struct _hw_cmt_pps_bitfields
    {
        uint8_t PPSDIV : 4;            /*!< [3:0] Primary Prescaler Divider */
        uint8_t RESERVED0 : 4;         /*!< [7:4]  */
    } B;
} hw_cmt_pps_t;

/*!
 * @name Constants and macros for entire CMT_PPS register
 */
/*@{*/
#define HW_CMT_PPS_ADDR(x)       ((uint32_t)(x) + 0xAU)

#define HW_CMT_PPS(x)            (*(__IO hw_cmt_pps_t *) HW_CMT_PPS_ADDR(x))
#define HW_CMT_PPS_RD(x)         (HW_CMT_PPS(x).U)
#define HW_CMT_PPS_WR(x, v)      (HW_CMT_PPS(x).U = (v))
#define HW_CMT_PPS_SET(x, v)     (HW_CMT_PPS_WR(x, HW_CMT_PPS_RD(x) |  (v)))
#define HW_CMT_PPS_CLR(x, v)     (HW_CMT_PPS_WR(x, HW_CMT_PPS_RD(x) & ~(v)))
#define HW_CMT_PPS_TOG(x, v)     (HW_CMT_PPS_WR(x, HW_CMT_PPS_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_PPS bitfields
 */

/*!
 * @name Register CMT_PPS, field PPSDIV[3:0] (RW)
 *
 * Divides the CMT clock to generate the Intermediate Frequency clock enable to
 * the secondary prescaler.
 *
 * Values:
 * - 0000 - Bus clock * 1
 * - 0001 - Bus clock * 2
 * - 0010 - Bus clock * 3
 * - 0011 - Bus clock * 4
 * - 0100 - Bus clock * 5
 * - 0101 - Bus clock * 6
 * - 0110 - Bus clock * 7
 * - 0111 - Bus clock * 8
 * - 1000 - Bus clock * 9
 * - 1001 - Bus clock * 10
 * - 1010 - Bus clock * 11
 * - 1011 - Bus clock * 12
 * - 1100 - Bus clock * 13
 * - 1101 - Bus clock * 14
 * - 1110 - Bus clock * 15
 * - 1111 - Bus clock * 16
 */
/*@{*/
#define BP_CMT_PPS_PPSDIV    (0U)          /*!< Bit position for CMT_PPS_PPSDIV. */
#define BM_CMT_PPS_PPSDIV    (0x0FU)       /*!< Bit mask for CMT_PPS_PPSDIV. */
#define BS_CMT_PPS_PPSDIV    (4U)          /*!< Bit field size in bits for CMT_PPS_PPSDIV. */

/*! @brief Read current value of the CMT_PPS_PPSDIV field. */
#define BR_CMT_PPS_PPSDIV(x) (HW_CMT_PPS(x).B.PPSDIV)

/*! @brief Format value for bitfield CMT_PPS_PPSDIV. */
#define BF_CMT_PPS_PPSDIV(v) ((uint8_t)((uint8_t)(v) << BP_CMT_PPS_PPSDIV) & BM_CMT_PPS_PPSDIV)

/*! @brief Set the PPSDIV field to a new value. */
#define BW_CMT_PPS_PPSDIV(x, v) (HW_CMT_PPS_WR(x, (HW_CMT_PPS_RD(x) & ~BM_CMT_PPS_PPSDIV) | BF_CMT_PPS_PPSDIV(v)))
/*@}*/

/*******************************************************************************
 * HW_CMT_DMA - CMT Direct Memory Access Register
 ******************************************************************************/

/*!
 * @brief HW_CMT_DMA - CMT Direct Memory Access Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is used to enable/disable direct memory access (DMA).
 */
typedef union _hw_cmt_dma
{
    uint8_t U;
    struct _hw_cmt_dma_bitfields
    {
        uint8_t DMA : 1;               /*!< [0] DMA Enable */
        uint8_t RESERVED0 : 7;         /*!< [7:1]  */
    } B;
} hw_cmt_dma_t;

/*!
 * @name Constants and macros for entire CMT_DMA register
 */
/*@{*/
#define HW_CMT_DMA_ADDR(x)       ((uint32_t)(x) + 0xBU)

#define HW_CMT_DMA(x)            (*(__IO hw_cmt_dma_t *) HW_CMT_DMA_ADDR(x))
#define HW_CMT_DMA_RD(x)         (HW_CMT_DMA(x).U)
#define HW_CMT_DMA_WR(x, v)      (HW_CMT_DMA(x).U = (v))
#define HW_CMT_DMA_SET(x, v)     (HW_CMT_DMA_WR(x, HW_CMT_DMA_RD(x) |  (v)))
#define HW_CMT_DMA_CLR(x, v)     (HW_CMT_DMA_WR(x, HW_CMT_DMA_RD(x) & ~(v)))
#define HW_CMT_DMA_TOG(x, v)     (HW_CMT_DMA_WR(x, HW_CMT_DMA_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CMT_DMA bitfields
 */

/*!
 * @name Register CMT_DMA, field DMA[0] (RW)
 *
 * Enables the DMA protocol.
 *
 * Values:
 * - 0 - DMA transfer request and done are disabled.
 * - 1 - DMA transfer request and done are enabled.
 */
/*@{*/
#define BP_CMT_DMA_DMA       (0U)          /*!< Bit position for CMT_DMA_DMA. */
#define BM_CMT_DMA_DMA       (0x01U)       /*!< Bit mask for CMT_DMA_DMA. */
#define BS_CMT_DMA_DMA       (1U)          /*!< Bit field size in bits for CMT_DMA_DMA. */

/*! @brief Read current value of the CMT_DMA_DMA field. */
#define BR_CMT_DMA_DMA(x)    (BITBAND_ACCESS8(HW_CMT_DMA_ADDR(x), BP_CMT_DMA_DMA))

/*! @brief Format value for bitfield CMT_DMA_DMA. */
#define BF_CMT_DMA_DMA(v)    ((uint8_t)((uint8_t)(v) << BP_CMT_DMA_DMA) & BM_CMT_DMA_DMA)

/*! @brief Set the DMA field to a new value. */
#define BW_CMT_DMA_DMA(x, v) (BITBAND_ACCESS8(HW_CMT_DMA_ADDR(x), BP_CMT_DMA_DMA) = (v))
/*@}*/

/*******************************************************************************
 * hw_cmt_t - module struct
 ******************************************************************************/
/*!
 * @brief All CMT module registers.
 */
#pragma pack(1)
typedef struct _hw_cmt
{
    __IO hw_cmt_cgh1_t CGH1;               /*!< [0x0] CMT Carrier Generator High Data Register 1 */
    __IO hw_cmt_cgl1_t CGL1;               /*!< [0x1] CMT Carrier Generator Low Data Register 1 */
    __IO hw_cmt_cgh2_t CGH2;               /*!< [0x2] CMT Carrier Generator High Data Register 2 */
    __IO hw_cmt_cgl2_t CGL2;               /*!< [0x3] CMT Carrier Generator Low Data Register 2 */
    __IO hw_cmt_oc_t OC;                   /*!< [0x4] CMT Output Control Register */
    __IO hw_cmt_msc_t MSC;                 /*!< [0x5] CMT Modulator Status and Control Register */
    __IO hw_cmt_cmd1_t CMD1;               /*!< [0x6] CMT Modulator Data Register Mark High */
    __IO hw_cmt_cmd2_t CMD2;               /*!< [0x7] CMT Modulator Data Register Mark Low */
    __IO hw_cmt_cmd3_t CMD3;               /*!< [0x8] CMT Modulator Data Register Space High */
    __IO hw_cmt_cmd4_t CMD4;               /*!< [0x9] CMT Modulator Data Register Space Low */
    __IO hw_cmt_pps_t PPS;                 /*!< [0xA] CMT Primary Prescaler Register */
    __IO hw_cmt_dma_t DMA;                 /*!< [0xB] CMT Direct Memory Access Register */
} hw_cmt_t;
#pragma pack()

/*! @brief Macro to access all CMT registers. */
/*! @param x CMT module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_CMT_REGS(CMT_BASE)</code>. */
#define HW_CMT_REGS(x) (*(hw_cmt_t *)(x))

/*
 * MK64F12 CRC
 *
 * Cyclic Redundancy Check
 *
 * Registers defined in this header file:
 * - HW_CRC_DATAL - CRC_DATAL register.
 * - HW_CRC_DATAH - CRC_DATAH register.
 * - HW_CRC_DATALL - CRC_DATALL register.
 * - HW_CRC_DATALU - CRC_DATALU register.
 * - HW_CRC_DATAHL - CRC_DATAHL register.
 * - HW_CRC_DATAHU - CRC_DATAHU register.
 * - HW_CRC_DATA - CRC Data register
 * - HW_CRC_GPOLY - CRC Polynomial register
 * - HW_CRC_GPOLYL - CRC_GPOLYL register.
 * - HW_CRC_GPOLYH - CRC_GPOLYH register.
 * - HW_CRC_GPOLYLL - CRC_GPOLYLL register.
 * - HW_CRC_GPOLYLU - CRC_GPOLYLU register.
 * - HW_CRC_GPOLYHL - CRC_GPOLYHL register.
 * - HW_CRC_GPOLYHU - CRC_GPOLYHU register.
 * - HW_CRC_CTRL - CRC Control register
 * - HW_CRC_CTRLHU - CRC_CTRLHU register.
 *
 * - hw_crc_t - Struct containing all module registers.
 */

#define HW_CRC_INSTANCE_COUNT (1U) /*!< Number of instances of the CRC module. */
#define HW_CRC (0U) /*!< Instance number for CRC. */

/*******************************************************************************
 * HW_CRC_DATAL - CRC_DATAL register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_DATAL - CRC_DATAL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
typedef union _hw_crc_datal
{
    uint16_t U;
    struct _hw_crc_datal_bitfields
    {
        uint16_t DATAL : 16;           /*!< [15:0] DATAL stores the lower 16 bits of
                                        * the 16/32 bit CRC */
    } B;
} hw_crc_datal_t;

/*!
 * @name Constants and macros for entire CRC_DATAL register
 */
/*@{*/
#define HW_CRC_DATAL_ADDR(x)     ((uint32_t)(x) + 0x0U)

#define HW_CRC_DATAL(x)          (*(__IO hw_crc_datal_t *) HW_CRC_DATAL_ADDR(x))
#define HW_CRC_DATAL_RD(x)       (HW_CRC_DATAL(x).U)
#define HW_CRC_DATAL_WR(x, v)    (HW_CRC_DATAL(x).U = (v))
#define HW_CRC_DATAL_SET(x, v)   (HW_CRC_DATAL_WR(x, HW_CRC_DATAL_RD(x) |  (v)))
#define HW_CRC_DATAL_CLR(x, v)   (HW_CRC_DATAL_WR(x, HW_CRC_DATAL_RD(x) & ~(v)))
#define HW_CRC_DATAL_TOG(x, v)   (HW_CRC_DATAL_WR(x, HW_CRC_DATAL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATAL bitfields
 */

/*!
 * @name Register CRC_DATAL, field DATAL[15:0] (RW)
 */
/*@{*/
#define BP_CRC_DATAL_DATAL   (0U)          /*!< Bit position for CRC_DATAL_DATAL. */
#define BM_CRC_DATAL_DATAL   (0xFFFFU)     /*!< Bit mask for CRC_DATAL_DATAL. */
#define BS_CRC_DATAL_DATAL   (16U)         /*!< Bit field size in bits for CRC_DATAL_DATAL. */

/*! @brief Read current value of the CRC_DATAL_DATAL field. */
#define BR_CRC_DATAL_DATAL(x) (HW_CRC_DATAL(x).U)

/*! @brief Format value for bitfield CRC_DATAL_DATAL. */
#define BF_CRC_DATAL_DATAL(v) ((uint16_t)((uint16_t)(v) << BP_CRC_DATAL_DATAL) & BM_CRC_DATAL_DATAL)

/*! @brief Set the DATAL field to a new value. */
#define BW_CRC_DATAL_DATAL(x, v) (HW_CRC_DATAL_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_CRC_DATAH - CRC_DATAH register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_DATAH - CRC_DATAH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
typedef union _hw_crc_datah
{
    uint16_t U;
    struct _hw_crc_datah_bitfields
    {
        uint16_t DATAH : 16;           /*!< [15:0] DATAH stores the high 16 bits of the
                                        * 16/32 bit CRC */
    } B;
} hw_crc_datah_t;

/*!
 * @name Constants and macros for entire CRC_DATAH register
 */
/*@{*/
#define HW_CRC_DATAH_ADDR(x)     ((uint32_t)(x) + 0x2U)

#define HW_CRC_DATAH(x)          (*(__IO hw_crc_datah_t *) HW_CRC_DATAH_ADDR(x))
#define HW_CRC_DATAH_RD(x)       (HW_CRC_DATAH(x).U)
#define HW_CRC_DATAH_WR(x, v)    (HW_CRC_DATAH(x).U = (v))
#define HW_CRC_DATAH_SET(x, v)   (HW_CRC_DATAH_WR(x, HW_CRC_DATAH_RD(x) |  (v)))
#define HW_CRC_DATAH_CLR(x, v)   (HW_CRC_DATAH_WR(x, HW_CRC_DATAH_RD(x) & ~(v)))
#define HW_CRC_DATAH_TOG(x, v)   (HW_CRC_DATAH_WR(x, HW_CRC_DATAH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATAH bitfields
 */

/*!
 * @name Register CRC_DATAH, field DATAH[15:0] (RW)
 */
/*@{*/
#define BP_CRC_DATAH_DATAH   (0U)          /*!< Bit position for CRC_DATAH_DATAH. */
#define BM_CRC_DATAH_DATAH   (0xFFFFU)     /*!< Bit mask for CRC_DATAH_DATAH. */
#define BS_CRC_DATAH_DATAH   (16U)         /*!< Bit field size in bits for CRC_DATAH_DATAH. */

/*! @brief Read current value of the CRC_DATAH_DATAH field. */
#define BR_CRC_DATAH_DATAH(x) (HW_CRC_DATAH(x).U)

/*! @brief Format value for bitfield CRC_DATAH_DATAH. */
#define BF_CRC_DATAH_DATAH(v) ((uint16_t)((uint16_t)(v) << BP_CRC_DATAH_DATAH) & BM_CRC_DATAH_DATAH)

/*! @brief Set the DATAH field to a new value. */
#define BW_CRC_DATAH_DATAH(x, v) (HW_CRC_DATAH_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_CRC_DATALL - CRC_DATALL register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_DATALL - CRC_DATALL register. (RW)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_crc_datall
{
    uint8_t U;
    struct _hw_crc_datall_bitfields
    {
        uint8_t DATALL : 8;            /*!< [7:0] CRCLL stores the first 8 bits of the
                                        * 32 bit DATA */
    } B;
} hw_crc_datall_t;

/*!
 * @name Constants and macros for entire CRC_DATALL register
 */
/*@{*/
#define HW_CRC_DATALL_ADDR(x)    ((uint32_t)(x) + 0x0U)

#define HW_CRC_DATALL(x)         (*(__IO hw_crc_datall_t *) HW_CRC_DATALL_ADDR(x))
#define HW_CRC_DATALL_RD(x)      (HW_CRC_DATALL(x).U)
#define HW_CRC_DATALL_WR(x, v)   (HW_CRC_DATALL(x).U = (v))
#define HW_CRC_DATALL_SET(x, v)  (HW_CRC_DATALL_WR(x, HW_CRC_DATALL_RD(x) |  (v)))
#define HW_CRC_DATALL_CLR(x, v)  (HW_CRC_DATALL_WR(x, HW_CRC_DATALL_RD(x) & ~(v)))
#define HW_CRC_DATALL_TOG(x, v)  (HW_CRC_DATALL_WR(x, HW_CRC_DATALL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATALL bitfields
 */

/*!
 * @name Register CRC_DATALL, field DATALL[7:0] (RW)
 */
/*@{*/
#define BP_CRC_DATALL_DATALL (0U)          /*!< Bit position for CRC_DATALL_DATALL. */
#define BM_CRC_DATALL_DATALL (0xFFU)       /*!< Bit mask for CRC_DATALL_DATALL. */
#define BS_CRC_DATALL_DATALL (8U)          /*!< Bit field size in bits for CRC_DATALL_DATALL. */

/*! @brief Read current value of the CRC_DATALL_DATALL field. */
#define BR_CRC_DATALL_DATALL(x) (HW_CRC_DATALL(x).U)

/*! @brief Format value for bitfield CRC_DATALL_DATALL. */
#define BF_CRC_DATALL_DATALL(v) ((uint8_t)((uint8_t)(v) << BP_CRC_DATALL_DATALL) & BM_CRC_DATALL_DATALL)

/*! @brief Set the DATALL field to a new value. */
#define BW_CRC_DATALL_DATALL(x, v) (HW_CRC_DATALL_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_CRC_DATALU - CRC_DATALU register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_DATALU - CRC_DATALU register. (RW)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_crc_datalu
{
    uint8_t U;
    struct _hw_crc_datalu_bitfields
    {
        uint8_t DATALU : 8;            /*!< [7:0] DATALL stores the second 8 bits of the
                                        * 32 bit CRC */
    } B;
} hw_crc_datalu_t;

/*!
 * @name Constants and macros for entire CRC_DATALU register
 */
/*@{*/
#define HW_CRC_DATALU_ADDR(x)    ((uint32_t)(x) + 0x1U)

#define HW_CRC_DATALU(x)         (*(__IO hw_crc_datalu_t *) HW_CRC_DATALU_ADDR(x))
#define HW_CRC_DATALU_RD(x)      (HW_CRC_DATALU(x).U)
#define HW_CRC_DATALU_WR(x, v)   (HW_CRC_DATALU(x).U = (v))
#define HW_CRC_DATALU_SET(x, v)  (HW_CRC_DATALU_WR(x, HW_CRC_DATALU_RD(x) |  (v)))
#define HW_CRC_DATALU_CLR(x, v)  (HW_CRC_DATALU_WR(x, HW_CRC_DATALU_RD(x) & ~(v)))
#define HW_CRC_DATALU_TOG(x, v)  (HW_CRC_DATALU_WR(x, HW_CRC_DATALU_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATALU bitfields
 */

/*!
 * @name Register CRC_DATALU, field DATALU[7:0] (RW)
 */
/*@{*/
#define BP_CRC_DATALU_DATALU (0U)          /*!< Bit position for CRC_DATALU_DATALU. */
#define BM_CRC_DATALU_DATALU (0xFFU)       /*!< Bit mask for CRC_DATALU_DATALU. */
#define BS_CRC_DATALU_DATALU (8U)          /*!< Bit field size in bits for CRC_DATALU_DATALU. */

/*! @brief Read current value of the CRC_DATALU_DATALU field. */
#define BR_CRC_DATALU_DATALU(x) (HW_CRC_DATALU(x).U)

/*! @brief Format value for bitfield CRC_DATALU_DATALU. */
#define BF_CRC_DATALU_DATALU(v) ((uint8_t)((uint8_t)(v) << BP_CRC_DATALU_DATALU) & BM_CRC_DATALU_DATALU)

/*! @brief Set the DATALU field to a new value. */
#define BW_CRC_DATALU_DATALU(x, v) (HW_CRC_DATALU_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_CRC_DATAHL - CRC_DATAHL register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_DATAHL - CRC_DATAHL register. (RW)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_crc_datahl
{
    uint8_t U;
    struct _hw_crc_datahl_bitfields
    {
        uint8_t DATAHL : 8;            /*!< [7:0] DATAHL stores the third 8 bits of the
                                        * 32 bit CRC */
    } B;
} hw_crc_datahl_t;

/*!
 * @name Constants and macros for entire CRC_DATAHL register
 */
/*@{*/
#define HW_CRC_DATAHL_ADDR(x)    ((uint32_t)(x) + 0x2U)

#define HW_CRC_DATAHL(x)         (*(__IO hw_crc_datahl_t *) HW_CRC_DATAHL_ADDR(x))
#define HW_CRC_DATAHL_RD(x)      (HW_CRC_DATAHL(x).U)
#define HW_CRC_DATAHL_WR(x, v)   (HW_CRC_DATAHL(x).U = (v))
#define HW_CRC_DATAHL_SET(x, v)  (HW_CRC_DATAHL_WR(x, HW_CRC_DATAHL_RD(x) |  (v)))
#define HW_CRC_DATAHL_CLR(x, v)  (HW_CRC_DATAHL_WR(x, HW_CRC_DATAHL_RD(x) & ~(v)))
#define HW_CRC_DATAHL_TOG(x, v)  (HW_CRC_DATAHL_WR(x, HW_CRC_DATAHL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATAHL bitfields
 */

/*!
 * @name Register CRC_DATAHL, field DATAHL[7:0] (RW)
 */
/*@{*/
#define BP_CRC_DATAHL_DATAHL (0U)          /*!< Bit position for CRC_DATAHL_DATAHL. */
#define BM_CRC_DATAHL_DATAHL (0xFFU)       /*!< Bit mask for CRC_DATAHL_DATAHL. */
#define BS_CRC_DATAHL_DATAHL (8U)          /*!< Bit field size in bits for CRC_DATAHL_DATAHL. */

/*! @brief Read current value of the CRC_DATAHL_DATAHL field. */
#define BR_CRC_DATAHL_DATAHL(x) (HW_CRC_DATAHL(x).U)

/*! @brief Format value for bitfield CRC_DATAHL_DATAHL. */
#define BF_CRC_DATAHL_DATAHL(v) ((uint8_t)((uint8_t)(v) << BP_CRC_DATAHL_DATAHL) & BM_CRC_DATAHL_DATAHL)

/*! @brief Set the DATAHL field to a new value. */
#define BW_CRC_DATAHL_DATAHL(x, v) (HW_CRC_DATAHL_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_CRC_DATAHU - CRC_DATAHU register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_DATAHU - CRC_DATAHU register. (RW)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_crc_datahu
{
    uint8_t U;
    struct _hw_crc_datahu_bitfields
    {
        uint8_t DATAHU : 8;            /*!< [7:0] DATAHU stores the fourth 8 bits of the
                                        * 32 bit CRC */
    } B;
} hw_crc_datahu_t;

/*!
 * @name Constants and macros for entire CRC_DATAHU register
 */
/*@{*/
#define HW_CRC_DATAHU_ADDR(x)    ((uint32_t)(x) + 0x3U)

#define HW_CRC_DATAHU(x)         (*(__IO hw_crc_datahu_t *) HW_CRC_DATAHU_ADDR(x))
#define HW_CRC_DATAHU_RD(x)      (HW_CRC_DATAHU(x).U)
#define HW_CRC_DATAHU_WR(x, v)   (HW_CRC_DATAHU(x).U = (v))
#define HW_CRC_DATAHU_SET(x, v)  (HW_CRC_DATAHU_WR(x, HW_CRC_DATAHU_RD(x) |  (v)))
#define HW_CRC_DATAHU_CLR(x, v)  (HW_CRC_DATAHU_WR(x, HW_CRC_DATAHU_RD(x) & ~(v)))
#define HW_CRC_DATAHU_TOG(x, v)  (HW_CRC_DATAHU_WR(x, HW_CRC_DATAHU_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATAHU bitfields
 */

/*!
 * @name Register CRC_DATAHU, field DATAHU[7:0] (RW)
 */
/*@{*/
#define BP_CRC_DATAHU_DATAHU (0U)          /*!< Bit position for CRC_DATAHU_DATAHU. */
#define BM_CRC_DATAHU_DATAHU (0xFFU)       /*!< Bit mask for CRC_DATAHU_DATAHU. */
#define BS_CRC_DATAHU_DATAHU (8U)          /*!< Bit field size in bits for CRC_DATAHU_DATAHU. */

/*! @brief Read current value of the CRC_DATAHU_DATAHU field. */
#define BR_CRC_DATAHU_DATAHU(x) (HW_CRC_DATAHU(x).U)

/*! @brief Format value for bitfield CRC_DATAHU_DATAHU. */
#define BF_CRC_DATAHU_DATAHU(v) ((uint8_t)((uint8_t)(v) << BP_CRC_DATAHU_DATAHU) & BM_CRC_DATAHU_DATAHU)

/*! @brief Set the DATAHU field to a new value. */
#define BW_CRC_DATAHU_DATAHU(x, v) (HW_CRC_DATAHU_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_CRC_DATA - CRC Data register
 ******************************************************************************/

/*!
 * @brief HW_CRC_DATA - CRC Data register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The CRC Data register contains the value of the seed, data, and checksum.
 * When CTRL[WAS] is set, any write to the data register is regarded as the seed
 * value. When CTRL[WAS] is cleared, any write to the data register is regarded as
 * data for general CRC computation. In 16-bit CRC mode, the HU and HL fields are
 * not used for programming the seed value, and reads of these fields return an
 * indeterminate value. In 32-bit CRC mode, all fields are used for programming
 * the seed value. When programming data values, the values can be written 8 bits,
 * 16 bits, or 32 bits at a time, provided all bytes are contiguous; with MSB of
 * data value written first. After all data values are written, the CRC result
 * can be read from this data register. In 16-bit CRC mode, the CRC result is
 * available in the LU and LL fields. In 32-bit CRC mode, all fields contain the
 * result. Reads of this register at any time return the intermediate CRC value,
 * provided the CRC module is configured.
 */
typedef union _hw_crc_data
{
    uint32_t U;
    struct _hw_crc_data_bitfields
    {
        uint32_t LL : 8;               /*!< [7:0] CRC Low Lower Byte */
        uint32_t LU : 8;               /*!< [15:8] CRC Low Upper Byte */
        uint32_t HL : 8;               /*!< [23:16] CRC High Lower Byte */
        uint32_t HU : 8;               /*!< [31:24] CRC High Upper Byte */
    } B;
} hw_crc_data_t;

/*!
 * @name Constants and macros for entire CRC_DATA register
 */
/*@{*/
#define HW_CRC_DATA_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_CRC_DATA(x)           (*(__IO hw_crc_data_t *) HW_CRC_DATA_ADDR(x))
#define HW_CRC_DATA_RD(x)        (HW_CRC_DATA(x).U)
#define HW_CRC_DATA_WR(x, v)     (HW_CRC_DATA(x).U = (v))
#define HW_CRC_DATA_SET(x, v)    (HW_CRC_DATA_WR(x, HW_CRC_DATA_RD(x) |  (v)))
#define HW_CRC_DATA_CLR(x, v)    (HW_CRC_DATA_WR(x, HW_CRC_DATA_RD(x) & ~(v)))
#define HW_CRC_DATA_TOG(x, v)    (HW_CRC_DATA_WR(x, HW_CRC_DATA_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATA bitfields
 */

/*!
 * @name Register CRC_DATA, field LL[7:0] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
#define BP_CRC_DATA_LL       (0U)          /*!< Bit position for CRC_DATA_LL. */
#define BM_CRC_DATA_LL       (0x000000FFU) /*!< Bit mask for CRC_DATA_LL. */
#define BS_CRC_DATA_LL       (8U)          /*!< Bit field size in bits for CRC_DATA_LL. */

/*! @brief Read current value of the CRC_DATA_LL field. */
#define BR_CRC_DATA_LL(x)    (HW_CRC_DATA(x).B.LL)

/*! @brief Format value for bitfield CRC_DATA_LL. */
#define BF_CRC_DATA_LL(v)    ((uint32_t)((uint32_t)(v) << BP_CRC_DATA_LL) & BM_CRC_DATA_LL)

/*! @brief Set the LL field to a new value. */
#define BW_CRC_DATA_LL(x, v) (HW_CRC_DATA_WR(x, (HW_CRC_DATA_RD(x) & ~BM_CRC_DATA_LL) | BF_CRC_DATA_LL(v)))
/*@}*/

/*!
 * @name Register CRC_DATA, field LU[15:8] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
#define BP_CRC_DATA_LU       (8U)          /*!< Bit position for CRC_DATA_LU. */
#define BM_CRC_DATA_LU       (0x0000FF00U) /*!< Bit mask for CRC_DATA_LU. */
#define BS_CRC_DATA_LU       (8U)          /*!< Bit field size in bits for CRC_DATA_LU. */

/*! @brief Read current value of the CRC_DATA_LU field. */
#define BR_CRC_DATA_LU(x)    (HW_CRC_DATA(x).B.LU)

/*! @brief Format value for bitfield CRC_DATA_LU. */
#define BF_CRC_DATA_LU(v)    ((uint32_t)((uint32_t)(v) << BP_CRC_DATA_LU) & BM_CRC_DATA_LU)

/*! @brief Set the LU field to a new value. */
#define BW_CRC_DATA_LU(x, v) (HW_CRC_DATA_WR(x, (HW_CRC_DATA_RD(x) & ~BM_CRC_DATA_LU) | BF_CRC_DATA_LU(v)))
/*@}*/

/*!
 * @name Register CRC_DATA, field HL[23:16] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
#define BP_CRC_DATA_HL       (16U)         /*!< Bit position for CRC_DATA_HL. */
#define BM_CRC_DATA_HL       (0x00FF0000U) /*!< Bit mask for CRC_DATA_HL. */
#define BS_CRC_DATA_HL       (8U)          /*!< Bit field size in bits for CRC_DATA_HL. */

/*! @brief Read current value of the CRC_DATA_HL field. */
#define BR_CRC_DATA_HL(x)    (HW_CRC_DATA(x).B.HL)

/*! @brief Format value for bitfield CRC_DATA_HL. */
#define BF_CRC_DATA_HL(v)    ((uint32_t)((uint32_t)(v) << BP_CRC_DATA_HL) & BM_CRC_DATA_HL)

/*! @brief Set the HL field to a new value. */
#define BW_CRC_DATA_HL(x, v) (HW_CRC_DATA_WR(x, (HW_CRC_DATA_RD(x) & ~BM_CRC_DATA_HL) | BF_CRC_DATA_HL(v)))
/*@}*/

/*!
 * @name Register CRC_DATA, field HU[31:24] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
#define BP_CRC_DATA_HU       (24U)         /*!< Bit position for CRC_DATA_HU. */
#define BM_CRC_DATA_HU       (0xFF000000U) /*!< Bit mask for CRC_DATA_HU. */
#define BS_CRC_DATA_HU       (8U)          /*!< Bit field size in bits for CRC_DATA_HU. */

/*! @brief Read current value of the CRC_DATA_HU field. */
#define BR_CRC_DATA_HU(x)    (HW_CRC_DATA(x).B.HU)

/*! @brief Format value for bitfield CRC_DATA_HU. */
#define BF_CRC_DATA_HU(v)    ((uint32_t)((uint32_t)(v) << BP_CRC_DATA_HU) & BM_CRC_DATA_HU)

/*! @brief Set the HU field to a new value. */
#define BW_CRC_DATA_HU(x, v) (HW_CRC_DATA_WR(x, (HW_CRC_DATA_RD(x) & ~BM_CRC_DATA_HU) | BF_CRC_DATA_HU(v)))
/*@}*/

/*******************************************************************************
 * HW_CRC_GPOLY - CRC Polynomial register
 ******************************************************************************/

/*!
 * @brief HW_CRC_GPOLY - CRC Polynomial register (RW)
 *
 * Reset value: 0x00001021U
 *
 * This register contains the value of the polynomial for the CRC calculation.
 * The HIGH field contains the upper 16 bits of the CRC polynomial, which are used
 * only in 32-bit CRC mode. Writes to the HIGH field are ignored in 16-bit CRC
 * mode. The LOW field contains the lower 16 bits of the CRC polynomial, which are
 * used in both 16- and 32-bit CRC modes.
 */
typedef union _hw_crc_gpoly
{
    uint32_t U;
    struct _hw_crc_gpoly_bitfields
    {
        uint32_t LOW : 16;             /*!< [15:0] Low Polynominal Half-word */
        uint32_t HIGH : 16;            /*!< [31:16] High Polynominal Half-word */
    } B;
} hw_crc_gpoly_t;

/*!
 * @name Constants and macros for entire CRC_GPOLY register
 */
/*@{*/
#define HW_CRC_GPOLY_ADDR(x)     ((uint32_t)(x) + 0x4U)

#define HW_CRC_GPOLY(x)          (*(__IO hw_crc_gpoly_t *) HW_CRC_GPOLY_ADDR(x))
#define HW_CRC_GPOLY_RD(x)       (HW_CRC_GPOLY(x).U)
#define HW_CRC_GPOLY_WR(x, v)    (HW_CRC_GPOLY(x).U = (v))
#define HW_CRC_GPOLY_SET(x, v)   (HW_CRC_GPOLY_WR(x, HW_CRC_GPOLY_RD(x) |  (v)))
#define HW_CRC_GPOLY_CLR(x, v)   (HW_CRC_GPOLY_WR(x, HW_CRC_GPOLY_RD(x) & ~(v)))
#define HW_CRC_GPOLY_TOG(x, v)   (HW_CRC_GPOLY_WR(x, HW_CRC_GPOLY_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLY bitfields
 */

/*!
 * @name Register CRC_GPOLY, field LOW[15:0] (RW)
 *
 * Writable and readable in both 32-bit and 16-bit CRC modes.
 */
/*@{*/
#define BP_CRC_GPOLY_LOW     (0U)          /*!< Bit position for CRC_GPOLY_LOW. */
#define BM_CRC_GPOLY_LOW     (0x0000FFFFU) /*!< Bit mask for CRC_GPOLY_LOW. */
#define BS_CRC_GPOLY_LOW     (16U)         /*!< Bit field size in bits for CRC_GPOLY_LOW. */

/*! @brief Read current value of the CRC_GPOLY_LOW field. */
#define BR_CRC_GPOLY_LOW(x)  (HW_CRC_GPOLY(x).B.LOW)

/*! @brief Format value for bitfield CRC_GPOLY_LOW. */
#define BF_CRC_GPOLY_LOW(v)  ((uint32_t)((uint32_t)(v) << BP_CRC_GPOLY_LOW) & BM_CRC_GPOLY_LOW)

/*! @brief Set the LOW field to a new value. */
#define BW_CRC_GPOLY_LOW(x, v) (HW_CRC_GPOLY_WR(x, (HW_CRC_GPOLY_RD(x) & ~BM_CRC_GPOLY_LOW) | BF_CRC_GPOLY_LOW(v)))
/*@}*/

/*!
 * @name Register CRC_GPOLY, field HIGH[31:16] (RW)
 *
 * Writable and readable in 32-bit CRC mode (CTRL[TCRC] is 1). This field is not
 * writable in 16-bit CRC mode (CTRL[TCRC] is 0).
 */
/*@{*/
#define BP_CRC_GPOLY_HIGH    (16U)         /*!< Bit position for CRC_GPOLY_HIGH. */
#define BM_CRC_GPOLY_HIGH    (0xFFFF0000U) /*!< Bit mask for CRC_GPOLY_HIGH. */
#define BS_CRC_GPOLY_HIGH    (16U)         /*!< Bit field size in bits for CRC_GPOLY_HIGH. */

/*! @brief Read current value of the CRC_GPOLY_HIGH field. */
#define BR_CRC_GPOLY_HIGH(x) (HW_CRC_GPOLY(x).B.HIGH)

/*! @brief Format value for bitfield CRC_GPOLY_HIGH. */
#define BF_CRC_GPOLY_HIGH(v) ((uint32_t)((uint32_t)(v) << BP_CRC_GPOLY_HIGH) & BM_CRC_GPOLY_HIGH)

/*! @brief Set the HIGH field to a new value. */
#define BW_CRC_GPOLY_HIGH(x, v) (HW_CRC_GPOLY_WR(x, (HW_CRC_GPOLY_RD(x) & ~BM_CRC_GPOLY_HIGH) | BF_CRC_GPOLY_HIGH(v)))
/*@}*/
/*******************************************************************************
 * HW_CRC_GPOLYL - CRC_GPOLYL register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_GPOLYL - CRC_GPOLYL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
typedef union _hw_crc_gpolyl
{
    uint16_t U;
    struct _hw_crc_gpolyl_bitfields
    {
        uint16_t GPOLYL : 16;          /*!< [15:0] POLYL stores the lower 16 bits of
                                        * the 16/32 bit CRC polynomial value */
    } B;
} hw_crc_gpolyl_t;

/*!
 * @name Constants and macros for entire CRC_GPOLYL register
 */
/*@{*/
#define HW_CRC_GPOLYL_ADDR(x)    ((uint32_t)(x) + 0x4U)

#define HW_CRC_GPOLYL(x)         (*(__IO hw_crc_gpolyl_t *) HW_CRC_GPOLYL_ADDR(x))
#define HW_CRC_GPOLYL_RD(x)      (HW_CRC_GPOLYL(x).U)
#define HW_CRC_GPOLYL_WR(x, v)   (HW_CRC_GPOLYL(x).U = (v))
#define HW_CRC_GPOLYL_SET(x, v)  (HW_CRC_GPOLYL_WR(x, HW_CRC_GPOLYL_RD(x) |  (v)))
#define HW_CRC_GPOLYL_CLR(x, v)  (HW_CRC_GPOLYL_WR(x, HW_CRC_GPOLYL_RD(x) & ~(v)))
#define HW_CRC_GPOLYL_TOG(x, v)  (HW_CRC_GPOLYL_WR(x, HW_CRC_GPOLYL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLYL bitfields
 */

/*!
 * @name Register CRC_GPOLYL, field GPOLYL[15:0] (RW)
 */
/*@{*/
#define BP_CRC_GPOLYL_GPOLYL (0U)          /*!< Bit position for CRC_GPOLYL_GPOLYL. */
#define BM_CRC_GPOLYL_GPOLYL (0xFFFFU)     /*!< Bit mask for CRC_GPOLYL_GPOLYL. */
#define BS_CRC_GPOLYL_GPOLYL (16U)         /*!< Bit field size in bits for CRC_GPOLYL_GPOLYL. */

/*! @brief Read current value of the CRC_GPOLYL_GPOLYL field. */
#define BR_CRC_GPOLYL_GPOLYL(x) (HW_CRC_GPOLYL(x).U)

/*! @brief Format value for bitfield CRC_GPOLYL_GPOLYL. */
#define BF_CRC_GPOLYL_GPOLYL(v) ((uint16_t)((uint16_t)(v) << BP_CRC_GPOLYL_GPOLYL) & BM_CRC_GPOLYL_GPOLYL)

/*! @brief Set the GPOLYL field to a new value. */
#define BW_CRC_GPOLYL_GPOLYL(x, v) (HW_CRC_GPOLYL_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_CRC_GPOLYH - CRC_GPOLYH register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_GPOLYH - CRC_GPOLYH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
typedef union _hw_crc_gpolyh
{
    uint16_t U;
    struct _hw_crc_gpolyh_bitfields
    {
        uint16_t GPOLYH : 16;          /*!< [15:0] POLYH stores the high 16 bits of
                                        * the 16/32 bit CRC polynomial value */
    } B;
} hw_crc_gpolyh_t;

/*!
 * @name Constants and macros for entire CRC_GPOLYH register
 */
/*@{*/
#define HW_CRC_GPOLYH_ADDR(x)    ((uint32_t)(x) + 0x6U)

#define HW_CRC_GPOLYH(x)         (*(__IO hw_crc_gpolyh_t *) HW_CRC_GPOLYH_ADDR(x))
#define HW_CRC_GPOLYH_RD(x)      (HW_CRC_GPOLYH(x).U)
#define HW_CRC_GPOLYH_WR(x, v)   (HW_CRC_GPOLYH(x).U = (v))
#define HW_CRC_GPOLYH_SET(x, v)  (HW_CRC_GPOLYH_WR(x, HW_CRC_GPOLYH_RD(x) |  (v)))
#define HW_CRC_GPOLYH_CLR(x, v)  (HW_CRC_GPOLYH_WR(x, HW_CRC_GPOLYH_RD(x) & ~(v)))
#define HW_CRC_GPOLYH_TOG(x, v)  (HW_CRC_GPOLYH_WR(x, HW_CRC_GPOLYH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLYH bitfields
 */

/*!
 * @name Register CRC_GPOLYH, field GPOLYH[15:0] (RW)
 */
/*@{*/
#define BP_CRC_GPOLYH_GPOLYH (0U)          /*!< Bit position for CRC_GPOLYH_GPOLYH. */
#define BM_CRC_GPOLYH_GPOLYH (0xFFFFU)     /*!< Bit mask for CRC_GPOLYH_GPOLYH. */
#define BS_CRC_GPOLYH_GPOLYH (16U)         /*!< Bit field size in bits for CRC_GPOLYH_GPOLYH. */

/*! @brief Read current value of the CRC_GPOLYH_GPOLYH field. */
#define BR_CRC_GPOLYH_GPOLYH(x) (HW_CRC_GPOLYH(x).U)

/*! @brief Format value for bitfield CRC_GPOLYH_GPOLYH. */
#define BF_CRC_GPOLYH_GPOLYH(v) ((uint16_t)((uint16_t)(v) << BP_CRC_GPOLYH_GPOLYH) & BM_CRC_GPOLYH_GPOLYH)

/*! @brief Set the GPOLYH field to a new value. */
#define BW_CRC_GPOLYH_GPOLYH(x, v) (HW_CRC_GPOLYH_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_CRC_GPOLYLL - CRC_GPOLYLL register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_GPOLYLL - CRC_GPOLYLL register. (RW)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_crc_gpolyll
{
    uint8_t U;
    struct _hw_crc_gpolyll_bitfields
    {
        uint8_t GPOLYLL : 8;           /*!< [7:0] POLYLL stores the first 8 bits of the
                                        * 32 bit CRC */
    } B;
} hw_crc_gpolyll_t;

/*!
 * @name Constants and macros for entire CRC_GPOLYLL register
 */
/*@{*/
#define HW_CRC_GPOLYLL_ADDR(x)   ((uint32_t)(x) + 0x4U)

#define HW_CRC_GPOLYLL(x)        (*(__IO hw_crc_gpolyll_t *) HW_CRC_GPOLYLL_ADDR(x))
#define HW_CRC_GPOLYLL_RD(x)     (HW_CRC_GPOLYLL(x).U)
#define HW_CRC_GPOLYLL_WR(x, v)  (HW_CRC_GPOLYLL(x).U = (v))
#define HW_CRC_GPOLYLL_SET(x, v) (HW_CRC_GPOLYLL_WR(x, HW_CRC_GPOLYLL_RD(x) |  (v)))
#define HW_CRC_GPOLYLL_CLR(x, v) (HW_CRC_GPOLYLL_WR(x, HW_CRC_GPOLYLL_RD(x) & ~(v)))
#define HW_CRC_GPOLYLL_TOG(x, v) (HW_CRC_GPOLYLL_WR(x, HW_CRC_GPOLYLL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLYLL bitfields
 */

/*!
 * @name Register CRC_GPOLYLL, field GPOLYLL[7:0] (RW)
 */
/*@{*/
#define BP_CRC_GPOLYLL_GPOLYLL (0U)        /*!< Bit position for CRC_GPOLYLL_GPOLYLL. */
#define BM_CRC_GPOLYLL_GPOLYLL (0xFFU)     /*!< Bit mask for CRC_GPOLYLL_GPOLYLL. */
#define BS_CRC_GPOLYLL_GPOLYLL (8U)        /*!< Bit field size in bits for CRC_GPOLYLL_GPOLYLL. */

/*! @brief Read current value of the CRC_GPOLYLL_GPOLYLL field. */
#define BR_CRC_GPOLYLL_GPOLYLL(x) (HW_CRC_GPOLYLL(x).U)

/*! @brief Format value for bitfield CRC_GPOLYLL_GPOLYLL. */
#define BF_CRC_GPOLYLL_GPOLYLL(v) ((uint8_t)((uint8_t)(v) << BP_CRC_GPOLYLL_GPOLYLL) & BM_CRC_GPOLYLL_GPOLYLL)

/*! @brief Set the GPOLYLL field to a new value. */
#define BW_CRC_GPOLYLL_GPOLYLL(x, v) (HW_CRC_GPOLYLL_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_CRC_GPOLYLU - CRC_GPOLYLU register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_GPOLYLU - CRC_GPOLYLU register. (RW)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_crc_gpolylu
{
    uint8_t U;
    struct _hw_crc_gpolylu_bitfields
    {
        uint8_t GPOLYLU : 8;           /*!< [7:0] POLYLL stores the second 8 bits of
                                        * the 32 bit CRC */
    } B;
} hw_crc_gpolylu_t;

/*!
 * @name Constants and macros for entire CRC_GPOLYLU register
 */
/*@{*/
#define HW_CRC_GPOLYLU_ADDR(x)   ((uint32_t)(x) + 0x5U)

#define HW_CRC_GPOLYLU(x)        (*(__IO hw_crc_gpolylu_t *) HW_CRC_GPOLYLU_ADDR(x))
#define HW_CRC_GPOLYLU_RD(x)     (HW_CRC_GPOLYLU(x).U)
#define HW_CRC_GPOLYLU_WR(x, v)  (HW_CRC_GPOLYLU(x).U = (v))
#define HW_CRC_GPOLYLU_SET(x, v) (HW_CRC_GPOLYLU_WR(x, HW_CRC_GPOLYLU_RD(x) |  (v)))
#define HW_CRC_GPOLYLU_CLR(x, v) (HW_CRC_GPOLYLU_WR(x, HW_CRC_GPOLYLU_RD(x) & ~(v)))
#define HW_CRC_GPOLYLU_TOG(x, v) (HW_CRC_GPOLYLU_WR(x, HW_CRC_GPOLYLU_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLYLU bitfields
 */

/*!
 * @name Register CRC_GPOLYLU, field GPOLYLU[7:0] (RW)
 */
/*@{*/
#define BP_CRC_GPOLYLU_GPOLYLU (0U)        /*!< Bit position for CRC_GPOLYLU_GPOLYLU. */
#define BM_CRC_GPOLYLU_GPOLYLU (0xFFU)     /*!< Bit mask for CRC_GPOLYLU_GPOLYLU. */
#define BS_CRC_GPOLYLU_GPOLYLU (8U)        /*!< Bit field size in bits for CRC_GPOLYLU_GPOLYLU. */

/*! @brief Read current value of the CRC_GPOLYLU_GPOLYLU field. */
#define BR_CRC_GPOLYLU_GPOLYLU(x) (HW_CRC_GPOLYLU(x).U)

/*! @brief Format value for bitfield CRC_GPOLYLU_GPOLYLU. */
#define BF_CRC_GPOLYLU_GPOLYLU(v) ((uint8_t)((uint8_t)(v) << BP_CRC_GPOLYLU_GPOLYLU) & BM_CRC_GPOLYLU_GPOLYLU)

/*! @brief Set the GPOLYLU field to a new value. */
#define BW_CRC_GPOLYLU_GPOLYLU(x, v) (HW_CRC_GPOLYLU_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_CRC_GPOLYHL - CRC_GPOLYHL register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_GPOLYHL - CRC_GPOLYHL register. (RW)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_crc_gpolyhl
{
    uint8_t U;
    struct _hw_crc_gpolyhl_bitfields
    {
        uint8_t GPOLYHL : 8;           /*!< [7:0] POLYHL stores the third 8 bits of the
                                        * 32 bit CRC */
    } B;
} hw_crc_gpolyhl_t;

/*!
 * @name Constants and macros for entire CRC_GPOLYHL register
 */
/*@{*/
#define HW_CRC_GPOLYHL_ADDR(x)   ((uint32_t)(x) + 0x6U)

#define HW_CRC_GPOLYHL(x)        (*(__IO hw_crc_gpolyhl_t *) HW_CRC_GPOLYHL_ADDR(x))
#define HW_CRC_GPOLYHL_RD(x)     (HW_CRC_GPOLYHL(x).U)
#define HW_CRC_GPOLYHL_WR(x, v)  (HW_CRC_GPOLYHL(x).U = (v))
#define HW_CRC_GPOLYHL_SET(x, v) (HW_CRC_GPOLYHL_WR(x, HW_CRC_GPOLYHL_RD(x) |  (v)))
#define HW_CRC_GPOLYHL_CLR(x, v) (HW_CRC_GPOLYHL_WR(x, HW_CRC_GPOLYHL_RD(x) & ~(v)))
#define HW_CRC_GPOLYHL_TOG(x, v) (HW_CRC_GPOLYHL_WR(x, HW_CRC_GPOLYHL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLYHL bitfields
 */

/*!
 * @name Register CRC_GPOLYHL, field GPOLYHL[7:0] (RW)
 */
/*@{*/
#define BP_CRC_GPOLYHL_GPOLYHL (0U)        /*!< Bit position for CRC_GPOLYHL_GPOLYHL. */
#define BM_CRC_GPOLYHL_GPOLYHL (0xFFU)     /*!< Bit mask for CRC_GPOLYHL_GPOLYHL. */
#define BS_CRC_GPOLYHL_GPOLYHL (8U)        /*!< Bit field size in bits for CRC_GPOLYHL_GPOLYHL. */

/*! @brief Read current value of the CRC_GPOLYHL_GPOLYHL field. */
#define BR_CRC_GPOLYHL_GPOLYHL(x) (HW_CRC_GPOLYHL(x).U)

/*! @brief Format value for bitfield CRC_GPOLYHL_GPOLYHL. */
#define BF_CRC_GPOLYHL_GPOLYHL(v) ((uint8_t)((uint8_t)(v) << BP_CRC_GPOLYHL_GPOLYHL) & BM_CRC_GPOLYHL_GPOLYHL)

/*! @brief Set the GPOLYHL field to a new value. */
#define BW_CRC_GPOLYHL_GPOLYHL(x, v) (HW_CRC_GPOLYHL_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_CRC_GPOLYHU - CRC_GPOLYHU register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_GPOLYHU - CRC_GPOLYHU register. (RW)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_crc_gpolyhu
{
    uint8_t U;
    struct _hw_crc_gpolyhu_bitfields
    {
        uint8_t GPOLYHU : 8;           /*!< [7:0] POLYHU stores the fourth 8 bits of
                                        * the 32 bit CRC */
    } B;
} hw_crc_gpolyhu_t;

/*!
 * @name Constants and macros for entire CRC_GPOLYHU register
 */
/*@{*/
#define HW_CRC_GPOLYHU_ADDR(x)   ((uint32_t)(x) + 0x7U)

#define HW_CRC_GPOLYHU(x)        (*(__IO hw_crc_gpolyhu_t *) HW_CRC_GPOLYHU_ADDR(x))
#define HW_CRC_GPOLYHU_RD(x)     (HW_CRC_GPOLYHU(x).U)
#define HW_CRC_GPOLYHU_WR(x, v)  (HW_CRC_GPOLYHU(x).U = (v))
#define HW_CRC_GPOLYHU_SET(x, v) (HW_CRC_GPOLYHU_WR(x, HW_CRC_GPOLYHU_RD(x) |  (v)))
#define HW_CRC_GPOLYHU_CLR(x, v) (HW_CRC_GPOLYHU_WR(x, HW_CRC_GPOLYHU_RD(x) & ~(v)))
#define HW_CRC_GPOLYHU_TOG(x, v) (HW_CRC_GPOLYHU_WR(x, HW_CRC_GPOLYHU_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLYHU bitfields
 */

/*!
 * @name Register CRC_GPOLYHU, field GPOLYHU[7:0] (RW)
 */
/*@{*/
#define BP_CRC_GPOLYHU_GPOLYHU (0U)        /*!< Bit position for CRC_GPOLYHU_GPOLYHU. */
#define BM_CRC_GPOLYHU_GPOLYHU (0xFFU)     /*!< Bit mask for CRC_GPOLYHU_GPOLYHU. */
#define BS_CRC_GPOLYHU_GPOLYHU (8U)        /*!< Bit field size in bits for CRC_GPOLYHU_GPOLYHU. */

/*! @brief Read current value of the CRC_GPOLYHU_GPOLYHU field. */
#define BR_CRC_GPOLYHU_GPOLYHU(x) (HW_CRC_GPOLYHU(x).U)

/*! @brief Format value for bitfield CRC_GPOLYHU_GPOLYHU. */
#define BF_CRC_GPOLYHU_GPOLYHU(v) ((uint8_t)((uint8_t)(v) << BP_CRC_GPOLYHU_GPOLYHU) & BM_CRC_GPOLYHU_GPOLYHU)

/*! @brief Set the GPOLYHU field to a new value. */
#define BW_CRC_GPOLYHU_GPOLYHU(x, v) (HW_CRC_GPOLYHU_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_CRC_CTRL - CRC Control register
 ******************************************************************************/

/*!
 * @brief HW_CRC_CTRL - CRC Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the configuration and working of the CRC module.
 * Appropriate bits must be set before starting a new CRC calculation. A new CRC
 * calculation is initialized by asserting CTRL[WAS] and then writing the seed into
 * the CRC data register.
 */
typedef union _hw_crc_ctrl
{
    uint32_t U;
    struct _hw_crc_ctrl_bitfields
    {
        uint32_t RESERVED0 : 24;       /*!< [23:0]  */
        uint32_t TCRC : 1;             /*!< [24]  */
        uint32_t WAS : 1;              /*!< [25] Write CRC Data Register As Seed */
        uint32_t FXOR : 1;             /*!< [26] Complement Read Of CRC Data Register */
        uint32_t RESERVED1 : 1;        /*!< [27]  */
        uint32_t TOTR : 2;             /*!< [29:28] Type Of Transpose For Read */
        uint32_t TOT : 2;              /*!< [31:30] Type Of Transpose For Writes */
    } B;
} hw_crc_ctrl_t;

/*!
 * @name Constants and macros for entire CRC_CTRL register
 */
/*@{*/
#define HW_CRC_CTRL_ADDR(x)      ((uint32_t)(x) + 0x8U)

#define HW_CRC_CTRL(x)           (*(__IO hw_crc_ctrl_t *) HW_CRC_CTRL_ADDR(x))
#define HW_CRC_CTRL_RD(x)        (HW_CRC_CTRL(x).U)
#define HW_CRC_CTRL_WR(x, v)     (HW_CRC_CTRL(x).U = (v))
#define HW_CRC_CTRL_SET(x, v)    (HW_CRC_CTRL_WR(x, HW_CRC_CTRL_RD(x) |  (v)))
#define HW_CRC_CTRL_CLR(x, v)    (HW_CRC_CTRL_WR(x, HW_CRC_CTRL_RD(x) & ~(v)))
#define HW_CRC_CTRL_TOG(x, v)    (HW_CRC_CTRL_WR(x, HW_CRC_CTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRL bitfields
 */

/*!
 * @name Register CRC_CTRL, field TCRC[24] (RW)
 *
 * Width of CRC protocol.
 *
 * Values:
 * - 0 - 16-bit CRC protocol.
 * - 1 - 32-bit CRC protocol.
 */
/*@{*/
#define BP_CRC_CTRL_TCRC     (24U)         /*!< Bit position for CRC_CTRL_TCRC. */
#define BM_CRC_CTRL_TCRC     (0x01000000U) /*!< Bit mask for CRC_CTRL_TCRC. */
#define BS_CRC_CTRL_TCRC     (1U)          /*!< Bit field size in bits for CRC_CTRL_TCRC. */

/*! @brief Read current value of the CRC_CTRL_TCRC field. */
#define BR_CRC_CTRL_TCRC(x)  (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR(x), BP_CRC_CTRL_TCRC))

/*! @brief Format value for bitfield CRC_CTRL_TCRC. */
#define BF_CRC_CTRL_TCRC(v)  ((uint32_t)((uint32_t)(v) << BP_CRC_CTRL_TCRC) & BM_CRC_CTRL_TCRC)

/*! @brief Set the TCRC field to a new value. */
#define BW_CRC_CTRL_TCRC(x, v) (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR(x), BP_CRC_CTRL_TCRC) = (v))
/*@}*/

/*!
 * @name Register CRC_CTRL, field WAS[25] (RW)
 *
 * When asserted, a value written to the CRC data register is considered a seed
 * value. When deasserted, a value written to the CRC data register is taken as
 * data for CRC computation.
 *
 * Values:
 * - 0 - Writes to the CRC data register are data values.
 * - 1 - Writes to the CRC data register are seed values.
 */
/*@{*/
#define BP_CRC_CTRL_WAS      (25U)         /*!< Bit position for CRC_CTRL_WAS. */
#define BM_CRC_CTRL_WAS      (0x02000000U) /*!< Bit mask for CRC_CTRL_WAS. */
#define BS_CRC_CTRL_WAS      (1U)          /*!< Bit field size in bits for CRC_CTRL_WAS. */

/*! @brief Read current value of the CRC_CTRL_WAS field. */
#define BR_CRC_CTRL_WAS(x)   (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR(x), BP_CRC_CTRL_WAS))

/*! @brief Format value for bitfield CRC_CTRL_WAS. */
#define BF_CRC_CTRL_WAS(v)   ((uint32_t)((uint32_t)(v) << BP_CRC_CTRL_WAS) & BM_CRC_CTRL_WAS)

/*! @brief Set the WAS field to a new value. */
#define BW_CRC_CTRL_WAS(x, v) (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR(x), BP_CRC_CTRL_WAS) = (v))
/*@}*/

/*!
 * @name Register CRC_CTRL, field FXOR[26] (RW)
 *
 * Some CRC protocols require the final checksum to be XORed with 0xFFFFFFFF or
 * 0xFFFF. Asserting this bit enables on the fly complementing of read data.
 *
 * Values:
 * - 0 - No XOR on reading.
 * - 1 - Invert or complement the read value of the CRC Data register.
 */
/*@{*/
#define BP_CRC_CTRL_FXOR     (26U)         /*!< Bit position for CRC_CTRL_FXOR. */
#define BM_CRC_CTRL_FXOR     (0x04000000U) /*!< Bit mask for CRC_CTRL_FXOR. */
#define BS_CRC_CTRL_FXOR     (1U)          /*!< Bit field size in bits for CRC_CTRL_FXOR. */

/*! @brief Read current value of the CRC_CTRL_FXOR field. */
#define BR_CRC_CTRL_FXOR(x)  (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR(x), BP_CRC_CTRL_FXOR))

/*! @brief Format value for bitfield CRC_CTRL_FXOR. */
#define BF_CRC_CTRL_FXOR(v)  ((uint32_t)((uint32_t)(v) << BP_CRC_CTRL_FXOR) & BM_CRC_CTRL_FXOR)

/*! @brief Set the FXOR field to a new value. */
#define BW_CRC_CTRL_FXOR(x, v) (BITBAND_ACCESS32(HW_CRC_CTRL_ADDR(x), BP_CRC_CTRL_FXOR) = (v))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOTR[29:28] (RW)
 *
 * Identifies the transpose configuration of the value read from the CRC Data
 * register. See the description of the transpose feature for the available
 * transpose options.
 *
 * Values:
 * - 00 - No transposition.
 * - 01 - Bits in bytes are transposed; bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
#define BP_CRC_CTRL_TOTR     (28U)         /*!< Bit position for CRC_CTRL_TOTR. */
#define BM_CRC_CTRL_TOTR     (0x30000000U) /*!< Bit mask for CRC_CTRL_TOTR. */
#define BS_CRC_CTRL_TOTR     (2U)          /*!< Bit field size in bits for CRC_CTRL_TOTR. */

/*! @brief Read current value of the CRC_CTRL_TOTR field. */
#define BR_CRC_CTRL_TOTR(x)  (HW_CRC_CTRL(x).B.TOTR)

/*! @brief Format value for bitfield CRC_CTRL_TOTR. */
#define BF_CRC_CTRL_TOTR(v)  ((uint32_t)((uint32_t)(v) << BP_CRC_CTRL_TOTR) & BM_CRC_CTRL_TOTR)

/*! @brief Set the TOTR field to a new value. */
#define BW_CRC_CTRL_TOTR(x, v) (HW_CRC_CTRL_WR(x, (HW_CRC_CTRL_RD(x) & ~BM_CRC_CTRL_TOTR) | BF_CRC_CTRL_TOTR(v)))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOT[31:30] (RW)
 *
 * Defines the transpose configuration of the data written to the CRC data
 * register. See the description of the transpose feature for the available transpose
 * options.
 *
 * Values:
 * - 00 - No transposition.
 * - 01 - Bits in bytes are transposed; bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
#define BP_CRC_CTRL_TOT      (30U)         /*!< Bit position for CRC_CTRL_TOT. */
#define BM_CRC_CTRL_TOT      (0xC0000000U) /*!< Bit mask for CRC_CTRL_TOT. */
#define BS_CRC_CTRL_TOT      (2U)          /*!< Bit field size in bits for CRC_CTRL_TOT. */

/*! @brief Read current value of the CRC_CTRL_TOT field. */
#define BR_CRC_CTRL_TOT(x)   (HW_CRC_CTRL(x).B.TOT)

/*! @brief Format value for bitfield CRC_CTRL_TOT. */
#define BF_CRC_CTRL_TOT(v)   ((uint32_t)((uint32_t)(v) << BP_CRC_CTRL_TOT) & BM_CRC_CTRL_TOT)

/*! @brief Set the TOT field to a new value. */
#define BW_CRC_CTRL_TOT(x, v) (HW_CRC_CTRL_WR(x, (HW_CRC_CTRL_RD(x) & ~BM_CRC_CTRL_TOT) | BF_CRC_CTRL_TOT(v)))
/*@}*/
/*******************************************************************************
 * HW_CRC_CTRLHU - CRC_CTRLHU register.
 ******************************************************************************/

/*!
 * @brief HW_CRC_CTRLHU - CRC_CTRLHU register. (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_crc_ctrlhu
{
    uint8_t U;
    struct _hw_crc_ctrlhu_bitfields
    {
        uint8_t TCRC : 1;              /*!< [0]  */
        uint8_t WAS : 1;               /*!< [1]  */
        uint8_t FXOR : 1;              /*!< [2]  */
        uint8_t RESERVED0 : 1;         /*!< [3]  */
        uint8_t TOTR : 2;              /*!< [5:4]  */
        uint8_t TOT : 2;               /*!< [7:6]  */
    } B;
} hw_crc_ctrlhu_t;

/*!
 * @name Constants and macros for entire CRC_CTRLHU register
 */
/*@{*/
#define HW_CRC_CTRLHU_ADDR(x)    ((uint32_t)(x) + 0xBU)

#define HW_CRC_CTRLHU(x)         (*(__IO hw_crc_ctrlhu_t *) HW_CRC_CTRLHU_ADDR(x))
#define HW_CRC_CTRLHU_RD(x)      (HW_CRC_CTRLHU(x).U)
#define HW_CRC_CTRLHU_WR(x, v)   (HW_CRC_CTRLHU(x).U = (v))
#define HW_CRC_CTRLHU_SET(x, v)  (HW_CRC_CTRLHU_WR(x, HW_CRC_CTRLHU_RD(x) |  (v)))
#define HW_CRC_CTRLHU_CLR(x, v)  (HW_CRC_CTRLHU_WR(x, HW_CRC_CTRLHU_RD(x) & ~(v)))
#define HW_CRC_CTRLHU_TOG(x, v)  (HW_CRC_CTRLHU_WR(x, HW_CRC_CTRLHU_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRLHU bitfields
 */

/*!
 * @name Register CRC_CTRLHU, field TCRC[0] (RW)
 *
 * Values:
 * - 0 - 16-bit CRC protocol.
 * - 1 - 32-bit CRC protocol.
 */
/*@{*/
#define BP_CRC_CTRLHU_TCRC   (0U)          /*!< Bit position for CRC_CTRLHU_TCRC. */
#define BM_CRC_CTRLHU_TCRC   (0x01U)       /*!< Bit mask for CRC_CTRLHU_TCRC. */
#define BS_CRC_CTRLHU_TCRC   (1U)          /*!< Bit field size in bits for CRC_CTRLHU_TCRC. */

/*! @brief Read current value of the CRC_CTRLHU_TCRC field. */
#define BR_CRC_CTRLHU_TCRC(x) (BITBAND_ACCESS8(HW_CRC_CTRLHU_ADDR(x), BP_CRC_CTRLHU_TCRC))

/*! @brief Format value for bitfield CRC_CTRLHU_TCRC. */
#define BF_CRC_CTRLHU_TCRC(v) ((uint8_t)((uint8_t)(v) << BP_CRC_CTRLHU_TCRC) & BM_CRC_CTRLHU_TCRC)

/*! @brief Set the TCRC field to a new value. */
#define BW_CRC_CTRLHU_TCRC(x, v) (BITBAND_ACCESS8(HW_CRC_CTRLHU_ADDR(x), BP_CRC_CTRLHU_TCRC) = (v))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field WAS[1] (RW)
 *
 * Values:
 * - 0 - Writes to CRC data register are data values.
 * - 1 - Writes to CRC data reguster are seed values.
 */
/*@{*/
#define BP_CRC_CTRLHU_WAS    (1U)          /*!< Bit position for CRC_CTRLHU_WAS. */
#define BM_CRC_CTRLHU_WAS    (0x02U)       /*!< Bit mask for CRC_CTRLHU_WAS. */
#define BS_CRC_CTRLHU_WAS    (1U)          /*!< Bit field size in bits for CRC_CTRLHU_WAS. */

/*! @brief Read current value of the CRC_CTRLHU_WAS field. */
#define BR_CRC_CTRLHU_WAS(x) (BITBAND_ACCESS8(HW_CRC_CTRLHU_ADDR(x), BP_CRC_CTRLHU_WAS))

/*! @brief Format value for bitfield CRC_CTRLHU_WAS. */
#define BF_CRC_CTRLHU_WAS(v) ((uint8_t)((uint8_t)(v) << BP_CRC_CTRLHU_WAS) & BM_CRC_CTRLHU_WAS)

/*! @brief Set the WAS field to a new value. */
#define BW_CRC_CTRLHU_WAS(x, v) (BITBAND_ACCESS8(HW_CRC_CTRLHU_ADDR(x), BP_CRC_CTRLHU_WAS) = (v))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field FXOR[2] (RW)
 *
 * Values:
 * - 0 - No XOR on reading.
 * - 1 - Invert or complement the read value of CRC data register.
 */
/*@{*/
#define BP_CRC_CTRLHU_FXOR   (2U)          /*!< Bit position for CRC_CTRLHU_FXOR. */
#define BM_CRC_CTRLHU_FXOR   (0x04U)       /*!< Bit mask for CRC_CTRLHU_FXOR. */
#define BS_CRC_CTRLHU_FXOR   (1U)          /*!< Bit field size in bits for CRC_CTRLHU_FXOR. */

/*! @brief Read current value of the CRC_CTRLHU_FXOR field. */
#define BR_CRC_CTRLHU_FXOR(x) (BITBAND_ACCESS8(HW_CRC_CTRLHU_ADDR(x), BP_CRC_CTRLHU_FXOR))

/*! @brief Format value for bitfield CRC_CTRLHU_FXOR. */
#define BF_CRC_CTRLHU_FXOR(v) ((uint8_t)((uint8_t)(v) << BP_CRC_CTRLHU_FXOR) & BM_CRC_CTRLHU_FXOR)

/*! @brief Set the FXOR field to a new value. */
#define BW_CRC_CTRLHU_FXOR(x, v) (BITBAND_ACCESS8(HW_CRC_CTRLHU_ADDR(x), BP_CRC_CTRLHU_FXOR) = (v))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOTR[5:4] (RW)
 *
 * Values:
 * - 00 - No Transposition.
 * - 01 - Bits in bytes are transposed, bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
#define BP_CRC_CTRLHU_TOTR   (4U)          /*!< Bit position for CRC_CTRLHU_TOTR. */
#define BM_CRC_CTRLHU_TOTR   (0x30U)       /*!< Bit mask for CRC_CTRLHU_TOTR. */
#define BS_CRC_CTRLHU_TOTR   (2U)          /*!< Bit field size in bits for CRC_CTRLHU_TOTR. */

/*! @brief Read current value of the CRC_CTRLHU_TOTR field. */
#define BR_CRC_CTRLHU_TOTR(x) (HW_CRC_CTRLHU(x).B.TOTR)

/*! @brief Format value for bitfield CRC_CTRLHU_TOTR. */
#define BF_CRC_CTRLHU_TOTR(v) ((uint8_t)((uint8_t)(v) << BP_CRC_CTRLHU_TOTR) & BM_CRC_CTRLHU_TOTR)

/*! @brief Set the TOTR field to a new value. */
#define BW_CRC_CTRLHU_TOTR(x, v) (HW_CRC_CTRLHU_WR(x, (HW_CRC_CTRLHU_RD(x) & ~BM_CRC_CTRLHU_TOTR) | BF_CRC_CTRLHU_TOTR(v)))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOT[7:6] (RW)
 *
 * Values:
 * - 00 - No Transposition.
 * - 01 - Bits in bytes are transposed, bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
#define BP_CRC_CTRLHU_TOT    (6U)          /*!< Bit position for CRC_CTRLHU_TOT. */
#define BM_CRC_CTRLHU_TOT    (0xC0U)       /*!< Bit mask for CRC_CTRLHU_TOT. */
#define BS_CRC_CTRLHU_TOT    (2U)          /*!< Bit field size in bits for CRC_CTRLHU_TOT. */

/*! @brief Read current value of the CRC_CTRLHU_TOT field. */
#define BR_CRC_CTRLHU_TOT(x) (HW_CRC_CTRLHU(x).B.TOT)

/*! @brief Format value for bitfield CRC_CTRLHU_TOT. */
#define BF_CRC_CTRLHU_TOT(v) ((uint8_t)((uint8_t)(v) << BP_CRC_CTRLHU_TOT) & BM_CRC_CTRLHU_TOT)

/*! @brief Set the TOT field to a new value. */
#define BW_CRC_CTRLHU_TOT(x, v) (HW_CRC_CTRLHU_WR(x, (HW_CRC_CTRLHU_RD(x) & ~BM_CRC_CTRLHU_TOT) | BF_CRC_CTRLHU_TOT(v)))
/*@}*/

/*
** Start of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma push
  #pragma anon_unions
#elif defined(__CWCC__)
  #pragma push
  #pragma cpp_extensions on
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=extended
#else
  #error Not supported compiler type
#endif

/*******************************************************************************
 * hw_crc_t - module struct
 ******************************************************************************/
/*!
 * @brief All CRC module registers.
 */
#pragma pack(1)
typedef struct _hw_crc
{
    union {
        struct {
            __IO hw_crc_datal_t DATAL;     /*!< [0x0] CRC_DATAL register. */
            __IO hw_crc_datah_t DATAH;     /*!< [0x2] CRC_DATAH register. */
        } ACCESS16BIT;
        struct {
            __IO hw_crc_datall_t DATALL;   /*!< [0x0] CRC_DATALL register. */
            __IO hw_crc_datalu_t DATALU;   /*!< [0x1] CRC_DATALU register. */
            __IO hw_crc_datahl_t DATAHL;   /*!< [0x2] CRC_DATAHL register. */
            __IO hw_crc_datahu_t DATAHU;   /*!< [0x3] CRC_DATAHU register. */
        } ACCESS8BIT;
        __IO hw_crc_data_t DATA;           /*!< [0x0] CRC Data register */
    };
    union {
        __IO hw_crc_gpoly_t GPOLY;         /*!< [0x4] CRC Polynomial register */
        struct {
            __IO hw_crc_gpolyl_t GPOLYL;   /*!< [0x4] CRC_GPOLYL register. */
            __IO hw_crc_gpolyh_t GPOLYH;   /*!< [0x6] CRC_GPOLYH register. */
        } GPOLY_ACCESS16BIT;
        struct {
            __IO hw_crc_gpolyll_t GPOLYLL; /*!< [0x4] CRC_GPOLYLL register. */
            __IO hw_crc_gpolylu_t GPOLYLU; /*!< [0x5] CRC_GPOLYLU register. */
            __IO hw_crc_gpolyhl_t GPOLYHL; /*!< [0x6] CRC_GPOLYHL register. */
            __IO hw_crc_gpolyhu_t GPOLYHU; /*!< [0x7] CRC_GPOLYHU register. */
        } GPOLY_ACCESS8BIT;
    };
    union {
        __IO hw_crc_ctrl_t CTRL;           /*!< [0x8] CRC Control register */
        struct {
            uint8_t _reserved0[3];
            __IO hw_crc_ctrlhu_t CTRLHU;   /*!< [0xB] CRC_CTRLHU register. */
        } CTRL_ACCESS8BIT;
    };
} hw_crc_t;
#pragma pack()

/*! @brief Macro to access all CRC registers. */
/*! @param x CRC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_CRC_REGS(CRC_BASE)</code>. */
#define HW_CRC_REGS(x) (*(hw_crc_t *)(x))

/*
** End of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma pop
#elif defined(__CWCC__)
  #pragma pop
#elif defined(__GNUC__)
  /* leave anonymous unions enabled */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=default
#else
  #error Not supported compiler type
#endif

/*
 * MK64F12 DAC
 *
 * 12-Bit Digital-to-Analog Converter
 *
 * Registers defined in this header file:
 * - HW_DAC_DATnL - DAC Data Low Register
 * - HW_DAC_DATnH - DAC Data High Register
 * - HW_DAC_SR - DAC Status Register
 * - HW_DAC_C0 - DAC Control Register
 * - HW_DAC_C1 - DAC Control Register 1
 * - HW_DAC_C2 - DAC Control Register 2
 *
 * - hw_dac_t - Struct containing all module registers.
 */

#define HW_DAC_INSTANCE_COUNT (2U) /*!< Number of instances of the DAC module. */
#define HW_DAC0 (0U) /*!< Instance number for DAC0. */
#define HW_DAC1 (1U) /*!< Instance number for DAC1. */

/*******************************************************************************
 * HW_DAC_DATnL - DAC Data Low Register
 ******************************************************************************/

/*!
 * @brief HW_DAC_DATnL - DAC Data Low Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_dac_datnl
{
    uint8_t U;
    struct _hw_dac_datnl_bitfields
    {
        uint8_t DATA0 : 8;             /*!< [7:0]  */
    } B;
} hw_dac_datnl_t;

/*!
 * @name Constants and macros for entire DAC_DATnL register
 */
/*@{*/
#define HW_DAC_DATnL_COUNT (16U)

#define HW_DAC_DATnL_ADDR(x, n)  ((uint32_t)(x) + 0x0U + (0x2U * (n)))

#define HW_DAC_DATnL(x, n)       (*(__IO hw_dac_datnl_t *) HW_DAC_DATnL_ADDR(x, n))
#define HW_DAC_DATnL_RD(x, n)    (HW_DAC_DATnL(x, n).U)
#define HW_DAC_DATnL_WR(x, n, v) (HW_DAC_DATnL(x, n).U = (v))
#define HW_DAC_DATnL_SET(x, n, v) (HW_DAC_DATnL_WR(x, n, HW_DAC_DATnL_RD(x, n) |  (v)))
#define HW_DAC_DATnL_CLR(x, n, v) (HW_DAC_DATnL_WR(x, n, HW_DAC_DATnL_RD(x, n) & ~(v)))
#define HW_DAC_DATnL_TOG(x, n, v) (HW_DAC_DATnL_WR(x, n, HW_DAC_DATnL_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DAC_DATnL bitfields
 */

/*!
 * @name Register DAC_DATnL, field DATA0[7:0] (RW)
 *
 * When the DAC buffer is not enabled, DATA[11:0] controls the output voltage
 * based on the following formula: V out = V in * (1 + DACDAT0[11:0])/4096 When the
 * DAC buffer is enabled, DATA is mapped to the 16-word buffer.
 */
/*@{*/
#define BP_DAC_DATnL_DATA0   (0U)          /*!< Bit position for DAC_DATnL_DATA0. */
#define BM_DAC_DATnL_DATA0   (0xFFU)       /*!< Bit mask for DAC_DATnL_DATA0. */
#define BS_DAC_DATnL_DATA0   (8U)          /*!< Bit field size in bits for DAC_DATnL_DATA0. */

/*! @brief Read current value of the DAC_DATnL_DATA0 field. */
#define BR_DAC_DATnL_DATA0(x, n) (HW_DAC_DATnL(x, n).U)

/*! @brief Format value for bitfield DAC_DATnL_DATA0. */
#define BF_DAC_DATnL_DATA0(v) ((uint8_t)((uint8_t)(v) << BP_DAC_DATnL_DATA0) & BM_DAC_DATnL_DATA0)

/*! @brief Set the DATA0 field to a new value. */
#define BW_DAC_DATnL_DATA0(x, n, v) (HW_DAC_DATnL_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DAC_DATnH - DAC Data High Register
 ******************************************************************************/

/*!
 * @brief HW_DAC_DATnH - DAC Data High Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_dac_datnh
{
    uint8_t U;
    struct _hw_dac_datnh_bitfields
    {
        uint8_t DATA1 : 4;             /*!< [3:0]  */
        uint8_t RESERVED0 : 4;         /*!< [7:4]  */
    } B;
} hw_dac_datnh_t;

/*!
 * @name Constants and macros for entire DAC_DATnH register
 */
/*@{*/
#define HW_DAC_DATnH_COUNT (16U)

#define HW_DAC_DATnH_ADDR(x, n)  ((uint32_t)(x) + 0x1U + (0x2U * (n)))

#define HW_DAC_DATnH(x, n)       (*(__IO hw_dac_datnh_t *) HW_DAC_DATnH_ADDR(x, n))
#define HW_DAC_DATnH_RD(x, n)    (HW_DAC_DATnH(x, n).U)
#define HW_DAC_DATnH_WR(x, n, v) (HW_DAC_DATnH(x, n).U = (v))
#define HW_DAC_DATnH_SET(x, n, v) (HW_DAC_DATnH_WR(x, n, HW_DAC_DATnH_RD(x, n) |  (v)))
#define HW_DAC_DATnH_CLR(x, n, v) (HW_DAC_DATnH_WR(x, n, HW_DAC_DATnH_RD(x, n) & ~(v)))
#define HW_DAC_DATnH_TOG(x, n, v) (HW_DAC_DATnH_WR(x, n, HW_DAC_DATnH_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DAC_DATnH bitfields
 */

/*!
 * @name Register DAC_DATnH, field DATA1[3:0] (RW)
 *
 * When the DAC Buffer is not enabled, DATA[11:0] controls the output voltage
 * based on the following formula. V out = V in * (1 + DACDAT0[11:0])/4096 When the
 * DAC buffer is enabled, DATA[11:0] is mapped to the 16-word buffer.
 */
/*@{*/
#define BP_DAC_DATnH_DATA1   (0U)          /*!< Bit position for DAC_DATnH_DATA1. */
#define BM_DAC_DATnH_DATA1   (0x0FU)       /*!< Bit mask for DAC_DATnH_DATA1. */
#define BS_DAC_DATnH_DATA1   (4U)          /*!< Bit field size in bits for DAC_DATnH_DATA1. */

/*! @brief Read current value of the DAC_DATnH_DATA1 field. */
#define BR_DAC_DATnH_DATA1(x, n) (HW_DAC_DATnH(x, n).B.DATA1)

/*! @brief Format value for bitfield DAC_DATnH_DATA1. */
#define BF_DAC_DATnH_DATA1(v) ((uint8_t)((uint8_t)(v) << BP_DAC_DATnH_DATA1) & BM_DAC_DATnH_DATA1)

/*! @brief Set the DATA1 field to a new value. */
#define BW_DAC_DATnH_DATA1(x, n, v) (HW_DAC_DATnH_WR(x, n, (HW_DAC_DATnH_RD(x, n) & ~BM_DAC_DATnH_DATA1) | BF_DAC_DATnH_DATA1(v)))
/*@}*/

/*******************************************************************************
 * HW_DAC_SR - DAC Status Register
 ******************************************************************************/

/*!
 * @brief HW_DAC_SR - DAC Status Register (RW)
 *
 * Reset value: 0x02U
 *
 * If DMA is enabled, the flags can be cleared automatically by DMA when the DMA
 * request is done. Writing 0 to a field clears it whereas writing 1 has no
 * effect. After reset, DACBFRPTF is set and can be cleared by software, if needed.
 * The flags are set only when the data buffer status is changed. Do not use
 * 32/16-bit accesses to this register.
 */
typedef union _hw_dac_sr
{
    uint8_t U;
    struct _hw_dac_sr_bitfields
    {
        uint8_t DACBFRPBF : 1;         /*!< [0] DAC Buffer Read Pointer Bottom
                                        * Position Flag */
        uint8_t DACBFRPTF : 1;         /*!< [1] DAC Buffer Read Pointer Top Position
                                        * Flag */
        uint8_t DACBFWMF : 1;          /*!< [2] DAC Buffer Watermark Flag */
        uint8_t RESERVED0 : 5;         /*!< [7:3]  */
    } B;
} hw_dac_sr_t;

/*!
 * @name Constants and macros for entire DAC_SR register
 */
/*@{*/
#define HW_DAC_SR_ADDR(x)        ((uint32_t)(x) + 0x20U)

#define HW_DAC_SR(x)             (*(__IO hw_dac_sr_t *) HW_DAC_SR_ADDR(x))
#define HW_DAC_SR_RD(x)          (HW_DAC_SR(x).U)
#define HW_DAC_SR_WR(x, v)       (HW_DAC_SR(x).U = (v))
#define HW_DAC_SR_SET(x, v)      (HW_DAC_SR_WR(x, HW_DAC_SR_RD(x) |  (v)))
#define HW_DAC_SR_CLR(x, v)      (HW_DAC_SR_WR(x, HW_DAC_SR_RD(x) & ~(v)))
#define HW_DAC_SR_TOG(x, v)      (HW_DAC_SR_WR(x, HW_DAC_SR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DAC_SR bitfields
 */

/*!
 * @name Register DAC_SR, field DACBFRPBF[0] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer is not equal to C2[DACBFUP].
 * - 1 - The DAC buffer read pointer is equal to C2[DACBFUP].
 */
/*@{*/
#define BP_DAC_SR_DACBFRPBF  (0U)          /*!< Bit position for DAC_SR_DACBFRPBF. */
#define BM_DAC_SR_DACBFRPBF  (0x01U)       /*!< Bit mask for DAC_SR_DACBFRPBF. */
#define BS_DAC_SR_DACBFRPBF  (1U)          /*!< Bit field size in bits for DAC_SR_DACBFRPBF. */

/*! @brief Read current value of the DAC_SR_DACBFRPBF field. */
#define BR_DAC_SR_DACBFRPBF(x) (BITBAND_ACCESS8(HW_DAC_SR_ADDR(x), BP_DAC_SR_DACBFRPBF))

/*! @brief Format value for bitfield DAC_SR_DACBFRPBF. */
#define BF_DAC_SR_DACBFRPBF(v) ((uint8_t)((uint8_t)(v) << BP_DAC_SR_DACBFRPBF) & BM_DAC_SR_DACBFRPBF)

/*! @brief Set the DACBFRPBF field to a new value. */
#define BW_DAC_SR_DACBFRPBF(x, v) (BITBAND_ACCESS8(HW_DAC_SR_ADDR(x), BP_DAC_SR_DACBFRPBF) = (v))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFRPTF[1] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer is not zero.
 * - 1 - The DAC buffer read pointer is zero.
 */
/*@{*/
#define BP_DAC_SR_DACBFRPTF  (1U)          /*!< Bit position for DAC_SR_DACBFRPTF. */
#define BM_DAC_SR_DACBFRPTF  (0x02U)       /*!< Bit mask for DAC_SR_DACBFRPTF. */
#define BS_DAC_SR_DACBFRPTF  (1U)          /*!< Bit field size in bits for DAC_SR_DACBFRPTF. */

/*! @brief Read current value of the DAC_SR_DACBFRPTF field. */
#define BR_DAC_SR_DACBFRPTF(x) (BITBAND_ACCESS8(HW_DAC_SR_ADDR(x), BP_DAC_SR_DACBFRPTF))

/*! @brief Format value for bitfield DAC_SR_DACBFRPTF. */
#define BF_DAC_SR_DACBFRPTF(v) ((uint8_t)((uint8_t)(v) << BP_DAC_SR_DACBFRPTF) & BM_DAC_SR_DACBFRPTF)

/*! @brief Set the DACBFRPTF field to a new value. */
#define BW_DAC_SR_DACBFRPTF(x, v) (BITBAND_ACCESS8(HW_DAC_SR_ADDR(x), BP_DAC_SR_DACBFRPTF) = (v))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFWMF[2] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer has not reached the watermark level.
 * - 1 - The DAC buffer read pointer has reached the watermark level.
 */
/*@{*/
#define BP_DAC_SR_DACBFWMF   (2U)          /*!< Bit position for DAC_SR_DACBFWMF. */
#define BM_DAC_SR_DACBFWMF   (0x04U)       /*!< Bit mask for DAC_SR_DACBFWMF. */
#define BS_DAC_SR_DACBFWMF   (1U)          /*!< Bit field size in bits for DAC_SR_DACBFWMF. */

/*! @brief Read current value of the DAC_SR_DACBFWMF field. */
#define BR_DAC_SR_DACBFWMF(x) (BITBAND_ACCESS8(HW_DAC_SR_ADDR(x), BP_DAC_SR_DACBFWMF))

/*! @brief Format value for bitfield DAC_SR_DACBFWMF. */
#define BF_DAC_SR_DACBFWMF(v) ((uint8_t)((uint8_t)(v) << BP_DAC_SR_DACBFWMF) & BM_DAC_SR_DACBFWMF)

/*! @brief Set the DACBFWMF field to a new value. */
#define BW_DAC_SR_DACBFWMF(x, v) (BITBAND_ACCESS8(HW_DAC_SR_ADDR(x), BP_DAC_SR_DACBFWMF) = (v))
/*@}*/

/*******************************************************************************
 * HW_DAC_C0 - DAC Control Register
 ******************************************************************************/

/*!
 * @brief HW_DAC_C0 - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * Do not use 32- or 16-bit accesses to this register.
 */
typedef union _hw_dac_c0
{
    uint8_t U;
    struct _hw_dac_c0_bitfields
    {
        uint8_t DACBBIEN : 1;          /*!< [0] DAC Buffer Read Pointer Bottom Flag
                                        * Interrupt Enable */
        uint8_t DACBTIEN : 1;          /*!< [1] DAC Buffer Read Pointer Top Flag
                                        * Interrupt Enable */
        uint8_t DACBWIEN : 1;          /*!< [2] DAC Buffer Watermark Interrupt Enable
                                        * */
        uint8_t LPEN : 1;              /*!< [3] DAC Low Power Control */
        uint8_t DACSWTRG : 1;          /*!< [4] DAC Software Trigger */
        uint8_t DACTRGSEL : 1;         /*!< [5] DAC Trigger Select */
        uint8_t DACRFS : 1;            /*!< [6] DAC Reference Select */
        uint8_t DACEN : 1;             /*!< [7] DAC Enable */
    } B;
} hw_dac_c0_t;

/*!
 * @name Constants and macros for entire DAC_C0 register
 */
/*@{*/
#define HW_DAC_C0_ADDR(x)        ((uint32_t)(x) + 0x21U)

#define HW_DAC_C0(x)             (*(__IO hw_dac_c0_t *) HW_DAC_C0_ADDR(x))
#define HW_DAC_C0_RD(x)          (HW_DAC_C0(x).U)
#define HW_DAC_C0_WR(x, v)       (HW_DAC_C0(x).U = (v))
#define HW_DAC_C0_SET(x, v)      (HW_DAC_C0_WR(x, HW_DAC_C0_RD(x) |  (v)))
#define HW_DAC_C0_CLR(x, v)      (HW_DAC_C0_WR(x, HW_DAC_C0_RD(x) & ~(v)))
#define HW_DAC_C0_TOG(x, v)      (HW_DAC_C0_WR(x, HW_DAC_C0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DAC_C0 bitfields
 */

/*!
 * @name Register DAC_C0, field DACBBIEN[0] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer bottom flag interrupt is disabled.
 * - 1 - The DAC buffer read pointer bottom flag interrupt is enabled.
 */
/*@{*/
#define BP_DAC_C0_DACBBIEN   (0U)          /*!< Bit position for DAC_C0_DACBBIEN. */
#define BM_DAC_C0_DACBBIEN   (0x01U)       /*!< Bit mask for DAC_C0_DACBBIEN. */
#define BS_DAC_C0_DACBBIEN   (1U)          /*!< Bit field size in bits for DAC_C0_DACBBIEN. */

/*! @brief Read current value of the DAC_C0_DACBBIEN field. */
#define BR_DAC_C0_DACBBIEN(x) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACBBIEN))

/*! @brief Format value for bitfield DAC_C0_DACBBIEN. */
#define BF_DAC_C0_DACBBIEN(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACBBIEN) & BM_DAC_C0_DACBBIEN)

/*! @brief Set the DACBBIEN field to a new value. */
#define BW_DAC_C0_DACBBIEN(x, v) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACBBIEN) = (v))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBTIEN[1] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer top flag interrupt is disabled.
 * - 1 - The DAC buffer read pointer top flag interrupt is enabled.
 */
/*@{*/
#define BP_DAC_C0_DACBTIEN   (1U)          /*!< Bit position for DAC_C0_DACBTIEN. */
#define BM_DAC_C0_DACBTIEN   (0x02U)       /*!< Bit mask for DAC_C0_DACBTIEN. */
#define BS_DAC_C0_DACBTIEN   (1U)          /*!< Bit field size in bits for DAC_C0_DACBTIEN. */

/*! @brief Read current value of the DAC_C0_DACBTIEN field. */
#define BR_DAC_C0_DACBTIEN(x) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACBTIEN))

/*! @brief Format value for bitfield DAC_C0_DACBTIEN. */
#define BF_DAC_C0_DACBTIEN(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACBTIEN) & BM_DAC_C0_DACBTIEN)

/*! @brief Set the DACBTIEN field to a new value. */
#define BW_DAC_C0_DACBTIEN(x, v) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACBTIEN) = (v))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBWIEN[2] (RW)
 *
 * Values:
 * - 0 - The DAC buffer watermark interrupt is disabled.
 * - 1 - The DAC buffer watermark interrupt is enabled.
 */
/*@{*/
#define BP_DAC_C0_DACBWIEN   (2U)          /*!< Bit position for DAC_C0_DACBWIEN. */
#define BM_DAC_C0_DACBWIEN   (0x04U)       /*!< Bit mask for DAC_C0_DACBWIEN. */
#define BS_DAC_C0_DACBWIEN   (1U)          /*!< Bit field size in bits for DAC_C0_DACBWIEN. */

/*! @brief Read current value of the DAC_C0_DACBWIEN field. */
#define BR_DAC_C0_DACBWIEN(x) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACBWIEN))

/*! @brief Format value for bitfield DAC_C0_DACBWIEN. */
#define BF_DAC_C0_DACBWIEN(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACBWIEN) & BM_DAC_C0_DACBWIEN)

/*! @brief Set the DACBWIEN field to a new value. */
#define BW_DAC_C0_DACBWIEN(x, v) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACBWIEN) = (v))
/*@}*/

/*!
 * @name Register DAC_C0, field LPEN[3] (RW)
 *
 * See the 12-bit DAC electrical characteristics of the device data sheet for
 * details on the impact of the modes below.
 *
 * Values:
 * - 0 - High-Power mode
 * - 1 - Low-Power mode
 */
/*@{*/
#define BP_DAC_C0_LPEN       (3U)          /*!< Bit position for DAC_C0_LPEN. */
#define BM_DAC_C0_LPEN       (0x08U)       /*!< Bit mask for DAC_C0_LPEN. */
#define BS_DAC_C0_LPEN       (1U)          /*!< Bit field size in bits for DAC_C0_LPEN. */

/*! @brief Read current value of the DAC_C0_LPEN field. */
#define BR_DAC_C0_LPEN(x)    (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_LPEN))

/*! @brief Format value for bitfield DAC_C0_LPEN. */
#define BF_DAC_C0_LPEN(v)    ((uint8_t)((uint8_t)(v) << BP_DAC_C0_LPEN) & BM_DAC_C0_LPEN)

/*! @brief Set the LPEN field to a new value. */
#define BW_DAC_C0_LPEN(x, v) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_LPEN) = (v))
/*@}*/

/*!
 * @name Register DAC_C0, field DACSWTRG[4] (WORZ)
 *
 * Active high. This is a write-only field, which always reads 0. If DAC
 * software trigger is selected and buffer is enabled, writing 1 to this field will
 * advance the buffer read pointer once.
 *
 * Values:
 * - 0 - The DAC soft trigger is not valid.
 * - 1 - The DAC soft trigger is valid.
 */
/*@{*/
#define BP_DAC_C0_DACSWTRG   (4U)          /*!< Bit position for DAC_C0_DACSWTRG. */
#define BM_DAC_C0_DACSWTRG   (0x10U)       /*!< Bit mask for DAC_C0_DACSWTRG. */
#define BS_DAC_C0_DACSWTRG   (1U)          /*!< Bit field size in bits for DAC_C0_DACSWTRG. */

/*! @brief Format value for bitfield DAC_C0_DACSWTRG. */
#define BF_DAC_C0_DACSWTRG(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACSWTRG) & BM_DAC_C0_DACSWTRG)

/*! @brief Set the DACSWTRG field to a new value. */
#define BW_DAC_C0_DACSWTRG(x, v) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACSWTRG) = (v))
/*@}*/

/*!
 * @name Register DAC_C0, field DACTRGSEL[5] (RW)
 *
 * Values:
 * - 0 - The DAC hardware trigger is selected.
 * - 1 - The DAC software trigger is selected.
 */
/*@{*/
#define BP_DAC_C0_DACTRGSEL  (5U)          /*!< Bit position for DAC_C0_DACTRGSEL. */
#define BM_DAC_C0_DACTRGSEL  (0x20U)       /*!< Bit mask for DAC_C0_DACTRGSEL. */
#define BS_DAC_C0_DACTRGSEL  (1U)          /*!< Bit field size in bits for DAC_C0_DACTRGSEL. */

/*! @brief Read current value of the DAC_C0_DACTRGSEL field. */
#define BR_DAC_C0_DACTRGSEL(x) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACTRGSEL))

/*! @brief Format value for bitfield DAC_C0_DACTRGSEL. */
#define BF_DAC_C0_DACTRGSEL(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACTRGSEL) & BM_DAC_C0_DACTRGSEL)

/*! @brief Set the DACTRGSEL field to a new value. */
#define BW_DAC_C0_DACTRGSEL(x, v) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACTRGSEL) = (v))
/*@}*/

/*!
 * @name Register DAC_C0, field DACRFS[6] (RW)
 *
 * Values:
 * - 0 - The DAC selects DACREF_1 as the reference voltage.
 * - 1 - The DAC selects DACREF_2 as the reference voltage.
 */
/*@{*/
#define BP_DAC_C0_DACRFS     (6U)          /*!< Bit position for DAC_C0_DACRFS. */
#define BM_DAC_C0_DACRFS     (0x40U)       /*!< Bit mask for DAC_C0_DACRFS. */
#define BS_DAC_C0_DACRFS     (1U)          /*!< Bit field size in bits for DAC_C0_DACRFS. */

/*! @brief Read current value of the DAC_C0_DACRFS field. */
#define BR_DAC_C0_DACRFS(x)  (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACRFS))

/*! @brief Format value for bitfield DAC_C0_DACRFS. */
#define BF_DAC_C0_DACRFS(v)  ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACRFS) & BM_DAC_C0_DACRFS)

/*! @brief Set the DACRFS field to a new value. */
#define BW_DAC_C0_DACRFS(x, v) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACRFS) = (v))
/*@}*/

/*!
 * @name Register DAC_C0, field DACEN[7] (RW)
 *
 * Starts the Programmable Reference Generator operation.
 *
 * Values:
 * - 0 - The DAC system is disabled.
 * - 1 - The DAC system is enabled.
 */
/*@{*/
#define BP_DAC_C0_DACEN      (7U)          /*!< Bit position for DAC_C0_DACEN. */
#define BM_DAC_C0_DACEN      (0x80U)       /*!< Bit mask for DAC_C0_DACEN. */
#define BS_DAC_C0_DACEN      (1U)          /*!< Bit field size in bits for DAC_C0_DACEN. */

/*! @brief Read current value of the DAC_C0_DACEN field. */
#define BR_DAC_C0_DACEN(x)   (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACEN))

/*! @brief Format value for bitfield DAC_C0_DACEN. */
#define BF_DAC_C0_DACEN(v)   ((uint8_t)((uint8_t)(v) << BP_DAC_C0_DACEN) & BM_DAC_C0_DACEN)

/*! @brief Set the DACEN field to a new value. */
#define BW_DAC_C0_DACEN(x, v) (BITBAND_ACCESS8(HW_DAC_C0_ADDR(x), BP_DAC_C0_DACEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_DAC_C1 - DAC Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_DAC_C1 - DAC Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * Do not use 32- or 16-bit accesses to this register.
 */
typedef union _hw_dac_c1
{
    uint8_t U;
    struct _hw_dac_c1_bitfields
    {
        uint8_t DACBFEN : 1;           /*!< [0] DAC Buffer Enable */
        uint8_t DACBFMD : 2;           /*!< [2:1] DAC Buffer Work Mode Select */
        uint8_t DACBFWM : 2;           /*!< [4:3] DAC Buffer Watermark Select */
        uint8_t RESERVED0 : 2;         /*!< [6:5]  */
        uint8_t DMAEN : 1;             /*!< [7] DMA Enable Select */
    } B;
} hw_dac_c1_t;

/*!
 * @name Constants and macros for entire DAC_C1 register
 */
/*@{*/
#define HW_DAC_C1_ADDR(x)        ((uint32_t)(x) + 0x22U)

#define HW_DAC_C1(x)             (*(__IO hw_dac_c1_t *) HW_DAC_C1_ADDR(x))
#define HW_DAC_C1_RD(x)          (HW_DAC_C1(x).U)
#define HW_DAC_C1_WR(x, v)       (HW_DAC_C1(x).U = (v))
#define HW_DAC_C1_SET(x, v)      (HW_DAC_C1_WR(x, HW_DAC_C1_RD(x) |  (v)))
#define HW_DAC_C1_CLR(x, v)      (HW_DAC_C1_WR(x, HW_DAC_C1_RD(x) & ~(v)))
#define HW_DAC_C1_TOG(x, v)      (HW_DAC_C1_WR(x, HW_DAC_C1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DAC_C1 bitfields
 */

/*!
 * @name Register DAC_C1, field DACBFEN[0] (RW)
 *
 * Values:
 * - 0 - Buffer read pointer is disabled. The converted data is always the first
 *     word of the buffer.
 * - 1 - Buffer read pointer is enabled. The converted data is the word that the
 *     read pointer points to. It means converted data can be from any word of
 *     the buffer.
 */
/*@{*/
#define BP_DAC_C1_DACBFEN    (0U)          /*!< Bit position for DAC_C1_DACBFEN. */
#define BM_DAC_C1_DACBFEN    (0x01U)       /*!< Bit mask for DAC_C1_DACBFEN. */
#define BS_DAC_C1_DACBFEN    (1U)          /*!< Bit field size in bits for DAC_C1_DACBFEN. */

/*! @brief Read current value of the DAC_C1_DACBFEN field. */
#define BR_DAC_C1_DACBFEN(x) (BITBAND_ACCESS8(HW_DAC_C1_ADDR(x), BP_DAC_C1_DACBFEN))

/*! @brief Format value for bitfield DAC_C1_DACBFEN. */
#define BF_DAC_C1_DACBFEN(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C1_DACBFEN) & BM_DAC_C1_DACBFEN)

/*! @brief Set the DACBFEN field to a new value. */
#define BW_DAC_C1_DACBFEN(x, v) (BITBAND_ACCESS8(HW_DAC_C1_ADDR(x), BP_DAC_C1_DACBFEN) = (v))
/*@}*/

/*!
 * @name Register DAC_C1, field DACBFMD[2:1] (RW)
 *
 * Values:
 * - 00 - Normal mode
 * - 01 - Swing mode
 * - 10 - One-Time Scan mode
 * - 11 - Reserved
 */
/*@{*/
#define BP_DAC_C1_DACBFMD    (1U)          /*!< Bit position for DAC_C1_DACBFMD. */
#define BM_DAC_C1_DACBFMD    (0x06U)       /*!< Bit mask for DAC_C1_DACBFMD. */
#define BS_DAC_C1_DACBFMD    (2U)          /*!< Bit field size in bits for DAC_C1_DACBFMD. */

/*! @brief Read current value of the DAC_C1_DACBFMD field. */
#define BR_DAC_C1_DACBFMD(x) (HW_DAC_C1(x).B.DACBFMD)

/*! @brief Format value for bitfield DAC_C1_DACBFMD. */
#define BF_DAC_C1_DACBFMD(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C1_DACBFMD) & BM_DAC_C1_DACBFMD)

/*! @brief Set the DACBFMD field to a new value. */
#define BW_DAC_C1_DACBFMD(x, v) (HW_DAC_C1_WR(x, (HW_DAC_C1_RD(x) & ~BM_DAC_C1_DACBFMD) | BF_DAC_C1_DACBFMD(v)))
/*@}*/

/*!
 * @name Register DAC_C1, field DACBFWM[4:3] (RW)
 *
 * Controls when SR[DACBFWMF] is set. When the DAC buffer read pointer reaches
 * the word defined by this field, which is 1-4 words away from the upper limit
 * (DACBUP), SR[DACBFWMF] will be set. This allows user configuration of the
 * watermark interrupt.
 *
 * Values:
 * - 00 - 1 word
 * - 01 - 2 words
 * - 10 - 3 words
 * - 11 - 4 words
 */
/*@{*/
#define BP_DAC_C1_DACBFWM    (3U)          /*!< Bit position for DAC_C1_DACBFWM. */
#define BM_DAC_C1_DACBFWM    (0x18U)       /*!< Bit mask for DAC_C1_DACBFWM. */
#define BS_DAC_C1_DACBFWM    (2U)          /*!< Bit field size in bits for DAC_C1_DACBFWM. */

/*! @brief Read current value of the DAC_C1_DACBFWM field. */
#define BR_DAC_C1_DACBFWM(x) (HW_DAC_C1(x).B.DACBFWM)

/*! @brief Format value for bitfield DAC_C1_DACBFWM. */
#define BF_DAC_C1_DACBFWM(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C1_DACBFWM) & BM_DAC_C1_DACBFWM)

/*! @brief Set the DACBFWM field to a new value. */
#define BW_DAC_C1_DACBFWM(x, v) (HW_DAC_C1_WR(x, (HW_DAC_C1_RD(x) & ~BM_DAC_C1_DACBFWM) | BF_DAC_C1_DACBFWM(v)))
/*@}*/

/*!
 * @name Register DAC_C1, field DMAEN[7] (RW)
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled. When DMA is enabled, the DMA request will be generated
 *     by original interrupts. The interrupts will not be presented on this
 *     module at the same time.
 */
/*@{*/
#define BP_DAC_C1_DMAEN      (7U)          /*!< Bit position for DAC_C1_DMAEN. */
#define BM_DAC_C1_DMAEN      (0x80U)       /*!< Bit mask for DAC_C1_DMAEN. */
#define BS_DAC_C1_DMAEN      (1U)          /*!< Bit field size in bits for DAC_C1_DMAEN. */

/*! @brief Read current value of the DAC_C1_DMAEN field. */
#define BR_DAC_C1_DMAEN(x)   (BITBAND_ACCESS8(HW_DAC_C1_ADDR(x), BP_DAC_C1_DMAEN))

/*! @brief Format value for bitfield DAC_C1_DMAEN. */
#define BF_DAC_C1_DMAEN(v)   ((uint8_t)((uint8_t)(v) << BP_DAC_C1_DMAEN) & BM_DAC_C1_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_DAC_C1_DMAEN(x, v) (BITBAND_ACCESS8(HW_DAC_C1_ADDR(x), BP_DAC_C1_DMAEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_DAC_C2 - DAC Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_DAC_C2 - DAC Control Register 2 (RW)
 *
 * Reset value: 0x0FU
 */
typedef union _hw_dac_c2
{
    uint8_t U;
    struct _hw_dac_c2_bitfields
    {
        uint8_t DACBFUP : 4;           /*!< [3:0] DAC Buffer Upper Limit */
        uint8_t DACBFRP : 4;           /*!< [7:4] DAC Buffer Read Pointer */
    } B;
} hw_dac_c2_t;

/*!
 * @name Constants and macros for entire DAC_C2 register
 */
/*@{*/
#define HW_DAC_C2_ADDR(x)        ((uint32_t)(x) + 0x23U)

#define HW_DAC_C2(x)             (*(__IO hw_dac_c2_t *) HW_DAC_C2_ADDR(x))
#define HW_DAC_C2_RD(x)          (HW_DAC_C2(x).U)
#define HW_DAC_C2_WR(x, v)       (HW_DAC_C2(x).U = (v))
#define HW_DAC_C2_SET(x, v)      (HW_DAC_C2_WR(x, HW_DAC_C2_RD(x) |  (v)))
#define HW_DAC_C2_CLR(x, v)      (HW_DAC_C2_WR(x, HW_DAC_C2_RD(x) & ~(v)))
#define HW_DAC_C2_TOG(x, v)      (HW_DAC_C2_WR(x, HW_DAC_C2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DAC_C2 bitfields
 */

/*!
 * @name Register DAC_C2, field DACBFUP[3:0] (RW)
 *
 * Selects the upper limit of the DAC buffer. The buffer read pointer cannot
 * exceed it.
 */
/*@{*/
#define BP_DAC_C2_DACBFUP    (0U)          /*!< Bit position for DAC_C2_DACBFUP. */
#define BM_DAC_C2_DACBFUP    (0x0FU)       /*!< Bit mask for DAC_C2_DACBFUP. */
#define BS_DAC_C2_DACBFUP    (4U)          /*!< Bit field size in bits for DAC_C2_DACBFUP. */

/*! @brief Read current value of the DAC_C2_DACBFUP field. */
#define BR_DAC_C2_DACBFUP(x) (HW_DAC_C2(x).B.DACBFUP)

/*! @brief Format value for bitfield DAC_C2_DACBFUP. */
#define BF_DAC_C2_DACBFUP(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C2_DACBFUP) & BM_DAC_C2_DACBFUP)

/*! @brief Set the DACBFUP field to a new value. */
#define BW_DAC_C2_DACBFUP(x, v) (HW_DAC_C2_WR(x, (HW_DAC_C2_RD(x) & ~BM_DAC_C2_DACBFUP) | BF_DAC_C2_DACBFUP(v)))
/*@}*/

/*!
 * @name Register DAC_C2, field DACBFRP[7:4] (RW)
 *
 * Keeps the current value of the buffer read pointer.
 */
/*@{*/
#define BP_DAC_C2_DACBFRP    (4U)          /*!< Bit position for DAC_C2_DACBFRP. */
#define BM_DAC_C2_DACBFRP    (0xF0U)       /*!< Bit mask for DAC_C2_DACBFRP. */
#define BS_DAC_C2_DACBFRP    (4U)          /*!< Bit field size in bits for DAC_C2_DACBFRP. */

/*! @brief Read current value of the DAC_C2_DACBFRP field. */
#define BR_DAC_C2_DACBFRP(x) (HW_DAC_C2(x).B.DACBFRP)

/*! @brief Format value for bitfield DAC_C2_DACBFRP. */
#define BF_DAC_C2_DACBFRP(v) ((uint8_t)((uint8_t)(v) << BP_DAC_C2_DACBFRP) & BM_DAC_C2_DACBFRP)

/*! @brief Set the DACBFRP field to a new value. */
#define BW_DAC_C2_DACBFRP(x, v) (HW_DAC_C2_WR(x, (HW_DAC_C2_RD(x) & ~BM_DAC_C2_DACBFRP) | BF_DAC_C2_DACBFRP(v)))
/*@}*/

/*******************************************************************************
 * hw_dac_t - module struct
 ******************************************************************************/
/*!
 * @brief All DAC module registers.
 */
#pragma pack(1)
typedef struct _hw_dac
{
    struct {
        __IO hw_dac_datnl_t DATnL;         /*!< [0x0] DAC Data Low Register */
        __IO hw_dac_datnh_t DATnH;         /*!< [0x1] DAC Data High Register */
    } DAT[16];
    __IO hw_dac_sr_t SR;                   /*!< [0x20] DAC Status Register */
    __IO hw_dac_c0_t C0;                   /*!< [0x21] DAC Control Register */
    __IO hw_dac_c1_t C1;                   /*!< [0x22] DAC Control Register 1 */
    __IO hw_dac_c2_t C2;                   /*!< [0x23] DAC Control Register 2 */
} hw_dac_t;
#pragma pack()

/*! @brief Macro to access all DAC registers. */
/*! @param x DAC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_DAC_REGS(DAC0_BASE)</code>. */
#define HW_DAC_REGS(x) (*(hw_dac_t *)(x))

/*
 * MK64F12 DMA
 *
 * Enhanced direct memory access controller
 *
 * Registers defined in this header file:
 * - HW_DMA_CR - Control Register
 * - HW_DMA_ES - Error Status Register
 * - HW_DMA_ERQ - Enable Request Register
 * - HW_DMA_EEI - Enable Error Interrupt Register
 * - HW_DMA_CEEI - Clear Enable Error Interrupt Register
 * - HW_DMA_SEEI - Set Enable Error Interrupt Register
 * - HW_DMA_CERQ - Clear Enable Request Register
 * - HW_DMA_SERQ - Set Enable Request Register
 * - HW_DMA_CDNE - Clear DONE Status Bit Register
 * - HW_DMA_SSRT - Set START Bit Register
 * - HW_DMA_CERR - Clear Error Register
 * - HW_DMA_CINT - Clear Interrupt Request Register
 * - HW_DMA_INT - Interrupt Request Register
 * - HW_DMA_ERR - Error Register
 * - HW_DMA_HRS - Hardware Request Status Register
 * - HW_DMA_DCHPRIn - Channel n Priority Register
 * - HW_DMA_TCDn_SADDR - TCD Source Address
 * - HW_DMA_TCDn_SOFF - TCD Signed Source Address Offset
 * - HW_DMA_TCDn_ATTR - TCD Transfer Attributes
 * - HW_DMA_TCDn_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 * - HW_DMA_TCDn_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 * - HW_DMA_TCDn_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 * - HW_DMA_TCDn_SLAST - TCD Last Source Address Adjustment
 * - HW_DMA_TCDn_DADDR - TCD Destination Address
 * - HW_DMA_TCDn_DOFF - TCD Signed Destination Address Offset
 * - HW_DMA_TCDn_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCDn_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - HW_DMA_TCDn_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - HW_DMA_TCDn_CSR - TCD Control and Status
 * - HW_DMA_TCDn_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - HW_DMA_TCDn_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 *
 * - hw_dma_t - Struct containing all module registers.
 */

#define HW_DMA_INSTANCE_COUNT (1U) /*!< Number of instances of the DMA module. */
#define HW_DMA (0U) /*!< Instance number for DMA. */

/*******************************************************************************
 * HW_DMA_CR - Control Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_CR - Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CR defines the basic operating configuration of the DMA. Arbitration can
 * be configured to use either a fixed-priority or a round-robin scheme. For
 * fixed-priority arbitration, the highest priority channel requesting service is
 * selected to execute. The channel priority registers assign the priorities; see
 * the DCHPRIn registers. For round-robin arbitration, the channel priorities are
 * ignored and channels are cycled through (from high to low channel number)
 * without regard to priority. For correct operation, writes to the CR register must
 * be performed only when the DMA channels are inactive; that is, when
 * TCDn_CSR[ACTIVE] bits are cleared. Minor loop offsets are address offset values added to
 * the final source address (TCDn_SADDR) or destination address (TCDn_DADDR) upon
 * minor loop completion. When minor loop offsets are enabled, the minor loop
 * offset (MLOFF) is added to the final source address (TCDn_SADDR), to the final
 * destination address (TCDn_DADDR), or to both prior to the addresses being
 * written back into the TCD. If the major loop is complete, the minor loop offset is
 * ignored and the major loop address offsets (TCDn_SLAST and TCDn_DLAST_SGA) are
 * used to compute the next TCDn_SADDR and TCDn_DADDR values. When minor loop
 * mapping is enabled (EMLM is 1), TCDn word2 is redefined. A portion of TCDn word2
 * is used to specify multiple fields: a source enable bit (SMLOE) to specify
 * the minor loop offset should be applied to the source address (TCDn_SADDR) upon
 * minor loop completion, a destination enable bit (DMLOE) to specify the minor
 * loop offset should be applied to the destination address (TCDn_DADDR) upon
 * minor loop completion, and the sign extended minor loop offset value (MLOFF). The
 * same offset value (MLOFF) is used for both source and destination minor loop
 * offsets. When either minor loop offset is enabled (SMLOE set or DMLOE set), the
 * NBYTES field is reduced to 10 bits. When both minor loop offsets are disabled
 * (SMLOE cleared and DMLOE cleared), the NBYTES field is a 30-bit vector. When
 * minor loop mapping is disabled (EMLM is 0), all 32 bits of TCDn word2 are
 * assigned to the NBYTES field.
 */
typedef union _hw_dma_cr
{
    uint32_t U;
    struct _hw_dma_cr_bitfields
    {
        uint32_t RESERVED0 : 1;        /*!< [0] Reserved. */
        uint32_t EDBG : 1;             /*!< [1] Enable Debug */
        uint32_t ERCA : 1;             /*!< [2] Enable Round Robin Channel Arbitration */
        uint32_t RESERVED1 : 1;        /*!< [3] Reserved. */
        uint32_t HOE : 1;              /*!< [4] Halt On Error */
        uint32_t HALT : 1;             /*!< [5] Halt DMA Operations */
        uint32_t CLM : 1;              /*!< [6] Continuous Link Mode */
        uint32_t EMLM : 1;             /*!< [7] Enable Minor Loop Mapping */
        uint32_t RESERVED2 : 8;        /*!< [15:8]  */
        uint32_t ECX : 1;              /*!< [16] Error Cancel Transfer */
        uint32_t CX : 1;               /*!< [17] Cancel Transfer */
        uint32_t RESERVED3 : 14;       /*!< [31:18]  */
    } B;
} hw_dma_cr_t;

/*!
 * @name Constants and macros for entire DMA_CR register
 */
/*@{*/
#define HW_DMA_CR_ADDR(x)        ((uint32_t)(x) + 0x0U)

#define HW_DMA_CR(x)             (*(__IO hw_dma_cr_t *) HW_DMA_CR_ADDR(x))
#define HW_DMA_CR_RD(x)          (HW_DMA_CR(x).U)
#define HW_DMA_CR_WR(x, v)       (HW_DMA_CR(x).U = (v))
#define HW_DMA_CR_SET(x, v)      (HW_DMA_CR_WR(x, HW_DMA_CR_RD(x) |  (v)))
#define HW_DMA_CR_CLR(x, v)      (HW_DMA_CR_WR(x, HW_DMA_CR_RD(x) & ~(v)))
#define HW_DMA_CR_TOG(x, v)      (HW_DMA_CR_WR(x, HW_DMA_CR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_CR bitfields
 */

/*!
 * @name Register DMA_CR, field EDBG[1] (RW)
 *
 * Values:
 * - 0 - When in debug mode, the DMA continues to operate.
 * - 1 - When in debug mode, the DMA stalls the start of a new channel.
 *     Executing channels are allowed to complete. Channel execution resumes when the
 *     system exits debug mode or the EDBG bit is cleared.
 */
/*@{*/
#define BP_DMA_CR_EDBG       (1U)          /*!< Bit position for DMA_CR_EDBG. */
#define BM_DMA_CR_EDBG       (0x00000002U) /*!< Bit mask for DMA_CR_EDBG. */
#define BS_DMA_CR_EDBG       (1U)          /*!< Bit field size in bits for DMA_CR_EDBG. */

/*! @brief Read current value of the DMA_CR_EDBG field. */
#define BR_DMA_CR_EDBG(x)    (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_EDBG))

/*! @brief Format value for bitfield DMA_CR_EDBG. */
#define BF_DMA_CR_EDBG(v)    ((uint32_t)((uint32_t)(v) << BP_DMA_CR_EDBG) & BM_DMA_CR_EDBG)

/*! @brief Set the EDBG field to a new value. */
#define BW_DMA_CR_EDBG(x, v) (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_EDBG) = (v))
/*@}*/

/*!
 * @name Register DMA_CR, field ERCA[2] (RW)
 *
 * Values:
 * - 0 - Fixed priority arbitration is used for channel selection .
 * - 1 - Round robin arbitration is used for channel selection .
 */
/*@{*/
#define BP_DMA_CR_ERCA       (2U)          /*!< Bit position for DMA_CR_ERCA. */
#define BM_DMA_CR_ERCA       (0x00000004U) /*!< Bit mask for DMA_CR_ERCA. */
#define BS_DMA_CR_ERCA       (1U)          /*!< Bit field size in bits for DMA_CR_ERCA. */

/*! @brief Read current value of the DMA_CR_ERCA field. */
#define BR_DMA_CR_ERCA(x)    (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_ERCA))

/*! @brief Format value for bitfield DMA_CR_ERCA. */
#define BF_DMA_CR_ERCA(v)    ((uint32_t)((uint32_t)(v) << BP_DMA_CR_ERCA) & BM_DMA_CR_ERCA)

/*! @brief Set the ERCA field to a new value. */
#define BW_DMA_CR_ERCA(x, v) (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_ERCA) = (v))
/*@}*/

/*!
 * @name Register DMA_CR, field HOE[4] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Any error causes the HALT bit to set. Subsequently, all service
 *     requests are ignored until the HALT bit is cleared.
 */
/*@{*/
#define BP_DMA_CR_HOE        (4U)          /*!< Bit position for DMA_CR_HOE. */
#define BM_DMA_CR_HOE        (0x00000010U) /*!< Bit mask for DMA_CR_HOE. */
#define BS_DMA_CR_HOE        (1U)          /*!< Bit field size in bits for DMA_CR_HOE. */

/*! @brief Read current value of the DMA_CR_HOE field. */
#define BR_DMA_CR_HOE(x)     (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_HOE))

/*! @brief Format value for bitfield DMA_CR_HOE. */
#define BF_DMA_CR_HOE(v)     ((uint32_t)((uint32_t)(v) << BP_DMA_CR_HOE) & BM_DMA_CR_HOE)

/*! @brief Set the HOE field to a new value. */
#define BW_DMA_CR_HOE(x, v)  (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_HOE) = (v))
/*@}*/

/*!
 * @name Register DMA_CR, field HALT[5] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Stall the start of any new channels. Executing channels are allowed to
 *     complete. Channel execution resumes when this bit is cleared.
 */
/*@{*/
#define BP_DMA_CR_HALT       (5U)          /*!< Bit position for DMA_CR_HALT. */
#define BM_DMA_CR_HALT       (0x00000020U) /*!< Bit mask for DMA_CR_HALT. */
#define BS_DMA_CR_HALT       (1U)          /*!< Bit field size in bits for DMA_CR_HALT. */

/*! @brief Read current value of the DMA_CR_HALT field. */
#define BR_DMA_CR_HALT(x)    (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_HALT))

/*! @brief Format value for bitfield DMA_CR_HALT. */
#define BF_DMA_CR_HALT(v)    ((uint32_t)((uint32_t)(v) << BP_DMA_CR_HALT) & BM_DMA_CR_HALT)

/*! @brief Set the HALT field to a new value. */
#define BW_DMA_CR_HALT(x, v) (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_HALT) = (v))
/*@}*/

/*!
 * @name Register DMA_CR, field CLM[6] (RW)
 *
 * Values:
 * - 0 - A minor loop channel link made to itself goes through channel
 *     arbitration before being activated again.
 * - 1 - A minor loop channel link made to itself does not go through channel
 *     arbitration before being activated again. Upon minor loop completion, the
 *     channel activates again if that channel has a minor loop channel link
 *     enabled and the link channel is itself. This effectively applies the minor loop
 *     offsets and restarts the next minor loop.
 */
/*@{*/
#define BP_DMA_CR_CLM        (6U)          /*!< Bit position for DMA_CR_CLM. */
#define BM_DMA_CR_CLM        (0x00000040U) /*!< Bit mask for DMA_CR_CLM. */
#define BS_DMA_CR_CLM        (1U)          /*!< Bit field size in bits for DMA_CR_CLM. */

/*! @brief Read current value of the DMA_CR_CLM field. */
#define BR_DMA_CR_CLM(x)     (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_CLM))

/*! @brief Format value for bitfield DMA_CR_CLM. */
#define BF_DMA_CR_CLM(v)     ((uint32_t)((uint32_t)(v) << BP_DMA_CR_CLM) & BM_DMA_CR_CLM)

/*! @brief Set the CLM field to a new value. */
#define BW_DMA_CR_CLM(x, v)  (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_CLM) = (v))
/*@}*/

/*!
 * @name Register DMA_CR, field EMLM[7] (RW)
 *
 * Values:
 * - 0 - Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
 * - 1 - Enabled. TCDn.word2 is redefined to include individual enable fields,
 *     an offset field, and the NBYTES field. The individual enable fields allow
 *     the minor loop offset to be applied to the source address, the destination
 *     address, or both. The NBYTES field is reduced when either offset is
 *     enabled.
 */
/*@{*/
#define BP_DMA_CR_EMLM       (7U)          /*!< Bit position for DMA_CR_EMLM. */
#define BM_DMA_CR_EMLM       (0x00000080U) /*!< Bit mask for DMA_CR_EMLM. */
#define BS_DMA_CR_EMLM       (1U)          /*!< Bit field size in bits for DMA_CR_EMLM. */

/*! @brief Read current value of the DMA_CR_EMLM field. */
#define BR_DMA_CR_EMLM(x)    (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_EMLM))

/*! @brief Format value for bitfield DMA_CR_EMLM. */
#define BF_DMA_CR_EMLM(v)    ((uint32_t)((uint32_t)(v) << BP_DMA_CR_EMLM) & BM_DMA_CR_EMLM)

/*! @brief Set the EMLM field to a new value. */
#define BW_DMA_CR_EMLM(x, v) (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_EMLM) = (v))
/*@}*/

/*!
 * @name Register DMA_CR, field ECX[16] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Cancel the remaining data transfer in the same fashion as the CX bit.
 *     Stop the executing channel and force the minor loop to finish. The cancel
 *     takes effect after the last write of the current read/write sequence. The
 *     ECX bit clears itself after the cancel is honored. In addition to
 *     cancelling the transfer, ECX treats the cancel as an error condition, thus updating
 *     the Error Status register (DMAx_ES) and generating an optional error
 *     interrupt.
 */
/*@{*/
#define BP_DMA_CR_ECX        (16U)         /*!< Bit position for DMA_CR_ECX. */
#define BM_DMA_CR_ECX        (0x00010000U) /*!< Bit mask for DMA_CR_ECX. */
#define BS_DMA_CR_ECX        (1U)          /*!< Bit field size in bits for DMA_CR_ECX. */

/*! @brief Read current value of the DMA_CR_ECX field. */
#define BR_DMA_CR_ECX(x)     (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_ECX))

/*! @brief Format value for bitfield DMA_CR_ECX. */
#define BF_DMA_CR_ECX(v)     ((uint32_t)((uint32_t)(v) << BP_DMA_CR_ECX) & BM_DMA_CR_ECX)

/*! @brief Set the ECX field to a new value. */
#define BW_DMA_CR_ECX(x, v)  (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_ECX) = (v))
/*@}*/

/*!
 * @name Register DMA_CR, field CX[17] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Cancel the remaining data transfer. Stop the executing channel and
 *     force the minor loop to finish. The cancel takes effect after the last write
 *     of the current read/write sequence. The CX bit clears itself after the
 *     cancel has been honored. This cancel retires the channel normally as if the
 *     minor loop was completed.
 */
/*@{*/
#define BP_DMA_CR_CX         (17U)         /*!< Bit position for DMA_CR_CX. */
#define BM_DMA_CR_CX         (0x00020000U) /*!< Bit mask for DMA_CR_CX. */
#define BS_DMA_CR_CX         (1U)          /*!< Bit field size in bits for DMA_CR_CX. */

/*! @brief Read current value of the DMA_CR_CX field. */
#define BR_DMA_CR_CX(x)      (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_CX))

/*! @brief Format value for bitfield DMA_CR_CX. */
#define BF_DMA_CR_CX(v)      ((uint32_t)((uint32_t)(v) << BP_DMA_CR_CX) & BM_DMA_CR_CX)

/*! @brief Set the CX field to a new value. */
#define BW_DMA_CR_CX(x, v)   (BITBAND_ACCESS32(HW_DMA_CR_ADDR(x), BP_DMA_CR_CX) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_ES - Error Status Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_ES - Error Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The ES provides information concerning the last recorded channel error.
 * Channel errors can be caused by: A configuration error, that is: An illegal setting
 * in the transfer-control descriptor, or An illegal priority register setting
 * in fixed-arbitration An error termination to a bus master read or write cycle
 * See the Error Reporting and Handling section for more details.
 */
typedef union _hw_dma_es
{
    uint32_t U;
    struct _hw_dma_es_bitfields
    {
        uint32_t DBE : 1;              /*!< [0] Destination Bus Error */
        uint32_t SBE : 1;              /*!< [1] Source Bus Error */
        uint32_t SGE : 1;              /*!< [2] Scatter/Gather Configuration Error */
        uint32_t NCE : 1;              /*!< [3] NBYTES/CITER Configuration Error */
        uint32_t DOE : 1;              /*!< [4] Destination Offset Error */
        uint32_t DAE : 1;              /*!< [5] Destination Address Error */
        uint32_t SOE : 1;              /*!< [6] Source Offset Error */
        uint32_t SAE : 1;              /*!< [7] Source Address Error */
        uint32_t ERRCHN : 4;           /*!< [11:8] Error Channel Number or Canceled
                                        * Channel Number */
        uint32_t RESERVED0 : 2;        /*!< [13:12]  */
        uint32_t CPE : 1;              /*!< [14] Channel Priority Error */
        uint32_t RESERVED1 : 1;        /*!< [15]  */
        uint32_t ECX : 1;              /*!< [16] Transfer Canceled */
        uint32_t RESERVED2 : 14;       /*!< [30:17]  */
        uint32_t VLD : 1;              /*!< [31]  */
    } B;
} hw_dma_es_t;

/*!
 * @name Constants and macros for entire DMA_ES register
 */
/*@{*/
#define HW_DMA_ES_ADDR(x)        ((uint32_t)(x) + 0x4U)

#define HW_DMA_ES(x)             (*(__I hw_dma_es_t *) HW_DMA_ES_ADDR(x))
#define HW_DMA_ES_RD(x)          (HW_DMA_ES(x).U)
/*@}*/

/*
 * Constants & macros for individual DMA_ES bitfields
 */

/*!
 * @name Register DMA_ES, field DBE[0] (RO)
 *
 * Values:
 * - 0 - No destination bus error
 * - 1 - The last recorded error was a bus error on a destination write
 */
/*@{*/
#define BP_DMA_ES_DBE        (0U)          /*!< Bit position for DMA_ES_DBE. */
#define BM_DMA_ES_DBE        (0x00000001U) /*!< Bit mask for DMA_ES_DBE. */
#define BS_DMA_ES_DBE        (1U)          /*!< Bit field size in bits for DMA_ES_DBE. */

/*! @brief Read current value of the DMA_ES_DBE field. */
#define BR_DMA_ES_DBE(x)     (BITBAND_ACCESS32(HW_DMA_ES_ADDR(x), BP_DMA_ES_DBE))
/*@}*/

/*!
 * @name Register DMA_ES, field SBE[1] (RO)
 *
 * Values:
 * - 0 - No source bus error
 * - 1 - The last recorded error was a bus error on a source read
 */
/*@{*/
#define BP_DMA_ES_SBE        (1U)          /*!< Bit position for DMA_ES_SBE. */
#define BM_DMA_ES_SBE        (0x00000002U) /*!< Bit mask for DMA_ES_SBE. */
#define BS_DMA_ES_SBE        (1U)          /*!< Bit field size in bits for DMA_ES_SBE. */

/*! @brief Read current value of the DMA_ES_SBE field. */
#define BR_DMA_ES_SBE(x)     (BITBAND_ACCESS32(HW_DMA_ES_ADDR(x), BP_DMA_ES_SBE))
/*@}*/

/*!
 * @name Register DMA_ES, field SGE[2] (RO)
 *
 * Values:
 * - 0 - No scatter/gather configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather
 *     operation after major loop completion if TCDn_CSR[ESG] is enabled.
 *     TCDn_DLASTSGA is not on a 32 byte boundary.
 */
/*@{*/
#define BP_DMA_ES_SGE        (2U)          /*!< Bit position for DMA_ES_SGE. */
#define BM_DMA_ES_SGE        (0x00000004U) /*!< Bit mask for DMA_ES_SGE. */
#define BS_DMA_ES_SGE        (1U)          /*!< Bit field size in bits for DMA_ES_SGE. */

/*! @brief Read current value of the DMA_ES_SGE field. */
#define BR_DMA_ES_SGE(x)     (BITBAND_ACCESS32(HW_DMA_ES_ADDR(x), BP_DMA_ES_SGE))
/*@}*/

/*!
 * @name Register DMA_ES, field NCE[3] (RO)
 *
 * Values:
 * - 0 - No NBYTES/CITER configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of
 *     TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or
 *     TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
 */
/*@{*/
#define BP_DMA_ES_NCE        (3U)          /*!< Bit position for DMA_ES_NCE. */
#define BM_DMA_ES_NCE        (0x00000008U) /*!< Bit mask for DMA_ES_NCE. */
#define BS_DMA_ES_NCE        (1U)          /*!< Bit field size in bits for DMA_ES_NCE. */

/*! @brief Read current value of the DMA_ES_NCE field. */
#define BR_DMA_ES_NCE(x)     (BITBAND_ACCESS32(HW_DMA_ES_ADDR(x), BP_DMA_ES_NCE))
/*@}*/

/*!
 * @name Register DMA_ES, field DOE[4] (RO)
 *
 * Values:
 * - 0 - No destination offset configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
#define BP_DMA_ES_DOE        (4U)          /*!< Bit position for DMA_ES_DOE. */
#define BM_DMA_ES_DOE        (0x00000010U) /*!< Bit mask for DMA_ES_DOE. */
#define BS_DMA_ES_DOE        (1U)          /*!< Bit field size in bits for DMA_ES_DOE. */

/*! @brief Read current value of the DMA_ES_DOE field. */
#define BR_DMA_ES_DOE(x)     (BITBAND_ACCESS32(HW_DMA_ES_ADDR(x), BP_DMA_ES_DOE))
/*@}*/

/*!
 * @name Register DMA_ES, field DAE[5] (RO)
 *
 * Values:
 * - 0 - No destination address configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
#define BP_DMA_ES_DAE        (5U)          /*!< Bit position for DMA_ES_DAE. */
#define BM_DMA_ES_DAE        (0x00000020U) /*!< Bit mask for DMA_ES_DAE. */
#define BS_DMA_ES_DAE        (1U)          /*!< Bit field size in bits for DMA_ES_DAE. */

/*! @brief Read current value of the DMA_ES_DAE field. */
#define BR_DMA_ES_DAE(x)     (BITBAND_ACCESS32(HW_DMA_ES_ADDR(x), BP_DMA_ES_DAE))
/*@}*/

/*!
 * @name Register DMA_ES, field SOE[6] (RO)
 *
 * Values:
 * - 0 - No source offset configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
#define BP_DMA_ES_SOE        (6U)          /*!< Bit position for DMA_ES_SOE. */
#define BM_DMA_ES_SOE        (0x00000040U) /*!< Bit mask for DMA_ES_SOE. */
#define BS_DMA_ES_SOE        (1U)          /*!< Bit field size in bits for DMA_ES_SOE. */

/*! @brief Read current value of the DMA_ES_SOE field. */
#define BR_DMA_ES_SOE(x)     (BITBAND_ACCESS32(HW_DMA_ES_ADDR(x), BP_DMA_ES_SOE))
/*@}*/

/*!
 * @name Register DMA_ES, field SAE[7] (RO)
 *
 * Values:
 * - 0 - No source address configuration error.
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
#define BP_DMA_ES_SAE        (7U)          /*!< Bit position for DMA_ES_SAE. */
#define BM_DMA_ES_SAE        (0x00000080U) /*!< Bit mask for DMA_ES_SAE. */
#define BS_DMA_ES_SAE        (1U)          /*!< Bit field size in bits for DMA_ES_SAE. */

/*! @brief Read current value of the DMA_ES_SAE field. */
#define BR_DMA_ES_SAE(x)     (BITBAND_ACCESS32(HW_DMA_ES_ADDR(x), BP_DMA_ES_SAE))
/*@}*/

/*!
 * @name Register DMA_ES, field ERRCHN[11:8] (RO)
 *
 * The channel number of the last recorded error (excluding CPE errors) or last
 * recorded error canceled transfer.
 */
/*@{*/
#define BP_DMA_ES_ERRCHN     (8U)          /*!< Bit position for DMA_ES_ERRCHN. */
#define BM_DMA_ES_ERRCHN     (0x00000F00U) /*!< Bit mask for DMA_ES_ERRCHN. */
#define BS_DMA_ES_ERRCHN     (4U)          /*!< Bit field size in bits for DMA_ES_ERRCHN. */

/*! @brief Read current value of the DMA_ES_ERRCHN field. */
#define BR_DMA_ES_ERRCHN(x)  (HW_DMA_ES(x).B.ERRCHN)
/*@}*/

/*!
 * @name Register DMA_ES, field CPE[14] (RO)
 *
 * Values:
 * - 0 - No channel priority error
 * - 1 - The last recorded error was a configuration error in the channel
 *     priorities . Channel priorities are not unique.
 */
/*@{*/
#define BP_DMA_ES_CPE        (14U)         /*!< Bit position for DMA_ES_CPE. */
#define BM_DMA_ES_CPE        (0x00004000U) /*!< Bit mask for DMA_ES_CPE. */
#define BS_DMA_ES_CPE        (1U)          /*!< Bit field size in bits for DMA_ES_CPE. */

/*! @brief Read current value of the DMA_ES_CPE field. */
#define BR_DMA_ES_CPE(x)     (BITBAND_ACCESS32(HW_DMA_ES_ADDR(x), BP_DMA_ES_CPE))
/*@}*/

/*!
 * @name Register DMA_ES, field ECX[16] (RO)
 *
 * Values:
 * - 0 - No canceled transfers
 * - 1 - The last recorded entry was a canceled transfer by the error cancel
 *     transfer input
 */
/*@{*/
#define BP_DMA_ES_ECX        (16U)         /*!< Bit position for DMA_ES_ECX. */
#define BM_DMA_ES_ECX        (0x00010000U) /*!< Bit mask for DMA_ES_ECX. */
#define BS_DMA_ES_ECX        (1U)          /*!< Bit field size in bits for DMA_ES_ECX. */

/*! @brief Read current value of the DMA_ES_ECX field. */
#define BR_DMA_ES_ECX(x)     (BITBAND_ACCESS32(HW_DMA_ES_ADDR(x), BP_DMA_ES_ECX))
/*@}*/

/*!
 * @name Register DMA_ES, field VLD[31] (RO)
 *
 * Logical OR of all ERR status bits
 *
 * Values:
 * - 0 - No ERR bits are set
 * - 1 - At least one ERR bit is set indicating a valid error exists that has
 *     not been cleared
 */
/*@{*/
#define BP_DMA_ES_VLD        (31U)         /*!< Bit position for DMA_ES_VLD. */
#define BM_DMA_ES_VLD        (0x80000000U) /*!< Bit mask for DMA_ES_VLD. */
#define BS_DMA_ES_VLD        (1U)          /*!< Bit field size in bits for DMA_ES_VLD. */

/*! @brief Read current value of the DMA_ES_VLD field. */
#define BR_DMA_ES_VLD(x)     (BITBAND_ACCESS32(HW_DMA_ES_ADDR(x), BP_DMA_ES_VLD))
/*@}*/

/*******************************************************************************
 * HW_DMA_ERQ - Enable Request Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_ERQ - Enable Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERQ register provides a bit map for the 16 implemented channels to enable
 * the request signal for each channel. The state of any given channel enable is
 * directly affected by writes to this register; it is also affected by writes
 * to the SERQ and CERQ. The {S,C}ERQ registers are provided so the request enable
 * for a single channel can easily be modified without needing to perform a
 * read-modify-write sequence to the ERQ. DMA request input signals and this enable
 * request flag must be asserted before a channel's hardware service request is
 * accepted. The state of the DMA enable request flag does not affect a channel
 * service request made explicitly through software or a linked channel request.
 */
typedef union _hw_dma_erq
{
    uint32_t U;
    struct _hw_dma_erq_bitfields
    {
        uint32_t ERQ0 : 1;             /*!< [0] Enable DMA Request 0 */
        uint32_t ERQ1 : 1;             /*!< [1] Enable DMA Request 1 */
        uint32_t ERQ2 : 1;             /*!< [2] Enable DMA Request 2 */
        uint32_t ERQ3 : 1;             /*!< [3] Enable DMA Request 3 */
        uint32_t ERQ4 : 1;             /*!< [4] Enable DMA Request 4 */
        uint32_t ERQ5 : 1;             /*!< [5] Enable DMA Request 5 */
        uint32_t ERQ6 : 1;             /*!< [6] Enable DMA Request 6 */
        uint32_t ERQ7 : 1;             /*!< [7] Enable DMA Request 7 */
        uint32_t ERQ8 : 1;             /*!< [8] Enable DMA Request 8 */
        uint32_t ERQ9 : 1;             /*!< [9] Enable DMA Request 9 */
        uint32_t ERQ10 : 1;            /*!< [10] Enable DMA Request 10 */
        uint32_t ERQ11 : 1;            /*!< [11] Enable DMA Request 11 */
        uint32_t ERQ12 : 1;            /*!< [12] Enable DMA Request 12 */
        uint32_t ERQ13 : 1;            /*!< [13] Enable DMA Request 13 */
        uint32_t ERQ14 : 1;            /*!< [14] Enable DMA Request 14 */
        uint32_t ERQ15 : 1;            /*!< [15] Enable DMA Request 15 */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_dma_erq_t;

/*!
 * @name Constants and macros for entire DMA_ERQ register
 */
/*@{*/
#define HW_DMA_ERQ_ADDR(x)       ((uint32_t)(x) + 0xCU)

#define HW_DMA_ERQ(x)            (*(__IO hw_dma_erq_t *) HW_DMA_ERQ_ADDR(x))
#define HW_DMA_ERQ_RD(x)         (HW_DMA_ERQ(x).U)
#define HW_DMA_ERQ_WR(x, v)      (HW_DMA_ERQ(x).U = (v))
#define HW_DMA_ERQ_SET(x, v)     (HW_DMA_ERQ_WR(x, HW_DMA_ERQ_RD(x) |  (v)))
#define HW_DMA_ERQ_CLR(x, v)     (HW_DMA_ERQ_WR(x, HW_DMA_ERQ_RD(x) & ~(v)))
#define HW_DMA_ERQ_TOG(x, v)     (HW_DMA_ERQ_WR(x, HW_DMA_ERQ_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERQ bitfields
 */

/*!
 * @name Register DMA_ERQ, field ERQ0[0] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ0      (0U)          /*!< Bit position for DMA_ERQ_ERQ0. */
#define BM_DMA_ERQ_ERQ0      (0x00000001U) /*!< Bit mask for DMA_ERQ_ERQ0. */
#define BS_DMA_ERQ_ERQ0      (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ0. */

/*! @brief Read current value of the DMA_ERQ_ERQ0 field. */
#define BR_DMA_ERQ_ERQ0(x)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ0))

/*! @brief Format value for bitfield DMA_ERQ_ERQ0. */
#define BF_DMA_ERQ_ERQ0(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ0) & BM_DMA_ERQ_ERQ0)

/*! @brief Set the ERQ0 field to a new value. */
#define BW_DMA_ERQ_ERQ0(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ0) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ1[1] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ1      (1U)          /*!< Bit position for DMA_ERQ_ERQ1. */
#define BM_DMA_ERQ_ERQ1      (0x00000002U) /*!< Bit mask for DMA_ERQ_ERQ1. */
#define BS_DMA_ERQ_ERQ1      (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ1. */

/*! @brief Read current value of the DMA_ERQ_ERQ1 field. */
#define BR_DMA_ERQ_ERQ1(x)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ1))

/*! @brief Format value for bitfield DMA_ERQ_ERQ1. */
#define BF_DMA_ERQ_ERQ1(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ1) & BM_DMA_ERQ_ERQ1)

/*! @brief Set the ERQ1 field to a new value. */
#define BW_DMA_ERQ_ERQ1(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ1) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ2[2] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ2      (2U)          /*!< Bit position for DMA_ERQ_ERQ2. */
#define BM_DMA_ERQ_ERQ2      (0x00000004U) /*!< Bit mask for DMA_ERQ_ERQ2. */
#define BS_DMA_ERQ_ERQ2      (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ2. */

/*! @brief Read current value of the DMA_ERQ_ERQ2 field. */
#define BR_DMA_ERQ_ERQ2(x)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ2))

/*! @brief Format value for bitfield DMA_ERQ_ERQ2. */
#define BF_DMA_ERQ_ERQ2(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ2) & BM_DMA_ERQ_ERQ2)

/*! @brief Set the ERQ2 field to a new value. */
#define BW_DMA_ERQ_ERQ2(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ2) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ3[3] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ3      (3U)          /*!< Bit position for DMA_ERQ_ERQ3. */
#define BM_DMA_ERQ_ERQ3      (0x00000008U) /*!< Bit mask for DMA_ERQ_ERQ3. */
#define BS_DMA_ERQ_ERQ3      (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ3. */

/*! @brief Read current value of the DMA_ERQ_ERQ3 field. */
#define BR_DMA_ERQ_ERQ3(x)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ3))

/*! @brief Format value for bitfield DMA_ERQ_ERQ3. */
#define BF_DMA_ERQ_ERQ3(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ3) & BM_DMA_ERQ_ERQ3)

/*! @brief Set the ERQ3 field to a new value. */
#define BW_DMA_ERQ_ERQ3(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ3) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ4[4] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ4      (4U)          /*!< Bit position for DMA_ERQ_ERQ4. */
#define BM_DMA_ERQ_ERQ4      (0x00000010U) /*!< Bit mask for DMA_ERQ_ERQ4. */
#define BS_DMA_ERQ_ERQ4      (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ4. */

/*! @brief Read current value of the DMA_ERQ_ERQ4 field. */
#define BR_DMA_ERQ_ERQ4(x)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ4))

/*! @brief Format value for bitfield DMA_ERQ_ERQ4. */
#define BF_DMA_ERQ_ERQ4(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ4) & BM_DMA_ERQ_ERQ4)

/*! @brief Set the ERQ4 field to a new value. */
#define BW_DMA_ERQ_ERQ4(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ4) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ5[5] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ5      (5U)          /*!< Bit position for DMA_ERQ_ERQ5. */
#define BM_DMA_ERQ_ERQ5      (0x00000020U) /*!< Bit mask for DMA_ERQ_ERQ5. */
#define BS_DMA_ERQ_ERQ5      (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ5. */

/*! @brief Read current value of the DMA_ERQ_ERQ5 field. */
#define BR_DMA_ERQ_ERQ5(x)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ5))

/*! @brief Format value for bitfield DMA_ERQ_ERQ5. */
#define BF_DMA_ERQ_ERQ5(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ5) & BM_DMA_ERQ_ERQ5)

/*! @brief Set the ERQ5 field to a new value. */
#define BW_DMA_ERQ_ERQ5(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ5) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ6[6] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ6      (6U)          /*!< Bit position for DMA_ERQ_ERQ6. */
#define BM_DMA_ERQ_ERQ6      (0x00000040U) /*!< Bit mask for DMA_ERQ_ERQ6. */
#define BS_DMA_ERQ_ERQ6      (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ6. */

/*! @brief Read current value of the DMA_ERQ_ERQ6 field. */
#define BR_DMA_ERQ_ERQ6(x)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ6))

/*! @brief Format value for bitfield DMA_ERQ_ERQ6. */
#define BF_DMA_ERQ_ERQ6(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ6) & BM_DMA_ERQ_ERQ6)

/*! @brief Set the ERQ6 field to a new value. */
#define BW_DMA_ERQ_ERQ6(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ6) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ7[7] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ7      (7U)          /*!< Bit position for DMA_ERQ_ERQ7. */
#define BM_DMA_ERQ_ERQ7      (0x00000080U) /*!< Bit mask for DMA_ERQ_ERQ7. */
#define BS_DMA_ERQ_ERQ7      (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ7. */

/*! @brief Read current value of the DMA_ERQ_ERQ7 field. */
#define BR_DMA_ERQ_ERQ7(x)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ7))

/*! @brief Format value for bitfield DMA_ERQ_ERQ7. */
#define BF_DMA_ERQ_ERQ7(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ7) & BM_DMA_ERQ_ERQ7)

/*! @brief Set the ERQ7 field to a new value. */
#define BW_DMA_ERQ_ERQ7(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ7) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ8[8] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ8      (8U)          /*!< Bit position for DMA_ERQ_ERQ8. */
#define BM_DMA_ERQ_ERQ8      (0x00000100U) /*!< Bit mask for DMA_ERQ_ERQ8. */
#define BS_DMA_ERQ_ERQ8      (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ8. */

/*! @brief Read current value of the DMA_ERQ_ERQ8 field. */
#define BR_DMA_ERQ_ERQ8(x)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ8))

/*! @brief Format value for bitfield DMA_ERQ_ERQ8. */
#define BF_DMA_ERQ_ERQ8(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ8) & BM_DMA_ERQ_ERQ8)

/*! @brief Set the ERQ8 field to a new value. */
#define BW_DMA_ERQ_ERQ8(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ8) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ9[9] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ9      (9U)          /*!< Bit position for DMA_ERQ_ERQ9. */
#define BM_DMA_ERQ_ERQ9      (0x00000200U) /*!< Bit mask for DMA_ERQ_ERQ9. */
#define BS_DMA_ERQ_ERQ9      (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ9. */

/*! @brief Read current value of the DMA_ERQ_ERQ9 field. */
#define BR_DMA_ERQ_ERQ9(x)   (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ9))

/*! @brief Format value for bitfield DMA_ERQ_ERQ9. */
#define BF_DMA_ERQ_ERQ9(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ9) & BM_DMA_ERQ_ERQ9)

/*! @brief Set the ERQ9 field to a new value. */
#define BW_DMA_ERQ_ERQ9(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ9) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ10[10] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ10     (10U)         /*!< Bit position for DMA_ERQ_ERQ10. */
#define BM_DMA_ERQ_ERQ10     (0x00000400U) /*!< Bit mask for DMA_ERQ_ERQ10. */
#define BS_DMA_ERQ_ERQ10     (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ10. */

/*! @brief Read current value of the DMA_ERQ_ERQ10 field. */
#define BR_DMA_ERQ_ERQ10(x)  (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ10))

/*! @brief Format value for bitfield DMA_ERQ_ERQ10. */
#define BF_DMA_ERQ_ERQ10(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ10) & BM_DMA_ERQ_ERQ10)

/*! @brief Set the ERQ10 field to a new value. */
#define BW_DMA_ERQ_ERQ10(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ10) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ11[11] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ11     (11U)         /*!< Bit position for DMA_ERQ_ERQ11. */
#define BM_DMA_ERQ_ERQ11     (0x00000800U) /*!< Bit mask for DMA_ERQ_ERQ11. */
#define BS_DMA_ERQ_ERQ11     (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ11. */

/*! @brief Read current value of the DMA_ERQ_ERQ11 field. */
#define BR_DMA_ERQ_ERQ11(x)  (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ11))

/*! @brief Format value for bitfield DMA_ERQ_ERQ11. */
#define BF_DMA_ERQ_ERQ11(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ11) & BM_DMA_ERQ_ERQ11)

/*! @brief Set the ERQ11 field to a new value. */
#define BW_DMA_ERQ_ERQ11(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ11) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ12[12] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ12     (12U)         /*!< Bit position for DMA_ERQ_ERQ12. */
#define BM_DMA_ERQ_ERQ12     (0x00001000U) /*!< Bit mask for DMA_ERQ_ERQ12. */
#define BS_DMA_ERQ_ERQ12     (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ12. */

/*! @brief Read current value of the DMA_ERQ_ERQ12 field. */
#define BR_DMA_ERQ_ERQ12(x)  (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ12))

/*! @brief Format value for bitfield DMA_ERQ_ERQ12. */
#define BF_DMA_ERQ_ERQ12(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ12) & BM_DMA_ERQ_ERQ12)

/*! @brief Set the ERQ12 field to a new value. */
#define BW_DMA_ERQ_ERQ12(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ12) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ13[13] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ13     (13U)         /*!< Bit position for DMA_ERQ_ERQ13. */
#define BM_DMA_ERQ_ERQ13     (0x00002000U) /*!< Bit mask for DMA_ERQ_ERQ13. */
#define BS_DMA_ERQ_ERQ13     (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ13. */

/*! @brief Read current value of the DMA_ERQ_ERQ13 field. */
#define BR_DMA_ERQ_ERQ13(x)  (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ13))

/*! @brief Format value for bitfield DMA_ERQ_ERQ13. */
#define BF_DMA_ERQ_ERQ13(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ13) & BM_DMA_ERQ_ERQ13)

/*! @brief Set the ERQ13 field to a new value. */
#define BW_DMA_ERQ_ERQ13(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ13) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ14[14] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ14     (14U)         /*!< Bit position for DMA_ERQ_ERQ14. */
#define BM_DMA_ERQ_ERQ14     (0x00004000U) /*!< Bit mask for DMA_ERQ_ERQ14. */
#define BS_DMA_ERQ_ERQ14     (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ14. */

/*! @brief Read current value of the DMA_ERQ_ERQ14 field. */
#define BR_DMA_ERQ_ERQ14(x)  (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ14))

/*! @brief Format value for bitfield DMA_ERQ_ERQ14. */
#define BF_DMA_ERQ_ERQ14(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ14) & BM_DMA_ERQ_ERQ14)

/*! @brief Set the ERQ14 field to a new value. */
#define BW_DMA_ERQ_ERQ14(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ14) = (v))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ15[15] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
#define BP_DMA_ERQ_ERQ15     (15U)         /*!< Bit position for DMA_ERQ_ERQ15. */
#define BM_DMA_ERQ_ERQ15     (0x00008000U) /*!< Bit mask for DMA_ERQ_ERQ15. */
#define BS_DMA_ERQ_ERQ15     (1U)          /*!< Bit field size in bits for DMA_ERQ_ERQ15. */

/*! @brief Read current value of the DMA_ERQ_ERQ15 field. */
#define BR_DMA_ERQ_ERQ15(x)  (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ15))

/*! @brief Format value for bitfield DMA_ERQ_ERQ15. */
#define BF_DMA_ERQ_ERQ15(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERQ_ERQ15) & BM_DMA_ERQ_ERQ15)

/*! @brief Set the ERQ15 field to a new value. */
#define BW_DMA_ERQ_ERQ15(x, v) (BITBAND_ACCESS32(HW_DMA_ERQ_ADDR(x), BP_DMA_ERQ_ERQ15) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_EEI - Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_EEI - Enable Error Interrupt Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The EEI register provides a bit map for the 16 channels to enable the error
 * interrupt signal for each channel. The state of any given channel's error
 * interrupt enable is directly affected by writes to this register; it is also
 * affected by writes to the SEEI and CEEI. The {S,C}EEI are provided so the error
 * interrupt enable for a single channel can easily be modified without the need to
 * perform a read-modify-write sequence to the EEI register. The DMA error
 * indicator and the error interrupt enable flag must be asserted before an error
 * interrupt request for a given channel is asserted to the interrupt controller.
 */
typedef union _hw_dma_eei
{
    uint32_t U;
    struct _hw_dma_eei_bitfields
    {
        uint32_t EEI0 : 1;             /*!< [0] Enable Error Interrupt 0 */
        uint32_t EEI1 : 1;             /*!< [1] Enable Error Interrupt 1 */
        uint32_t EEI2 : 1;             /*!< [2] Enable Error Interrupt 2 */
        uint32_t EEI3 : 1;             /*!< [3] Enable Error Interrupt 3 */
        uint32_t EEI4 : 1;             /*!< [4] Enable Error Interrupt 4 */
        uint32_t EEI5 : 1;             /*!< [5] Enable Error Interrupt 5 */
        uint32_t EEI6 : 1;             /*!< [6] Enable Error Interrupt 6 */
        uint32_t EEI7 : 1;             /*!< [7] Enable Error Interrupt 7 */
        uint32_t EEI8 : 1;             /*!< [8] Enable Error Interrupt 8 */
        uint32_t EEI9 : 1;             /*!< [9] Enable Error Interrupt 9 */
        uint32_t EEI10 : 1;            /*!< [10] Enable Error Interrupt 10 */
        uint32_t EEI11 : 1;            /*!< [11] Enable Error Interrupt 11 */
        uint32_t EEI12 : 1;            /*!< [12] Enable Error Interrupt 12 */
        uint32_t EEI13 : 1;            /*!< [13] Enable Error Interrupt 13 */
        uint32_t EEI14 : 1;            /*!< [14] Enable Error Interrupt 14 */
        uint32_t EEI15 : 1;            /*!< [15] Enable Error Interrupt 15 */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_dma_eei_t;

/*!
 * @name Constants and macros for entire DMA_EEI register
 */
/*@{*/
#define HW_DMA_EEI_ADDR(x)       ((uint32_t)(x) + 0x14U)

#define HW_DMA_EEI(x)            (*(__IO hw_dma_eei_t *) HW_DMA_EEI_ADDR(x))
#define HW_DMA_EEI_RD(x)         (HW_DMA_EEI(x).U)
#define HW_DMA_EEI_WR(x, v)      (HW_DMA_EEI(x).U = (v))
#define HW_DMA_EEI_SET(x, v)     (HW_DMA_EEI_WR(x, HW_DMA_EEI_RD(x) |  (v)))
#define HW_DMA_EEI_CLR(x, v)     (HW_DMA_EEI_WR(x, HW_DMA_EEI_RD(x) & ~(v)))
#define HW_DMA_EEI_TOG(x, v)     (HW_DMA_EEI_WR(x, HW_DMA_EEI_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_EEI bitfields
 */

/*!
 * @name Register DMA_EEI, field EEI0[0] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI0      (0U)          /*!< Bit position for DMA_EEI_EEI0. */
#define BM_DMA_EEI_EEI0      (0x00000001U) /*!< Bit mask for DMA_EEI_EEI0. */
#define BS_DMA_EEI_EEI0      (1U)          /*!< Bit field size in bits for DMA_EEI_EEI0. */

/*! @brief Read current value of the DMA_EEI_EEI0 field. */
#define BR_DMA_EEI_EEI0(x)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI0))

/*! @brief Format value for bitfield DMA_EEI_EEI0. */
#define BF_DMA_EEI_EEI0(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI0) & BM_DMA_EEI_EEI0)

/*! @brief Set the EEI0 field to a new value. */
#define BW_DMA_EEI_EEI0(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI0) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI1[1] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI1      (1U)          /*!< Bit position for DMA_EEI_EEI1. */
#define BM_DMA_EEI_EEI1      (0x00000002U) /*!< Bit mask for DMA_EEI_EEI1. */
#define BS_DMA_EEI_EEI1      (1U)          /*!< Bit field size in bits for DMA_EEI_EEI1. */

/*! @brief Read current value of the DMA_EEI_EEI1 field. */
#define BR_DMA_EEI_EEI1(x)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI1))

/*! @brief Format value for bitfield DMA_EEI_EEI1. */
#define BF_DMA_EEI_EEI1(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI1) & BM_DMA_EEI_EEI1)

/*! @brief Set the EEI1 field to a new value. */
#define BW_DMA_EEI_EEI1(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI1) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI2[2] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI2      (2U)          /*!< Bit position for DMA_EEI_EEI2. */
#define BM_DMA_EEI_EEI2      (0x00000004U) /*!< Bit mask for DMA_EEI_EEI2. */
#define BS_DMA_EEI_EEI2      (1U)          /*!< Bit field size in bits for DMA_EEI_EEI2. */

/*! @brief Read current value of the DMA_EEI_EEI2 field. */
#define BR_DMA_EEI_EEI2(x)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI2))

/*! @brief Format value for bitfield DMA_EEI_EEI2. */
#define BF_DMA_EEI_EEI2(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI2) & BM_DMA_EEI_EEI2)

/*! @brief Set the EEI2 field to a new value. */
#define BW_DMA_EEI_EEI2(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI2) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI3[3] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI3      (3U)          /*!< Bit position for DMA_EEI_EEI3. */
#define BM_DMA_EEI_EEI3      (0x00000008U) /*!< Bit mask for DMA_EEI_EEI3. */
#define BS_DMA_EEI_EEI3      (1U)          /*!< Bit field size in bits for DMA_EEI_EEI3. */

/*! @brief Read current value of the DMA_EEI_EEI3 field. */
#define BR_DMA_EEI_EEI3(x)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI3))

/*! @brief Format value for bitfield DMA_EEI_EEI3. */
#define BF_DMA_EEI_EEI3(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI3) & BM_DMA_EEI_EEI3)

/*! @brief Set the EEI3 field to a new value. */
#define BW_DMA_EEI_EEI3(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI3) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI4[4] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI4      (4U)          /*!< Bit position for DMA_EEI_EEI4. */
#define BM_DMA_EEI_EEI4      (0x00000010U) /*!< Bit mask for DMA_EEI_EEI4. */
#define BS_DMA_EEI_EEI4      (1U)          /*!< Bit field size in bits for DMA_EEI_EEI4. */

/*! @brief Read current value of the DMA_EEI_EEI4 field. */
#define BR_DMA_EEI_EEI4(x)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI4))

/*! @brief Format value for bitfield DMA_EEI_EEI4. */
#define BF_DMA_EEI_EEI4(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI4) & BM_DMA_EEI_EEI4)

/*! @brief Set the EEI4 field to a new value. */
#define BW_DMA_EEI_EEI4(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI4) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI5[5] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI5      (5U)          /*!< Bit position for DMA_EEI_EEI5. */
#define BM_DMA_EEI_EEI5      (0x00000020U) /*!< Bit mask for DMA_EEI_EEI5. */
#define BS_DMA_EEI_EEI5      (1U)          /*!< Bit field size in bits for DMA_EEI_EEI5. */

/*! @brief Read current value of the DMA_EEI_EEI5 field. */
#define BR_DMA_EEI_EEI5(x)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI5))

/*! @brief Format value for bitfield DMA_EEI_EEI5. */
#define BF_DMA_EEI_EEI5(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI5) & BM_DMA_EEI_EEI5)

/*! @brief Set the EEI5 field to a new value. */
#define BW_DMA_EEI_EEI5(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI5) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI6[6] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI6      (6U)          /*!< Bit position for DMA_EEI_EEI6. */
#define BM_DMA_EEI_EEI6      (0x00000040U) /*!< Bit mask for DMA_EEI_EEI6. */
#define BS_DMA_EEI_EEI6      (1U)          /*!< Bit field size in bits for DMA_EEI_EEI6. */

/*! @brief Read current value of the DMA_EEI_EEI6 field. */
#define BR_DMA_EEI_EEI6(x)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI6))

/*! @brief Format value for bitfield DMA_EEI_EEI6. */
#define BF_DMA_EEI_EEI6(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI6) & BM_DMA_EEI_EEI6)

/*! @brief Set the EEI6 field to a new value. */
#define BW_DMA_EEI_EEI6(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI6) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI7[7] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI7      (7U)          /*!< Bit position for DMA_EEI_EEI7. */
#define BM_DMA_EEI_EEI7      (0x00000080U) /*!< Bit mask for DMA_EEI_EEI7. */
#define BS_DMA_EEI_EEI7      (1U)          /*!< Bit field size in bits for DMA_EEI_EEI7. */

/*! @brief Read current value of the DMA_EEI_EEI7 field. */
#define BR_DMA_EEI_EEI7(x)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI7))

/*! @brief Format value for bitfield DMA_EEI_EEI7. */
#define BF_DMA_EEI_EEI7(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI7) & BM_DMA_EEI_EEI7)

/*! @brief Set the EEI7 field to a new value. */
#define BW_DMA_EEI_EEI7(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI7) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI8[8] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI8      (8U)          /*!< Bit position for DMA_EEI_EEI8. */
#define BM_DMA_EEI_EEI8      (0x00000100U) /*!< Bit mask for DMA_EEI_EEI8. */
#define BS_DMA_EEI_EEI8      (1U)          /*!< Bit field size in bits for DMA_EEI_EEI8. */

/*! @brief Read current value of the DMA_EEI_EEI8 field. */
#define BR_DMA_EEI_EEI8(x)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI8))

/*! @brief Format value for bitfield DMA_EEI_EEI8. */
#define BF_DMA_EEI_EEI8(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI8) & BM_DMA_EEI_EEI8)

/*! @brief Set the EEI8 field to a new value. */
#define BW_DMA_EEI_EEI8(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI8) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI9[9] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI9      (9U)          /*!< Bit position for DMA_EEI_EEI9. */
#define BM_DMA_EEI_EEI9      (0x00000200U) /*!< Bit mask for DMA_EEI_EEI9. */
#define BS_DMA_EEI_EEI9      (1U)          /*!< Bit field size in bits for DMA_EEI_EEI9. */

/*! @brief Read current value of the DMA_EEI_EEI9 field. */
#define BR_DMA_EEI_EEI9(x)   (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI9))

/*! @brief Format value for bitfield DMA_EEI_EEI9. */
#define BF_DMA_EEI_EEI9(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI9) & BM_DMA_EEI_EEI9)

/*! @brief Set the EEI9 field to a new value. */
#define BW_DMA_EEI_EEI9(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI9) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI10[10] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI10     (10U)         /*!< Bit position for DMA_EEI_EEI10. */
#define BM_DMA_EEI_EEI10     (0x00000400U) /*!< Bit mask for DMA_EEI_EEI10. */
#define BS_DMA_EEI_EEI10     (1U)          /*!< Bit field size in bits for DMA_EEI_EEI10. */

/*! @brief Read current value of the DMA_EEI_EEI10 field. */
#define BR_DMA_EEI_EEI10(x)  (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI10))

/*! @brief Format value for bitfield DMA_EEI_EEI10. */
#define BF_DMA_EEI_EEI10(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI10) & BM_DMA_EEI_EEI10)

/*! @brief Set the EEI10 field to a new value. */
#define BW_DMA_EEI_EEI10(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI10) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI11[11] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI11     (11U)         /*!< Bit position for DMA_EEI_EEI11. */
#define BM_DMA_EEI_EEI11     (0x00000800U) /*!< Bit mask for DMA_EEI_EEI11. */
#define BS_DMA_EEI_EEI11     (1U)          /*!< Bit field size in bits for DMA_EEI_EEI11. */

/*! @brief Read current value of the DMA_EEI_EEI11 field. */
#define BR_DMA_EEI_EEI11(x)  (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI11))

/*! @brief Format value for bitfield DMA_EEI_EEI11. */
#define BF_DMA_EEI_EEI11(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI11) & BM_DMA_EEI_EEI11)

/*! @brief Set the EEI11 field to a new value. */
#define BW_DMA_EEI_EEI11(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI11) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI12[12] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI12     (12U)         /*!< Bit position for DMA_EEI_EEI12. */
#define BM_DMA_EEI_EEI12     (0x00001000U) /*!< Bit mask for DMA_EEI_EEI12. */
#define BS_DMA_EEI_EEI12     (1U)          /*!< Bit field size in bits for DMA_EEI_EEI12. */

/*! @brief Read current value of the DMA_EEI_EEI12 field. */
#define BR_DMA_EEI_EEI12(x)  (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI12))

/*! @brief Format value for bitfield DMA_EEI_EEI12. */
#define BF_DMA_EEI_EEI12(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI12) & BM_DMA_EEI_EEI12)

/*! @brief Set the EEI12 field to a new value. */
#define BW_DMA_EEI_EEI12(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI12) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI13[13] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI13     (13U)         /*!< Bit position for DMA_EEI_EEI13. */
#define BM_DMA_EEI_EEI13     (0x00002000U) /*!< Bit mask for DMA_EEI_EEI13. */
#define BS_DMA_EEI_EEI13     (1U)          /*!< Bit field size in bits for DMA_EEI_EEI13. */

/*! @brief Read current value of the DMA_EEI_EEI13 field. */
#define BR_DMA_EEI_EEI13(x)  (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI13))

/*! @brief Format value for bitfield DMA_EEI_EEI13. */
#define BF_DMA_EEI_EEI13(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI13) & BM_DMA_EEI_EEI13)

/*! @brief Set the EEI13 field to a new value. */
#define BW_DMA_EEI_EEI13(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI13) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI14[14] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI14     (14U)         /*!< Bit position for DMA_EEI_EEI14. */
#define BM_DMA_EEI_EEI14     (0x00004000U) /*!< Bit mask for DMA_EEI_EEI14. */
#define BS_DMA_EEI_EEI14     (1U)          /*!< Bit field size in bits for DMA_EEI_EEI14. */

/*! @brief Read current value of the DMA_EEI_EEI14 field. */
#define BR_DMA_EEI_EEI14(x)  (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI14))

/*! @brief Format value for bitfield DMA_EEI_EEI14. */
#define BF_DMA_EEI_EEI14(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI14) & BM_DMA_EEI_EEI14)

/*! @brief Set the EEI14 field to a new value. */
#define BW_DMA_EEI_EEI14(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI14) = (v))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI15[15] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
#define BP_DMA_EEI_EEI15     (15U)         /*!< Bit position for DMA_EEI_EEI15. */
#define BM_DMA_EEI_EEI15     (0x00008000U) /*!< Bit mask for DMA_EEI_EEI15. */
#define BS_DMA_EEI_EEI15     (1U)          /*!< Bit field size in bits for DMA_EEI_EEI15. */

/*! @brief Read current value of the DMA_EEI_EEI15 field. */
#define BR_DMA_EEI_EEI15(x)  (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI15))

/*! @brief Format value for bitfield DMA_EEI_EEI15. */
#define BF_DMA_EEI_EEI15(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_EEI_EEI15) & BM_DMA_EEI_EEI15)

/*! @brief Set the EEI15 field to a new value. */
#define BW_DMA_EEI_EEI15(x, v) (BITBAND_ACCESS32(HW_DMA_EEI_ADDR(x), BP_DMA_EEI_EEI15) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_CEEI - Clear Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_CEEI - Clear Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CEEI provides a simple memory-mapped mechanism to clear a given bit in
 * the EEI to disable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be cleared. Setting
 * the CAEE bit provides a global clear function, forcing the EEI contents to be
 * cleared, disabling all DMA request inputs. If the NOP bit is set, the command
 * is ignored. This allows you to write multiple-byte registers as a 32-bit word.
 * Reads of this register return all zeroes.
 */
typedef union _hw_dma_ceei
{
    uint8_t U;
    struct _hw_dma_ceei_bitfields
    {
        uint8_t CEEI : 4;              /*!< [3:0] Clear Enable Error Interrupt */
        uint8_t RESERVED0 : 2;         /*!< [5:4]  */
        uint8_t CAEE : 1;              /*!< [6] Clear All Enable Error Interrupts */
        uint8_t NOP : 1;               /*!< [7] No Op enable */
    } B;
} hw_dma_ceei_t;

/*!
 * @name Constants and macros for entire DMA_CEEI register
 */
/*@{*/
#define HW_DMA_CEEI_ADDR(x)      ((uint32_t)(x) + 0x18U)

#define HW_DMA_CEEI(x)           (*(__O hw_dma_ceei_t *) HW_DMA_CEEI_ADDR(x))
#define HW_DMA_CEEI_RD(x)        (HW_DMA_CEEI(x).U)
#define HW_DMA_CEEI_WR(x, v)     (HW_DMA_CEEI(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual DMA_CEEI bitfields
 */

/*!
 * @name Register DMA_CEEI, field CEEI[3:0] (WORZ)
 *
 * Clears the corresponding bit in EEI
 */
/*@{*/
#define BP_DMA_CEEI_CEEI     (0U)          /*!< Bit position for DMA_CEEI_CEEI. */
#define BM_DMA_CEEI_CEEI     (0x0FU)       /*!< Bit mask for DMA_CEEI_CEEI. */
#define BS_DMA_CEEI_CEEI     (4U)          /*!< Bit field size in bits for DMA_CEEI_CEEI. */

/*! @brief Format value for bitfield DMA_CEEI_CEEI. */
#define BF_DMA_CEEI_CEEI(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_CEEI_CEEI) & BM_DMA_CEEI_CEEI)

/*! @brief Set the CEEI field to a new value. */
#define BW_DMA_CEEI_CEEI(x, v) (HW_DMA_CEEI_WR(x, (HW_DMA_CEEI_RD(x) & ~BM_DMA_CEEI_CEEI) | BF_DMA_CEEI_CEEI(v)))
/*@}*/

/*!
 * @name Register DMA_CEEI, field CAEE[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the EEI bit specified in the CEEI field
 * - 1 - Clear all bits in EEI
 */
/*@{*/
#define BP_DMA_CEEI_CAEE     (6U)          /*!< Bit position for DMA_CEEI_CAEE. */
#define BM_DMA_CEEI_CAEE     (0x40U)       /*!< Bit mask for DMA_CEEI_CAEE. */
#define BS_DMA_CEEI_CAEE     (1U)          /*!< Bit field size in bits for DMA_CEEI_CAEE. */

/*! @brief Format value for bitfield DMA_CEEI_CAEE. */
#define BF_DMA_CEEI_CAEE(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_CEEI_CAEE) & BM_DMA_CEEI_CAEE)

/*! @brief Set the CAEE field to a new value. */
#define BW_DMA_CEEI_CAEE(x, v) (BITBAND_ACCESS8(HW_DMA_CEEI_ADDR(x), BP_DMA_CEEI_CAEE) = (v))
/*@}*/

/*!
 * @name Register DMA_CEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
#define BP_DMA_CEEI_NOP      (7U)          /*!< Bit position for DMA_CEEI_NOP. */
#define BM_DMA_CEEI_NOP      (0x80U)       /*!< Bit mask for DMA_CEEI_NOP. */
#define BS_DMA_CEEI_NOP      (1U)          /*!< Bit field size in bits for DMA_CEEI_NOP. */

/*! @brief Format value for bitfield DMA_CEEI_NOP. */
#define BF_DMA_CEEI_NOP(v)   ((uint8_t)((uint8_t)(v) << BP_DMA_CEEI_NOP) & BM_DMA_CEEI_NOP)

/*! @brief Set the NOP field to a new value. */
#define BW_DMA_CEEI_NOP(x, v) (BITBAND_ACCESS8(HW_DMA_CEEI_ADDR(x), BP_DMA_CEEI_NOP) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_SEEI - Set Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_SEEI - Set Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SEEI provides a simple memory-mapped mechanism to set a given bit in the
 * EEI to enable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be set. Setting the
 * SAEE bit provides a global set function, forcing the entire EEI contents to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
typedef union _hw_dma_seei
{
    uint8_t U;
    struct _hw_dma_seei_bitfields
    {
        uint8_t SEEI : 4;              /*!< [3:0] Set Enable Error Interrupt */
        uint8_t RESERVED0 : 2;         /*!< [5:4]  */
        uint8_t SAEE : 1;              /*!< [6] Sets All Enable Error Interrupts */
        uint8_t NOP : 1;               /*!< [7] No Op enable */
    } B;
} hw_dma_seei_t;

/*!
 * @name Constants and macros for entire DMA_SEEI register
 */
/*@{*/
#define HW_DMA_SEEI_ADDR(x)      ((uint32_t)(x) + 0x19U)

#define HW_DMA_SEEI(x)           (*(__O hw_dma_seei_t *) HW_DMA_SEEI_ADDR(x))
#define HW_DMA_SEEI_RD(x)        (HW_DMA_SEEI(x).U)
#define HW_DMA_SEEI_WR(x, v)     (HW_DMA_SEEI(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual DMA_SEEI bitfields
 */

/*!
 * @name Register DMA_SEEI, field SEEI[3:0] (WORZ)
 *
 * Sets the corresponding bit in EEI
 */
/*@{*/
#define BP_DMA_SEEI_SEEI     (0U)          /*!< Bit position for DMA_SEEI_SEEI. */
#define BM_DMA_SEEI_SEEI     (0x0FU)       /*!< Bit mask for DMA_SEEI_SEEI. */
#define BS_DMA_SEEI_SEEI     (4U)          /*!< Bit field size in bits for DMA_SEEI_SEEI. */

/*! @brief Format value for bitfield DMA_SEEI_SEEI. */
#define BF_DMA_SEEI_SEEI(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_SEEI_SEEI) & BM_DMA_SEEI_SEEI)

/*! @brief Set the SEEI field to a new value. */
#define BW_DMA_SEEI_SEEI(x, v) (HW_DMA_SEEI_WR(x, (HW_DMA_SEEI_RD(x) & ~BM_DMA_SEEI_SEEI) | BF_DMA_SEEI_SEEI(v)))
/*@}*/

/*!
 * @name Register DMA_SEEI, field SAEE[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the EEI bit specified in the SEEI field.
 * - 1 - Sets all bits in EEI
 */
/*@{*/
#define BP_DMA_SEEI_SAEE     (6U)          /*!< Bit position for DMA_SEEI_SAEE. */
#define BM_DMA_SEEI_SAEE     (0x40U)       /*!< Bit mask for DMA_SEEI_SAEE. */
#define BS_DMA_SEEI_SAEE     (1U)          /*!< Bit field size in bits for DMA_SEEI_SAEE. */

/*! @brief Format value for bitfield DMA_SEEI_SAEE. */
#define BF_DMA_SEEI_SAEE(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_SEEI_SAEE) & BM_DMA_SEEI_SAEE)

/*! @brief Set the SAEE field to a new value. */
#define BW_DMA_SEEI_SAEE(x, v) (BITBAND_ACCESS8(HW_DMA_SEEI_ADDR(x), BP_DMA_SEEI_SAEE) = (v))
/*@}*/

/*!
 * @name Register DMA_SEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
#define BP_DMA_SEEI_NOP      (7U)          /*!< Bit position for DMA_SEEI_NOP. */
#define BM_DMA_SEEI_NOP      (0x80U)       /*!< Bit mask for DMA_SEEI_NOP. */
#define BS_DMA_SEEI_NOP      (1U)          /*!< Bit field size in bits for DMA_SEEI_NOP. */

/*! @brief Format value for bitfield DMA_SEEI_NOP. */
#define BF_DMA_SEEI_NOP(v)   ((uint8_t)((uint8_t)(v) << BP_DMA_SEEI_NOP) & BM_DMA_SEEI_NOP)

/*! @brief Set the NOP field to a new value. */
#define BW_DMA_SEEI_NOP(x, v) (BITBAND_ACCESS8(HW_DMA_SEEI_ADDR(x), BP_DMA_SEEI_NOP) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_CERQ - Clear Enable Request Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_CERQ - Clear Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERQ provides a simple memory-mapped mechanism to clear a given bit in
 * the ERQ to disable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be cleared. Setting the
 * CAER bit provides a global clear function, forcing the entire contents of the
 * ERQ to be cleared, disabling all DMA request inputs. If NOP is set, the
 * command is ignored. This allows you to write multiple-byte registers as a 32-bit
 * word. Reads of this register return all zeroes.
 */
typedef union _hw_dma_cerq
{
    uint8_t U;
    struct _hw_dma_cerq_bitfields
    {
        uint8_t CERQ : 4;              /*!< [3:0] Clear Enable Request */
        uint8_t RESERVED0 : 2;         /*!< [5:4]  */
        uint8_t CAER : 1;              /*!< [6] Clear All Enable Requests */
        uint8_t NOP : 1;               /*!< [7] No Op enable */
    } B;
} hw_dma_cerq_t;

/*!
 * @name Constants and macros for entire DMA_CERQ register
 */
/*@{*/
#define HW_DMA_CERQ_ADDR(x)      ((uint32_t)(x) + 0x1AU)

#define HW_DMA_CERQ(x)           (*(__O hw_dma_cerq_t *) HW_DMA_CERQ_ADDR(x))
#define HW_DMA_CERQ_RD(x)        (HW_DMA_CERQ(x).U)
#define HW_DMA_CERQ_WR(x, v)     (HW_DMA_CERQ(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual DMA_CERQ bitfields
 */

/*!
 * @name Register DMA_CERQ, field CERQ[3:0] (WORZ)
 *
 * Clears the corresponding bit in ERQ
 */
/*@{*/
#define BP_DMA_CERQ_CERQ     (0U)          /*!< Bit position for DMA_CERQ_CERQ. */
#define BM_DMA_CERQ_CERQ     (0x0FU)       /*!< Bit mask for DMA_CERQ_CERQ. */
#define BS_DMA_CERQ_CERQ     (4U)          /*!< Bit field size in bits for DMA_CERQ_CERQ. */

/*! @brief Format value for bitfield DMA_CERQ_CERQ. */
#define BF_DMA_CERQ_CERQ(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_CERQ_CERQ) & BM_DMA_CERQ_CERQ)

/*! @brief Set the CERQ field to a new value. */
#define BW_DMA_CERQ_CERQ(x, v) (HW_DMA_CERQ_WR(x, (HW_DMA_CERQ_RD(x) & ~BM_DMA_CERQ_CERQ) | BF_DMA_CERQ_CERQ(v)))
/*@}*/

/*!
 * @name Register DMA_CERQ, field CAER[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the ERQ bit specified in the CERQ field
 * - 1 - Clear all bits in ERQ
 */
/*@{*/
#define BP_DMA_CERQ_CAER     (6U)          /*!< Bit position for DMA_CERQ_CAER. */
#define BM_DMA_CERQ_CAER     (0x40U)       /*!< Bit mask for DMA_CERQ_CAER. */
#define BS_DMA_CERQ_CAER     (1U)          /*!< Bit field size in bits for DMA_CERQ_CAER. */

/*! @brief Format value for bitfield DMA_CERQ_CAER. */
#define BF_DMA_CERQ_CAER(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_CERQ_CAER) & BM_DMA_CERQ_CAER)

/*! @brief Set the CAER field to a new value. */
#define BW_DMA_CERQ_CAER(x, v) (BITBAND_ACCESS8(HW_DMA_CERQ_ADDR(x), BP_DMA_CERQ_CAER) = (v))
/*@}*/

/*!
 * @name Register DMA_CERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
#define BP_DMA_CERQ_NOP      (7U)          /*!< Bit position for DMA_CERQ_NOP. */
#define BM_DMA_CERQ_NOP      (0x80U)       /*!< Bit mask for DMA_CERQ_NOP. */
#define BS_DMA_CERQ_NOP      (1U)          /*!< Bit field size in bits for DMA_CERQ_NOP. */

/*! @brief Format value for bitfield DMA_CERQ_NOP. */
#define BF_DMA_CERQ_NOP(v)   ((uint8_t)((uint8_t)(v) << BP_DMA_CERQ_NOP) & BM_DMA_CERQ_NOP)

/*! @brief Set the NOP field to a new value. */
#define BW_DMA_CERQ_NOP(x, v) (BITBAND_ACCESS8(HW_DMA_CERQ_ADDR(x), BP_DMA_CERQ_NOP) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_SERQ - Set Enable Request Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_SERQ - Set Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SERQ provides a simple memory-mapped mechanism to set a given bit in the
 * ERQ to enable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be set. Setting the SAER
 * bit provides a global set function, forcing the entire contents of ERQ to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
typedef union _hw_dma_serq
{
    uint8_t U;
    struct _hw_dma_serq_bitfields
    {
        uint8_t SERQ : 4;              /*!< [3:0] Set enable request */
        uint8_t RESERVED0 : 2;         /*!< [5:4]  */
        uint8_t SAER : 1;              /*!< [6] Set All Enable Requests */
        uint8_t NOP : 1;               /*!< [7] No Op enable */
    } B;
} hw_dma_serq_t;

/*!
 * @name Constants and macros for entire DMA_SERQ register
 */
/*@{*/
#define HW_DMA_SERQ_ADDR(x)      ((uint32_t)(x) + 0x1BU)

#define HW_DMA_SERQ(x)           (*(__O hw_dma_serq_t *) HW_DMA_SERQ_ADDR(x))
#define HW_DMA_SERQ_RD(x)        (HW_DMA_SERQ(x).U)
#define HW_DMA_SERQ_WR(x, v)     (HW_DMA_SERQ(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual DMA_SERQ bitfields
 */

/*!
 * @name Register DMA_SERQ, field SERQ[3:0] (WORZ)
 *
 * Sets the corresponding bit in ERQ
 */
/*@{*/
#define BP_DMA_SERQ_SERQ     (0U)          /*!< Bit position for DMA_SERQ_SERQ. */
#define BM_DMA_SERQ_SERQ     (0x0FU)       /*!< Bit mask for DMA_SERQ_SERQ. */
#define BS_DMA_SERQ_SERQ     (4U)          /*!< Bit field size in bits for DMA_SERQ_SERQ. */

/*! @brief Format value for bitfield DMA_SERQ_SERQ. */
#define BF_DMA_SERQ_SERQ(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_SERQ_SERQ) & BM_DMA_SERQ_SERQ)

/*! @brief Set the SERQ field to a new value. */
#define BW_DMA_SERQ_SERQ(x, v) (HW_DMA_SERQ_WR(x, (HW_DMA_SERQ_RD(x) & ~BM_DMA_SERQ_SERQ) | BF_DMA_SERQ_SERQ(v)))
/*@}*/

/*!
 * @name Register DMA_SERQ, field SAER[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the ERQ bit specified in the SERQ field
 * - 1 - Set all bits in ERQ
 */
/*@{*/
#define BP_DMA_SERQ_SAER     (6U)          /*!< Bit position for DMA_SERQ_SAER. */
#define BM_DMA_SERQ_SAER     (0x40U)       /*!< Bit mask for DMA_SERQ_SAER. */
#define BS_DMA_SERQ_SAER     (1U)          /*!< Bit field size in bits for DMA_SERQ_SAER. */

/*! @brief Format value for bitfield DMA_SERQ_SAER. */
#define BF_DMA_SERQ_SAER(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_SERQ_SAER) & BM_DMA_SERQ_SAER)

/*! @brief Set the SAER field to a new value. */
#define BW_DMA_SERQ_SAER(x, v) (BITBAND_ACCESS8(HW_DMA_SERQ_ADDR(x), BP_DMA_SERQ_SAER) = (v))
/*@}*/

/*!
 * @name Register DMA_SERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
#define BP_DMA_SERQ_NOP      (7U)          /*!< Bit position for DMA_SERQ_NOP. */
#define BM_DMA_SERQ_NOP      (0x80U)       /*!< Bit mask for DMA_SERQ_NOP. */
#define BS_DMA_SERQ_NOP      (1U)          /*!< Bit field size in bits for DMA_SERQ_NOP. */

/*! @brief Format value for bitfield DMA_SERQ_NOP. */
#define BF_DMA_SERQ_NOP(v)   ((uint8_t)((uint8_t)(v) << BP_DMA_SERQ_NOP) & BM_DMA_SERQ_NOP)

/*! @brief Set the NOP field to a new value. */
#define BW_DMA_SERQ_NOP(x, v) (BITBAND_ACCESS8(HW_DMA_SERQ_ADDR(x), BP_DMA_SERQ_NOP) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_CDNE - Clear DONE Status Bit Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_CDNE - Clear DONE Status Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CDNE provides a simple memory-mapped mechanism to clear the DONE bit in
 * the TCD of the given channel. The data value on a register write causes the
 * DONE bit in the corresponding transfer control descriptor to be cleared. Setting
 * the CADN bit provides a global clear function, forcing all DONE bits to be
 * cleared. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
typedef union _hw_dma_cdne
{
    uint8_t U;
    struct _hw_dma_cdne_bitfields
    {
        uint8_t CDNE : 4;              /*!< [3:0] Clear DONE Bit */
        uint8_t RESERVED0 : 2;         /*!< [5:4]  */
        uint8_t CADN : 1;              /*!< [6] Clears All DONE Bits */
        uint8_t NOP : 1;               /*!< [7] No Op enable */
    } B;
} hw_dma_cdne_t;

/*!
 * @name Constants and macros for entire DMA_CDNE register
 */
/*@{*/
#define HW_DMA_CDNE_ADDR(x)      ((uint32_t)(x) + 0x1CU)

#define HW_DMA_CDNE(x)           (*(__O hw_dma_cdne_t *) HW_DMA_CDNE_ADDR(x))
#define HW_DMA_CDNE_RD(x)        (HW_DMA_CDNE(x).U)
#define HW_DMA_CDNE_WR(x, v)     (HW_DMA_CDNE(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual DMA_CDNE bitfields
 */

/*!
 * @name Register DMA_CDNE, field CDNE[3:0] (WORZ)
 *
 * Clears the corresponding bit in TCDn_CSR[DONE]
 */
/*@{*/
#define BP_DMA_CDNE_CDNE     (0U)          /*!< Bit position for DMA_CDNE_CDNE. */
#define BM_DMA_CDNE_CDNE     (0x0FU)       /*!< Bit mask for DMA_CDNE_CDNE. */
#define BS_DMA_CDNE_CDNE     (4U)          /*!< Bit field size in bits for DMA_CDNE_CDNE. */

/*! @brief Format value for bitfield DMA_CDNE_CDNE. */
#define BF_DMA_CDNE_CDNE(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_CDNE_CDNE) & BM_DMA_CDNE_CDNE)

/*! @brief Set the CDNE field to a new value. */
#define BW_DMA_CDNE_CDNE(x, v) (HW_DMA_CDNE_WR(x, (HW_DMA_CDNE_RD(x) & ~BM_DMA_CDNE_CDNE) | BF_DMA_CDNE_CDNE(v)))
/*@}*/

/*!
 * @name Register DMA_CDNE, field CADN[6] (WORZ)
 *
 * Values:
 * - 0 - Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
 * - 1 - Clears all bits in TCDn_CSR[DONE]
 */
/*@{*/
#define BP_DMA_CDNE_CADN     (6U)          /*!< Bit position for DMA_CDNE_CADN. */
#define BM_DMA_CDNE_CADN     (0x40U)       /*!< Bit mask for DMA_CDNE_CADN. */
#define BS_DMA_CDNE_CADN     (1U)          /*!< Bit field size in bits for DMA_CDNE_CADN. */

/*! @brief Format value for bitfield DMA_CDNE_CADN. */
#define BF_DMA_CDNE_CADN(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_CDNE_CADN) & BM_DMA_CDNE_CADN)

/*! @brief Set the CADN field to a new value. */
#define BW_DMA_CDNE_CADN(x, v) (BITBAND_ACCESS8(HW_DMA_CDNE_ADDR(x), BP_DMA_CDNE_CADN) = (v))
/*@}*/

/*!
 * @name Register DMA_CDNE, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
#define BP_DMA_CDNE_NOP      (7U)          /*!< Bit position for DMA_CDNE_NOP. */
#define BM_DMA_CDNE_NOP      (0x80U)       /*!< Bit mask for DMA_CDNE_NOP. */
#define BS_DMA_CDNE_NOP      (1U)          /*!< Bit field size in bits for DMA_CDNE_NOP. */

/*! @brief Format value for bitfield DMA_CDNE_NOP. */
#define BF_DMA_CDNE_NOP(v)   ((uint8_t)((uint8_t)(v) << BP_DMA_CDNE_NOP) & BM_DMA_CDNE_NOP)

/*! @brief Set the NOP field to a new value. */
#define BW_DMA_CDNE_NOP(x, v) (BITBAND_ACCESS8(HW_DMA_CDNE_ADDR(x), BP_DMA_CDNE_NOP) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_SSRT - Set START Bit Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_SSRT - Set START Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SSRT provides a simple memory-mapped mechanism to set the START bit in
 * the TCD of the given channel. The data value on a register write causes the
 * START bit in the corresponding transfer control descriptor to be set. Setting the
 * SAST bit provides a global set function, forcing all START bits to be set. If
 * the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
typedef union _hw_dma_ssrt
{
    uint8_t U;
    struct _hw_dma_ssrt_bitfields
    {
        uint8_t SSRT : 4;              /*!< [3:0] Set START Bit */
        uint8_t RESERVED0 : 2;         /*!< [5:4]  */
        uint8_t SAST : 1;              /*!< [6] Set All START Bits (activates all
                                        * channels) */
        uint8_t NOP : 1;               /*!< [7] No Op enable */
    } B;
} hw_dma_ssrt_t;

/*!
 * @name Constants and macros for entire DMA_SSRT register
 */
/*@{*/
#define HW_DMA_SSRT_ADDR(x)      ((uint32_t)(x) + 0x1DU)

#define HW_DMA_SSRT(x)           (*(__O hw_dma_ssrt_t *) HW_DMA_SSRT_ADDR(x))
#define HW_DMA_SSRT_RD(x)        (HW_DMA_SSRT(x).U)
#define HW_DMA_SSRT_WR(x, v)     (HW_DMA_SSRT(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual DMA_SSRT bitfields
 */

/*!
 * @name Register DMA_SSRT, field SSRT[3:0] (WORZ)
 *
 * Sets the corresponding bit in TCDn_CSR[START]
 */
/*@{*/
#define BP_DMA_SSRT_SSRT     (0U)          /*!< Bit position for DMA_SSRT_SSRT. */
#define BM_DMA_SSRT_SSRT     (0x0FU)       /*!< Bit mask for DMA_SSRT_SSRT. */
#define BS_DMA_SSRT_SSRT     (4U)          /*!< Bit field size in bits for DMA_SSRT_SSRT. */

/*! @brief Format value for bitfield DMA_SSRT_SSRT. */
#define BF_DMA_SSRT_SSRT(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_SSRT_SSRT) & BM_DMA_SSRT_SSRT)

/*! @brief Set the SSRT field to a new value. */
#define BW_DMA_SSRT_SSRT(x, v) (HW_DMA_SSRT_WR(x, (HW_DMA_SSRT_RD(x) & ~BM_DMA_SSRT_SSRT) | BF_DMA_SSRT_SSRT(v)))
/*@}*/

/*!
 * @name Register DMA_SSRT, field SAST[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the TCDn_CSR[START] bit specified in the SSRT field
 * - 1 - Set all bits in TCDn_CSR[START]
 */
/*@{*/
#define BP_DMA_SSRT_SAST     (6U)          /*!< Bit position for DMA_SSRT_SAST. */
#define BM_DMA_SSRT_SAST     (0x40U)       /*!< Bit mask for DMA_SSRT_SAST. */
#define BS_DMA_SSRT_SAST     (1U)          /*!< Bit field size in bits for DMA_SSRT_SAST. */

/*! @brief Format value for bitfield DMA_SSRT_SAST. */
#define BF_DMA_SSRT_SAST(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_SSRT_SAST) & BM_DMA_SSRT_SAST)

/*! @brief Set the SAST field to a new value. */
#define BW_DMA_SSRT_SAST(x, v) (BITBAND_ACCESS8(HW_DMA_SSRT_ADDR(x), BP_DMA_SSRT_SAST) = (v))
/*@}*/

/*!
 * @name Register DMA_SSRT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
#define BP_DMA_SSRT_NOP      (7U)          /*!< Bit position for DMA_SSRT_NOP. */
#define BM_DMA_SSRT_NOP      (0x80U)       /*!< Bit mask for DMA_SSRT_NOP. */
#define BS_DMA_SSRT_NOP      (1U)          /*!< Bit field size in bits for DMA_SSRT_NOP. */

/*! @brief Format value for bitfield DMA_SSRT_NOP. */
#define BF_DMA_SSRT_NOP(v)   ((uint8_t)((uint8_t)(v) << BP_DMA_SSRT_NOP) & BM_DMA_SSRT_NOP)

/*! @brief Set the NOP field to a new value. */
#define BW_DMA_SSRT_NOP(x, v) (BITBAND_ACCESS8(HW_DMA_SSRT_ADDR(x), BP_DMA_SSRT_NOP) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_CERR - Clear Error Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_CERR - Clear Error Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERR provides a simple memory-mapped mechanism to clear a given bit in
 * the ERR to disable the error condition flag for a given channel. The given value
 * on a register write causes the corresponding bit in the ERR to be cleared.
 * Setting the CAEI bit provides a global clear function, forcing the ERR contents
 * to be cleared, clearing all channel error indicators. If the NOP bit is set,
 * the command is ignored. This allows you to write multiple-byte registers as a
 * 32-bit word. Reads of this register return all zeroes.
 */
typedef union _hw_dma_cerr
{
    uint8_t U;
    struct _hw_dma_cerr_bitfields
    {
        uint8_t CERR : 4;              /*!< [3:0] Clear Error Indicator */
        uint8_t RESERVED0 : 2;         /*!< [5:4]  */
        uint8_t CAEI : 1;              /*!< [6] Clear All Error Indicators */
        uint8_t NOP : 1;               /*!< [7] No Op enable */
    } B;
} hw_dma_cerr_t;

/*!
 * @name Constants and macros for entire DMA_CERR register
 */
/*@{*/
#define HW_DMA_CERR_ADDR(x)      ((uint32_t)(x) + 0x1EU)

#define HW_DMA_CERR(x)           (*(__O hw_dma_cerr_t *) HW_DMA_CERR_ADDR(x))
#define HW_DMA_CERR_RD(x)        (HW_DMA_CERR(x).U)
#define HW_DMA_CERR_WR(x, v)     (HW_DMA_CERR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual DMA_CERR bitfields
 */

/*!
 * @name Register DMA_CERR, field CERR[3:0] (WORZ)
 *
 * Clears the corresponding bit in ERR
 */
/*@{*/
#define BP_DMA_CERR_CERR     (0U)          /*!< Bit position for DMA_CERR_CERR. */
#define BM_DMA_CERR_CERR     (0x0FU)       /*!< Bit mask for DMA_CERR_CERR. */
#define BS_DMA_CERR_CERR     (4U)          /*!< Bit field size in bits for DMA_CERR_CERR. */

/*! @brief Format value for bitfield DMA_CERR_CERR. */
#define BF_DMA_CERR_CERR(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_CERR_CERR) & BM_DMA_CERR_CERR)

/*! @brief Set the CERR field to a new value. */
#define BW_DMA_CERR_CERR(x, v) (HW_DMA_CERR_WR(x, (HW_DMA_CERR_RD(x) & ~BM_DMA_CERR_CERR) | BF_DMA_CERR_CERR(v)))
/*@}*/

/*!
 * @name Register DMA_CERR, field CAEI[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the ERR bit specified in the CERR field
 * - 1 - Clear all bits in ERR
 */
/*@{*/
#define BP_DMA_CERR_CAEI     (6U)          /*!< Bit position for DMA_CERR_CAEI. */
#define BM_DMA_CERR_CAEI     (0x40U)       /*!< Bit mask for DMA_CERR_CAEI. */
#define BS_DMA_CERR_CAEI     (1U)          /*!< Bit field size in bits for DMA_CERR_CAEI. */

/*! @brief Format value for bitfield DMA_CERR_CAEI. */
#define BF_DMA_CERR_CAEI(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_CERR_CAEI) & BM_DMA_CERR_CAEI)

/*! @brief Set the CAEI field to a new value. */
#define BW_DMA_CERR_CAEI(x, v) (BITBAND_ACCESS8(HW_DMA_CERR_ADDR(x), BP_DMA_CERR_CAEI) = (v))
/*@}*/

/*!
 * @name Register DMA_CERR, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
#define BP_DMA_CERR_NOP      (7U)          /*!< Bit position for DMA_CERR_NOP. */
#define BM_DMA_CERR_NOP      (0x80U)       /*!< Bit mask for DMA_CERR_NOP. */
#define BS_DMA_CERR_NOP      (1U)          /*!< Bit field size in bits for DMA_CERR_NOP. */

/*! @brief Format value for bitfield DMA_CERR_NOP. */
#define BF_DMA_CERR_NOP(v)   ((uint8_t)((uint8_t)(v) << BP_DMA_CERR_NOP) & BM_DMA_CERR_NOP)

/*! @brief Set the NOP field to a new value. */
#define BW_DMA_CERR_NOP(x, v) (BITBAND_ACCESS8(HW_DMA_CERR_ADDR(x), BP_DMA_CERR_NOP) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_CINT - Clear Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_CINT - Clear Interrupt Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CINT provides a simple, memory-mapped mechanism to clear a given bit in
 * the INT to disable the interrupt request for a given channel. The given value
 * on a register write causes the corresponding bit in the INT to be cleared.
 * Setting the CAIR bit provides a global clear function, forcing the entire contents
 * of the INT to be cleared, disabling all DMA interrupt requests. If the NOP
 * bit is set, the command is ignored. This allows you to write multiple-byte
 * registers as a 32-bit word. Reads of this register return all zeroes.
 */
typedef union _hw_dma_cint
{
    uint8_t U;
    struct _hw_dma_cint_bitfields
    {
        uint8_t CINT : 4;              /*!< [3:0] Clear Interrupt Request */
        uint8_t RESERVED0 : 2;         /*!< [5:4]  */
        uint8_t CAIR : 1;              /*!< [6] Clear All Interrupt Requests */
        uint8_t NOP : 1;               /*!< [7] No Op enable */
    } B;
} hw_dma_cint_t;

/*!
 * @name Constants and macros for entire DMA_CINT register
 */
/*@{*/
#define HW_DMA_CINT_ADDR(x)      ((uint32_t)(x) + 0x1FU)

#define HW_DMA_CINT(x)           (*(__O hw_dma_cint_t *) HW_DMA_CINT_ADDR(x))
#define HW_DMA_CINT_RD(x)        (HW_DMA_CINT(x).U)
#define HW_DMA_CINT_WR(x, v)     (HW_DMA_CINT(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual DMA_CINT bitfields
 */

/*!
 * @name Register DMA_CINT, field CINT[3:0] (WORZ)
 *
 * Clears the corresponding bit in INT
 */
/*@{*/
#define BP_DMA_CINT_CINT     (0U)          /*!< Bit position for DMA_CINT_CINT. */
#define BM_DMA_CINT_CINT     (0x0FU)       /*!< Bit mask for DMA_CINT_CINT. */
#define BS_DMA_CINT_CINT     (4U)          /*!< Bit field size in bits for DMA_CINT_CINT. */

/*! @brief Format value for bitfield DMA_CINT_CINT. */
#define BF_DMA_CINT_CINT(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_CINT_CINT) & BM_DMA_CINT_CINT)

/*! @brief Set the CINT field to a new value. */
#define BW_DMA_CINT_CINT(x, v) (HW_DMA_CINT_WR(x, (HW_DMA_CINT_RD(x) & ~BM_DMA_CINT_CINT) | BF_DMA_CINT_CINT(v)))
/*@}*/

/*!
 * @name Register DMA_CINT, field CAIR[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the INT bit specified in the CINT field
 * - 1 - Clear all bits in INT
 */
/*@{*/
#define BP_DMA_CINT_CAIR     (6U)          /*!< Bit position for DMA_CINT_CAIR. */
#define BM_DMA_CINT_CAIR     (0x40U)       /*!< Bit mask for DMA_CINT_CAIR. */
#define BS_DMA_CINT_CAIR     (1U)          /*!< Bit field size in bits for DMA_CINT_CAIR. */

/*! @brief Format value for bitfield DMA_CINT_CAIR. */
#define BF_DMA_CINT_CAIR(v)  ((uint8_t)((uint8_t)(v) << BP_DMA_CINT_CAIR) & BM_DMA_CINT_CAIR)

/*! @brief Set the CAIR field to a new value. */
#define BW_DMA_CINT_CAIR(x, v) (BITBAND_ACCESS8(HW_DMA_CINT_ADDR(x), BP_DMA_CINT_CAIR) = (v))
/*@}*/

/*!
 * @name Register DMA_CINT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
#define BP_DMA_CINT_NOP      (7U)          /*!< Bit position for DMA_CINT_NOP. */
#define BM_DMA_CINT_NOP      (0x80U)       /*!< Bit mask for DMA_CINT_NOP. */
#define BS_DMA_CINT_NOP      (1U)          /*!< Bit field size in bits for DMA_CINT_NOP. */

/*! @brief Format value for bitfield DMA_CINT_NOP. */
#define BF_DMA_CINT_NOP(v)   ((uint8_t)((uint8_t)(v) << BP_DMA_CINT_NOP) & BM_DMA_CINT_NOP)

/*! @brief Set the NOP field to a new value. */
#define BW_DMA_CINT_NOP(x, v) (BITBAND_ACCESS8(HW_DMA_CINT_ADDR(x), BP_DMA_CINT_NOP) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_INT - Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_INT - Interrupt Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The INT register provides a bit map for the 16 channels signaling the
 * presence of an interrupt request for each channel. Depending on the appropriate bit
 * setting in the transfer-control descriptors, the eDMA engine generates an
 * interrupt on data transfer completion. The outputs of this register are directly
 * routed to the interrupt controller (INTC). During the interrupt-service routine
 * associated with any given channel, it is the software's responsibility to
 * clear the appropriate bit, negating the interrupt request. Typically, a write to
 * the CINT register in the interrupt service routine is used for this purpose.
 * The state of any given channel's interrupt request is directly affected by
 * writes to this register; it is also affected by writes to the CINT register. On
 * writes to INT, a 1 in any bit position clears the corresponding channel's
 * interrupt request. A zero in any bit position has no affect on the corresponding
 * channel's current interrupt status. The CINT register is provided so the interrupt
 * request for a single channel can easily be cleared without the need to
 * perform a read-modify-write sequence to the INT register.
 */
typedef union _hw_dma_int
{
    uint32_t U;
    struct _hw_dma_int_bitfields
    {
        uint32_t INT0 : 1;             /*!< [0] Interrupt Request 0 */
        uint32_t INT1 : 1;             /*!< [1] Interrupt Request 1 */
        uint32_t INT2 : 1;             /*!< [2] Interrupt Request 2 */
        uint32_t INT3 : 1;             /*!< [3] Interrupt Request 3 */
        uint32_t INT4 : 1;             /*!< [4] Interrupt Request 4 */
        uint32_t INT5 : 1;             /*!< [5] Interrupt Request 5 */
        uint32_t INT6 : 1;             /*!< [6] Interrupt Request 6 */
        uint32_t INT7 : 1;             /*!< [7] Interrupt Request 7 */
        uint32_t INT8 : 1;             /*!< [8] Interrupt Request 8 */
        uint32_t INT9 : 1;             /*!< [9] Interrupt Request 9 */
        uint32_t INT10 : 1;            /*!< [10] Interrupt Request 10 */
        uint32_t INT11 : 1;            /*!< [11] Interrupt Request 11 */
        uint32_t INT12 : 1;            /*!< [12] Interrupt Request 12 */
        uint32_t INT13 : 1;            /*!< [13] Interrupt Request 13 */
        uint32_t INT14 : 1;            /*!< [14] Interrupt Request 14 */
        uint32_t INT15 : 1;            /*!< [15] Interrupt Request 15 */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_dma_int_t;

/*!
 * @name Constants and macros for entire DMA_INT register
 */
/*@{*/
#define HW_DMA_INT_ADDR(x)       ((uint32_t)(x) + 0x24U)

#define HW_DMA_INT(x)            (*(__IO hw_dma_int_t *) HW_DMA_INT_ADDR(x))
#define HW_DMA_INT_RD(x)         (HW_DMA_INT(x).U)
#define HW_DMA_INT_WR(x, v)      (HW_DMA_INT(x).U = (v))
#define HW_DMA_INT_SET(x, v)     (HW_DMA_INT_WR(x, HW_DMA_INT_RD(x) |  (v)))
#define HW_DMA_INT_CLR(x, v)     (HW_DMA_INT_WR(x, HW_DMA_INT_RD(x) & ~(v)))
#define HW_DMA_INT_TOG(x, v)     (HW_DMA_INT_WR(x, HW_DMA_INT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_INT bitfields
 */

/*!
 * @name Register DMA_INT, field INT0[0] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT0      (0U)          /*!< Bit position for DMA_INT_INT0. */
#define BM_DMA_INT_INT0      (0x00000001U) /*!< Bit mask for DMA_INT_INT0. */
#define BS_DMA_INT_INT0      (1U)          /*!< Bit field size in bits for DMA_INT_INT0. */

/*! @brief Read current value of the DMA_INT_INT0 field. */
#define BR_DMA_INT_INT0(x)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT0))

/*! @brief Format value for bitfield DMA_INT_INT0. */
#define BF_DMA_INT_INT0(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT0) & BM_DMA_INT_INT0)

/*! @brief Set the INT0 field to a new value. */
#define BW_DMA_INT_INT0(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT0) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT1[1] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT1      (1U)          /*!< Bit position for DMA_INT_INT1. */
#define BM_DMA_INT_INT1      (0x00000002U) /*!< Bit mask for DMA_INT_INT1. */
#define BS_DMA_INT_INT1      (1U)          /*!< Bit field size in bits for DMA_INT_INT1. */

/*! @brief Read current value of the DMA_INT_INT1 field. */
#define BR_DMA_INT_INT1(x)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT1))

/*! @brief Format value for bitfield DMA_INT_INT1. */
#define BF_DMA_INT_INT1(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT1) & BM_DMA_INT_INT1)

/*! @brief Set the INT1 field to a new value. */
#define BW_DMA_INT_INT1(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT1) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT2[2] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT2      (2U)          /*!< Bit position for DMA_INT_INT2. */
#define BM_DMA_INT_INT2      (0x00000004U) /*!< Bit mask for DMA_INT_INT2. */
#define BS_DMA_INT_INT2      (1U)          /*!< Bit field size in bits for DMA_INT_INT2. */

/*! @brief Read current value of the DMA_INT_INT2 field. */
#define BR_DMA_INT_INT2(x)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT2))

/*! @brief Format value for bitfield DMA_INT_INT2. */
#define BF_DMA_INT_INT2(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT2) & BM_DMA_INT_INT2)

/*! @brief Set the INT2 field to a new value. */
#define BW_DMA_INT_INT2(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT2) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT3[3] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT3      (3U)          /*!< Bit position for DMA_INT_INT3. */
#define BM_DMA_INT_INT3      (0x00000008U) /*!< Bit mask for DMA_INT_INT3. */
#define BS_DMA_INT_INT3      (1U)          /*!< Bit field size in bits for DMA_INT_INT3. */

/*! @brief Read current value of the DMA_INT_INT3 field. */
#define BR_DMA_INT_INT3(x)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT3))

/*! @brief Format value for bitfield DMA_INT_INT3. */
#define BF_DMA_INT_INT3(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT3) & BM_DMA_INT_INT3)

/*! @brief Set the INT3 field to a new value. */
#define BW_DMA_INT_INT3(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT3) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT4[4] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT4      (4U)          /*!< Bit position for DMA_INT_INT4. */
#define BM_DMA_INT_INT4      (0x00000010U) /*!< Bit mask for DMA_INT_INT4. */
#define BS_DMA_INT_INT4      (1U)          /*!< Bit field size in bits for DMA_INT_INT4. */

/*! @brief Read current value of the DMA_INT_INT4 field. */
#define BR_DMA_INT_INT4(x)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT4))

/*! @brief Format value for bitfield DMA_INT_INT4. */
#define BF_DMA_INT_INT4(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT4) & BM_DMA_INT_INT4)

/*! @brief Set the INT4 field to a new value. */
#define BW_DMA_INT_INT4(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT4) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT5[5] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT5      (5U)          /*!< Bit position for DMA_INT_INT5. */
#define BM_DMA_INT_INT5      (0x00000020U) /*!< Bit mask for DMA_INT_INT5. */
#define BS_DMA_INT_INT5      (1U)          /*!< Bit field size in bits for DMA_INT_INT5. */

/*! @brief Read current value of the DMA_INT_INT5 field. */
#define BR_DMA_INT_INT5(x)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT5))

/*! @brief Format value for bitfield DMA_INT_INT5. */
#define BF_DMA_INT_INT5(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT5) & BM_DMA_INT_INT5)

/*! @brief Set the INT5 field to a new value. */
#define BW_DMA_INT_INT5(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT5) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT6[6] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT6      (6U)          /*!< Bit position for DMA_INT_INT6. */
#define BM_DMA_INT_INT6      (0x00000040U) /*!< Bit mask for DMA_INT_INT6. */
#define BS_DMA_INT_INT6      (1U)          /*!< Bit field size in bits for DMA_INT_INT6. */

/*! @brief Read current value of the DMA_INT_INT6 field. */
#define BR_DMA_INT_INT6(x)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT6))

/*! @brief Format value for bitfield DMA_INT_INT6. */
#define BF_DMA_INT_INT6(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT6) & BM_DMA_INT_INT6)

/*! @brief Set the INT6 field to a new value. */
#define BW_DMA_INT_INT6(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT6) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT7[7] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT7      (7U)          /*!< Bit position for DMA_INT_INT7. */
#define BM_DMA_INT_INT7      (0x00000080U) /*!< Bit mask for DMA_INT_INT7. */
#define BS_DMA_INT_INT7      (1U)          /*!< Bit field size in bits for DMA_INT_INT7. */

/*! @brief Read current value of the DMA_INT_INT7 field. */
#define BR_DMA_INT_INT7(x)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT7))

/*! @brief Format value for bitfield DMA_INT_INT7. */
#define BF_DMA_INT_INT7(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT7) & BM_DMA_INT_INT7)

/*! @brief Set the INT7 field to a new value. */
#define BW_DMA_INT_INT7(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT7) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT8[8] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT8      (8U)          /*!< Bit position for DMA_INT_INT8. */
#define BM_DMA_INT_INT8      (0x00000100U) /*!< Bit mask for DMA_INT_INT8. */
#define BS_DMA_INT_INT8      (1U)          /*!< Bit field size in bits for DMA_INT_INT8. */

/*! @brief Read current value of the DMA_INT_INT8 field. */
#define BR_DMA_INT_INT8(x)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT8))

/*! @brief Format value for bitfield DMA_INT_INT8. */
#define BF_DMA_INT_INT8(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT8) & BM_DMA_INT_INT8)

/*! @brief Set the INT8 field to a new value. */
#define BW_DMA_INT_INT8(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT8) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT9[9] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT9      (9U)          /*!< Bit position for DMA_INT_INT9. */
#define BM_DMA_INT_INT9      (0x00000200U) /*!< Bit mask for DMA_INT_INT9. */
#define BS_DMA_INT_INT9      (1U)          /*!< Bit field size in bits for DMA_INT_INT9. */

/*! @brief Read current value of the DMA_INT_INT9 field. */
#define BR_DMA_INT_INT9(x)   (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT9))

/*! @brief Format value for bitfield DMA_INT_INT9. */
#define BF_DMA_INT_INT9(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT9) & BM_DMA_INT_INT9)

/*! @brief Set the INT9 field to a new value. */
#define BW_DMA_INT_INT9(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT9) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT10[10] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT10     (10U)         /*!< Bit position for DMA_INT_INT10. */
#define BM_DMA_INT_INT10     (0x00000400U) /*!< Bit mask for DMA_INT_INT10. */
#define BS_DMA_INT_INT10     (1U)          /*!< Bit field size in bits for DMA_INT_INT10. */

/*! @brief Read current value of the DMA_INT_INT10 field. */
#define BR_DMA_INT_INT10(x)  (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT10))

/*! @brief Format value for bitfield DMA_INT_INT10. */
#define BF_DMA_INT_INT10(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT10) & BM_DMA_INT_INT10)

/*! @brief Set the INT10 field to a new value. */
#define BW_DMA_INT_INT10(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT10) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT11[11] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT11     (11U)         /*!< Bit position for DMA_INT_INT11. */
#define BM_DMA_INT_INT11     (0x00000800U) /*!< Bit mask for DMA_INT_INT11. */
#define BS_DMA_INT_INT11     (1U)          /*!< Bit field size in bits for DMA_INT_INT11. */

/*! @brief Read current value of the DMA_INT_INT11 field. */
#define BR_DMA_INT_INT11(x)  (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT11))

/*! @brief Format value for bitfield DMA_INT_INT11. */
#define BF_DMA_INT_INT11(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT11) & BM_DMA_INT_INT11)

/*! @brief Set the INT11 field to a new value. */
#define BW_DMA_INT_INT11(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT11) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT12[12] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT12     (12U)         /*!< Bit position for DMA_INT_INT12. */
#define BM_DMA_INT_INT12     (0x00001000U) /*!< Bit mask for DMA_INT_INT12. */
#define BS_DMA_INT_INT12     (1U)          /*!< Bit field size in bits for DMA_INT_INT12. */

/*! @brief Read current value of the DMA_INT_INT12 field. */
#define BR_DMA_INT_INT12(x)  (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT12))

/*! @brief Format value for bitfield DMA_INT_INT12. */
#define BF_DMA_INT_INT12(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT12) & BM_DMA_INT_INT12)

/*! @brief Set the INT12 field to a new value. */
#define BW_DMA_INT_INT12(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT12) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT13[13] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT13     (13U)         /*!< Bit position for DMA_INT_INT13. */
#define BM_DMA_INT_INT13     (0x00002000U) /*!< Bit mask for DMA_INT_INT13. */
#define BS_DMA_INT_INT13     (1U)          /*!< Bit field size in bits for DMA_INT_INT13. */

/*! @brief Read current value of the DMA_INT_INT13 field. */
#define BR_DMA_INT_INT13(x)  (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT13))

/*! @brief Format value for bitfield DMA_INT_INT13. */
#define BF_DMA_INT_INT13(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT13) & BM_DMA_INT_INT13)

/*! @brief Set the INT13 field to a new value. */
#define BW_DMA_INT_INT13(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT13) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT14[14] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT14     (14U)         /*!< Bit position for DMA_INT_INT14. */
#define BM_DMA_INT_INT14     (0x00004000U) /*!< Bit mask for DMA_INT_INT14. */
#define BS_DMA_INT_INT14     (1U)          /*!< Bit field size in bits for DMA_INT_INT14. */

/*! @brief Read current value of the DMA_INT_INT14 field. */
#define BR_DMA_INT_INT14(x)  (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT14))

/*! @brief Format value for bitfield DMA_INT_INT14. */
#define BF_DMA_INT_INT14(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT14) & BM_DMA_INT_INT14)

/*! @brief Set the INT14 field to a new value. */
#define BW_DMA_INT_INT14(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT14) = (v))
/*@}*/

/*!
 * @name Register DMA_INT, field INT15[15] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
#define BP_DMA_INT_INT15     (15U)         /*!< Bit position for DMA_INT_INT15. */
#define BM_DMA_INT_INT15     (0x00008000U) /*!< Bit mask for DMA_INT_INT15. */
#define BS_DMA_INT_INT15     (1U)          /*!< Bit field size in bits for DMA_INT_INT15. */

/*! @brief Read current value of the DMA_INT_INT15 field. */
#define BR_DMA_INT_INT15(x)  (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT15))

/*! @brief Format value for bitfield DMA_INT_INT15. */
#define BF_DMA_INT_INT15(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_INT_INT15) & BM_DMA_INT_INT15)

/*! @brief Set the INT15 field to a new value. */
#define BW_DMA_INT_INT15(x, v) (BITBAND_ACCESS32(HW_DMA_INT_ADDR(x), BP_DMA_INT_INT15) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_ERR - Error Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_ERR - Error Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERR provides a bit map for the 16 channels, signaling the presence of an
 * error for each channel. The eDMA engine signals the occurrence of an error
 * condition by setting the appropriate bit in this register. The outputs of this
 * register are enabled by the contents of the EEI, and then routed to the
 * interrupt controller. During the execution of the interrupt-service routine associated
 * with any DMA errors, it is software's responsibility to clear the appropriate
 * bit, negating the error-interrupt request. Typically, a write to the CERR in
 * the interrupt-service routine is used for this purpose. The normal DMA channel
 * completion indicators (setting the transfer control descriptor DONE flag and
 * the possible assertion of an interrupt request) are not affected when an error
 * is detected. The contents of this register can also be polled because a
 * non-zero value indicates the presence of a channel error regardless of the state of
 * the EEI. The state of any given channel's error indicators is affected by
 * writes to this register; it is also affected by writes to the CERR. On writes to
 * the ERR, a one in any bit position clears the corresponding channel's error
 * status. A zero in any bit position has no affect on the corresponding channel's
 * current error status. The CERR is provided so the error indicator for a single
 * channel can easily be cleared.
 */
typedef union _hw_dma_err
{
    uint32_t U;
    struct _hw_dma_err_bitfields
    {
        uint32_t ERR0 : 1;             /*!< [0] Error In Channel 0 */
        uint32_t ERR1 : 1;             /*!< [1] Error In Channel 1 */
        uint32_t ERR2 : 1;             /*!< [2] Error In Channel 2 */
        uint32_t ERR3 : 1;             /*!< [3] Error In Channel 3 */
        uint32_t ERR4 : 1;             /*!< [4] Error In Channel 4 */
        uint32_t ERR5 : 1;             /*!< [5] Error In Channel 5 */
        uint32_t ERR6 : 1;             /*!< [6] Error In Channel 6 */
        uint32_t ERR7 : 1;             /*!< [7] Error In Channel 7 */
        uint32_t ERR8 : 1;             /*!< [8] Error In Channel 8 */
        uint32_t ERR9 : 1;             /*!< [9] Error In Channel 9 */
        uint32_t ERR10 : 1;            /*!< [10] Error In Channel 10 */
        uint32_t ERR11 : 1;            /*!< [11] Error In Channel 11 */
        uint32_t ERR12 : 1;            /*!< [12] Error In Channel 12 */
        uint32_t ERR13 : 1;            /*!< [13] Error In Channel 13 */
        uint32_t ERR14 : 1;            /*!< [14] Error In Channel 14 */
        uint32_t ERR15 : 1;            /*!< [15] Error In Channel 15 */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_dma_err_t;

/*!
 * @name Constants and macros for entire DMA_ERR register
 */
/*@{*/
#define HW_DMA_ERR_ADDR(x)       ((uint32_t)(x) + 0x2CU)

#define HW_DMA_ERR(x)            (*(__IO hw_dma_err_t *) HW_DMA_ERR_ADDR(x))
#define HW_DMA_ERR_RD(x)         (HW_DMA_ERR(x).U)
#define HW_DMA_ERR_WR(x, v)      (HW_DMA_ERR(x).U = (v))
#define HW_DMA_ERR_SET(x, v)     (HW_DMA_ERR_WR(x, HW_DMA_ERR_RD(x) |  (v)))
#define HW_DMA_ERR_CLR(x, v)     (HW_DMA_ERR_WR(x, HW_DMA_ERR_RD(x) & ~(v)))
#define HW_DMA_ERR_TOG(x, v)     (HW_DMA_ERR_WR(x, HW_DMA_ERR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERR bitfields
 */

/*!
 * @name Register DMA_ERR, field ERR0[0] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR0      (0U)          /*!< Bit position for DMA_ERR_ERR0. */
#define BM_DMA_ERR_ERR0      (0x00000001U) /*!< Bit mask for DMA_ERR_ERR0. */
#define BS_DMA_ERR_ERR0      (1U)          /*!< Bit field size in bits for DMA_ERR_ERR0. */

/*! @brief Read current value of the DMA_ERR_ERR0 field. */
#define BR_DMA_ERR_ERR0(x)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR0))

/*! @brief Format value for bitfield DMA_ERR_ERR0. */
#define BF_DMA_ERR_ERR0(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR0) & BM_DMA_ERR_ERR0)

/*! @brief Set the ERR0 field to a new value. */
#define BW_DMA_ERR_ERR0(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR0) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR1[1] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR1      (1U)          /*!< Bit position for DMA_ERR_ERR1. */
#define BM_DMA_ERR_ERR1      (0x00000002U) /*!< Bit mask for DMA_ERR_ERR1. */
#define BS_DMA_ERR_ERR1      (1U)          /*!< Bit field size in bits for DMA_ERR_ERR1. */

/*! @brief Read current value of the DMA_ERR_ERR1 field. */
#define BR_DMA_ERR_ERR1(x)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR1))

/*! @brief Format value for bitfield DMA_ERR_ERR1. */
#define BF_DMA_ERR_ERR1(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR1) & BM_DMA_ERR_ERR1)

/*! @brief Set the ERR1 field to a new value. */
#define BW_DMA_ERR_ERR1(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR1) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR2[2] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR2      (2U)          /*!< Bit position for DMA_ERR_ERR2. */
#define BM_DMA_ERR_ERR2      (0x00000004U) /*!< Bit mask for DMA_ERR_ERR2. */
#define BS_DMA_ERR_ERR2      (1U)          /*!< Bit field size in bits for DMA_ERR_ERR2. */

/*! @brief Read current value of the DMA_ERR_ERR2 field. */
#define BR_DMA_ERR_ERR2(x)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR2))

/*! @brief Format value for bitfield DMA_ERR_ERR2. */
#define BF_DMA_ERR_ERR2(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR2) & BM_DMA_ERR_ERR2)

/*! @brief Set the ERR2 field to a new value. */
#define BW_DMA_ERR_ERR2(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR2) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR3[3] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR3      (3U)          /*!< Bit position for DMA_ERR_ERR3. */
#define BM_DMA_ERR_ERR3      (0x00000008U) /*!< Bit mask for DMA_ERR_ERR3. */
#define BS_DMA_ERR_ERR3      (1U)          /*!< Bit field size in bits for DMA_ERR_ERR3. */

/*! @brief Read current value of the DMA_ERR_ERR3 field. */
#define BR_DMA_ERR_ERR3(x)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR3))

/*! @brief Format value for bitfield DMA_ERR_ERR3. */
#define BF_DMA_ERR_ERR3(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR3) & BM_DMA_ERR_ERR3)

/*! @brief Set the ERR3 field to a new value. */
#define BW_DMA_ERR_ERR3(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR3) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR4[4] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR4      (4U)          /*!< Bit position for DMA_ERR_ERR4. */
#define BM_DMA_ERR_ERR4      (0x00000010U) /*!< Bit mask for DMA_ERR_ERR4. */
#define BS_DMA_ERR_ERR4      (1U)          /*!< Bit field size in bits for DMA_ERR_ERR4. */

/*! @brief Read current value of the DMA_ERR_ERR4 field. */
#define BR_DMA_ERR_ERR4(x)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR4))

/*! @brief Format value for bitfield DMA_ERR_ERR4. */
#define BF_DMA_ERR_ERR4(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR4) & BM_DMA_ERR_ERR4)

/*! @brief Set the ERR4 field to a new value. */
#define BW_DMA_ERR_ERR4(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR4) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR5[5] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR5      (5U)          /*!< Bit position for DMA_ERR_ERR5. */
#define BM_DMA_ERR_ERR5      (0x00000020U) /*!< Bit mask for DMA_ERR_ERR5. */
#define BS_DMA_ERR_ERR5      (1U)          /*!< Bit field size in bits for DMA_ERR_ERR5. */

/*! @brief Read current value of the DMA_ERR_ERR5 field. */
#define BR_DMA_ERR_ERR5(x)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR5))

/*! @brief Format value for bitfield DMA_ERR_ERR5. */
#define BF_DMA_ERR_ERR5(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR5) & BM_DMA_ERR_ERR5)

/*! @brief Set the ERR5 field to a new value. */
#define BW_DMA_ERR_ERR5(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR5) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR6[6] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR6      (6U)          /*!< Bit position for DMA_ERR_ERR6. */
#define BM_DMA_ERR_ERR6      (0x00000040U) /*!< Bit mask for DMA_ERR_ERR6. */
#define BS_DMA_ERR_ERR6      (1U)          /*!< Bit field size in bits for DMA_ERR_ERR6. */

/*! @brief Read current value of the DMA_ERR_ERR6 field. */
#define BR_DMA_ERR_ERR6(x)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR6))

/*! @brief Format value for bitfield DMA_ERR_ERR6. */
#define BF_DMA_ERR_ERR6(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR6) & BM_DMA_ERR_ERR6)

/*! @brief Set the ERR6 field to a new value. */
#define BW_DMA_ERR_ERR6(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR6) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR7[7] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR7      (7U)          /*!< Bit position for DMA_ERR_ERR7. */
#define BM_DMA_ERR_ERR7      (0x00000080U) /*!< Bit mask for DMA_ERR_ERR7. */
#define BS_DMA_ERR_ERR7      (1U)          /*!< Bit field size in bits for DMA_ERR_ERR7. */

/*! @brief Read current value of the DMA_ERR_ERR7 field. */
#define BR_DMA_ERR_ERR7(x)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR7))

/*! @brief Format value for bitfield DMA_ERR_ERR7. */
#define BF_DMA_ERR_ERR7(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR7) & BM_DMA_ERR_ERR7)

/*! @brief Set the ERR7 field to a new value. */
#define BW_DMA_ERR_ERR7(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR7) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR8[8] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR8      (8U)          /*!< Bit position for DMA_ERR_ERR8. */
#define BM_DMA_ERR_ERR8      (0x00000100U) /*!< Bit mask for DMA_ERR_ERR8. */
#define BS_DMA_ERR_ERR8      (1U)          /*!< Bit field size in bits for DMA_ERR_ERR8. */

/*! @brief Read current value of the DMA_ERR_ERR8 field. */
#define BR_DMA_ERR_ERR8(x)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR8))

/*! @brief Format value for bitfield DMA_ERR_ERR8. */
#define BF_DMA_ERR_ERR8(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR8) & BM_DMA_ERR_ERR8)

/*! @brief Set the ERR8 field to a new value. */
#define BW_DMA_ERR_ERR8(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR8) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR9[9] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR9      (9U)          /*!< Bit position for DMA_ERR_ERR9. */
#define BM_DMA_ERR_ERR9      (0x00000200U) /*!< Bit mask for DMA_ERR_ERR9. */
#define BS_DMA_ERR_ERR9      (1U)          /*!< Bit field size in bits for DMA_ERR_ERR9. */

/*! @brief Read current value of the DMA_ERR_ERR9 field. */
#define BR_DMA_ERR_ERR9(x)   (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR9))

/*! @brief Format value for bitfield DMA_ERR_ERR9. */
#define BF_DMA_ERR_ERR9(v)   ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR9) & BM_DMA_ERR_ERR9)

/*! @brief Set the ERR9 field to a new value. */
#define BW_DMA_ERR_ERR9(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR9) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR10[10] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR10     (10U)         /*!< Bit position for DMA_ERR_ERR10. */
#define BM_DMA_ERR_ERR10     (0x00000400U) /*!< Bit mask for DMA_ERR_ERR10. */
#define BS_DMA_ERR_ERR10     (1U)          /*!< Bit field size in bits for DMA_ERR_ERR10. */

/*! @brief Read current value of the DMA_ERR_ERR10 field. */
#define BR_DMA_ERR_ERR10(x)  (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR10))

/*! @brief Format value for bitfield DMA_ERR_ERR10. */
#define BF_DMA_ERR_ERR10(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR10) & BM_DMA_ERR_ERR10)

/*! @brief Set the ERR10 field to a new value. */
#define BW_DMA_ERR_ERR10(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR10) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR11[11] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR11     (11U)         /*!< Bit position for DMA_ERR_ERR11. */
#define BM_DMA_ERR_ERR11     (0x00000800U) /*!< Bit mask for DMA_ERR_ERR11. */
#define BS_DMA_ERR_ERR11     (1U)          /*!< Bit field size in bits for DMA_ERR_ERR11. */

/*! @brief Read current value of the DMA_ERR_ERR11 field. */
#define BR_DMA_ERR_ERR11(x)  (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR11))

/*! @brief Format value for bitfield DMA_ERR_ERR11. */
#define BF_DMA_ERR_ERR11(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR11) & BM_DMA_ERR_ERR11)

/*! @brief Set the ERR11 field to a new value. */
#define BW_DMA_ERR_ERR11(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR11) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR12[12] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR12     (12U)         /*!< Bit position for DMA_ERR_ERR12. */
#define BM_DMA_ERR_ERR12     (0x00001000U) /*!< Bit mask for DMA_ERR_ERR12. */
#define BS_DMA_ERR_ERR12     (1U)          /*!< Bit field size in bits for DMA_ERR_ERR12. */

/*! @brief Read current value of the DMA_ERR_ERR12 field. */
#define BR_DMA_ERR_ERR12(x)  (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR12))

/*! @brief Format value for bitfield DMA_ERR_ERR12. */
#define BF_DMA_ERR_ERR12(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR12) & BM_DMA_ERR_ERR12)

/*! @brief Set the ERR12 field to a new value. */
#define BW_DMA_ERR_ERR12(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR12) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR13[13] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR13     (13U)         /*!< Bit position for DMA_ERR_ERR13. */
#define BM_DMA_ERR_ERR13     (0x00002000U) /*!< Bit mask for DMA_ERR_ERR13. */
#define BS_DMA_ERR_ERR13     (1U)          /*!< Bit field size in bits for DMA_ERR_ERR13. */

/*! @brief Read current value of the DMA_ERR_ERR13 field. */
#define BR_DMA_ERR_ERR13(x)  (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR13))

/*! @brief Format value for bitfield DMA_ERR_ERR13. */
#define BF_DMA_ERR_ERR13(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR13) & BM_DMA_ERR_ERR13)

/*! @brief Set the ERR13 field to a new value. */
#define BW_DMA_ERR_ERR13(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR13) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR14[14] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR14     (14U)         /*!< Bit position for DMA_ERR_ERR14. */
#define BM_DMA_ERR_ERR14     (0x00004000U) /*!< Bit mask for DMA_ERR_ERR14. */
#define BS_DMA_ERR_ERR14     (1U)          /*!< Bit field size in bits for DMA_ERR_ERR14. */

/*! @brief Read current value of the DMA_ERR_ERR14 field. */
#define BR_DMA_ERR_ERR14(x)  (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR14))

/*! @brief Format value for bitfield DMA_ERR_ERR14. */
#define BF_DMA_ERR_ERR14(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR14) & BM_DMA_ERR_ERR14)

/*! @brief Set the ERR14 field to a new value. */
#define BW_DMA_ERR_ERR14(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR14) = (v))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR15[15] (W1C)
 *
 * Values:
 * - 0 - An error in the corresponding channel has not occurred
 * - 1 - An error in the corresponding channel has occurred
 */
/*@{*/
#define BP_DMA_ERR_ERR15     (15U)         /*!< Bit position for DMA_ERR_ERR15. */
#define BM_DMA_ERR_ERR15     (0x00008000U) /*!< Bit mask for DMA_ERR_ERR15. */
#define BS_DMA_ERR_ERR15     (1U)          /*!< Bit field size in bits for DMA_ERR_ERR15. */

/*! @brief Read current value of the DMA_ERR_ERR15 field. */
#define BR_DMA_ERR_ERR15(x)  (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR15))

/*! @brief Format value for bitfield DMA_ERR_ERR15. */
#define BF_DMA_ERR_ERR15(v)  ((uint32_t)((uint32_t)(v) << BP_DMA_ERR_ERR15) & BM_DMA_ERR_ERR15)

/*! @brief Set the ERR15 field to a new value. */
#define BW_DMA_ERR_ERR15(x, v) (BITBAND_ACCESS32(HW_DMA_ERR_ADDR(x), BP_DMA_ERR_ERR15) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_HRS - Hardware Request Status Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_HRS - Hardware Request Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The HRS register provides a bit map for the DMA channels, signaling the
 * presence of a hardware request for each channel. The hardware request status bits
 * reflect the current state of the register and qualified (via the ERQ fields)
 * DMA request signals as seen by the DMA's arbitration logic. This view into the
 * hardware request signals may be used for debug purposes. These bits reflect the
 * state of the request as seen by the arbitration logic. Therefore, this status
 * is affected by the ERQ bits.
 */
typedef union _hw_dma_hrs
{
    uint32_t U;
    struct _hw_dma_hrs_bitfields
    {
        uint32_t HRS0 : 1;             /*!< [0] Hardware Request Status Channel 0 */
        uint32_t HRS1 : 1;             /*!< [1] Hardware Request Status Channel 1 */
        uint32_t HRS2 : 1;             /*!< [2] Hardware Request Status Channel 2 */
        uint32_t HRS3 : 1;             /*!< [3] Hardware Request Status Channel 3 */
        uint32_t HRS4 : 1;             /*!< [4] Hardware Request Status Channel 4 */
        uint32_t HRS5 : 1;             /*!< [5] Hardware Request Status Channel 5 */
        uint32_t HRS6 : 1;             /*!< [6] Hardware Request Status Channel 6 */
        uint32_t HRS7 : 1;             /*!< [7] Hardware Request Status Channel 7 */
        uint32_t HRS8 : 1;             /*!< [8] Hardware Request Status Channel 8 */
        uint32_t HRS9 : 1;             /*!< [9] Hardware Request Status Channel 9 */
        uint32_t HRS10 : 1;            /*!< [10] Hardware Request Status Channel 10 */
        uint32_t HRS11 : 1;            /*!< [11] Hardware Request Status Channel 11 */
        uint32_t HRS12 : 1;            /*!< [12] Hardware Request Status Channel 12 */
        uint32_t HRS13 : 1;            /*!< [13] Hardware Request Status Channel 13 */
        uint32_t HRS14 : 1;            /*!< [14] Hardware Request Status Channel 14 */
        uint32_t HRS15 : 1;            /*!< [15] Hardware Request Status Channel 15 */
        uint32_t RESERVED0 : 16;       /*!< [31:16] Reserved */
    } B;
} hw_dma_hrs_t;

/*!
 * @name Constants and macros for entire DMA_HRS register
 */
/*@{*/
#define HW_DMA_HRS_ADDR(x)       ((uint32_t)(x) + 0x34U)

#define HW_DMA_HRS(x)            (*(__I hw_dma_hrs_t *) HW_DMA_HRS_ADDR(x))
#define HW_DMA_HRS_RD(x)         (HW_DMA_HRS(x).U)
/*@}*/

/*
 * Constants & macros for individual DMA_HRS bitfields
 */

/*!
 * @name Register DMA_HRS, field HRS0[0] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 0 is not present
 * - 1 - A hardware service request for channel 0 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS0      (0U)          /*!< Bit position for DMA_HRS_HRS0. */
#define BM_DMA_HRS_HRS0      (0x00000001U) /*!< Bit mask for DMA_HRS_HRS0. */
#define BS_DMA_HRS_HRS0      (1U)          /*!< Bit field size in bits for DMA_HRS_HRS0. */

/*! @brief Read current value of the DMA_HRS_HRS0 field. */
#define BR_DMA_HRS_HRS0(x)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS0))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS1[1] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 1 is not present
 * - 1 - A hardware service request for channel 1 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS1      (1U)          /*!< Bit position for DMA_HRS_HRS1. */
#define BM_DMA_HRS_HRS1      (0x00000002U) /*!< Bit mask for DMA_HRS_HRS1. */
#define BS_DMA_HRS_HRS1      (1U)          /*!< Bit field size in bits for DMA_HRS_HRS1. */

/*! @brief Read current value of the DMA_HRS_HRS1 field. */
#define BR_DMA_HRS_HRS1(x)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS1))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS2[2] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 2 is not present
 * - 1 - A hardware service request for channel 2 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS2      (2U)          /*!< Bit position for DMA_HRS_HRS2. */
#define BM_DMA_HRS_HRS2      (0x00000004U) /*!< Bit mask for DMA_HRS_HRS2. */
#define BS_DMA_HRS_HRS2      (1U)          /*!< Bit field size in bits for DMA_HRS_HRS2. */

/*! @brief Read current value of the DMA_HRS_HRS2 field. */
#define BR_DMA_HRS_HRS2(x)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS2))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS3[3] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 3 is not present
 * - 1 - A hardware service request for channel 3 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS3      (3U)          /*!< Bit position for DMA_HRS_HRS3. */
#define BM_DMA_HRS_HRS3      (0x00000008U) /*!< Bit mask for DMA_HRS_HRS3. */
#define BS_DMA_HRS_HRS3      (1U)          /*!< Bit field size in bits for DMA_HRS_HRS3. */

/*! @brief Read current value of the DMA_HRS_HRS3 field. */
#define BR_DMA_HRS_HRS3(x)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS3))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS4[4] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 4 is not present
 * - 1 - A hardware service request for channel 4 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS4      (4U)          /*!< Bit position for DMA_HRS_HRS4. */
#define BM_DMA_HRS_HRS4      (0x00000010U) /*!< Bit mask for DMA_HRS_HRS4. */
#define BS_DMA_HRS_HRS4      (1U)          /*!< Bit field size in bits for DMA_HRS_HRS4. */

/*! @brief Read current value of the DMA_HRS_HRS4 field. */
#define BR_DMA_HRS_HRS4(x)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS4))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS5[5] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 5 is not present
 * - 1 - A hardware service request for channel 5 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS5      (5U)          /*!< Bit position for DMA_HRS_HRS5. */
#define BM_DMA_HRS_HRS5      (0x00000020U) /*!< Bit mask for DMA_HRS_HRS5. */
#define BS_DMA_HRS_HRS5      (1U)          /*!< Bit field size in bits for DMA_HRS_HRS5. */

/*! @brief Read current value of the DMA_HRS_HRS5 field. */
#define BR_DMA_HRS_HRS5(x)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS5))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS6[6] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 6 is not present
 * - 1 - A hardware service request for channel 6 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS6      (6U)          /*!< Bit position for DMA_HRS_HRS6. */
#define BM_DMA_HRS_HRS6      (0x00000040U) /*!< Bit mask for DMA_HRS_HRS6. */
#define BS_DMA_HRS_HRS6      (1U)          /*!< Bit field size in bits for DMA_HRS_HRS6. */

/*! @brief Read current value of the DMA_HRS_HRS6 field. */
#define BR_DMA_HRS_HRS6(x)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS6))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS7[7] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 7 is not present
 * - 1 - A hardware service request for channel 7 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS7      (7U)          /*!< Bit position for DMA_HRS_HRS7. */
#define BM_DMA_HRS_HRS7      (0x00000080U) /*!< Bit mask for DMA_HRS_HRS7. */
#define BS_DMA_HRS_HRS7      (1U)          /*!< Bit field size in bits for DMA_HRS_HRS7. */

/*! @brief Read current value of the DMA_HRS_HRS7 field. */
#define BR_DMA_HRS_HRS7(x)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS7))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS8[8] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 8 is not present
 * - 1 - A hardware service request for channel 8 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS8      (8U)          /*!< Bit position for DMA_HRS_HRS8. */
#define BM_DMA_HRS_HRS8      (0x00000100U) /*!< Bit mask for DMA_HRS_HRS8. */
#define BS_DMA_HRS_HRS8      (1U)          /*!< Bit field size in bits for DMA_HRS_HRS8. */

/*! @brief Read current value of the DMA_HRS_HRS8 field. */
#define BR_DMA_HRS_HRS8(x)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS8))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS9[9] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 9 is not present
 * - 1 - A hardware service request for channel 9 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS9      (9U)          /*!< Bit position for DMA_HRS_HRS9. */
#define BM_DMA_HRS_HRS9      (0x00000200U) /*!< Bit mask for DMA_HRS_HRS9. */
#define BS_DMA_HRS_HRS9      (1U)          /*!< Bit field size in bits for DMA_HRS_HRS9. */

/*! @brief Read current value of the DMA_HRS_HRS9 field. */
#define BR_DMA_HRS_HRS9(x)   (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS9))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS10[10] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 10 is not present
 * - 1 - A hardware service request for channel 10 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS10     (10U)         /*!< Bit position for DMA_HRS_HRS10. */
#define BM_DMA_HRS_HRS10     (0x00000400U) /*!< Bit mask for DMA_HRS_HRS10. */
#define BS_DMA_HRS_HRS10     (1U)          /*!< Bit field size in bits for DMA_HRS_HRS10. */

/*! @brief Read current value of the DMA_HRS_HRS10 field. */
#define BR_DMA_HRS_HRS10(x)  (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS10))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS11[11] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 11 is not present
 * - 1 - A hardware service request for channel 11 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS11     (11U)         /*!< Bit position for DMA_HRS_HRS11. */
#define BM_DMA_HRS_HRS11     (0x00000800U) /*!< Bit mask for DMA_HRS_HRS11. */
#define BS_DMA_HRS_HRS11     (1U)          /*!< Bit field size in bits for DMA_HRS_HRS11. */

/*! @brief Read current value of the DMA_HRS_HRS11 field. */
#define BR_DMA_HRS_HRS11(x)  (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS11))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS12[12] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 12 is not present
 * - 1 - A hardware service request for channel 12 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS12     (12U)         /*!< Bit position for DMA_HRS_HRS12. */
#define BM_DMA_HRS_HRS12     (0x00001000U) /*!< Bit mask for DMA_HRS_HRS12. */
#define BS_DMA_HRS_HRS12     (1U)          /*!< Bit field size in bits for DMA_HRS_HRS12. */

/*! @brief Read current value of the DMA_HRS_HRS12 field. */
#define BR_DMA_HRS_HRS12(x)  (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS12))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS13[13] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 13 is not present
 * - 1 - A hardware service request for channel 13 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS13     (13U)         /*!< Bit position for DMA_HRS_HRS13. */
#define BM_DMA_HRS_HRS13     (0x00002000U) /*!< Bit mask for DMA_HRS_HRS13. */
#define BS_DMA_HRS_HRS13     (1U)          /*!< Bit field size in bits for DMA_HRS_HRS13. */

/*! @brief Read current value of the DMA_HRS_HRS13 field. */
#define BR_DMA_HRS_HRS13(x)  (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS13))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS14[14] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 14 is not present
 * - 1 - A hardware service request for channel 14 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS14     (14U)         /*!< Bit position for DMA_HRS_HRS14. */
#define BM_DMA_HRS_HRS14     (0x00004000U) /*!< Bit mask for DMA_HRS_HRS14. */
#define BS_DMA_HRS_HRS14     (1U)          /*!< Bit field size in bits for DMA_HRS_HRS14. */

/*! @brief Read current value of the DMA_HRS_HRS14 field. */
#define BR_DMA_HRS_HRS14(x)  (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS14))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS15[15] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free , the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 15 is not present
 * - 1 - A hardware service request for channel 15 is present
 */
/*@{*/
#define BP_DMA_HRS_HRS15     (15U)         /*!< Bit position for DMA_HRS_HRS15. */
#define BM_DMA_HRS_HRS15     (0x00008000U) /*!< Bit mask for DMA_HRS_HRS15. */
#define BS_DMA_HRS_HRS15     (1U)          /*!< Bit field size in bits for DMA_HRS_HRS15. */

/*! @brief Read current value of the DMA_HRS_HRS15 field. */
#define BR_DMA_HRS_HRS15(x)  (BITBAND_ACCESS32(HW_DMA_HRS_ADDR(x), BP_DMA_HRS_HRS15))
/*@}*/

/*******************************************************************************
 * HW_DMA_DCHPRIn - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief HW_DMA_DCHPRIn - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel . The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next priority, then 2, 3, etc. Software must
 * program the channel priorities with unique values; otherwise, a configuration
 * error is reported. The range of the priority value is limited to the values of 0
 * through 15.
 */
typedef union _hw_dma_dchprin
{
    uint8_t U;
    struct _hw_dma_dchprin_bitfields
    {
        uint8_t CHPRI : 4;             /*!< [3:0] Channel n Arbitration Priority */
        uint8_t RESERVED0 : 2;         /*!< [5:4]  */
        uint8_t DPA : 1;               /*!< [6] Disable Preempt Ability */
        uint8_t ECP : 1;               /*!< [7] Enable Channel Preemption */
    } B;
} hw_dma_dchprin_t;

/*!
 * @name Constants and macros for entire DMA_DCHPRIn register
 */
/*@{*/
#define HW_DMA_DCHPRIn_COUNT (16U)

#define HW_DMA_DCHPRIn_ADDR(x, n) ((uint32_t)(x) + 0x100U + (0x1U * (n)))

/* DMA channel index to DMA channel priority register array index conversion macro */
#define HW_DMA_DCHPRIn_CHANNEL(n) (((n) & ~0x03U) | (3 - ((n) & 0x03U)))

#define HW_DMA_DCHPRIn(x, n)     (*(__IO hw_dma_dchprin_t *) HW_DMA_DCHPRIn_ADDR(x, n))
#define HW_DMA_DCHPRIn_RD(x, n)  (HW_DMA_DCHPRIn(x, n).U)
#define HW_DMA_DCHPRIn_WR(x, n, v) (HW_DMA_DCHPRIn(x, n).U = (v))
#define HW_DMA_DCHPRIn_SET(x, n, v) (HW_DMA_DCHPRIn_WR(x, n, HW_DMA_DCHPRIn_RD(x, n) |  (v)))
#define HW_DMA_DCHPRIn_CLR(x, n, v) (HW_DMA_DCHPRIn_WR(x, n, HW_DMA_DCHPRIn_RD(x, n) & ~(v)))
#define HW_DMA_DCHPRIn_TOG(x, n, v) (HW_DMA_DCHPRIn_WR(x, n, HW_DMA_DCHPRIn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRIn bitfields
 */

/*!
 * @name Register DMA_DCHPRIn, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority fields, CHPRI, is equal to the corresponding channel
 * number for each priority register, i.e., DCHPRI15[CHPRI] equals 0b1111.
 */
/*@{*/
#define BP_DMA_DCHPRIn_CHPRI (0U)          /*!< Bit position for DMA_DCHPRIn_CHPRI. */
#define BM_DMA_DCHPRIn_CHPRI (0x0FU)       /*!< Bit mask for DMA_DCHPRIn_CHPRI. */
#define BS_DMA_DCHPRIn_CHPRI (4U)          /*!< Bit field size in bits for DMA_DCHPRIn_CHPRI. */

/*! @brief Read current value of the DMA_DCHPRIn_CHPRI field. */
#define BR_DMA_DCHPRIn_CHPRI(x, n) (HW_DMA_DCHPRIn(x, n).B.CHPRI)

/*! @brief Format value for bitfield DMA_DCHPRIn_CHPRI. */
#define BF_DMA_DCHPRIn_CHPRI(v) ((uint8_t)((uint8_t)(v) << BP_DMA_DCHPRIn_CHPRI) & BM_DMA_DCHPRIn_CHPRI)

/*! @brief Set the CHPRI field to a new value. */
#define BW_DMA_DCHPRIn_CHPRI(x, n, v) (HW_DMA_DCHPRIn_WR(x, n, (HW_DMA_DCHPRIn_RD(x, n) & ~BM_DMA_DCHPRIn_CHPRI) | BF_DMA_DCHPRIn_CHPRI(v)))
/*@}*/

/*!
 * @name Register DMA_DCHPRIn, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority
 */
/*@{*/
#define BP_DMA_DCHPRIn_DPA   (6U)          /*!< Bit position for DMA_DCHPRIn_DPA. */
#define BM_DMA_DCHPRIn_DPA   (0x40U)       /*!< Bit mask for DMA_DCHPRIn_DPA. */
#define BS_DMA_DCHPRIn_DPA   (1U)          /*!< Bit field size in bits for DMA_DCHPRIn_DPA. */

/*! @brief Read current value of the DMA_DCHPRIn_DPA field. */
#define BR_DMA_DCHPRIn_DPA(x, n) (BITBAND_ACCESS8(HW_DMA_DCHPRIn_ADDR(x, n), BP_DMA_DCHPRIn_DPA))

/*! @brief Format value for bitfield DMA_DCHPRIn_DPA. */
#define BF_DMA_DCHPRIn_DPA(v) ((uint8_t)((uint8_t)(v) << BP_DMA_DCHPRIn_DPA) & BM_DMA_DCHPRIn_DPA)

/*! @brief Set the DPA field to a new value. */
#define BW_DMA_DCHPRIn_DPA(x, n, v) (BITBAND_ACCESS8(HW_DMA_DCHPRIn_ADDR(x, n), BP_DMA_DCHPRIn_DPA) = (v))
/*@}*/

/*!
 * @name Register DMA_DCHPRIn, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel
 */
/*@{*/
#define BP_DMA_DCHPRIn_ECP   (7U)          /*!< Bit position for DMA_DCHPRIn_ECP. */
#define BM_DMA_DCHPRIn_ECP   (0x80U)       /*!< Bit mask for DMA_DCHPRIn_ECP. */
#define BS_DMA_DCHPRIn_ECP   (1U)          /*!< Bit field size in bits for DMA_DCHPRIn_ECP. */

/*! @brief Read current value of the DMA_DCHPRIn_ECP field. */
#define BR_DMA_DCHPRIn_ECP(x, n) (BITBAND_ACCESS8(HW_DMA_DCHPRIn_ADDR(x, n), BP_DMA_DCHPRIn_ECP))

/*! @brief Format value for bitfield DMA_DCHPRIn_ECP. */
#define BF_DMA_DCHPRIn_ECP(v) ((uint8_t)((uint8_t)(v) << BP_DMA_DCHPRIn_ECP) & BM_DMA_DCHPRIn_ECP)

/*! @brief Set the ECP field to a new value. */
#define BW_DMA_DCHPRIn_ECP(x, n, v) (BITBAND_ACCESS8(HW_DMA_DCHPRIn_ADDR(x, n), BP_DMA_DCHPRIn_ECP) = (v))
/*@}*/

/*******************************************************************************
 * HW_DMA_TCDn_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcdn_saddr
{
    uint32_t U;
    struct _hw_dma_tcdn_saddr_bitfields
    {
        uint32_t SADDR : 32;           /*!< [31:0] Source Address */
    } B;
} hw_dma_tcdn_saddr_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_SADDR register
 */
/*@{*/
#define HW_DMA_TCDn_SADDR_COUNT (16U)

#define HW_DMA_TCDn_SADDR_ADDR(x, n) ((uint32_t)(x) + 0x1000U + (0x20U * (n)))

#define HW_DMA_TCDn_SADDR(x, n)  (*(__IO hw_dma_tcdn_saddr_t *) HW_DMA_TCDn_SADDR_ADDR(x, n))
#define HW_DMA_TCDn_SADDR_RD(x, n) (HW_DMA_TCDn_SADDR(x, n).U)
#define HW_DMA_TCDn_SADDR_WR(x, n, v) (HW_DMA_TCDn_SADDR(x, n).U = (v))
#define HW_DMA_TCDn_SADDR_SET(x, n, v) (HW_DMA_TCDn_SADDR_WR(x, n, HW_DMA_TCDn_SADDR_RD(x, n) |  (v)))
#define HW_DMA_TCDn_SADDR_CLR(x, n, v) (HW_DMA_TCDn_SADDR_WR(x, n, HW_DMA_TCDn_SADDR_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_SADDR_TOG(x, n, v) (HW_DMA_TCDn_SADDR_WR(x, n, HW_DMA_TCDn_SADDR_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_SADDR bitfields
 */

/*!
 * @name Register DMA_TCDn_SADDR, field SADDR[31:0] (RW)
 *
 * Memory address pointing to the source data.
 */
/*@{*/
#define BP_DMA_TCDn_SADDR_SADDR (0U)       /*!< Bit position for DMA_TCDn_SADDR_SADDR. */
#define BM_DMA_TCDn_SADDR_SADDR (0xFFFFFFFFU) /*!< Bit mask for DMA_TCDn_SADDR_SADDR. */
#define BS_DMA_TCDn_SADDR_SADDR (32U)      /*!< Bit field size in bits for DMA_TCDn_SADDR_SADDR. */

/*! @brief Read current value of the DMA_TCDn_SADDR_SADDR field. */
#define BR_DMA_TCDn_SADDR_SADDR(x, n) (HW_DMA_TCDn_SADDR(x, n).U)

/*! @brief Format value for bitfield DMA_TCDn_SADDR_SADDR. */
#define BF_DMA_TCDn_SADDR_SADDR(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_SADDR_SADDR) & BM_DMA_TCDn_SADDR_SADDR)

/*! @brief Set the SADDR field to a new value. */
#define BW_DMA_TCDn_SADDR_SADDR(x, n, v) (HW_DMA_TCDn_SADDR_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcdn_soff
{
    uint16_t U;
    struct _hw_dma_tcdn_soff_bitfields
    {
        uint16_t SOFF : 16;            /*!< [15:0] Source address signed offset */
    } B;
} hw_dma_tcdn_soff_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_SOFF register
 */
/*@{*/
#define HW_DMA_TCDn_SOFF_COUNT (16U)

#define HW_DMA_TCDn_SOFF_ADDR(x, n) ((uint32_t)(x) + 0x1004U + (0x20U * (n)))

#define HW_DMA_TCDn_SOFF(x, n)   (*(__IO hw_dma_tcdn_soff_t *) HW_DMA_TCDn_SOFF_ADDR(x, n))
#define HW_DMA_TCDn_SOFF_RD(x, n) (HW_DMA_TCDn_SOFF(x, n).U)
#define HW_DMA_TCDn_SOFF_WR(x, n, v) (HW_DMA_TCDn_SOFF(x, n).U = (v))
#define HW_DMA_TCDn_SOFF_SET(x, n, v) (HW_DMA_TCDn_SOFF_WR(x, n, HW_DMA_TCDn_SOFF_RD(x, n) |  (v)))
#define HW_DMA_TCDn_SOFF_CLR(x, n, v) (HW_DMA_TCDn_SOFF_WR(x, n, HW_DMA_TCDn_SOFF_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_SOFF_TOG(x, n, v) (HW_DMA_TCDn_SOFF_WR(x, n, HW_DMA_TCDn_SOFF_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_SOFF bitfields
 */

/*!
 * @name Register DMA_TCDn_SOFF, field SOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current source address to form the
 * next-state value as each source read is completed.
 */
/*@{*/
#define BP_DMA_TCDn_SOFF_SOFF (0U)         /*!< Bit position for DMA_TCDn_SOFF_SOFF. */
#define BM_DMA_TCDn_SOFF_SOFF (0xFFFFU)    /*!< Bit mask for DMA_TCDn_SOFF_SOFF. */
#define BS_DMA_TCDn_SOFF_SOFF (16U)        /*!< Bit field size in bits for DMA_TCDn_SOFF_SOFF. */

/*! @brief Read current value of the DMA_TCDn_SOFF_SOFF field. */
#define BR_DMA_TCDn_SOFF_SOFF(x, n) (HW_DMA_TCDn_SOFF(x, n).U)

/*! @brief Format value for bitfield DMA_TCDn_SOFF_SOFF. */
#define BF_DMA_TCDn_SOFF_SOFF(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_SOFF_SOFF) & BM_DMA_TCDn_SOFF_SOFF)

/*! @brief Set the SOFF field to a new value. */
#define BW_DMA_TCDn_SOFF_SOFF(x, n, v) (HW_DMA_TCDn_SOFF_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcdn_attr
{
    uint16_t U;
    struct _hw_dma_tcdn_attr_bitfields
    {
        uint16_t DSIZE : 3;            /*!< [2:0] Destination Data Transfer Size */
        uint16_t DMOD : 5;             /*!< [7:3] Destination Address Modulo */
        uint16_t SSIZE : 3;            /*!< [10:8] Source data transfer size */
        uint16_t SMOD : 5;             /*!< [15:11] Source Address Modulo. */
    } B;
} hw_dma_tcdn_attr_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_ATTR register
 */
/*@{*/
#define HW_DMA_TCDn_ATTR_COUNT (16U)

#define HW_DMA_TCDn_ATTR_ADDR(x, n) ((uint32_t)(x) + 0x1006U + (0x20U * (n)))

#define HW_DMA_TCDn_ATTR(x, n)   (*(__IO hw_dma_tcdn_attr_t *) HW_DMA_TCDn_ATTR_ADDR(x, n))
#define HW_DMA_TCDn_ATTR_RD(x, n) (HW_DMA_TCDn_ATTR(x, n).U)
#define HW_DMA_TCDn_ATTR_WR(x, n, v) (HW_DMA_TCDn_ATTR(x, n).U = (v))
#define HW_DMA_TCDn_ATTR_SET(x, n, v) (HW_DMA_TCDn_ATTR_WR(x, n, HW_DMA_TCDn_ATTR_RD(x, n) |  (v)))
#define HW_DMA_TCDn_ATTR_CLR(x, n, v) (HW_DMA_TCDn_ATTR_WR(x, n, HW_DMA_TCDn_ATTR_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_ATTR_TOG(x, n, v) (HW_DMA_TCDn_ATTR_WR(x, n, HW_DMA_TCDn_ATTR_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_ATTR bitfields
 */

/*!
 * @name Register DMA_TCDn_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
#define BP_DMA_TCDn_ATTR_DSIZE (0U)        /*!< Bit position for DMA_TCDn_ATTR_DSIZE. */
#define BM_DMA_TCDn_ATTR_DSIZE (0x0007U)   /*!< Bit mask for DMA_TCDn_ATTR_DSIZE. */
#define BS_DMA_TCDn_ATTR_DSIZE (3U)        /*!< Bit field size in bits for DMA_TCDn_ATTR_DSIZE. */

/*! @brief Read current value of the DMA_TCDn_ATTR_DSIZE field. */
#define BR_DMA_TCDn_ATTR_DSIZE(x, n) (HW_DMA_TCDn_ATTR(x, n).B.DSIZE)

/*! @brief Format value for bitfield DMA_TCDn_ATTR_DSIZE. */
#define BF_DMA_TCDn_ATTR_DSIZE(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_ATTR_DSIZE) & BM_DMA_TCDn_ATTR_DSIZE)

/*! @brief Set the DSIZE field to a new value. */
#define BW_DMA_TCDn_ATTR_DSIZE(x, n, v) (HW_DMA_TCDn_ATTR_WR(x, n, (HW_DMA_TCDn_ATTR_RD(x, n) & ~BM_DMA_TCDn_ATTR_DSIZE) | BF_DMA_TCDn_ATTR_DSIZE(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
#define BP_DMA_TCDn_ATTR_DMOD (3U)         /*!< Bit position for DMA_TCDn_ATTR_DMOD. */
#define BM_DMA_TCDn_ATTR_DMOD (0x00F8U)    /*!< Bit mask for DMA_TCDn_ATTR_DMOD. */
#define BS_DMA_TCDn_ATTR_DMOD (5U)         /*!< Bit field size in bits for DMA_TCDn_ATTR_DMOD. */

/*! @brief Read current value of the DMA_TCDn_ATTR_DMOD field. */
#define BR_DMA_TCDn_ATTR_DMOD(x, n) (HW_DMA_TCDn_ATTR(x, n).B.DMOD)

/*! @brief Format value for bitfield DMA_TCDn_ATTR_DMOD. */
#define BF_DMA_TCDn_ATTR_DMOD(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_ATTR_DMOD) & BM_DMA_TCDn_ATTR_DMOD)

/*! @brief Set the DMOD field to a new value. */
#define BW_DMA_TCDn_ATTR_DMOD(x, n, v) (HW_DMA_TCDn_ATTR_WR(x, n, (HW_DMA_TCDn_ATTR_RD(x, n) & ~BM_DMA_TCDn_ATTR_DMOD) | BF_DMA_TCDn_ATTR_DMOD(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_ATTR, field SSIZE[10:8] (RW)
 *
 * The attempted use of a Reserved encoding causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte
 * - 101 - 32-byte
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
#define BP_DMA_TCDn_ATTR_SSIZE (8U)        /*!< Bit position for DMA_TCDn_ATTR_SSIZE. */
#define BM_DMA_TCDn_ATTR_SSIZE (0x0700U)   /*!< Bit mask for DMA_TCDn_ATTR_SSIZE. */
#define BS_DMA_TCDn_ATTR_SSIZE (3U)        /*!< Bit field size in bits for DMA_TCDn_ATTR_SSIZE. */

/*! @brief Read current value of the DMA_TCDn_ATTR_SSIZE field. */
#define BR_DMA_TCDn_ATTR_SSIZE(x, n) (HW_DMA_TCDn_ATTR(x, n).B.SSIZE)

/*! @brief Format value for bitfield DMA_TCDn_ATTR_SSIZE. */
#define BF_DMA_TCDn_ATTR_SSIZE(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_ATTR_SSIZE) & BM_DMA_TCDn_ATTR_SSIZE)

/*! @brief Set the SSIZE field to a new value. */
#define BW_DMA_TCDn_ATTR_SSIZE(x, n, v) (HW_DMA_TCDn_ATTR_WR(x, n, (HW_DMA_TCDn_ATTR_RD(x, n) & ~BM_DMA_TCDn_ATTR_SSIZE) | BF_DMA_TCDn_ATTR_SSIZE(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 */
/*@{*/
#define BP_DMA_TCDn_ATTR_SMOD (11U)        /*!< Bit position for DMA_TCDn_ATTR_SMOD. */
#define BM_DMA_TCDn_ATTR_SMOD (0xF800U)    /*!< Bit mask for DMA_TCDn_ATTR_SMOD. */
#define BS_DMA_TCDn_ATTR_SMOD (5U)         /*!< Bit field size in bits for DMA_TCDn_ATTR_SMOD. */

/*! @brief Read current value of the DMA_TCDn_ATTR_SMOD field. */
#define BR_DMA_TCDn_ATTR_SMOD(x, n) (HW_DMA_TCDn_ATTR(x, n).B.SMOD)

/*! @brief Format value for bitfield DMA_TCDn_ATTR_SMOD. */
#define BF_DMA_TCDn_ATTR_SMOD(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_ATTR_SMOD) & BM_DMA_TCDn_ATTR_SMOD)

/*! @brief Set the SMOD field to a new value. */
#define BW_DMA_TCDn_ATTR_SMOD(x, n, v) (HW_DMA_TCDn_ATTR_WR(x, n, (HW_DMA_TCDn_ATTR_RD(x, n) & ~BM_DMA_TCDn_ATTR_SMOD) | BF_DMA_TCDn_ATTR_SMOD(v)))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled)
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for TCD word 2's definition.
 */
typedef union _hw_dma_tcdn_nbytes_mlno
{
    uint32_t U;
    struct _hw_dma_tcdn_nbytes_mlno_bitfields
    {
        uint32_t NBYTES : 32;          /*!< [31:0] Minor Byte Transfer Count */
    } B;
} hw_dma_tcdn_nbytes_mlno_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_NBYTES_MLNO register
 */
/*@{*/
#define HW_DMA_TCDn_NBYTES_MLNO_COUNT (16U)

#define HW_DMA_TCDn_NBYTES_MLNO_ADDR(x, n) ((uint32_t)(x) + 0x1008U + (0x20U * (n)))

#define HW_DMA_TCDn_NBYTES_MLNO(x, n) (*(__IO hw_dma_tcdn_nbytes_mlno_t *) HW_DMA_TCDn_NBYTES_MLNO_ADDR(x, n))
#define HW_DMA_TCDn_NBYTES_MLNO_RD(x, n) (HW_DMA_TCDn_NBYTES_MLNO(x, n).U)
#define HW_DMA_TCDn_NBYTES_MLNO_WR(x, n, v) (HW_DMA_TCDn_NBYTES_MLNO(x, n).U = (v))
#define HW_DMA_TCDn_NBYTES_MLNO_SET(x, n, v) (HW_DMA_TCDn_NBYTES_MLNO_WR(x, n, HW_DMA_TCDn_NBYTES_MLNO_RD(x, n) |  (v)))
#define HW_DMA_TCDn_NBYTES_MLNO_CLR(x, n, v) (HW_DMA_TCDn_NBYTES_MLNO_WR(x, n, HW_DMA_TCDn_NBYTES_MLNO_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_NBYTES_MLNO_TOG(x, n, v) (HW_DMA_TCDn_NBYTES_MLNO_WR(x, n, HW_DMA_TCDn_NBYTES_MLNO_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_NBYTES_MLNO bitfields
 */

/*!
 * @name Register DMA_TCDn_NBYTES_MLNO, field NBYTES[31:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted.
 * (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are
 * written back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed. An NBYTES value of 0x0000_0000 is interpreted as a 4
 * GB transfer.
 */
/*@{*/
#define BP_DMA_TCDn_NBYTES_MLNO_NBYTES (0U) /*!< Bit position for DMA_TCDn_NBYTES_MLNO_NBYTES. */
#define BM_DMA_TCDn_NBYTES_MLNO_NBYTES (0xFFFFFFFFU) /*!< Bit mask for DMA_TCDn_NBYTES_MLNO_NBYTES. */
#define BS_DMA_TCDn_NBYTES_MLNO_NBYTES (32U) /*!< Bit field size in bits for DMA_TCDn_NBYTES_MLNO_NBYTES. */

/*! @brief Read current value of the DMA_TCDn_NBYTES_MLNO_NBYTES field. */
#define BR_DMA_TCDn_NBYTES_MLNO_NBYTES(x, n) (HW_DMA_TCDn_NBYTES_MLNO(x, n).U)

/*! @brief Format value for bitfield DMA_TCDn_NBYTES_MLNO_NBYTES. */
#define BF_DMA_TCDn_NBYTES_MLNO_NBYTES(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_NBYTES_MLNO_NBYTES) & BM_DMA_TCDn_NBYTES_MLNO_NBYTES)

/*! @brief Set the NBYTES field to a new value. */
#define BW_DMA_TCDn_NBYTES_MLNO_NBYTES(x, n, v) (HW_DMA_TCDn_NBYTES_MLNO_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcdn_nbytes_mloffno
{
    uint32_t U;
    struct _hw_dma_tcdn_nbytes_mloffno_bitfields
    {
        uint32_t NBYTES : 30;          /*!< [29:0] Minor Byte Transfer Count */
        uint32_t DMLOE : 1;            /*!< [30] Destination Minor Loop Offset enable */
        uint32_t SMLOE : 1;            /*!< [31] Source Minor Loop Offset Enable */
    } B;
} hw_dma_tcdn_nbytes_mloffno_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_NBYTES_MLOFFNO register
 */
/*@{*/
#define HW_DMA_TCDn_NBYTES_MLOFFNO_COUNT (16U)

#define HW_DMA_TCDn_NBYTES_MLOFFNO_ADDR(x, n) ((uint32_t)(x) + 0x1008U + (0x20U * (n)))

#define HW_DMA_TCDn_NBYTES_MLOFFNO(x, n) (*(__IO hw_dma_tcdn_nbytes_mloffno_t *) HW_DMA_TCDn_NBYTES_MLOFFNO_ADDR(x, n))
#define HW_DMA_TCDn_NBYTES_MLOFFNO_RD(x, n) (HW_DMA_TCDn_NBYTES_MLOFFNO(x, n).U)
#define HW_DMA_TCDn_NBYTES_MLOFFNO_WR(x, n, v) (HW_DMA_TCDn_NBYTES_MLOFFNO(x, n).U = (v))
#define HW_DMA_TCDn_NBYTES_MLOFFNO_SET(x, n, v) (HW_DMA_TCDn_NBYTES_MLOFFNO_WR(x, n, HW_DMA_TCDn_NBYTES_MLOFFNO_RD(x, n) |  (v)))
#define HW_DMA_TCDn_NBYTES_MLOFFNO_CLR(x, n, v) (HW_DMA_TCDn_NBYTES_MLOFFNO_WR(x, n, HW_DMA_TCDn_NBYTES_MLOFFNO_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_NBYTES_MLOFFNO_TOG(x, n, v) (HW_DMA_TCDn_NBYTES_MLOFFNO_WR(x, n, HW_DMA_TCDn_NBYTES_MLOFFNO_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCDn_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted;
 * although, it may be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
#define BP_DMA_TCDn_NBYTES_MLOFFNO_NBYTES (0U) /*!< Bit position for DMA_TCDn_NBYTES_MLOFFNO_NBYTES. */
#define BM_DMA_TCDn_NBYTES_MLOFFNO_NBYTES (0x3FFFFFFFU) /*!< Bit mask for DMA_TCDn_NBYTES_MLOFFNO_NBYTES. */
#define BS_DMA_TCDn_NBYTES_MLOFFNO_NBYTES (30U) /*!< Bit field size in bits for DMA_TCDn_NBYTES_MLOFFNO_NBYTES. */

/*! @brief Read current value of the DMA_TCDn_NBYTES_MLOFFNO_NBYTES field. */
#define BR_DMA_TCDn_NBYTES_MLOFFNO_NBYTES(x, n) (HW_DMA_TCDn_NBYTES_MLOFFNO(x, n).B.NBYTES)

/*! @brief Format value for bitfield DMA_TCDn_NBYTES_MLOFFNO_NBYTES. */
#define BF_DMA_TCDn_NBYTES_MLOFFNO_NBYTES(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_NBYTES_MLOFFNO_NBYTES) & BM_DMA_TCDn_NBYTES_MLOFFNO_NBYTES)

/*! @brief Set the NBYTES field to a new value. */
#define BW_DMA_TCDn_NBYTES_MLOFFNO_NBYTES(x, n, v) (HW_DMA_TCDn_NBYTES_MLOFFNO_WR(x, n, (HW_DMA_TCDn_NBYTES_MLOFFNO_RD(x, n) & ~BM_DMA_TCDn_NBYTES_MLOFFNO_NBYTES) | BF_DMA_TCDn_NBYTES_MLOFFNO_NBYTES(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
#define BP_DMA_TCDn_NBYTES_MLOFFNO_DMLOE (30U) /*!< Bit position for DMA_TCDn_NBYTES_MLOFFNO_DMLOE. */
#define BM_DMA_TCDn_NBYTES_MLOFFNO_DMLOE (0x40000000U) /*!< Bit mask for DMA_TCDn_NBYTES_MLOFFNO_DMLOE. */
#define BS_DMA_TCDn_NBYTES_MLOFFNO_DMLOE (1U) /*!< Bit field size in bits for DMA_TCDn_NBYTES_MLOFFNO_DMLOE. */

/*! @brief Read current value of the DMA_TCDn_NBYTES_MLOFFNO_DMLOE field. */
#define BR_DMA_TCDn_NBYTES_MLOFFNO_DMLOE(x, n) (BITBAND_ACCESS32(HW_DMA_TCDn_NBYTES_MLOFFNO_ADDR(x, n), BP_DMA_TCDn_NBYTES_MLOFFNO_DMLOE))

/*! @brief Format value for bitfield DMA_TCDn_NBYTES_MLOFFNO_DMLOE. */
#define BF_DMA_TCDn_NBYTES_MLOFFNO_DMLOE(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_NBYTES_MLOFFNO_DMLOE) & BM_DMA_TCDn_NBYTES_MLOFFNO_DMLOE)

/*! @brief Set the DMLOE field to a new value. */
#define BW_DMA_TCDn_NBYTES_MLOFFNO_DMLOE(x, n, v) (BITBAND_ACCESS32(HW_DMA_TCDn_NBYTES_MLOFFNO_ADDR(x, n), BP_DMA_TCDn_NBYTES_MLOFFNO_DMLOE) = (v))
/*@}*/

/*!
 * @name Register DMA_TCDn_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
#define BP_DMA_TCDn_NBYTES_MLOFFNO_SMLOE (31U) /*!< Bit position for DMA_TCDn_NBYTES_MLOFFNO_SMLOE. */
#define BM_DMA_TCDn_NBYTES_MLOFFNO_SMLOE (0x80000000U) /*!< Bit mask for DMA_TCDn_NBYTES_MLOFFNO_SMLOE. */
#define BS_DMA_TCDn_NBYTES_MLOFFNO_SMLOE (1U) /*!< Bit field size in bits for DMA_TCDn_NBYTES_MLOFFNO_SMLOE. */

/*! @brief Read current value of the DMA_TCDn_NBYTES_MLOFFNO_SMLOE field. */
#define BR_DMA_TCDn_NBYTES_MLOFFNO_SMLOE(x, n) (BITBAND_ACCESS32(HW_DMA_TCDn_NBYTES_MLOFFNO_ADDR(x, n), BP_DMA_TCDn_NBYTES_MLOFFNO_SMLOE))

/*! @brief Format value for bitfield DMA_TCDn_NBYTES_MLOFFNO_SMLOE. */
#define BF_DMA_TCDn_NBYTES_MLOFFNO_SMLOE(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_NBYTES_MLOFFNO_SMLOE) & BM_DMA_TCDn_NBYTES_MLOFFNO_SMLOE)

/*! @brief Set the SMLOE field to a new value. */
#define BW_DMA_TCDn_NBYTES_MLOFFNO_SMLOE(x, n, v) (BITBAND_ACCESS32(HW_DMA_TCDn_NBYTES_MLOFFNO_ADDR(x, n), BP_DMA_TCDn_NBYTES_MLOFFNO_SMLOE) = (v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
typedef union _hw_dma_tcdn_nbytes_mloffyes
{
    uint32_t U;
    struct _hw_dma_tcdn_nbytes_mloffyes_bitfields
    {
        uint32_t NBYTES : 10;          /*!< [9:0] Minor Byte Transfer Count */
        uint32_t MLOFF : 20;           /*!< [29:10] If SMLOE or DMLOE is set, this
                                        * field represents a sign-extended offset applied to the source or destination
                                        * address to form the next-state value after the minor loop completes. */
        uint32_t DMLOE : 1;            /*!< [30] Destination Minor Loop Offset enable */
        uint32_t SMLOE : 1;            /*!< [31] Source Minor Loop Offset Enable */
    } B;
} hw_dma_tcdn_nbytes_mloffyes_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_NBYTES_MLOFFYES register
 */
/*@{*/
#define HW_DMA_TCDn_NBYTES_MLOFFYES_COUNT (16U)

#define HW_DMA_TCDn_NBYTES_MLOFFYES_ADDR(x, n) ((uint32_t)(x) + 0x1008U + (0x20U * (n)))

#define HW_DMA_TCDn_NBYTES_MLOFFYES(x, n) (*(__IO hw_dma_tcdn_nbytes_mloffyes_t *) HW_DMA_TCDn_NBYTES_MLOFFYES_ADDR(x, n))
#define HW_DMA_TCDn_NBYTES_MLOFFYES_RD(x, n) (HW_DMA_TCDn_NBYTES_MLOFFYES(x, n).U)
#define HW_DMA_TCDn_NBYTES_MLOFFYES_WR(x, n, v) (HW_DMA_TCDn_NBYTES_MLOFFYES(x, n).U = (v))
#define HW_DMA_TCDn_NBYTES_MLOFFYES_SET(x, n, v) (HW_DMA_TCDn_NBYTES_MLOFFYES_WR(x, n, HW_DMA_TCDn_NBYTES_MLOFFYES_RD(x, n) |  (v)))
#define HW_DMA_TCDn_NBYTES_MLOFFYES_CLR(x, n, v) (HW_DMA_TCDn_NBYTES_MLOFFYES_WR(x, n, HW_DMA_TCDn_NBYTES_MLOFFYES_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_NBYTES_MLOFFYES_TOG(x, n, v) (HW_DMA_TCDn_NBYTES_MLOFFYES_WR(x, n, HW_DMA_TCDn_NBYTES_MLOFFYES_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCDn_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted.
 * (Although, it may be stalled by using the bandwidth control field, or via
 * preemption.) After the minor count is exhausted, the SADDR and DADDR values are
 * written back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
#define BP_DMA_TCDn_NBYTES_MLOFFYES_NBYTES (0U) /*!< Bit position for DMA_TCDn_NBYTES_MLOFFYES_NBYTES. */
#define BM_DMA_TCDn_NBYTES_MLOFFYES_NBYTES (0x000003FFU) /*!< Bit mask for DMA_TCDn_NBYTES_MLOFFYES_NBYTES. */
#define BS_DMA_TCDn_NBYTES_MLOFFYES_NBYTES (10U) /*!< Bit field size in bits for DMA_TCDn_NBYTES_MLOFFYES_NBYTES. */

/*! @brief Read current value of the DMA_TCDn_NBYTES_MLOFFYES_NBYTES field. */
#define BR_DMA_TCDn_NBYTES_MLOFFYES_NBYTES(x, n) (HW_DMA_TCDn_NBYTES_MLOFFYES(x, n).B.NBYTES)

/*! @brief Format value for bitfield DMA_TCDn_NBYTES_MLOFFYES_NBYTES. */
#define BF_DMA_TCDn_NBYTES_MLOFFYES_NBYTES(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_NBYTES_MLOFFYES_NBYTES) & BM_DMA_TCDn_NBYTES_MLOFFYES_NBYTES)

/*! @brief Set the NBYTES field to a new value. */
#define BW_DMA_TCDn_NBYTES_MLOFFYES_NBYTES(x, n, v) (HW_DMA_TCDn_NBYTES_MLOFFYES_WR(x, n, (HW_DMA_TCDn_NBYTES_MLOFFYES_RD(x, n) & ~BM_DMA_TCDn_NBYTES_MLOFFYES_NBYTES) | BF_DMA_TCDn_NBYTES_MLOFFYES_NBYTES(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
#define BP_DMA_TCDn_NBYTES_MLOFFYES_MLOFF (10U) /*!< Bit position for DMA_TCDn_NBYTES_MLOFFYES_MLOFF. */
#define BM_DMA_TCDn_NBYTES_MLOFFYES_MLOFF (0x3FFFFC00U) /*!< Bit mask for DMA_TCDn_NBYTES_MLOFFYES_MLOFF. */
#define BS_DMA_TCDn_NBYTES_MLOFFYES_MLOFF (20U) /*!< Bit field size in bits for DMA_TCDn_NBYTES_MLOFFYES_MLOFF. */

/*! @brief Read current value of the DMA_TCDn_NBYTES_MLOFFYES_MLOFF field. */
#define BR_DMA_TCDn_NBYTES_MLOFFYES_MLOFF(x, n) (HW_DMA_TCDn_NBYTES_MLOFFYES(x, n).B.MLOFF)

/*! @brief Format value for bitfield DMA_TCDn_NBYTES_MLOFFYES_MLOFF. */
#define BF_DMA_TCDn_NBYTES_MLOFFYES_MLOFF(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_NBYTES_MLOFFYES_MLOFF) & BM_DMA_TCDn_NBYTES_MLOFFYES_MLOFF)

/*! @brief Set the MLOFF field to a new value. */
#define BW_DMA_TCDn_NBYTES_MLOFFYES_MLOFF(x, n, v) (HW_DMA_TCDn_NBYTES_MLOFFYES_WR(x, n, (HW_DMA_TCDn_NBYTES_MLOFFYES_RD(x, n) & ~BM_DMA_TCDn_NBYTES_MLOFFYES_MLOFF) | BF_DMA_TCDn_NBYTES_MLOFFYES_MLOFF(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
#define BP_DMA_TCDn_NBYTES_MLOFFYES_DMLOE (30U) /*!< Bit position for DMA_TCDn_NBYTES_MLOFFYES_DMLOE. */
#define BM_DMA_TCDn_NBYTES_MLOFFYES_DMLOE (0x40000000U) /*!< Bit mask for DMA_TCDn_NBYTES_MLOFFYES_DMLOE. */
#define BS_DMA_TCDn_NBYTES_MLOFFYES_DMLOE (1U) /*!< Bit field size in bits for DMA_TCDn_NBYTES_MLOFFYES_DMLOE. */

/*! @brief Read current value of the DMA_TCDn_NBYTES_MLOFFYES_DMLOE field. */
#define BR_DMA_TCDn_NBYTES_MLOFFYES_DMLOE(x, n) (BITBAND_ACCESS32(HW_DMA_TCDn_NBYTES_MLOFFYES_ADDR(x, n), BP_DMA_TCDn_NBYTES_MLOFFYES_DMLOE))

/*! @brief Format value for bitfield DMA_TCDn_NBYTES_MLOFFYES_DMLOE. */
#define BF_DMA_TCDn_NBYTES_MLOFFYES_DMLOE(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_NBYTES_MLOFFYES_DMLOE) & BM_DMA_TCDn_NBYTES_MLOFFYES_DMLOE)

/*! @brief Set the DMLOE field to a new value. */
#define BW_DMA_TCDn_NBYTES_MLOFFYES_DMLOE(x, n, v) (BITBAND_ACCESS32(HW_DMA_TCDn_NBYTES_MLOFFYES_ADDR(x, n), BP_DMA_TCDn_NBYTES_MLOFFYES_DMLOE) = (v))
/*@}*/

/*!
 * @name Register DMA_TCDn_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
#define BP_DMA_TCDn_NBYTES_MLOFFYES_SMLOE (31U) /*!< Bit position for DMA_TCDn_NBYTES_MLOFFYES_SMLOE. */
#define BM_DMA_TCDn_NBYTES_MLOFFYES_SMLOE (0x80000000U) /*!< Bit mask for DMA_TCDn_NBYTES_MLOFFYES_SMLOE. */
#define BS_DMA_TCDn_NBYTES_MLOFFYES_SMLOE (1U) /*!< Bit field size in bits for DMA_TCDn_NBYTES_MLOFFYES_SMLOE. */

/*! @brief Read current value of the DMA_TCDn_NBYTES_MLOFFYES_SMLOE field. */
#define BR_DMA_TCDn_NBYTES_MLOFFYES_SMLOE(x, n) (BITBAND_ACCESS32(HW_DMA_TCDn_NBYTES_MLOFFYES_ADDR(x, n), BP_DMA_TCDn_NBYTES_MLOFFYES_SMLOE))

/*! @brief Format value for bitfield DMA_TCDn_NBYTES_MLOFFYES_SMLOE. */
#define BF_DMA_TCDn_NBYTES_MLOFFYES_SMLOE(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_NBYTES_MLOFFYES_SMLOE) & BM_DMA_TCDn_NBYTES_MLOFFYES_SMLOE)

/*! @brief Set the SMLOE field to a new value. */
#define BW_DMA_TCDn_NBYTES_MLOFFYES_SMLOE(x, n, v) (BITBAND_ACCESS32(HW_DMA_TCDn_NBYTES_MLOFFYES_ADDR(x, n), BP_DMA_TCDn_NBYTES_MLOFFYES_SMLOE) = (v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcdn_slast
{
    uint32_t U;
    struct _hw_dma_tcdn_slast_bitfields
    {
        uint32_t SLAST : 32;           /*!< [31:0] Last source Address Adjustment */
    } B;
} hw_dma_tcdn_slast_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_SLAST register
 */
/*@{*/
#define HW_DMA_TCDn_SLAST_COUNT (16U)

#define HW_DMA_TCDn_SLAST_ADDR(x, n) ((uint32_t)(x) + 0x100CU + (0x20U * (n)))

#define HW_DMA_TCDn_SLAST(x, n)  (*(__IO hw_dma_tcdn_slast_t *) HW_DMA_TCDn_SLAST_ADDR(x, n))
#define HW_DMA_TCDn_SLAST_RD(x, n) (HW_DMA_TCDn_SLAST(x, n).U)
#define HW_DMA_TCDn_SLAST_WR(x, n, v) (HW_DMA_TCDn_SLAST(x, n).U = (v))
#define HW_DMA_TCDn_SLAST_SET(x, n, v) (HW_DMA_TCDn_SLAST_WR(x, n, HW_DMA_TCDn_SLAST_RD(x, n) |  (v)))
#define HW_DMA_TCDn_SLAST_CLR(x, n, v) (HW_DMA_TCDn_SLAST_WR(x, n, HW_DMA_TCDn_SLAST_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_SLAST_TOG(x, n, v) (HW_DMA_TCDn_SLAST_WR(x, n, HW_DMA_TCDn_SLAST_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_SLAST bitfields
 */

/*!
 * @name Register DMA_TCDn_SLAST, field SLAST[31:0] (RW)
 *
 * Adjustment value added to the source address at the completion of the major
 * iteration count. This value can be applied to restore the source address to the
 * initial value, or adjust the address to reference the next data structure.
 * This register uses two's complement notation; the overflow bit is discarded.
 */
/*@{*/
#define BP_DMA_TCDn_SLAST_SLAST (0U)       /*!< Bit position for DMA_TCDn_SLAST_SLAST. */
#define BM_DMA_TCDn_SLAST_SLAST (0xFFFFFFFFU) /*!< Bit mask for DMA_TCDn_SLAST_SLAST. */
#define BS_DMA_TCDn_SLAST_SLAST (32U)      /*!< Bit field size in bits for DMA_TCDn_SLAST_SLAST. */

/*! @brief Read current value of the DMA_TCDn_SLAST_SLAST field. */
#define BR_DMA_TCDn_SLAST_SLAST(x, n) (HW_DMA_TCDn_SLAST(x, n).U)

/*! @brief Format value for bitfield DMA_TCDn_SLAST_SLAST. */
#define BF_DMA_TCDn_SLAST_SLAST(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_SLAST_SLAST) & BM_DMA_TCDn_SLAST_SLAST)

/*! @brief Set the SLAST field to a new value. */
#define BW_DMA_TCDn_SLAST_SLAST(x, n, v) (HW_DMA_TCDn_SLAST_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcdn_daddr
{
    uint32_t U;
    struct _hw_dma_tcdn_daddr_bitfields
    {
        uint32_t DADDR : 32;           /*!< [31:0] Destination Address */
    } B;
} hw_dma_tcdn_daddr_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_DADDR register
 */
/*@{*/
#define HW_DMA_TCDn_DADDR_COUNT (16U)

#define HW_DMA_TCDn_DADDR_ADDR(x, n) ((uint32_t)(x) + 0x1010U + (0x20U * (n)))

#define HW_DMA_TCDn_DADDR(x, n)  (*(__IO hw_dma_tcdn_daddr_t *) HW_DMA_TCDn_DADDR_ADDR(x, n))
#define HW_DMA_TCDn_DADDR_RD(x, n) (HW_DMA_TCDn_DADDR(x, n).U)
#define HW_DMA_TCDn_DADDR_WR(x, n, v) (HW_DMA_TCDn_DADDR(x, n).U = (v))
#define HW_DMA_TCDn_DADDR_SET(x, n, v) (HW_DMA_TCDn_DADDR_WR(x, n, HW_DMA_TCDn_DADDR_RD(x, n) |  (v)))
#define HW_DMA_TCDn_DADDR_CLR(x, n, v) (HW_DMA_TCDn_DADDR_WR(x, n, HW_DMA_TCDn_DADDR_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_DADDR_TOG(x, n, v) (HW_DMA_TCDn_DADDR_WR(x, n, HW_DMA_TCDn_DADDR_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_DADDR bitfields
 */

/*!
 * @name Register DMA_TCDn_DADDR, field DADDR[31:0] (RW)
 *
 * Memory address pointing to the destination data.
 */
/*@{*/
#define BP_DMA_TCDn_DADDR_DADDR (0U)       /*!< Bit position for DMA_TCDn_DADDR_DADDR. */
#define BM_DMA_TCDn_DADDR_DADDR (0xFFFFFFFFU) /*!< Bit mask for DMA_TCDn_DADDR_DADDR. */
#define BS_DMA_TCDn_DADDR_DADDR (32U)      /*!< Bit field size in bits for DMA_TCDn_DADDR_DADDR. */

/*! @brief Read current value of the DMA_TCDn_DADDR_DADDR field. */
#define BR_DMA_TCDn_DADDR_DADDR(x, n) (HW_DMA_TCDn_DADDR(x, n).U)

/*! @brief Format value for bitfield DMA_TCDn_DADDR_DADDR. */
#define BF_DMA_TCDn_DADDR_DADDR(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_DADDR_DADDR) & BM_DMA_TCDn_DADDR_DADDR)

/*! @brief Set the DADDR field to a new value. */
#define BW_DMA_TCDn_DADDR_DADDR(x, n, v) (HW_DMA_TCDn_DADDR_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcdn_doff
{
    uint16_t U;
    struct _hw_dma_tcdn_doff_bitfields
    {
        uint16_t DOFF : 16;            /*!< [15:0] Destination Address Signed offset */
    } B;
} hw_dma_tcdn_doff_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_DOFF register
 */
/*@{*/
#define HW_DMA_TCDn_DOFF_COUNT (16U)

#define HW_DMA_TCDn_DOFF_ADDR(x, n) ((uint32_t)(x) + 0x1014U + (0x20U * (n)))

#define HW_DMA_TCDn_DOFF(x, n)   (*(__IO hw_dma_tcdn_doff_t *) HW_DMA_TCDn_DOFF_ADDR(x, n))
#define HW_DMA_TCDn_DOFF_RD(x, n) (HW_DMA_TCDn_DOFF(x, n).U)
#define HW_DMA_TCDn_DOFF_WR(x, n, v) (HW_DMA_TCDn_DOFF(x, n).U = (v))
#define HW_DMA_TCDn_DOFF_SET(x, n, v) (HW_DMA_TCDn_DOFF_WR(x, n, HW_DMA_TCDn_DOFF_RD(x, n) |  (v)))
#define HW_DMA_TCDn_DOFF_CLR(x, n, v) (HW_DMA_TCDn_DOFF_WR(x, n, HW_DMA_TCDn_DOFF_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_DOFF_TOG(x, n, v) (HW_DMA_TCDn_DOFF_WR(x, n, HW_DMA_TCDn_DOFF_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_DOFF bitfields
 */

/*!
 * @name Register DMA_TCDn_DOFF, field DOFF[15:0] (RW)
 *
 * Sign-extended offset applied to the current destination address to form the
 * next-state value as each destination write is completed.
 */
/*@{*/
#define BP_DMA_TCDn_DOFF_DOFF (0U)         /*!< Bit position for DMA_TCDn_DOFF_DOFF. */
#define BM_DMA_TCDn_DOFF_DOFF (0xFFFFU)    /*!< Bit mask for DMA_TCDn_DOFF_DOFF. */
#define BS_DMA_TCDn_DOFF_DOFF (16U)        /*!< Bit field size in bits for DMA_TCDn_DOFF_DOFF. */

/*! @brief Read current value of the DMA_TCDn_DOFF_DOFF field. */
#define BR_DMA_TCDn_DOFF_DOFF(x, n) (HW_DMA_TCDn_DOFF(x, n).U)

/*! @brief Format value for bitfield DMA_TCDn_DOFF_DOFF. */
#define BF_DMA_TCDn_DOFF_DOFF(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_DOFF_DOFF) & BM_DMA_TCDn_DOFF_DOFF)

/*! @brief Set the DOFF field to a new value. */
#define BW_DMA_TCDn_DOFF_DOFF(x, n, v) (HW_DMA_TCDn_DOFF_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
typedef union _hw_dma_tcdn_citer_elinkno
{
    uint16_t U;
    struct _hw_dma_tcdn_citer_elinkno_bitfields
    {
        uint16_t CITER : 15;           /*!< [14:0] Current Major Iteration Count */
        uint16_t ELINK : 1;            /*!< [15] Enable channel-to-channel linking on
                                        * minor-loop complete */
    } B;
} hw_dma_tcdn_citer_elinkno_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_CITER_ELINKNO register
 */
/*@{*/
#define HW_DMA_TCDn_CITER_ELINKNO_COUNT (16U)

#define HW_DMA_TCDn_CITER_ELINKNO_ADDR(x, n) ((uint32_t)(x) + 0x1016U + (0x20U * (n)))

#define HW_DMA_TCDn_CITER_ELINKNO(x, n) (*(__IO hw_dma_tcdn_citer_elinkno_t *) HW_DMA_TCDn_CITER_ELINKNO_ADDR(x, n))
#define HW_DMA_TCDn_CITER_ELINKNO_RD(x, n) (HW_DMA_TCDn_CITER_ELINKNO(x, n).U)
#define HW_DMA_TCDn_CITER_ELINKNO_WR(x, n, v) (HW_DMA_TCDn_CITER_ELINKNO(x, n).U = (v))
#define HW_DMA_TCDn_CITER_ELINKNO_SET(x, n, v) (HW_DMA_TCDn_CITER_ELINKNO_WR(x, n, HW_DMA_TCDn_CITER_ELINKNO_RD(x, n) |  (v)))
#define HW_DMA_TCDn_CITER_ELINKNO_CLR(x, n, v) (HW_DMA_TCDn_CITER_ELINKNO_WR(x, n, HW_DMA_TCDn_CITER_ELINKNO_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_CITER_ELINKNO_TOG(x, n, v) (HW_DMA_TCDn_CITER_ELINKNO_WR(x, n, HW_DMA_TCDn_CITER_ELINKNO_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCDn_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations
 * (e.g., final source and destination address calculations), optionally generating
 * an interrupt to signal channel completion before reloading the CITER field
 * from the beginning iteration count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that contained in
 * the BITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
#define BP_DMA_TCDn_CITER_ELINKNO_CITER (0U) /*!< Bit position for DMA_TCDn_CITER_ELINKNO_CITER. */
#define BM_DMA_TCDn_CITER_ELINKNO_CITER (0x7FFFU) /*!< Bit mask for DMA_TCDn_CITER_ELINKNO_CITER. */
#define BS_DMA_TCDn_CITER_ELINKNO_CITER (15U) /*!< Bit field size in bits for DMA_TCDn_CITER_ELINKNO_CITER. */

/*! @brief Read current value of the DMA_TCDn_CITER_ELINKNO_CITER field. */
#define BR_DMA_TCDn_CITER_ELINKNO_CITER(x, n) (HW_DMA_TCDn_CITER_ELINKNO(x, n).B.CITER)

/*! @brief Format value for bitfield DMA_TCDn_CITER_ELINKNO_CITER. */
#define BF_DMA_TCDn_CITER_ELINKNO_CITER(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CITER_ELINKNO_CITER) & BM_DMA_TCDn_CITER_ELINKNO_CITER)

/*! @brief Set the CITER field to a new value. */
#define BW_DMA_TCDn_CITER_ELINKNO_CITER(x, n, v) (HW_DMA_TCDn_CITER_ELINKNO_WR(x, n, (HW_DMA_TCDn_CITER_ELINKNO_RD(x, n) & ~BM_DMA_TCDn_CITER_ELINKNO_CITER) | BF_DMA_TCDn_CITER_ELINKNO_CITER(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
#define BP_DMA_TCDn_CITER_ELINKNO_ELINK (15U) /*!< Bit position for DMA_TCDn_CITER_ELINKNO_ELINK. */
#define BM_DMA_TCDn_CITER_ELINKNO_ELINK (0x8000U) /*!< Bit mask for DMA_TCDn_CITER_ELINKNO_ELINK. */
#define BS_DMA_TCDn_CITER_ELINKNO_ELINK (1U) /*!< Bit field size in bits for DMA_TCDn_CITER_ELINKNO_ELINK. */

/*! @brief Read current value of the DMA_TCDn_CITER_ELINKNO_ELINK field. */
#define BR_DMA_TCDn_CITER_ELINKNO_ELINK(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_CITER_ELINKNO_ADDR(x, n), BP_DMA_TCDn_CITER_ELINKNO_ELINK))

/*! @brief Format value for bitfield DMA_TCDn_CITER_ELINKNO_ELINK. */
#define BF_DMA_TCDn_CITER_ELINKNO_ELINK(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CITER_ELINKNO_ELINK) & BM_DMA_TCDn_CITER_ELINKNO_ELINK)

/*! @brief Set the ELINK field to a new value. */
#define BW_DMA_TCDn_CITER_ELINKNO_ELINK(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_CITER_ELINKNO_ADDR(x, n), BP_DMA_TCDn_CITER_ELINKNO_ELINK) = (v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
typedef union _hw_dma_tcdn_citer_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcdn_citer_elinkyes_bitfields
    {
        uint16_t CITER : 9;            /*!< [8:0] Current Major Iteration Count */
        uint16_t LINKCH : 4;           /*!< [12:9] Link Channel Number */
        uint16_t RESERVED0 : 2;        /*!< [14:13]  */
        uint16_t ELINK : 1;            /*!< [15] Enable channel-to-channel linking on
                                        * minor-loop complete */
    } B;
} hw_dma_tcdn_citer_elinkyes_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_CITER_ELINKYES register
 */
/*@{*/
#define HW_DMA_TCDn_CITER_ELINKYES_COUNT (16U)

#define HW_DMA_TCDn_CITER_ELINKYES_ADDR(x, n) ((uint32_t)(x) + 0x1016U + (0x20U * (n)))

#define HW_DMA_TCDn_CITER_ELINKYES(x, n) (*(__IO hw_dma_tcdn_citer_elinkyes_t *) HW_DMA_TCDn_CITER_ELINKYES_ADDR(x, n))
#define HW_DMA_TCDn_CITER_ELINKYES_RD(x, n) (HW_DMA_TCDn_CITER_ELINKYES(x, n).U)
#define HW_DMA_TCDn_CITER_ELINKYES_WR(x, n, v) (HW_DMA_TCDn_CITER_ELINKYES(x, n).U = (v))
#define HW_DMA_TCDn_CITER_ELINKYES_SET(x, n, v) (HW_DMA_TCDn_CITER_ELINKYES_WR(x, n, HW_DMA_TCDn_CITER_ELINKYES_RD(x, n) |  (v)))
#define HW_DMA_TCDn_CITER_ELINKYES_CLR(x, n, v) (HW_DMA_TCDn_CITER_ELINKYES_WR(x, n, HW_DMA_TCDn_CITER_ELINKYES_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_CITER_ELINKYES_TOG(x, n, v) (HW_DMA_TCDn_CITER_ELINKYES_WR(x, n, HW_DMA_TCDn_CITER_ELINKYES_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCDn_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations
 * (e.g., final source and destination address calculations), optionally generating
 * an interrupt to signal channel completion before reloading the CITER field
 * from the beginning iteration count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that contained in
 * the BITER field. If the channel is configured to execute a single service
 * request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
#define BP_DMA_TCDn_CITER_ELINKYES_CITER (0U) /*!< Bit position for DMA_TCDn_CITER_ELINKYES_CITER. */
#define BM_DMA_TCDn_CITER_ELINKYES_CITER (0x01FFU) /*!< Bit mask for DMA_TCDn_CITER_ELINKYES_CITER. */
#define BS_DMA_TCDn_CITER_ELINKYES_CITER (9U) /*!< Bit field size in bits for DMA_TCDn_CITER_ELINKYES_CITER. */

/*! @brief Read current value of the DMA_TCDn_CITER_ELINKYES_CITER field. */
#define BR_DMA_TCDn_CITER_ELINKYES_CITER(x, n) (HW_DMA_TCDn_CITER_ELINKYES(x, n).B.CITER)

/*! @brief Format value for bitfield DMA_TCDn_CITER_ELINKYES_CITER. */
#define BF_DMA_TCDn_CITER_ELINKYES_CITER(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CITER_ELINKYES_CITER) & BM_DMA_TCDn_CITER_ELINKYES_CITER)

/*! @brief Set the CITER field to a new value. */
#define BW_DMA_TCDn_CITER_ELINKYES_CITER(x, n, v) (HW_DMA_TCDn_CITER_ELINKYES_WR(x, n, (HW_DMA_TCDn_CITER_ELINKYES_RD(x, n) & ~BM_DMA_TCDn_CITER_ELINKYES_CITER) | BF_DMA_TCDn_CITER_ELINKYES_CITER(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by these four bits by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
#define BP_DMA_TCDn_CITER_ELINKYES_LINKCH (9U) /*!< Bit position for DMA_TCDn_CITER_ELINKYES_LINKCH. */
#define BM_DMA_TCDn_CITER_ELINKYES_LINKCH (0x1E00U) /*!< Bit mask for DMA_TCDn_CITER_ELINKYES_LINKCH. */
#define BS_DMA_TCDn_CITER_ELINKYES_LINKCH (4U) /*!< Bit field size in bits for DMA_TCDn_CITER_ELINKYES_LINKCH. */

/*! @brief Read current value of the DMA_TCDn_CITER_ELINKYES_LINKCH field. */
#define BR_DMA_TCDn_CITER_ELINKYES_LINKCH(x, n) (HW_DMA_TCDn_CITER_ELINKYES(x, n).B.LINKCH)

/*! @brief Format value for bitfield DMA_TCDn_CITER_ELINKYES_LINKCH. */
#define BF_DMA_TCDn_CITER_ELINKYES_LINKCH(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CITER_ELINKYES_LINKCH) & BM_DMA_TCDn_CITER_ELINKYES_LINKCH)

/*! @brief Set the LINKCH field to a new value. */
#define BW_DMA_TCDn_CITER_ELINKYES_LINKCH(x, n, v) (HW_DMA_TCDn_CITER_ELINKYES_WR(x, n, (HW_DMA_TCDn_CITER_ELINKYES_RD(x, n) & ~BM_DMA_TCDn_CITER_ELINKYES_LINKCH) | BF_DMA_TCDn_CITER_ELINKYES_LINKCH(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
#define BP_DMA_TCDn_CITER_ELINKYES_ELINK (15U) /*!< Bit position for DMA_TCDn_CITER_ELINKYES_ELINK. */
#define BM_DMA_TCDn_CITER_ELINKYES_ELINK (0x8000U) /*!< Bit mask for DMA_TCDn_CITER_ELINKYES_ELINK. */
#define BS_DMA_TCDn_CITER_ELINKYES_ELINK (1U) /*!< Bit field size in bits for DMA_TCDn_CITER_ELINKYES_ELINK. */

/*! @brief Read current value of the DMA_TCDn_CITER_ELINKYES_ELINK field. */
#define BR_DMA_TCDn_CITER_ELINKYES_ELINK(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_CITER_ELINKYES_ADDR(x, n), BP_DMA_TCDn_CITER_ELINKYES_ELINK))

/*! @brief Format value for bitfield DMA_TCDn_CITER_ELINKYES_ELINK. */
#define BF_DMA_TCDn_CITER_ELINKYES_ELINK(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CITER_ELINKYES_ELINK) & BM_DMA_TCDn_CITER_ELINKYES_ELINK)

/*! @brief Set the ELINK field to a new value. */
#define BW_DMA_TCDn_CITER_ELINKYES_ELINK(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_CITER_ELINKYES_ADDR(x, n), BP_DMA_TCDn_CITER_ELINKYES_ELINK) = (v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_dma_tcdn_dlastsga
{
    uint32_t U;
    struct _hw_dma_tcdn_dlastsga_bitfields
    {
        uint32_t DLASTSGA : 32;        /*!< [31:0]  */
    } B;
} hw_dma_tcdn_dlastsga_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_DLASTSGA register
 */
/*@{*/
#define HW_DMA_TCDn_DLASTSGA_COUNT (16U)

#define HW_DMA_TCDn_DLASTSGA_ADDR(x, n) ((uint32_t)(x) + 0x1018U + (0x20U * (n)))

#define HW_DMA_TCDn_DLASTSGA(x, n) (*(__IO hw_dma_tcdn_dlastsga_t *) HW_DMA_TCDn_DLASTSGA_ADDR(x, n))
#define HW_DMA_TCDn_DLASTSGA_RD(x, n) (HW_DMA_TCDn_DLASTSGA(x, n).U)
#define HW_DMA_TCDn_DLASTSGA_WR(x, n, v) (HW_DMA_TCDn_DLASTSGA(x, n).U = (v))
#define HW_DMA_TCDn_DLASTSGA_SET(x, n, v) (HW_DMA_TCDn_DLASTSGA_WR(x, n, HW_DMA_TCDn_DLASTSGA_RD(x, n) |  (v)))
#define HW_DMA_TCDn_DLASTSGA_CLR(x, n, v) (HW_DMA_TCDn_DLASTSGA_WR(x, n, HW_DMA_TCDn_DLASTSGA_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_DLASTSGA_TOG(x, n, v) (HW_DMA_TCDn_DLASTSGA_WR(x, n, HW_DMA_TCDn_DLASTSGA_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_DLASTSGA bitfields
 */

/*!
 * @name Register DMA_TCDn_DLASTSGA, field DLASTSGA[31:0] (RW)
 *
 * Destination last address adjustment or the memory address for the next
 * transfer control descriptor to be loaded into this channel (scatter/gather). If
 * (TCDn_CSR[ESG] = 0), then: Adjustment value added to the destination address at
 * the completion of the major iteration count. This value can apply to restore the
 * destination address to the initial value or adjust the address to reference
 * the next data structure. This field uses two's complement notation for the
 * final destination address adjustment. Otherwise: This address points to the
 * beginning of a 0-modulo-32-byte region containing the next transfer control
 * descriptor to be loaded into this channel. This channel reload is performed as the
 * major iteration count completes. The scatter/gather address must be
 * 0-modulo-32-byte, else a configuration error is reported.
 */
/*@{*/
#define BP_DMA_TCDn_DLASTSGA_DLASTSGA (0U) /*!< Bit position for DMA_TCDn_DLASTSGA_DLASTSGA. */
#define BM_DMA_TCDn_DLASTSGA_DLASTSGA (0xFFFFFFFFU) /*!< Bit mask for DMA_TCDn_DLASTSGA_DLASTSGA. */
#define BS_DMA_TCDn_DLASTSGA_DLASTSGA (32U) /*!< Bit field size in bits for DMA_TCDn_DLASTSGA_DLASTSGA. */

/*! @brief Read current value of the DMA_TCDn_DLASTSGA_DLASTSGA field. */
#define BR_DMA_TCDn_DLASTSGA_DLASTSGA(x, n) (HW_DMA_TCDn_DLASTSGA(x, n).U)

/*! @brief Format value for bitfield DMA_TCDn_DLASTSGA_DLASTSGA. */
#define BF_DMA_TCDn_DLASTSGA_DLASTSGA(v) ((uint32_t)((uint32_t)(v) << BP_DMA_TCDn_DLASTSGA_DLASTSGA) & BM_DMA_TCDn_DLASTSGA_DLASTSGA)

/*! @brief Set the DLASTSGA field to a new value. */
#define BW_DMA_TCDn_DLASTSGA_DLASTSGA(x, n, v) (HW_DMA_TCDn_DLASTSGA_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_dma_tcdn_csr
{
    uint16_t U;
    struct _hw_dma_tcdn_csr_bitfields
    {
        uint16_t START : 1;            /*!< [0] Channel Start */
        uint16_t INTMAJOR : 1;         /*!< [1] Enable an interrupt when major
                                        * iteration count completes */
        uint16_t INTHALF : 1;          /*!< [2] Enable an interrupt when major counter
                                        * is half complete. */
        uint16_t DREQ : 1;             /*!< [3] Disable Request */
        uint16_t ESG : 1;              /*!< [4] Enable Scatter/Gather Processing */
        uint16_t MAJORELINK : 1;       /*!< [5] Enable channel-to-channel linking
                                        * on major loop complete */
        uint16_t ACTIVE : 1;           /*!< [6] Channel Active */
        uint16_t DONE : 1;             /*!< [7] Channel Done */
        uint16_t MAJORLINKCH : 4;      /*!< [11:8] Link Channel Number */
        uint16_t RESERVED0 : 2;        /*!< [13:12]  */
        uint16_t BWC : 2;              /*!< [15:14] Bandwidth Control */
    } B;
} hw_dma_tcdn_csr_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_CSR register
 */
/*@{*/
#define HW_DMA_TCDn_CSR_COUNT (16U)

#define HW_DMA_TCDn_CSR_ADDR(x, n) ((uint32_t)(x) + 0x101CU + (0x20U * (n)))

#define HW_DMA_TCDn_CSR(x, n)    (*(__IO hw_dma_tcdn_csr_t *) HW_DMA_TCDn_CSR_ADDR(x, n))
#define HW_DMA_TCDn_CSR_RD(x, n) (HW_DMA_TCDn_CSR(x, n).U)
#define HW_DMA_TCDn_CSR_WR(x, n, v) (HW_DMA_TCDn_CSR(x, n).U = (v))
#define HW_DMA_TCDn_CSR_SET(x, n, v) (HW_DMA_TCDn_CSR_WR(x, n, HW_DMA_TCDn_CSR_RD(x, n) |  (v)))
#define HW_DMA_TCDn_CSR_CLR(x, n, v) (HW_DMA_TCDn_CSR_WR(x, n, HW_DMA_TCDn_CSR_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_CSR_TOG(x, n, v) (HW_DMA_TCDn_CSR_WR(x, n, HW_DMA_TCDn_CSR_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_CSR bitfields
 */

/*!
 * @name Register DMA_TCDn_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0 - The channel is not explicitly started
 * - 1 - The channel is explicitly started via a software initiated service
 *     request
 */
/*@{*/
#define BP_DMA_TCDn_CSR_START (0U)         /*!< Bit position for DMA_TCDn_CSR_START. */
#define BM_DMA_TCDn_CSR_START (0x0001U)    /*!< Bit mask for DMA_TCDn_CSR_START. */
#define BS_DMA_TCDn_CSR_START (1U)         /*!< Bit field size in bits for DMA_TCDn_CSR_START. */

/*! @brief Read current value of the DMA_TCDn_CSR_START field. */
#define BR_DMA_TCDn_CSR_START(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_START))

/*! @brief Format value for bitfield DMA_TCDn_CSR_START. */
#define BF_DMA_TCDn_CSR_START(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CSR_START) & BM_DMA_TCDn_CSR_START)

/*! @brief Set the START field to a new value. */
#define BW_DMA_TCDn_CSR_START(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_START) = (v))
/*@}*/

/*!
 * @name Register DMA_TCDn_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled
 * - 1 - The end-of-major loop interrupt is enabled
 */
/*@{*/
#define BP_DMA_TCDn_CSR_INTMAJOR (1U)      /*!< Bit position for DMA_TCDn_CSR_INTMAJOR. */
#define BM_DMA_TCDn_CSR_INTMAJOR (0x0002U) /*!< Bit mask for DMA_TCDn_CSR_INTMAJOR. */
#define BS_DMA_TCDn_CSR_INTMAJOR (1U)      /*!< Bit field size in bits for DMA_TCDn_CSR_INTMAJOR. */

/*! @brief Read current value of the DMA_TCDn_CSR_INTMAJOR field. */
#define BR_DMA_TCDn_CSR_INTMAJOR(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_INTMAJOR))

/*! @brief Format value for bitfield DMA_TCDn_CSR_INTMAJOR. */
#define BF_DMA_TCDn_CSR_INTMAJOR(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CSR_INTMAJOR) & BM_DMA_TCDn_CSR_INTMAJOR)

/*! @brief Set the INTMAJOR field to a new value. */
#define BW_DMA_TCDn_CSR_INTMAJOR(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_INTMAJOR) = (v))
/*@}*/

/*!
 * @name Register DMA_TCDn_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered (aka ping-pong) schemes or other types of data
 * movement where the processor needs an early indication of the transfer's
 * progress. If BITER is set, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled
 * - 1 - The half-point interrupt is enabled
 */
/*@{*/
#define BP_DMA_TCDn_CSR_INTHALF (2U)       /*!< Bit position for DMA_TCDn_CSR_INTHALF. */
#define BM_DMA_TCDn_CSR_INTHALF (0x0004U)  /*!< Bit mask for DMA_TCDn_CSR_INTHALF. */
#define BS_DMA_TCDn_CSR_INTHALF (1U)       /*!< Bit field size in bits for DMA_TCDn_CSR_INTHALF. */

/*! @brief Read current value of the DMA_TCDn_CSR_INTHALF field. */
#define BR_DMA_TCDn_CSR_INTHALF(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_INTHALF))

/*! @brief Format value for bitfield DMA_TCDn_CSR_INTHALF. */
#define BF_DMA_TCDn_CSR_INTHALF(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CSR_INTHALF) & BM_DMA_TCDn_CSR_INTHALF)

/*! @brief Set the INTHALF field to a new value. */
#define BW_DMA_TCDn_CSR_INTHALF(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_INTHALF) = (v))
/*@}*/

/*!
 * @name Register DMA_TCDn_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channel's ERQ bit is not affected
 * - 1 - The channel's ERQ bit is cleared when the major loop is complete
 */
/*@{*/
#define BP_DMA_TCDn_CSR_DREQ (3U)          /*!< Bit position for DMA_TCDn_CSR_DREQ. */
#define BM_DMA_TCDn_CSR_DREQ (0x0008U)     /*!< Bit mask for DMA_TCDn_CSR_DREQ. */
#define BS_DMA_TCDn_CSR_DREQ (1U)          /*!< Bit field size in bits for DMA_TCDn_CSR_DREQ. */

/*! @brief Read current value of the DMA_TCDn_CSR_DREQ field. */
#define BR_DMA_TCDn_CSR_DREQ(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_DREQ))

/*! @brief Format value for bitfield DMA_TCDn_CSR_DREQ. */
#define BF_DMA_TCDn_CSR_DREQ(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CSR_DREQ) & BM_DMA_TCDn_CSR_DREQ)

/*! @brief Set the DREQ field to a new value. */
#define BW_DMA_TCDn_CSR_DREQ(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_DREQ) = (v))
/*@}*/

/*!
 * @name Register DMA_TCDn_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channel's TCD is normal format.
 * - 1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into this
 *     channel after the major loop completes its execution.
 */
/*@{*/
#define BP_DMA_TCDn_CSR_ESG  (4U)          /*!< Bit position for DMA_TCDn_CSR_ESG. */
#define BM_DMA_TCDn_CSR_ESG  (0x0010U)     /*!< Bit mask for DMA_TCDn_CSR_ESG. */
#define BS_DMA_TCDn_CSR_ESG  (1U)          /*!< Bit field size in bits for DMA_TCDn_CSR_ESG. */

/*! @brief Read current value of the DMA_TCDn_CSR_ESG field. */
#define BR_DMA_TCDn_CSR_ESG(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_ESG))

/*! @brief Format value for bitfield DMA_TCDn_CSR_ESG. */
#define BF_DMA_TCDn_CSR_ESG(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CSR_ESG) & BM_DMA_TCDn_CSR_ESG)

/*! @brief Set the ESG field to a new value. */
#define BW_DMA_TCDn_CSR_ESG(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_ESG) = (v))
/*@}*/

/*!
 * @name Register DMA_TCDn_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
#define BP_DMA_TCDn_CSR_MAJORELINK (5U)    /*!< Bit position for DMA_TCDn_CSR_MAJORELINK. */
#define BM_DMA_TCDn_CSR_MAJORELINK (0x0020U) /*!< Bit mask for DMA_TCDn_CSR_MAJORELINK. */
#define BS_DMA_TCDn_CSR_MAJORELINK (1U)    /*!< Bit field size in bits for DMA_TCDn_CSR_MAJORELINK. */

/*! @brief Read current value of the DMA_TCDn_CSR_MAJORELINK field. */
#define BR_DMA_TCDn_CSR_MAJORELINK(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_MAJORELINK))

/*! @brief Format value for bitfield DMA_TCDn_CSR_MAJORELINK. */
#define BF_DMA_TCDn_CSR_MAJORELINK(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CSR_MAJORELINK) & BM_DMA_TCDn_CSR_MAJORELINK)

/*! @brief Set the MAJORELINK field to a new value. */
#define BW_DMA_TCDn_CSR_MAJORELINK(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_MAJORELINK) = (v))
/*@}*/

/*!
 * @name Register DMA_TCDn_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and the eDMA clears it as the minor loop completes or if
 * any error condition is detected. This bit resets to zero.
 */
/*@{*/
#define BP_DMA_TCDn_CSR_ACTIVE (6U)        /*!< Bit position for DMA_TCDn_CSR_ACTIVE. */
#define BM_DMA_TCDn_CSR_ACTIVE (0x0040U)   /*!< Bit mask for DMA_TCDn_CSR_ACTIVE. */
#define BS_DMA_TCDn_CSR_ACTIVE (1U)        /*!< Bit field size in bits for DMA_TCDn_CSR_ACTIVE. */

/*! @brief Read current value of the DMA_TCDn_CSR_ACTIVE field. */
#define BR_DMA_TCDn_CSR_ACTIVE(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_ACTIVE))

/*! @brief Format value for bitfield DMA_TCDn_CSR_ACTIVE. */
#define BF_DMA_TCDn_CSR_ACTIVE(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CSR_ACTIVE) & BM_DMA_TCDn_CSR_ACTIVE)

/*! @brief Set the ACTIVE field to a new value. */
#define BW_DMA_TCDn_CSR_ACTIVE(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_ACTIVE) = (v))
/*@}*/

/*!
 * @name Register DMA_TCDn_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero; The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
#define BP_DMA_TCDn_CSR_DONE (7U)          /*!< Bit position for DMA_TCDn_CSR_DONE. */
#define BM_DMA_TCDn_CSR_DONE (0x0080U)     /*!< Bit mask for DMA_TCDn_CSR_DONE. */
#define BS_DMA_TCDn_CSR_DONE (1U)          /*!< Bit field size in bits for DMA_TCDn_CSR_DONE. */

/*! @brief Read current value of the DMA_TCDn_CSR_DONE field. */
#define BR_DMA_TCDn_CSR_DONE(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_DONE))

/*! @brief Format value for bitfield DMA_TCDn_CSR_DONE. */
#define BF_DMA_TCDn_CSR_DONE(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CSR_DONE) & BM_DMA_TCDn_CSR_DONE)

/*! @brief Set the DONE field to a new value. */
#define BW_DMA_TCDn_CSR_DONE(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_CSR_ADDR(x, n), BP_DMA_TCDn_CSR_DONE) = (v))
/*@}*/

/*!
 * @name Register DMA_TCDn_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then No channel-to-channel linking (or chaining) is
 * performed after the major loop counter is exhausted. else After the major loop
 * counter is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by these six bits by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
#define BP_DMA_TCDn_CSR_MAJORLINKCH (8U)   /*!< Bit position for DMA_TCDn_CSR_MAJORLINKCH. */
#define BM_DMA_TCDn_CSR_MAJORLINKCH (0x0F00U) /*!< Bit mask for DMA_TCDn_CSR_MAJORLINKCH. */
#define BS_DMA_TCDn_CSR_MAJORLINKCH (4U)   /*!< Bit field size in bits for DMA_TCDn_CSR_MAJORLINKCH. */

/*! @brief Read current value of the DMA_TCDn_CSR_MAJORLINKCH field. */
#define BR_DMA_TCDn_CSR_MAJORLINKCH(x, n) (HW_DMA_TCDn_CSR(x, n).B.MAJORLINKCH)

/*! @brief Format value for bitfield DMA_TCDn_CSR_MAJORLINKCH. */
#define BF_DMA_TCDn_CSR_MAJORLINKCH(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CSR_MAJORLINKCH) & BM_DMA_TCDn_CSR_MAJORLINKCH)

/*! @brief Set the MAJORLINKCH field to a new value. */
#define BW_DMA_TCDn_CSR_MAJORLINKCH(x, n, v) (HW_DMA_TCDn_CSR_WR(x, n, (HW_DMA_TCDn_CSR_RD(x, n) & ~BM_DMA_TCDn_CSR_MAJORLINKCH) | BF_DMA_TCDn_CSR_MAJORLINKCH(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. In general, as
 * the eDMA processes the minor loop, it continuously generates read/write
 * sequences until the minor count is exhausted. This field forces the eDMA to stall
 * after the completion of each read/write access to control the bus request
 * bandwidth seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the
 * last write of each minor loop. This behavior is a side effect of reducing
 * start-up latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each r/w
 * - 11 - eDMA engine stalls for 8 cycles after each r/w
 */
/*@{*/
#define BP_DMA_TCDn_CSR_BWC  (14U)         /*!< Bit position for DMA_TCDn_CSR_BWC. */
#define BM_DMA_TCDn_CSR_BWC  (0xC000U)     /*!< Bit mask for DMA_TCDn_CSR_BWC. */
#define BS_DMA_TCDn_CSR_BWC  (2U)          /*!< Bit field size in bits for DMA_TCDn_CSR_BWC. */

/*! @brief Read current value of the DMA_TCDn_CSR_BWC field. */
#define BR_DMA_TCDn_CSR_BWC(x, n) (HW_DMA_TCDn_CSR(x, n).B.BWC)

/*! @brief Format value for bitfield DMA_TCDn_CSR_BWC. */
#define BF_DMA_TCDn_CSR_BWC(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_CSR_BWC) & BM_DMA_TCDn_CSR_BWC)

/*! @brief Set the BWC field to a new value. */
#define BW_DMA_TCDn_CSR_BWC(x, n, v) (HW_DMA_TCDn_CSR_WR(x, n, (HW_DMA_TCDn_CSR_RD(x, n) & ~BM_DMA_TCDn_CSR_BWC) | BF_DMA_TCDn_CSR_BWC(v)))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
typedef union _hw_dma_tcdn_biter_elinkno
{
    uint16_t U;
    struct _hw_dma_tcdn_biter_elinkno_bitfields
    {
        uint16_t BITER : 15;           /*!< [14:0] Starting Major Iteration Count */
        uint16_t ELINK : 1;            /*!< [15] Enables channel-to-channel linking on
                                        * minor loop complete */
    } B;
} hw_dma_tcdn_biter_elinkno_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_BITER_ELINKNO register
 */
/*@{*/
#define HW_DMA_TCDn_BITER_ELINKNO_COUNT (16U)

#define HW_DMA_TCDn_BITER_ELINKNO_ADDR(x, n) ((uint32_t)(x) + 0x101EU + (0x20U * (n)))

#define HW_DMA_TCDn_BITER_ELINKNO(x, n) (*(__IO hw_dma_tcdn_biter_elinkno_t *) HW_DMA_TCDn_BITER_ELINKNO_ADDR(x, n))
#define HW_DMA_TCDn_BITER_ELINKNO_RD(x, n) (HW_DMA_TCDn_BITER_ELINKNO(x, n).U)
#define HW_DMA_TCDn_BITER_ELINKNO_WR(x, n, v) (HW_DMA_TCDn_BITER_ELINKNO(x, n).U = (v))
#define HW_DMA_TCDn_BITER_ELINKNO_SET(x, n, v) (HW_DMA_TCDn_BITER_ELINKNO_WR(x, n, HW_DMA_TCDn_BITER_ELINKNO_RD(x, n) |  (v)))
#define HW_DMA_TCDn_BITER_ELINKNO_CLR(x, n, v) (HW_DMA_TCDn_BITER_ELINKNO_WR(x, n, HW_DMA_TCDn_BITER_ELINKNO_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_BITER_ELINKNO_TOG(x, n, v) (HW_DMA_TCDn_BITER_ELINKNO_WR(x, n, HW_DMA_TCDn_BITER_ELINKNO_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCDn_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
#define BP_DMA_TCDn_BITER_ELINKNO_BITER (0U) /*!< Bit position for DMA_TCDn_BITER_ELINKNO_BITER. */
#define BM_DMA_TCDn_BITER_ELINKNO_BITER (0x7FFFU) /*!< Bit mask for DMA_TCDn_BITER_ELINKNO_BITER. */
#define BS_DMA_TCDn_BITER_ELINKNO_BITER (15U) /*!< Bit field size in bits for DMA_TCDn_BITER_ELINKNO_BITER. */

/*! @brief Read current value of the DMA_TCDn_BITER_ELINKNO_BITER field. */
#define BR_DMA_TCDn_BITER_ELINKNO_BITER(x, n) (HW_DMA_TCDn_BITER_ELINKNO(x, n).B.BITER)

/*! @brief Format value for bitfield DMA_TCDn_BITER_ELINKNO_BITER. */
#define BF_DMA_TCDn_BITER_ELINKNO_BITER(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_BITER_ELINKNO_BITER) & BM_DMA_TCDn_BITER_ELINKNO_BITER)

/*! @brief Set the BITER field to a new value. */
#define BW_DMA_TCDn_BITER_ELINKNO_BITER(x, n, v) (HW_DMA_TCDn_BITER_ELINKNO_WR(x, n, (HW_DMA_TCDn_BITER_ELINKNO_RD(x, n) & ~BM_DMA_TCDn_BITER_ELINKNO_BITER) | BF_DMA_TCDn_BITER_ELINKNO_BITER(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded
 * into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
#define BP_DMA_TCDn_BITER_ELINKNO_ELINK (15U) /*!< Bit position for DMA_TCDn_BITER_ELINKNO_ELINK. */
#define BM_DMA_TCDn_BITER_ELINKNO_ELINK (0x8000U) /*!< Bit mask for DMA_TCDn_BITER_ELINKNO_ELINK. */
#define BS_DMA_TCDn_BITER_ELINKNO_ELINK (1U) /*!< Bit field size in bits for DMA_TCDn_BITER_ELINKNO_ELINK. */

/*! @brief Read current value of the DMA_TCDn_BITER_ELINKNO_ELINK field. */
#define BR_DMA_TCDn_BITER_ELINKNO_ELINK(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_BITER_ELINKNO_ADDR(x, n), BP_DMA_TCDn_BITER_ELINKNO_ELINK))

/*! @brief Format value for bitfield DMA_TCDn_BITER_ELINKNO_ELINK. */
#define BF_DMA_TCDn_BITER_ELINKNO_ELINK(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_BITER_ELINKNO_ELINK) & BM_DMA_TCDn_BITER_ELINKNO_ELINK)

/*! @brief Set the ELINK field to a new value. */
#define BW_DMA_TCDn_BITER_ELINKNO_ELINK(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_BITER_ELINKNO_ADDR(x, n), BP_DMA_TCDn_BITER_ELINKNO_ELINK) = (v))
/*@}*/
/*******************************************************************************
 * HW_DMA_TCDn_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief HW_DMA_TCDn_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
typedef union _hw_dma_tcdn_biter_elinkyes
{
    uint16_t U;
    struct _hw_dma_tcdn_biter_elinkyes_bitfields
    {
        uint16_t BITER : 9;            /*!< [8:0] Starting Major Iteration Count */
        uint16_t LINKCH : 4;           /*!< [12:9] Link Channel Number */
        uint16_t RESERVED0 : 2;        /*!< [14:13]  */
        uint16_t ELINK : 1;            /*!< [15] Enables channel-to-channel linking on
                                        * minor loop complete */
    } B;
} hw_dma_tcdn_biter_elinkyes_t;

/*!
 * @name Constants and macros for entire DMA_TCDn_BITER_ELINKYES register
 */
/*@{*/
#define HW_DMA_TCDn_BITER_ELINKYES_COUNT (16U)

#define HW_DMA_TCDn_BITER_ELINKYES_ADDR(x, n) ((uint32_t)(x) + 0x101EU + (0x20U * (n)))

#define HW_DMA_TCDn_BITER_ELINKYES(x, n) (*(__IO hw_dma_tcdn_biter_elinkyes_t *) HW_DMA_TCDn_BITER_ELINKYES_ADDR(x, n))
#define HW_DMA_TCDn_BITER_ELINKYES_RD(x, n) (HW_DMA_TCDn_BITER_ELINKYES(x, n).U)
#define HW_DMA_TCDn_BITER_ELINKYES_WR(x, n, v) (HW_DMA_TCDn_BITER_ELINKYES(x, n).U = (v))
#define HW_DMA_TCDn_BITER_ELINKYES_SET(x, n, v) (HW_DMA_TCDn_BITER_ELINKYES_WR(x, n, HW_DMA_TCDn_BITER_ELINKYES_RD(x, n) |  (v)))
#define HW_DMA_TCDn_BITER_ELINKYES_CLR(x, n, v) (HW_DMA_TCDn_BITER_ELINKYES_WR(x, n, HW_DMA_TCDn_BITER_ELINKYES_RD(x, n) & ~(v)))
#define HW_DMA_TCDn_BITER_ELINKYES_TOG(x, n, v) (HW_DMA_TCDn_BITER_ELINKYES_WR(x, n, HW_DMA_TCDn_BITER_ELINKYES_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCDn_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCDn_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
#define BP_DMA_TCDn_BITER_ELINKYES_BITER (0U) /*!< Bit position for DMA_TCDn_BITER_ELINKYES_BITER. */
#define BM_DMA_TCDn_BITER_ELINKYES_BITER (0x01FFU) /*!< Bit mask for DMA_TCDn_BITER_ELINKYES_BITER. */
#define BS_DMA_TCDn_BITER_ELINKYES_BITER (9U) /*!< Bit field size in bits for DMA_TCDn_BITER_ELINKYES_BITER. */

/*! @brief Read current value of the DMA_TCDn_BITER_ELINKYES_BITER field. */
#define BR_DMA_TCDn_BITER_ELINKYES_BITER(x, n) (HW_DMA_TCDn_BITER_ELINKYES(x, n).B.BITER)

/*! @brief Format value for bitfield DMA_TCDn_BITER_ELINKYES_BITER. */
#define BF_DMA_TCDn_BITER_ELINKYES_BITER(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_BITER_ELINKYES_BITER) & BM_DMA_TCDn_BITER_ELINKYES_BITER)

/*! @brief Set the BITER field to a new value. */
#define BW_DMA_TCDn_BITER_ELINKYES_BITER(x, n, v) (HW_DMA_TCDn_BITER_ELINKYES_WR(x, n, (HW_DMA_TCDn_BITER_ELINKYES_RD(x, n) & ~BM_DMA_TCDn_BITER_ELINKYES_BITER) | BF_DMA_TCDn_BITER_ELINKYES_BITER(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by these four bits by setting that channel's TCDn_CSR[START]
 * bit. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field is reloaded into the
 * CITER field.
 */
/*@{*/
#define BP_DMA_TCDn_BITER_ELINKYES_LINKCH (9U) /*!< Bit position for DMA_TCDn_BITER_ELINKYES_LINKCH. */
#define BM_DMA_TCDn_BITER_ELINKYES_LINKCH (0x1E00U) /*!< Bit mask for DMA_TCDn_BITER_ELINKYES_LINKCH. */
#define BS_DMA_TCDn_BITER_ELINKYES_LINKCH (4U) /*!< Bit field size in bits for DMA_TCDn_BITER_ELINKYES_LINKCH. */

/*! @brief Read current value of the DMA_TCDn_BITER_ELINKYES_LINKCH field. */
#define BR_DMA_TCDn_BITER_ELINKYES_LINKCH(x, n) (HW_DMA_TCDn_BITER_ELINKYES(x, n).B.LINKCH)

/*! @brief Format value for bitfield DMA_TCDn_BITER_ELINKYES_LINKCH. */
#define BF_DMA_TCDn_BITER_ELINKYES_LINKCH(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_BITER_ELINKYES_LINKCH) & BM_DMA_TCDn_BITER_ELINKYES_LINKCH)

/*! @brief Set the LINKCH field to a new value. */
#define BW_DMA_TCDn_BITER_ELINKYES_LINKCH(x, n, v) (HW_DMA_TCDn_BITER_ELINKYES_WR(x, n, (HW_DMA_TCDn_BITER_ELINKYES_RD(x, n) & ~BM_DMA_TCDn_BITER_ELINKYES_LINKCH) | BF_DMA_TCDn_BITER_ELINKYES_LINKCH(v)))
/*@}*/

/*!
 * @name Register DMA_TCDn_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field is reloaded into
 * the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
#define BP_DMA_TCDn_BITER_ELINKYES_ELINK (15U) /*!< Bit position for DMA_TCDn_BITER_ELINKYES_ELINK. */
#define BM_DMA_TCDn_BITER_ELINKYES_ELINK (0x8000U) /*!< Bit mask for DMA_TCDn_BITER_ELINKYES_ELINK. */
#define BS_DMA_TCDn_BITER_ELINKYES_ELINK (1U) /*!< Bit field size in bits for DMA_TCDn_BITER_ELINKYES_ELINK. */

/*! @brief Read current value of the DMA_TCDn_BITER_ELINKYES_ELINK field. */
#define BR_DMA_TCDn_BITER_ELINKYES_ELINK(x, n) (BITBAND_ACCESS16(HW_DMA_TCDn_BITER_ELINKYES_ADDR(x, n), BP_DMA_TCDn_BITER_ELINKYES_ELINK))

/*! @brief Format value for bitfield DMA_TCDn_BITER_ELINKYES_ELINK. */
#define BF_DMA_TCDn_BITER_ELINKYES_ELINK(v) ((uint16_t)((uint16_t)(v) << BP_DMA_TCDn_BITER_ELINKYES_ELINK) & BM_DMA_TCDn_BITER_ELINKYES_ELINK)

/*! @brief Set the ELINK field to a new value. */
#define BW_DMA_TCDn_BITER_ELINKYES_ELINK(x, n, v) (BITBAND_ACCESS16(HW_DMA_TCDn_BITER_ELINKYES_ADDR(x, n), BP_DMA_TCDn_BITER_ELINKYES_ELINK) = (v))
/*@}*/

/*
** Start of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma push
  #pragma anon_unions
#elif defined(__CWCC__)
  #pragma push
  #pragma cpp_extensions on
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=extended
#else
  #error Not supported compiler type
#endif

/*******************************************************************************
 * hw_dma_t - module struct
 ******************************************************************************/
/*!
 * @brief All DMA module registers.
 */
#pragma pack(1)
typedef struct _hw_dma
{
    __IO hw_dma_cr_t CR;                   /*!< [0x0] Control Register */
    __I hw_dma_es_t ES;                    /*!< [0x4] Error Status Register */
    uint8_t _reserved0[4];
    __IO hw_dma_erq_t ERQ;                 /*!< [0xC] Enable Request Register */
    uint8_t _reserved1[4];
    __IO hw_dma_eei_t EEI;                 /*!< [0x14] Enable Error Interrupt Register */
    __O hw_dma_ceei_t CEEI;                /*!< [0x18] Clear Enable Error Interrupt Register */
    __O hw_dma_seei_t SEEI;                /*!< [0x19] Set Enable Error Interrupt Register */
    __O hw_dma_cerq_t CERQ;                /*!< [0x1A] Clear Enable Request Register */
    __O hw_dma_serq_t SERQ;                /*!< [0x1B] Set Enable Request Register */
    __O hw_dma_cdne_t CDNE;                /*!< [0x1C] Clear DONE Status Bit Register */
    __O hw_dma_ssrt_t SSRT;                /*!< [0x1D] Set START Bit Register */
    __O hw_dma_cerr_t CERR;                /*!< [0x1E] Clear Error Register */
    __O hw_dma_cint_t CINT;                /*!< [0x1F] Clear Interrupt Request Register */
    uint8_t _reserved2[4];
    __IO hw_dma_int_t INT;                 /*!< [0x24] Interrupt Request Register */
    uint8_t _reserved3[4];
    __IO hw_dma_err_t ERR;                 /*!< [0x2C] Error Register */
    uint8_t _reserved4[4];
    __I hw_dma_hrs_t HRS;                  /*!< [0x34] Hardware Request Status Register */
    uint8_t _reserved5[200];
    __IO hw_dma_dchprin_t DCHPRIn[16];     /*!< [0x100] Channel n Priority Register */
    uint8_t _reserved6[3824];
    struct {
        __IO hw_dma_tcdn_saddr_t TCDn_SADDR; /*!< [0x1000] TCD Source Address */
        __IO hw_dma_tcdn_soff_t TCDn_SOFF; /*!< [0x1004] TCD Signed Source Address Offset */
        __IO hw_dma_tcdn_attr_t TCDn_ATTR; /*!< [0x1006] TCD Transfer Attributes */
        union {
            __IO hw_dma_tcdn_nbytes_mlno_t TCDn_NBYTES_MLNO; /*!< [0x1008] TCD Minor Byte Count (Minor Loop Disabled) */
            __IO hw_dma_tcdn_nbytes_mloffno_t TCDn_NBYTES_MLOFFNO; /*!< [0x1008] TCD Signed Minor Loop Offset (Minor Loop Enabled and Offset Disabled) */
            __IO hw_dma_tcdn_nbytes_mloffyes_t TCDn_NBYTES_MLOFFYES; /*!< [0x1008] TCD Signed Minor Loop Offset (Minor Loop and Offset Enabled) */
        };
        __IO hw_dma_tcdn_slast_t TCDn_SLAST; /*!< [0x100C] TCD Last Source Address Adjustment */
        __IO hw_dma_tcdn_daddr_t TCDn_DADDR; /*!< [0x1010] TCD Destination Address */
        __IO hw_dma_tcdn_doff_t TCDn_DOFF; /*!< [0x1014] TCD Signed Destination Address Offset */
        union {
            __IO hw_dma_tcdn_citer_elinkno_t TCDn_CITER_ELINKNO; /*!< [0x1016] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) */
            __IO hw_dma_tcdn_citer_elinkyes_t TCDn_CITER_ELINKYES; /*!< [0x1016] TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) */
        };
        __IO hw_dma_tcdn_dlastsga_t TCDn_DLASTSGA; /*!< [0x1018] TCD Last Destination Address Adjustment/Scatter Gather Address */
        __IO hw_dma_tcdn_csr_t TCDn_CSR;   /*!< [0x101C] TCD Control and Status */
        union {
            __IO hw_dma_tcdn_biter_elinkno_t TCDn_BITER_ELINKNO; /*!< [0x101E] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) */
            __IO hw_dma_tcdn_biter_elinkyes_t TCDn_BITER_ELINKYES; /*!< [0x101E] TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) */
        };
    } TCD[16];
} hw_dma_t;
#pragma pack()

/*! @brief Macro to access all DMA registers. */
/*! @param x DMA module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_DMA_REGS(DMA_BASE)</code>. */
#define HW_DMA_REGS(x) (*(hw_dma_t *)(x))

/*
** End of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma pop
#elif defined(__CWCC__)
  #pragma pop
#elif defined(__GNUC__)
  /* leave anonymous unions enabled */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=default
#else
  #error Not supported compiler type
#endif

/*
 * MK64F12 DMAMUX
 *
 * DMA channel multiplexor
 *
 * Registers defined in this header file:
 * - HW_DMAMUX_CHCFGn - Channel Configuration register
 *
 * - hw_dmamux_t - Struct containing all module registers.
 */

#define HW_DMAMUX_INSTANCE_COUNT (1U) /*!< Number of instances of the DMAMUX module. */
#define HW_DMAMUX (0U) /*!< Instance number for DMAMUX. */

/*******************************************************************************
 * HW_DMAMUX_CHCFGn - Channel Configuration register
 ******************************************************************************/

/*!
 * @brief HW_DMAMUX_CHCFGn - Channel Configuration register (RW)
 *
 * Reset value: 0x00U
 *
 * Each of the DMA channels can be independently enabled/disabled and associated
 * with one of the DMA slots (peripheral slots or always-on slots) in the
 * system. Setting multiple CHCFG registers with the same source value will result in
 * unpredictable behavior. This is true, even if a channel is disabled (ENBL==0).
 * Before changing the trigger or source settings, a DMA channel must be disabled
 * via CHCFGn[ENBL].
 */
typedef union _hw_dmamux_chcfgn
{
    uint8_t U;
    struct _hw_dmamux_chcfgn_bitfields
    {
        uint8_t SOURCE : 6;            /*!< [5:0] DMA Channel Source (Slot) */
        uint8_t TRIG : 1;              /*!< [6] DMA Channel Trigger Enable */
        uint8_t ENBL : 1;              /*!< [7] DMA Channel Enable */
    } B;
} hw_dmamux_chcfgn_t;

/*!
 * @name Constants and macros for entire DMAMUX_CHCFGn register
 */
/*@{*/
#define HW_DMAMUX_CHCFGn_COUNT (16U)

#define HW_DMAMUX_CHCFGn_ADDR(x, n) ((uint32_t)(x) + 0x0U + (0x1U * (n)))

#define HW_DMAMUX_CHCFGn(x, n)   (*(__IO hw_dmamux_chcfgn_t *) HW_DMAMUX_CHCFGn_ADDR(x, n))
#define HW_DMAMUX_CHCFGn_RD(x, n) (HW_DMAMUX_CHCFGn(x, n).U)
#define HW_DMAMUX_CHCFGn_WR(x, n, v) (HW_DMAMUX_CHCFGn(x, n).U = (v))
#define HW_DMAMUX_CHCFGn_SET(x, n, v) (HW_DMAMUX_CHCFGn_WR(x, n, HW_DMAMUX_CHCFGn_RD(x, n) |  (v)))
#define HW_DMAMUX_CHCFGn_CLR(x, n, v) (HW_DMAMUX_CHCFGn_WR(x, n, HW_DMAMUX_CHCFGn_RD(x, n) & ~(v)))
#define HW_DMAMUX_CHCFGn_TOG(x, n, v) (HW_DMAMUX_CHCFGn_WR(x, n, HW_DMAMUX_CHCFGn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual DMAMUX_CHCFGn bitfields
 */

/*!
 * @name Register DMAMUX_CHCFGn, field SOURCE[5:0] (RW)
 *
 * Specifies which DMA source, if any, is routed to a particular DMA channel.
 * See your device's chip configuration details for information about the
 * peripherals and their slot numbers.
 */
/*@{*/
#define BP_DMAMUX_CHCFGn_SOURCE (0U)       /*!< Bit position for DMAMUX_CHCFGn_SOURCE. */
#define BM_DMAMUX_CHCFGn_SOURCE (0x3FU)    /*!< Bit mask for DMAMUX_CHCFGn_SOURCE. */
#define BS_DMAMUX_CHCFGn_SOURCE (6U)       /*!< Bit field size in bits for DMAMUX_CHCFGn_SOURCE. */

/*! @brief Read current value of the DMAMUX_CHCFGn_SOURCE field. */
#define BR_DMAMUX_CHCFGn_SOURCE(x, n) (HW_DMAMUX_CHCFGn(x, n).B.SOURCE)

/*! @brief Format value for bitfield DMAMUX_CHCFGn_SOURCE. */
#define BF_DMAMUX_CHCFGn_SOURCE(v) ((uint8_t)((uint8_t)(v) << BP_DMAMUX_CHCFGn_SOURCE) & BM_DMAMUX_CHCFGn_SOURCE)

/*! @brief Set the SOURCE field to a new value. */
#define BW_DMAMUX_CHCFGn_SOURCE(x, n, v) (HW_DMAMUX_CHCFGn_WR(x, n, (HW_DMAMUX_CHCFGn_RD(x, n) & ~BM_DMAMUX_CHCFGn_SOURCE) | BF_DMAMUX_CHCFGn_SOURCE(v)))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFGn, field TRIG[6] (RW)
 *
 * Enables the periodic trigger capability for the triggered DMA channel.
 *
 * Values:
 * - 0 - Triggering is disabled. If triggering is disabled and ENBL is set, the
 *     DMA Channel will simply route the specified source to the DMA channel.
 *     (Normal mode)
 * - 1 - Triggering is enabled. If triggering is enabled and ENBL is set, the
 *     DMAMUX is in Periodic Trigger mode.
 */
/*@{*/
#define BP_DMAMUX_CHCFGn_TRIG (6U)         /*!< Bit position for DMAMUX_CHCFGn_TRIG. */
#define BM_DMAMUX_CHCFGn_TRIG (0x40U)      /*!< Bit mask for DMAMUX_CHCFGn_TRIG. */
#define BS_DMAMUX_CHCFGn_TRIG (1U)         /*!< Bit field size in bits for DMAMUX_CHCFGn_TRIG. */

/*! @brief Read current value of the DMAMUX_CHCFGn_TRIG field. */
#define BR_DMAMUX_CHCFGn_TRIG(x, n) (BITBAND_ACCESS8(HW_DMAMUX_CHCFGn_ADDR(x, n), BP_DMAMUX_CHCFGn_TRIG))

/*! @brief Format value for bitfield DMAMUX_CHCFGn_TRIG. */
#define BF_DMAMUX_CHCFGn_TRIG(v) ((uint8_t)((uint8_t)(v) << BP_DMAMUX_CHCFGn_TRIG) & BM_DMAMUX_CHCFGn_TRIG)

/*! @brief Set the TRIG field to a new value. */
#define BW_DMAMUX_CHCFGn_TRIG(x, n, v) (BITBAND_ACCESS8(HW_DMAMUX_CHCFGn_ADDR(x, n), BP_DMAMUX_CHCFGn_TRIG) = (v))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFGn, field ENBL[7] (RW)
 *
 * Enables the DMA channel.
 *
 * Values:
 * - 0 - DMA channel is disabled. This mode is primarily used during
 *     configuration of the DMAMux. The DMA has separate channel enables/disables, which
 *     should be used to disable or reconfigure a DMA channel.
 * - 1 - DMA channel is enabled
 */
/*@{*/
#define BP_DMAMUX_CHCFGn_ENBL (7U)         /*!< Bit position for DMAMUX_CHCFGn_ENBL. */
#define BM_DMAMUX_CHCFGn_ENBL (0x80U)      /*!< Bit mask for DMAMUX_CHCFGn_ENBL. */
#define BS_DMAMUX_CHCFGn_ENBL (1U)         /*!< Bit field size in bits for DMAMUX_CHCFGn_ENBL. */

/*! @brief Read current value of the DMAMUX_CHCFGn_ENBL field. */
#define BR_DMAMUX_CHCFGn_ENBL(x, n) (BITBAND_ACCESS8(HW_DMAMUX_CHCFGn_ADDR(x, n), BP_DMAMUX_CHCFGn_ENBL))

/*! @brief Format value for bitfield DMAMUX_CHCFGn_ENBL. */
#define BF_DMAMUX_CHCFGn_ENBL(v) ((uint8_t)((uint8_t)(v) << BP_DMAMUX_CHCFGn_ENBL) & BM_DMAMUX_CHCFGn_ENBL)

/*! @brief Set the ENBL field to a new value. */
#define BW_DMAMUX_CHCFGn_ENBL(x, n, v) (BITBAND_ACCESS8(HW_DMAMUX_CHCFGn_ADDR(x, n), BP_DMAMUX_CHCFGn_ENBL) = (v))
/*@}*/

/*******************************************************************************
 * hw_dmamux_t - module struct
 ******************************************************************************/
/*!
 * @brief All DMAMUX module registers.
 */
#pragma pack(1)
typedef struct _hw_dmamux
{
    __IO hw_dmamux_chcfgn_t CHCFGn[16];    /*!< [0x0] Channel Configuration register */
} hw_dmamux_t;
#pragma pack()

/*! @brief Macro to access all DMAMUX registers. */
/*! @param x DMAMUX module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_DMAMUX_REGS(DMAMUX_BASE)</code>. */
#define HW_DMAMUX_REGS(x) (*(hw_dmamux_t *)(x))

/*
 * MK64F12 ENET
 *
 * Ethernet MAC-NET Core
 *
 * Registers defined in this header file:
 * - HW_ENET_EIR - Interrupt Event Register
 * - HW_ENET_EIMR - Interrupt Mask Register
 * - HW_ENET_RDAR - Receive Descriptor Active Register
 * - HW_ENET_TDAR - Transmit Descriptor Active Register
 * - HW_ENET_ECR - Ethernet Control Register
 * - HW_ENET_MMFR - MII Management Frame Register
 * - HW_ENET_MSCR - MII Speed Control Register
 * - HW_ENET_MIBC - MIB Control Register
 * - HW_ENET_RCR - Receive Control Register
 * - HW_ENET_TCR - Transmit Control Register
 * - HW_ENET_PALR - Physical Address Lower Register
 * - HW_ENET_PAUR - Physical Address Upper Register
 * - HW_ENET_OPD - Opcode/Pause Duration Register
 * - HW_ENET_IAUR - Descriptor Individual Upper Address Register
 * - HW_ENET_IALR - Descriptor Individual Lower Address Register
 * - HW_ENET_GAUR - Descriptor Group Upper Address Register
 * - HW_ENET_GALR - Descriptor Group Lower Address Register
 * - HW_ENET_TFWR - Transmit FIFO Watermark Register
 * - HW_ENET_RDSR - Receive Descriptor Ring Start Register
 * - HW_ENET_TDSR - Transmit Buffer Descriptor Ring Start Register
 * - HW_ENET_MRBR - Maximum Receive Buffer Size Register
 * - HW_ENET_RSFL - Receive FIFO Section Full Threshold
 * - HW_ENET_RSEM - Receive FIFO Section Empty Threshold
 * - HW_ENET_RAEM - Receive FIFO Almost Empty Threshold
 * - HW_ENET_RAFL - Receive FIFO Almost Full Threshold
 * - HW_ENET_TSEM - Transmit FIFO Section Empty Threshold
 * - HW_ENET_TAEM - Transmit FIFO Almost Empty Threshold
 * - HW_ENET_TAFL - Transmit FIFO Almost Full Threshold
 * - HW_ENET_TIPG - Transmit Inter-Packet Gap
 * - HW_ENET_FTRL - Frame Truncation Length
 * - HW_ENET_TACC - Transmit Accelerator Function Configuration
 * - HW_ENET_RACC - Receive Accelerator Function Configuration
 * - HW_ENET_RMON_T_PACKETS - Tx Packet Count Statistic Register
 * - HW_ENET_RMON_T_BC_PKT - Tx Broadcast Packets Statistic Register
 * - HW_ENET_RMON_T_MC_PKT - Tx Multicast Packets Statistic Register
 * - HW_ENET_RMON_T_CRC_ALIGN - Tx Packets with CRC/Align Error Statistic Register
 * - HW_ENET_RMON_T_UNDERSIZE - Tx Packets Less Than Bytes and Good CRC Statistic Register
 * - HW_ENET_RMON_T_OVERSIZE - Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
 * - HW_ENET_RMON_T_FRAG - Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
 * - HW_ENET_RMON_T_JAB - Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
 * - HW_ENET_RMON_T_COL - Tx Collision Count Statistic Register
 * - HW_ENET_RMON_T_P64 - Tx 64-Byte Packets Statistic Register
 * - HW_ENET_RMON_T_P65TO127 - Tx 65- to 127-byte Packets Statistic Register
 * - HW_ENET_RMON_T_P128TO255 - Tx 128- to 255-byte Packets Statistic Register
 * - HW_ENET_RMON_T_P256TO511 - Tx 256- to 511-byte Packets Statistic Register
 * - HW_ENET_RMON_T_P512TO1023 - Tx 512- to 1023-byte Packets Statistic Register
 * - HW_ENET_RMON_T_P1024TO2047 - Tx 1024- to 2047-byte Packets Statistic Register
 * - HW_ENET_RMON_T_P_GTE2048 - Tx Packets Greater Than 2048 Bytes Statistic Register
 * - HW_ENET_RMON_T_OCTETS - Tx Octets Statistic Register
 * - HW_ENET_IEEE_T_FRAME_OK - Frames Transmitted OK Statistic Register
 * - HW_ENET_IEEE_T_1COL - Frames Transmitted with Single Collision Statistic Register
 * - HW_ENET_IEEE_T_MCOL - Frames Transmitted with Multiple Collisions Statistic Register
 * - HW_ENET_IEEE_T_DEF - Frames Transmitted after Deferral Delay Statistic Register
 * - HW_ENET_IEEE_T_LCOL - Frames Transmitted with Late Collision Statistic Register
 * - HW_ENET_IEEE_T_EXCOL - Frames Transmitted with Excessive Collisions Statistic Register
 * - HW_ENET_IEEE_T_MACERR - Frames Transmitted with Tx FIFO Underrun Statistic Register
 * - HW_ENET_IEEE_T_CSERR - Frames Transmitted with Carrier Sense Error Statistic Register
 * - HW_ENET_IEEE_T_FDXFC - Flow Control Pause Frames Transmitted Statistic Register
 * - HW_ENET_IEEE_T_OCTETS_OK - Octet Count for Frames Transmitted w/o Error Statistic Register
 * - HW_ENET_RMON_R_PACKETS - Rx Packet Count Statistic Register
 * - HW_ENET_RMON_R_BC_PKT - Rx Broadcast Packets Statistic Register
 * - HW_ENET_RMON_R_MC_PKT - Rx Multicast Packets Statistic Register
 * - HW_ENET_RMON_R_CRC_ALIGN - Rx Packets with CRC/Align Error Statistic Register
 * - HW_ENET_RMON_R_UNDERSIZE - Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
 * - HW_ENET_RMON_R_OVERSIZE - Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
 * - HW_ENET_RMON_R_FRAG - Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
 * - HW_ENET_RMON_R_JAB - Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
 * - HW_ENET_RMON_R_P64 - Rx 64-Byte Packets Statistic Register
 * - HW_ENET_RMON_R_P65TO127 - Rx 65- to 127-Byte Packets Statistic Register
 * - HW_ENET_RMON_R_P128TO255 - Rx 128- to 255-Byte Packets Statistic Register
 * - HW_ENET_RMON_R_P256TO511 - Rx 256- to 511-Byte Packets Statistic Register
 * - HW_ENET_RMON_R_P512TO1023 - Rx 512- to 1023-Byte Packets Statistic Register
 * - HW_ENET_RMON_R_P1024TO2047 - Rx 1024- to 2047-Byte Packets Statistic Register
 * - HW_ENET_RMON_R_P_GTE2048 - Rx Packets Greater than 2048 Bytes Statistic Register
 * - HW_ENET_RMON_R_OCTETS - Rx Octets Statistic Register
 * - HW_ENET_IEEE_R_DROP - Frames not Counted Correctly Statistic Register
 * - HW_ENET_IEEE_R_FRAME_OK - Frames Received OK Statistic Register
 * - HW_ENET_IEEE_R_CRC - Frames Received with CRC Error Statistic Register
 * - HW_ENET_IEEE_R_ALIGN - Frames Received with Alignment Error Statistic Register
 * - HW_ENET_IEEE_R_MACERR - Receive FIFO Overflow Count Statistic Register
 * - HW_ENET_IEEE_R_FDXFC - Flow Control Pause Frames Received Statistic Register
 * - HW_ENET_IEEE_R_OCTETS_OK - Octet Count for Frames Received without Error Statistic Register
 * - HW_ENET_ATCR - Adjustable Timer Control Register
 * - HW_ENET_ATVR - Timer Value Register
 * - HW_ENET_ATOFF - Timer Offset Register
 * - HW_ENET_ATPER - Timer Period Register
 * - HW_ENET_ATCOR - Timer Correction Register
 * - HW_ENET_ATINC - Time-Stamping Clock Period Register
 * - HW_ENET_ATSTMP - Timestamp of Last Transmitted Frame
 * - HW_ENET_TGSR - Timer Global Status Register
 * - HW_ENET_TCSRn - Timer Control Status Register
 * - HW_ENET_TCCRn - Timer Compare Capture Register
 *
 * - hw_enet_t - Struct containing all module registers.
 */

#define HW_ENET_INSTANCE_COUNT (1U) /*!< Number of instances of the ENET module. */
#define HW_ENET (0U) /*!< Instance number for ENET. */

/*******************************************************************************
 * HW_ENET_EIR - Interrupt Event Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_EIR - Interrupt Event Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * When an event occurs that sets a bit in EIR, an interrupt occurs if the
 * corresponding bit in the interrupt mask register (EIMR) is also set. Writing a 1 to
 * an EIR bit clears it; writing 0 has no effect. This register is cleared upon
 * hardware reset. TxBD[INT] and RxBD[INT] must be set to 1 to allow setting the
 * corresponding EIR register flags in enhanced mode, ENET_ECR[EN1588] = 1.
 * Legacy mode does not require these flags to be enabled.
 */
typedef union _hw_enet_eir
{
    uint32_t U;
    struct _hw_enet_eir_bitfields
    {
        uint32_t RESERVED0 : 15;       /*!< [14:0]  */
        uint32_t TS_TIMER : 1;         /*!< [15] Timestamp Timer */
        uint32_t TS_AVAIL : 1;         /*!< [16] Transmit Timestamp Available */
        uint32_t WAKEUP : 1;           /*!< [17] Node Wakeup Request Indication */
        uint32_t PLR : 1;              /*!< [18] Payload Receive Error */
        uint32_t UN : 1;               /*!< [19] Transmit FIFO Underrun */
        uint32_t RL : 1;               /*!< [20] Collision Retry Limit */
        uint32_t LC : 1;               /*!< [21] Late Collision */
        uint32_t EBERR : 1;            /*!< [22] Ethernet Bus Error */
        uint32_t MII : 1;              /*!< [23] MII Interrupt. */
        uint32_t RXB : 1;              /*!< [24] Receive Buffer Interrupt */
        uint32_t RXF : 1;              /*!< [25] Receive Frame Interrupt */
        uint32_t TXB : 1;              /*!< [26] Transmit Buffer Interrupt */
        uint32_t TXF : 1;              /*!< [27] Transmit Frame Interrupt */
        uint32_t GRA : 1;              /*!< [28] Graceful Stop Complete */
        uint32_t BABT : 1;             /*!< [29] Babbling Transmit Error */
        uint32_t BABR : 1;             /*!< [30] Babbling Receive Error */
        uint32_t RESERVED1 : 1;        /*!< [31]  */
    } B;
} hw_enet_eir_t;

/*!
 * @name Constants and macros for entire ENET_EIR register
 */
/*@{*/
#define HW_ENET_EIR_ADDR(x)      ((uint32_t)(x) + 0x4U)

#define HW_ENET_EIR(x)           (*(__IO hw_enet_eir_t *) HW_ENET_EIR_ADDR(x))
#define HW_ENET_EIR_RD(x)        (HW_ENET_EIR(x).U)
#define HW_ENET_EIR_WR(x, v)     (HW_ENET_EIR(x).U = (v))
#define HW_ENET_EIR_SET(x, v)    (HW_ENET_EIR_WR(x, HW_ENET_EIR_RD(x) |  (v)))
#define HW_ENET_EIR_CLR(x, v)    (HW_ENET_EIR_WR(x, HW_ENET_EIR_RD(x) & ~(v)))
#define HW_ENET_EIR_TOG(x, v)    (HW_ENET_EIR_WR(x, HW_ENET_EIR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_EIR bitfields
 */

/*!
 * @name Register ENET_EIR, field TS_TIMER[15] (W1C)
 *
 * The adjustable timer reached the period event. A period event interrupt can
 * be generated if ATCR[PEREN] is set and the timer wraps according to the
 * periodic setting in the ATPER register. Set the timer period value before setting
 * ATCR[PEREN].
 */
/*@{*/
#define BP_ENET_EIR_TS_TIMER (15U)         /*!< Bit position for ENET_EIR_TS_TIMER. */
#define BM_ENET_EIR_TS_TIMER (0x00008000U) /*!< Bit mask for ENET_EIR_TS_TIMER. */
#define BS_ENET_EIR_TS_TIMER (1U)          /*!< Bit field size in bits for ENET_EIR_TS_TIMER. */

/*! @brief Read current value of the ENET_EIR_TS_TIMER field. */
#define BR_ENET_EIR_TS_TIMER(x) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_TS_TIMER))

/*! @brief Format value for bitfield ENET_EIR_TS_TIMER. */
#define BF_ENET_EIR_TS_TIMER(v) ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_TS_TIMER) & BM_ENET_EIR_TS_TIMER)

/*! @brief Set the TS_TIMER field to a new value. */
#define BW_ENET_EIR_TS_TIMER(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_TS_TIMER) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field TS_AVAIL[16] (W1C)
 *
 * Indicates that the timestamp of the last transmitted timing frame is
 * available in the ATSTMP register.
 */
/*@{*/
#define BP_ENET_EIR_TS_AVAIL (16U)         /*!< Bit position for ENET_EIR_TS_AVAIL. */
#define BM_ENET_EIR_TS_AVAIL (0x00010000U) /*!< Bit mask for ENET_EIR_TS_AVAIL. */
#define BS_ENET_EIR_TS_AVAIL (1U)          /*!< Bit field size in bits for ENET_EIR_TS_AVAIL. */

/*! @brief Read current value of the ENET_EIR_TS_AVAIL field. */
#define BR_ENET_EIR_TS_AVAIL(x) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_TS_AVAIL))

/*! @brief Format value for bitfield ENET_EIR_TS_AVAIL. */
#define BF_ENET_EIR_TS_AVAIL(v) ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_TS_AVAIL) & BM_ENET_EIR_TS_AVAIL)

/*! @brief Set the TS_AVAIL field to a new value. */
#define BW_ENET_EIR_TS_AVAIL(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_TS_AVAIL) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field WAKEUP[17] (W1C)
 *
 * Read-only status bit to indicate that a magic packet has been detected. Will
 * act only if ECR[MAGICEN] is set.
 */
/*@{*/
#define BP_ENET_EIR_WAKEUP   (17U)         /*!< Bit position for ENET_EIR_WAKEUP. */
#define BM_ENET_EIR_WAKEUP   (0x00020000U) /*!< Bit mask for ENET_EIR_WAKEUP. */
#define BS_ENET_EIR_WAKEUP   (1U)          /*!< Bit field size in bits for ENET_EIR_WAKEUP. */

/*! @brief Read current value of the ENET_EIR_WAKEUP field. */
#define BR_ENET_EIR_WAKEUP(x) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_WAKEUP))

/*! @brief Format value for bitfield ENET_EIR_WAKEUP. */
#define BF_ENET_EIR_WAKEUP(v) ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_WAKEUP) & BM_ENET_EIR_WAKEUP)

/*! @brief Set the WAKEUP field to a new value. */
#define BW_ENET_EIR_WAKEUP(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_WAKEUP) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field PLR[18] (W1C)
 *
 * Indicates a frame was received with a payload length error. See Frame
 * Length/Type Verification: Payload Length Check for more information.
 */
/*@{*/
#define BP_ENET_EIR_PLR      (18U)         /*!< Bit position for ENET_EIR_PLR. */
#define BM_ENET_EIR_PLR      (0x00040000U) /*!< Bit mask for ENET_EIR_PLR. */
#define BS_ENET_EIR_PLR      (1U)          /*!< Bit field size in bits for ENET_EIR_PLR. */

/*! @brief Read current value of the ENET_EIR_PLR field. */
#define BR_ENET_EIR_PLR(x)   (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_PLR))

/*! @brief Format value for bitfield ENET_EIR_PLR. */
#define BF_ENET_EIR_PLR(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_PLR) & BM_ENET_EIR_PLR)

/*! @brief Set the PLR field to a new value. */
#define BW_ENET_EIR_PLR(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_PLR) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field UN[19] (W1C)
 *
 * Indicates the transmit FIFO became empty before the complete frame was
 * transmitted. A bad CRC is appended to the frame fragment and the remainder of the
 * frame is discarded.
 */
/*@{*/
#define BP_ENET_EIR_UN       (19U)         /*!< Bit position for ENET_EIR_UN. */
#define BM_ENET_EIR_UN       (0x00080000U) /*!< Bit mask for ENET_EIR_UN. */
#define BS_ENET_EIR_UN       (1U)          /*!< Bit field size in bits for ENET_EIR_UN. */

/*! @brief Read current value of the ENET_EIR_UN field. */
#define BR_ENET_EIR_UN(x)    (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_UN))

/*! @brief Format value for bitfield ENET_EIR_UN. */
#define BF_ENET_EIR_UN(v)    ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_UN) & BM_ENET_EIR_UN)

/*! @brief Set the UN field to a new value. */
#define BW_ENET_EIR_UN(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_UN) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field RL[20] (W1C)
 *
 * Indicates a collision occurred on each of 16 successive attempts to transmit
 * the frame. The frame is discarded without being transmitted and transmission
 * of the next frame commences. This error can only occur in half-duplex mode.
 */
/*@{*/
#define BP_ENET_EIR_RL       (20U)         /*!< Bit position for ENET_EIR_RL. */
#define BM_ENET_EIR_RL       (0x00100000U) /*!< Bit mask for ENET_EIR_RL. */
#define BS_ENET_EIR_RL       (1U)          /*!< Bit field size in bits for ENET_EIR_RL. */

/*! @brief Read current value of the ENET_EIR_RL field. */
#define BR_ENET_EIR_RL(x)    (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_RL))

/*! @brief Format value for bitfield ENET_EIR_RL. */
#define BF_ENET_EIR_RL(v)    ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_RL) & BM_ENET_EIR_RL)

/*! @brief Set the RL field to a new value. */
#define BW_ENET_EIR_RL(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_RL) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field LC[21] (W1C)
 *
 * Indicates a collision occurred beyond the collision window (slot time) in
 * half-duplex mode. The frame truncates with a bad CRC and the remainder of the
 * frame is discarded.
 */
/*@{*/
#define BP_ENET_EIR_LC       (21U)         /*!< Bit position for ENET_EIR_LC. */
#define BM_ENET_EIR_LC       (0x00200000U) /*!< Bit mask for ENET_EIR_LC. */
#define BS_ENET_EIR_LC       (1U)          /*!< Bit field size in bits for ENET_EIR_LC. */

/*! @brief Read current value of the ENET_EIR_LC field. */
#define BR_ENET_EIR_LC(x)    (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_LC))

/*! @brief Format value for bitfield ENET_EIR_LC. */
#define BF_ENET_EIR_LC(v)    ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_LC) & BM_ENET_EIR_LC)

/*! @brief Set the LC field to a new value. */
#define BW_ENET_EIR_LC(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_LC) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field EBERR[22] (W1C)
 *
 * Indicates a system bus error occurred when a uDMA transaction is underway.
 * When this bit is set, ECR[ETHEREN] is cleared, halting frame processing by the
 * MAC. When this occurs, software must ensure proper actions, possibly resetting
 * the system, to resume normal operation.
 */
/*@{*/
#define BP_ENET_EIR_EBERR    (22U)         /*!< Bit position for ENET_EIR_EBERR. */
#define BM_ENET_EIR_EBERR    (0x00400000U) /*!< Bit mask for ENET_EIR_EBERR. */
#define BS_ENET_EIR_EBERR    (1U)          /*!< Bit field size in bits for ENET_EIR_EBERR. */

/*! @brief Read current value of the ENET_EIR_EBERR field. */
#define BR_ENET_EIR_EBERR(x) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_EBERR))

/*! @brief Format value for bitfield ENET_EIR_EBERR. */
#define BF_ENET_EIR_EBERR(v) ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_EBERR) & BM_ENET_EIR_EBERR)

/*! @brief Set the EBERR field to a new value. */
#define BW_ENET_EIR_EBERR(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_EBERR) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field MII[23] (W1C)
 *
 * Indicates that the MII has completed the data transfer requested.
 */
/*@{*/
#define BP_ENET_EIR_MII      (23U)         /*!< Bit position for ENET_EIR_MII. */
#define BM_ENET_EIR_MII      (0x00800000U) /*!< Bit mask for ENET_EIR_MII. */
#define BS_ENET_EIR_MII      (1U)          /*!< Bit field size in bits for ENET_EIR_MII. */

/*! @brief Read current value of the ENET_EIR_MII field. */
#define BR_ENET_EIR_MII(x)   (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_MII))

/*! @brief Format value for bitfield ENET_EIR_MII. */
#define BF_ENET_EIR_MII(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_MII) & BM_ENET_EIR_MII)

/*! @brief Set the MII field to a new value. */
#define BW_ENET_EIR_MII(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_MII) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field RXB[24] (W1C)
 *
 * Indicates a receive buffer descriptor is not the last in the frame has been
 * updated.
 */
/*@{*/
#define BP_ENET_EIR_RXB      (24U)         /*!< Bit position for ENET_EIR_RXB. */
#define BM_ENET_EIR_RXB      (0x01000000U) /*!< Bit mask for ENET_EIR_RXB. */
#define BS_ENET_EIR_RXB      (1U)          /*!< Bit field size in bits for ENET_EIR_RXB. */

/*! @brief Read current value of the ENET_EIR_RXB field. */
#define BR_ENET_EIR_RXB(x)   (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_RXB))

/*! @brief Format value for bitfield ENET_EIR_RXB. */
#define BF_ENET_EIR_RXB(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_RXB) & BM_ENET_EIR_RXB)

/*! @brief Set the RXB field to a new value. */
#define BW_ENET_EIR_RXB(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_RXB) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field RXF[25] (W1C)
 *
 * Indicates a frame has been received and the last corresponding buffer
 * descriptor has been updated.
 */
/*@{*/
#define BP_ENET_EIR_RXF      (25U)         /*!< Bit position for ENET_EIR_RXF. */
#define BM_ENET_EIR_RXF      (0x02000000U) /*!< Bit mask for ENET_EIR_RXF. */
#define BS_ENET_EIR_RXF      (1U)          /*!< Bit field size in bits for ENET_EIR_RXF. */

/*! @brief Read current value of the ENET_EIR_RXF field. */
#define BR_ENET_EIR_RXF(x)   (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_RXF))

/*! @brief Format value for bitfield ENET_EIR_RXF. */
#define BF_ENET_EIR_RXF(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_RXF) & BM_ENET_EIR_RXF)

/*! @brief Set the RXF field to a new value. */
#define BW_ENET_EIR_RXF(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_RXF) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field TXB[26] (W1C)
 *
 * Indicates a transmit buffer descriptor has been updated.
 */
/*@{*/
#define BP_ENET_EIR_TXB      (26U)         /*!< Bit position for ENET_EIR_TXB. */
#define BM_ENET_EIR_TXB      (0x04000000U) /*!< Bit mask for ENET_EIR_TXB. */
#define BS_ENET_EIR_TXB      (1U)          /*!< Bit field size in bits for ENET_EIR_TXB. */

/*! @brief Read current value of the ENET_EIR_TXB field. */
#define BR_ENET_EIR_TXB(x)   (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_TXB))

/*! @brief Format value for bitfield ENET_EIR_TXB. */
#define BF_ENET_EIR_TXB(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_TXB) & BM_ENET_EIR_TXB)

/*! @brief Set the TXB field to a new value. */
#define BW_ENET_EIR_TXB(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_TXB) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field TXF[27] (W1C)
 *
 * Indicates a frame has been transmitted and the last corresponding buffer
 * descriptor has been updated.
 */
/*@{*/
#define BP_ENET_EIR_TXF      (27U)         /*!< Bit position for ENET_EIR_TXF. */
#define BM_ENET_EIR_TXF      (0x08000000U) /*!< Bit mask for ENET_EIR_TXF. */
#define BS_ENET_EIR_TXF      (1U)          /*!< Bit field size in bits for ENET_EIR_TXF. */

/*! @brief Read current value of the ENET_EIR_TXF field. */
#define BR_ENET_EIR_TXF(x)   (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_TXF))

/*! @brief Format value for bitfield ENET_EIR_TXF. */
#define BF_ENET_EIR_TXF(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_TXF) & BM_ENET_EIR_TXF)

/*! @brief Set the TXF field to a new value. */
#define BW_ENET_EIR_TXF(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_TXF) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field GRA[28] (W1C)
 *
 * This interrupt is asserted after the transmitter is put into a pause state
 * after completion of the frame currently being transmitted. See Graceful Transmit
 * Stop (GTS) for conditions that lead to graceful stop. The GRA interrupt is
 * asserted only when the TX transitions into the stopped state. If this bit is
 * cleared by writing 1 and the TX is still stopped, the bit is not set again.
 */
/*@{*/
#define BP_ENET_EIR_GRA      (28U)         /*!< Bit position for ENET_EIR_GRA. */
#define BM_ENET_EIR_GRA      (0x10000000U) /*!< Bit mask for ENET_EIR_GRA. */
#define BS_ENET_EIR_GRA      (1U)          /*!< Bit field size in bits for ENET_EIR_GRA. */

/*! @brief Read current value of the ENET_EIR_GRA field. */
#define BR_ENET_EIR_GRA(x)   (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_GRA))

/*! @brief Format value for bitfield ENET_EIR_GRA. */
#define BF_ENET_EIR_GRA(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_GRA) & BM_ENET_EIR_GRA)

/*! @brief Set the GRA field to a new value. */
#define BW_ENET_EIR_GRA(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_GRA) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field BABT[29] (W1C)
 *
 * Indicates the transmitted frame length exceeds RCR[MAX_FL] bytes. Usually
 * this condition is caused when a frame that is too long is placed into the
 * transmit data buffer(s). Truncation does not occur.
 */
/*@{*/
#define BP_ENET_EIR_BABT     (29U)         /*!< Bit position for ENET_EIR_BABT. */
#define BM_ENET_EIR_BABT     (0x20000000U) /*!< Bit mask for ENET_EIR_BABT. */
#define BS_ENET_EIR_BABT     (1U)          /*!< Bit field size in bits for ENET_EIR_BABT. */

/*! @brief Read current value of the ENET_EIR_BABT field. */
#define BR_ENET_EIR_BABT(x)  (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_BABT))

/*! @brief Format value for bitfield ENET_EIR_BABT. */
#define BF_ENET_EIR_BABT(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_BABT) & BM_ENET_EIR_BABT)

/*! @brief Set the BABT field to a new value. */
#define BW_ENET_EIR_BABT(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_BABT) = (v))
/*@}*/

/*!
 * @name Register ENET_EIR, field BABR[30] (W1C)
 *
 * Indicates a frame was received with length in excess of RCR[MAX_FL] bytes.
 */
/*@{*/
#define BP_ENET_EIR_BABR     (30U)         /*!< Bit position for ENET_EIR_BABR. */
#define BM_ENET_EIR_BABR     (0x40000000U) /*!< Bit mask for ENET_EIR_BABR. */
#define BS_ENET_EIR_BABR     (1U)          /*!< Bit field size in bits for ENET_EIR_BABR. */

/*! @brief Read current value of the ENET_EIR_BABR field. */
#define BR_ENET_EIR_BABR(x)  (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_BABR))

/*! @brief Format value for bitfield ENET_EIR_BABR. */
#define BF_ENET_EIR_BABR(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_EIR_BABR) & BM_ENET_EIR_BABR)

/*! @brief Set the BABR field to a new value. */
#define BW_ENET_EIR_BABR(x, v) (BITBAND_ACCESS32(HW_ENET_EIR_ADDR(x), BP_ENET_EIR_BABR) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_EIMR - Interrupt Mask Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_EIMR - Interrupt Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * EIMR controls which interrupt events are allowed to generate actual
 * interrupts. A hardware reset clears this register. If the corresponding bits in the EIR
 * and EIMR registers are set, an interrupt is generated. The interrupt signal
 * remains asserted until a 1 is written to the EIR field (write 1 to clear) or a
 * 0 is written to the EIMR field.
 */
typedef union _hw_enet_eimr
{
    uint32_t U;
    struct _hw_enet_eimr_bitfields
    {
        uint32_t RESERVED0 : 15;       /*!< [14:0]  */
        uint32_t TS_TIMER : 1;         /*!< [15] TS_TIMER Interrupt Mask */
        uint32_t TS_AVAIL : 1;         /*!< [16] TS_AVAIL Interrupt Mask */
        uint32_t WAKEUP : 1;           /*!< [17] WAKEUP Interrupt Mask */
        uint32_t PLR : 1;              /*!< [18] PLR Interrupt Mask */
        uint32_t UN : 1;               /*!< [19] UN Interrupt Mask */
        uint32_t RL : 1;               /*!< [20] RL Interrupt Mask */
        uint32_t LC : 1;               /*!< [21] LC Interrupt Mask */
        uint32_t EBERR : 1;            /*!< [22] EBERR Interrupt Mask */
        uint32_t MII : 1;              /*!< [23] MII Interrupt Mask */
        uint32_t RXB : 1;              /*!< [24] RXB Interrupt Mask */
        uint32_t RXF : 1;              /*!< [25] RXF Interrupt Mask */
        uint32_t TXB : 1;              /*!< [26] TXB Interrupt Mask */
        uint32_t TXF : 1;              /*!< [27] TXF Interrupt Mask */
        uint32_t GRA : 1;              /*!< [28] GRA Interrupt Mask */
        uint32_t BABT : 1;             /*!< [29] BABT Interrupt Mask */
        uint32_t BABR : 1;             /*!< [30] BABR Interrupt Mask */
        uint32_t RESERVED1 : 1;        /*!< [31]  */
    } B;
} hw_enet_eimr_t;

/*!
 * @name Constants and macros for entire ENET_EIMR register
 */
/*@{*/
#define HW_ENET_EIMR_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_ENET_EIMR(x)          (*(__IO hw_enet_eimr_t *) HW_ENET_EIMR_ADDR(x))
#define HW_ENET_EIMR_RD(x)       (HW_ENET_EIMR(x).U)
#define HW_ENET_EIMR_WR(x, v)    (HW_ENET_EIMR(x).U = (v))
#define HW_ENET_EIMR_SET(x, v)   (HW_ENET_EIMR_WR(x, HW_ENET_EIMR_RD(x) |  (v)))
#define HW_ENET_EIMR_CLR(x, v)   (HW_ENET_EIMR_WR(x, HW_ENET_EIMR_RD(x) & ~(v)))
#define HW_ENET_EIMR_TOG(x, v)   (HW_ENET_EIMR_WR(x, HW_ENET_EIMR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_EIMR bitfields
 */

/*!
 * @name Register ENET_EIMR, field TS_TIMER[15] (RW)
 *
 * Corresponds to interrupt source EIR[TS_TIMER] register and determines whether
 * an interrupt condition can generate an interrupt. At every module clock, the
 * EIR samples the signal generated by the interrupting source. The corresponding
 * EIR TS_TIMER field reflects the state of the interrupt signal even if the
 * corresponding EIMR field is cleared.
 */
/*@{*/
#define BP_ENET_EIMR_TS_TIMER (15U)        /*!< Bit position for ENET_EIMR_TS_TIMER. */
#define BM_ENET_EIMR_TS_TIMER (0x00008000U) /*!< Bit mask for ENET_EIMR_TS_TIMER. */
#define BS_ENET_EIMR_TS_TIMER (1U)         /*!< Bit field size in bits for ENET_EIMR_TS_TIMER. */

/*! @brief Read current value of the ENET_EIMR_TS_TIMER field. */
#define BR_ENET_EIMR_TS_TIMER(x) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_TS_TIMER))

/*! @brief Format value for bitfield ENET_EIMR_TS_TIMER. */
#define BF_ENET_EIMR_TS_TIMER(v) ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_TS_TIMER) & BM_ENET_EIMR_TS_TIMER)

/*! @brief Set the TS_TIMER field to a new value. */
#define BW_ENET_EIMR_TS_TIMER(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_TS_TIMER) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field TS_AVAIL[16] (RW)
 *
 * Corresponds to interrupt source EIR[TS_AVAIL] register and determines whether
 * an interrupt condition can generate an interrupt. At every module clock, the
 * EIR samples the signal generated by the interrupting source. The corresponding
 * EIR TS_AVAIL field reflects the state of the interrupt signal even if the
 * corresponding EIMR field is cleared.
 */
/*@{*/
#define BP_ENET_EIMR_TS_AVAIL (16U)        /*!< Bit position for ENET_EIMR_TS_AVAIL. */
#define BM_ENET_EIMR_TS_AVAIL (0x00010000U) /*!< Bit mask for ENET_EIMR_TS_AVAIL. */
#define BS_ENET_EIMR_TS_AVAIL (1U)         /*!< Bit field size in bits for ENET_EIMR_TS_AVAIL. */

/*! @brief Read current value of the ENET_EIMR_TS_AVAIL field. */
#define BR_ENET_EIMR_TS_AVAIL(x) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_TS_AVAIL))

/*! @brief Format value for bitfield ENET_EIMR_TS_AVAIL. */
#define BF_ENET_EIMR_TS_AVAIL(v) ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_TS_AVAIL) & BM_ENET_EIMR_TS_AVAIL)

/*! @brief Set the TS_AVAIL field to a new value. */
#define BW_ENET_EIMR_TS_AVAIL(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_TS_AVAIL) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field WAKEUP[17] (RW)
 *
 * Corresponds to interrupt source EIR[WAKEUP] register and determines whether
 * an interrupt condition can generate an interrupt. At every module clock, the
 * EIR samples the signal generated by the interrupting source. The corresponding
 * EIR WAKEUP field reflects the state of the interrupt signal even if the
 * corresponding EIMR field is cleared.
 */
/*@{*/
#define BP_ENET_EIMR_WAKEUP  (17U)         /*!< Bit position for ENET_EIMR_WAKEUP. */
#define BM_ENET_EIMR_WAKEUP  (0x00020000U) /*!< Bit mask for ENET_EIMR_WAKEUP. */
#define BS_ENET_EIMR_WAKEUP  (1U)          /*!< Bit field size in bits for ENET_EIMR_WAKEUP. */

/*! @brief Read current value of the ENET_EIMR_WAKEUP field. */
#define BR_ENET_EIMR_WAKEUP(x) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_WAKEUP))

/*! @brief Format value for bitfield ENET_EIMR_WAKEUP. */
#define BF_ENET_EIMR_WAKEUP(v) ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_WAKEUP) & BM_ENET_EIMR_WAKEUP)

/*! @brief Set the WAKEUP field to a new value. */
#define BW_ENET_EIMR_WAKEUP(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_WAKEUP) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field PLR[18] (RW)
 *
 * Corresponds to interrupt source EIR[PLR] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR PLR field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 */
/*@{*/
#define BP_ENET_EIMR_PLR     (18U)         /*!< Bit position for ENET_EIMR_PLR. */
#define BM_ENET_EIMR_PLR     (0x00040000U) /*!< Bit mask for ENET_EIMR_PLR. */
#define BS_ENET_EIMR_PLR     (1U)          /*!< Bit field size in bits for ENET_EIMR_PLR. */

/*! @brief Read current value of the ENET_EIMR_PLR field. */
#define BR_ENET_EIMR_PLR(x)  (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_PLR))

/*! @brief Format value for bitfield ENET_EIMR_PLR. */
#define BF_ENET_EIMR_PLR(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_PLR) & BM_ENET_EIMR_PLR)

/*! @brief Set the PLR field to a new value. */
#define BW_ENET_EIMR_PLR(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_PLR) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field UN[19] (RW)
 *
 * Corresponds to interrupt source EIR[UN] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples the
 * signal generated by the interrupting source. The corresponding EIR UN field
 * reflects the state of the interrupt signal even if the corresponding EIMR field
 * is cleared.
 */
/*@{*/
#define BP_ENET_EIMR_UN      (19U)         /*!< Bit position for ENET_EIMR_UN. */
#define BM_ENET_EIMR_UN      (0x00080000U) /*!< Bit mask for ENET_EIMR_UN. */
#define BS_ENET_EIMR_UN      (1U)          /*!< Bit field size in bits for ENET_EIMR_UN. */

/*! @brief Read current value of the ENET_EIMR_UN field. */
#define BR_ENET_EIMR_UN(x)   (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_UN))

/*! @brief Format value for bitfield ENET_EIMR_UN. */
#define BF_ENET_EIMR_UN(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_UN) & BM_ENET_EIMR_UN)

/*! @brief Set the UN field to a new value. */
#define BW_ENET_EIMR_UN(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_UN) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field RL[20] (RW)
 *
 * Corresponds to interrupt source EIR[RL] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples the
 * signal generated by the interrupting source. The corresponding EIR RL field
 * reflects the state of the interrupt signal even if the corresponding EIMR field
 * is cleared.
 */
/*@{*/
#define BP_ENET_EIMR_RL      (20U)         /*!< Bit position for ENET_EIMR_RL. */
#define BM_ENET_EIMR_RL      (0x00100000U) /*!< Bit mask for ENET_EIMR_RL. */
#define BS_ENET_EIMR_RL      (1U)          /*!< Bit field size in bits for ENET_EIMR_RL. */

/*! @brief Read current value of the ENET_EIMR_RL field. */
#define BR_ENET_EIMR_RL(x)   (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_RL))

/*! @brief Format value for bitfield ENET_EIMR_RL. */
#define BF_ENET_EIMR_RL(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_RL) & BM_ENET_EIMR_RL)

/*! @brief Set the RL field to a new value. */
#define BW_ENET_EIMR_RL(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_RL) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field LC[21] (RW)
 *
 * Corresponds to interrupt source EIR[LC] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples the
 * signal generated by the interrupting source. The corresponding EIR LC field
 * reflects the state of the interrupt signal even if the corresponding EIMR field
 * is cleared.
 */
/*@{*/
#define BP_ENET_EIMR_LC      (21U)         /*!< Bit position for ENET_EIMR_LC. */
#define BM_ENET_EIMR_LC      (0x00200000U) /*!< Bit mask for ENET_EIMR_LC. */
#define BS_ENET_EIMR_LC      (1U)          /*!< Bit field size in bits for ENET_EIMR_LC. */

/*! @brief Read current value of the ENET_EIMR_LC field. */
#define BR_ENET_EIMR_LC(x)   (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_LC))

/*! @brief Format value for bitfield ENET_EIMR_LC. */
#define BF_ENET_EIMR_LC(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_LC) & BM_ENET_EIMR_LC)

/*! @brief Set the LC field to a new value. */
#define BW_ENET_EIMR_LC(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_LC) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field EBERR[22] (RW)
 *
 * Corresponds to interrupt source EIR[EBERR] and determines whether an
 * interrupt condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR EBERR
 * field reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 */
/*@{*/
#define BP_ENET_EIMR_EBERR   (22U)         /*!< Bit position for ENET_EIMR_EBERR. */
#define BM_ENET_EIMR_EBERR   (0x00400000U) /*!< Bit mask for ENET_EIMR_EBERR. */
#define BS_ENET_EIMR_EBERR   (1U)          /*!< Bit field size in bits for ENET_EIMR_EBERR. */

/*! @brief Read current value of the ENET_EIMR_EBERR field. */
#define BR_ENET_EIMR_EBERR(x) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_EBERR))

/*! @brief Format value for bitfield ENET_EIMR_EBERR. */
#define BF_ENET_EIMR_EBERR(v) ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_EBERR) & BM_ENET_EIMR_EBERR)

/*! @brief Set the EBERR field to a new value. */
#define BW_ENET_EIMR_EBERR(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_EBERR) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field MII[23] (RW)
 *
 * Corresponds to interrupt source EIR[MII] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR MII field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 */
/*@{*/
#define BP_ENET_EIMR_MII     (23U)         /*!< Bit position for ENET_EIMR_MII. */
#define BM_ENET_EIMR_MII     (0x00800000U) /*!< Bit mask for ENET_EIMR_MII. */
#define BS_ENET_EIMR_MII     (1U)          /*!< Bit field size in bits for ENET_EIMR_MII. */

/*! @brief Read current value of the ENET_EIMR_MII field. */
#define BR_ENET_EIMR_MII(x)  (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_MII))

/*! @brief Format value for bitfield ENET_EIMR_MII. */
#define BF_ENET_EIMR_MII(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_MII) & BM_ENET_EIMR_MII)

/*! @brief Set the MII field to a new value. */
#define BW_ENET_EIMR_MII(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_MII) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field RXB[24] (RW)
 *
 * Corresponds to interrupt source EIR[RXB] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR RXB field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 */
/*@{*/
#define BP_ENET_EIMR_RXB     (24U)         /*!< Bit position for ENET_EIMR_RXB. */
#define BM_ENET_EIMR_RXB     (0x01000000U) /*!< Bit mask for ENET_EIMR_RXB. */
#define BS_ENET_EIMR_RXB     (1U)          /*!< Bit field size in bits for ENET_EIMR_RXB. */

/*! @brief Read current value of the ENET_EIMR_RXB field. */
#define BR_ENET_EIMR_RXB(x)  (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_RXB))

/*! @brief Format value for bitfield ENET_EIMR_RXB. */
#define BF_ENET_EIMR_RXB(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_RXB) & BM_ENET_EIMR_RXB)

/*! @brief Set the RXB field to a new value. */
#define BW_ENET_EIMR_RXB(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_RXB) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field RXF[25] (RW)
 *
 * Corresponds to interrupt source EIR[RXF] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR RXF field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 */
/*@{*/
#define BP_ENET_EIMR_RXF     (25U)         /*!< Bit position for ENET_EIMR_RXF. */
#define BM_ENET_EIMR_RXF     (0x02000000U) /*!< Bit mask for ENET_EIMR_RXF. */
#define BS_ENET_EIMR_RXF     (1U)          /*!< Bit field size in bits for ENET_EIMR_RXF. */

/*! @brief Read current value of the ENET_EIMR_RXF field. */
#define BR_ENET_EIMR_RXF(x)  (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_RXF))

/*! @brief Format value for bitfield ENET_EIMR_RXF. */
#define BF_ENET_EIMR_RXF(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_RXF) & BM_ENET_EIMR_RXF)

/*! @brief Set the RXF field to a new value. */
#define BW_ENET_EIMR_RXF(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_RXF) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field TXB[26] (RW)
 *
 * Corresponds to interrupt source EIR[TXB] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR TXF field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 *
 * Values:
 * - 0 - The corresponding interrupt source is masked.
 * - 1 - The corresponding interrupt source is not masked.
 */
/*@{*/
#define BP_ENET_EIMR_TXB     (26U)         /*!< Bit position for ENET_EIMR_TXB. */
#define BM_ENET_EIMR_TXB     (0x04000000U) /*!< Bit mask for ENET_EIMR_TXB. */
#define BS_ENET_EIMR_TXB     (1U)          /*!< Bit field size in bits for ENET_EIMR_TXB. */

/*! @brief Read current value of the ENET_EIMR_TXB field. */
#define BR_ENET_EIMR_TXB(x)  (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_TXB))

/*! @brief Format value for bitfield ENET_EIMR_TXB. */
#define BF_ENET_EIMR_TXB(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_TXB) & BM_ENET_EIMR_TXB)

/*! @brief Set the TXB field to a new value. */
#define BW_ENET_EIMR_TXB(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_TXB) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field TXF[27] (RW)
 *
 * Corresponds to interrupt source EIR[TXF] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR TXF field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 *
 * Values:
 * - 0 - The corresponding interrupt source is masked.
 * - 1 - The corresponding interrupt source is not masked.
 */
/*@{*/
#define BP_ENET_EIMR_TXF     (27U)         /*!< Bit position for ENET_EIMR_TXF. */
#define BM_ENET_EIMR_TXF     (0x08000000U) /*!< Bit mask for ENET_EIMR_TXF. */
#define BS_ENET_EIMR_TXF     (1U)          /*!< Bit field size in bits for ENET_EIMR_TXF. */

/*! @brief Read current value of the ENET_EIMR_TXF field. */
#define BR_ENET_EIMR_TXF(x)  (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_TXF))

/*! @brief Format value for bitfield ENET_EIMR_TXF. */
#define BF_ENET_EIMR_TXF(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_TXF) & BM_ENET_EIMR_TXF)

/*! @brief Set the TXF field to a new value. */
#define BW_ENET_EIMR_TXF(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_TXF) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field GRA[28] (RW)
 *
 * Corresponds to interrupt source EIR[GRA] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR GRA field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 *
 * Values:
 * - 0 - The corresponding interrupt source is masked.
 * - 1 - The corresponding interrupt source is not masked.
 */
/*@{*/
#define BP_ENET_EIMR_GRA     (28U)         /*!< Bit position for ENET_EIMR_GRA. */
#define BM_ENET_EIMR_GRA     (0x10000000U) /*!< Bit mask for ENET_EIMR_GRA. */
#define BS_ENET_EIMR_GRA     (1U)          /*!< Bit field size in bits for ENET_EIMR_GRA. */

/*! @brief Read current value of the ENET_EIMR_GRA field. */
#define BR_ENET_EIMR_GRA(x)  (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_GRA))

/*! @brief Format value for bitfield ENET_EIMR_GRA. */
#define BF_ENET_EIMR_GRA(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_GRA) & BM_ENET_EIMR_GRA)

/*! @brief Set the GRA field to a new value. */
#define BW_ENET_EIMR_GRA(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_GRA) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field BABT[29] (RW)
 *
 * Corresponds to interrupt source EIR[BABT] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR BABT
 * field reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 *
 * Values:
 * - 0 - The corresponding interrupt source is masked.
 * - 1 - The corresponding interrupt source is not masked.
 */
/*@{*/
#define BP_ENET_EIMR_BABT    (29U)         /*!< Bit position for ENET_EIMR_BABT. */
#define BM_ENET_EIMR_BABT    (0x20000000U) /*!< Bit mask for ENET_EIMR_BABT. */
#define BS_ENET_EIMR_BABT    (1U)          /*!< Bit field size in bits for ENET_EIMR_BABT. */

/*! @brief Read current value of the ENET_EIMR_BABT field. */
#define BR_ENET_EIMR_BABT(x) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_BABT))

/*! @brief Format value for bitfield ENET_EIMR_BABT. */
#define BF_ENET_EIMR_BABT(v) ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_BABT) & BM_ENET_EIMR_BABT)

/*! @brief Set the BABT field to a new value. */
#define BW_ENET_EIMR_BABT(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_BABT) = (v))
/*@}*/

/*!
 * @name Register ENET_EIMR, field BABR[30] (RW)
 *
 * Corresponds to interrupt source EIR[BABR] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR BABR
 * field reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 *
 * Values:
 * - 0 - The corresponding interrupt source is masked.
 * - 1 - The corresponding interrupt source is not masked.
 */
/*@{*/
#define BP_ENET_EIMR_BABR    (30U)         /*!< Bit position for ENET_EIMR_BABR. */
#define BM_ENET_EIMR_BABR    (0x40000000U) /*!< Bit mask for ENET_EIMR_BABR. */
#define BS_ENET_EIMR_BABR    (1U)          /*!< Bit field size in bits for ENET_EIMR_BABR. */

/*! @brief Read current value of the ENET_EIMR_BABR field. */
#define BR_ENET_EIMR_BABR(x) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_BABR))

/*! @brief Format value for bitfield ENET_EIMR_BABR. */
#define BF_ENET_EIMR_BABR(v) ((uint32_t)((uint32_t)(v) << BP_ENET_EIMR_BABR) & BM_ENET_EIMR_BABR)

/*! @brief Set the BABR field to a new value. */
#define BW_ENET_EIMR_BABR(x, v) (BITBAND_ACCESS32(HW_ENET_EIMR_ADDR(x), BP_ENET_EIMR_BABR) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_RDAR - Receive Descriptor Active Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RDAR - Receive Descriptor Active Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * RDAR is a command register, written by the user, to indicate that the receive
 * descriptor ring has been updated, that is, that the driver produced empty
 * receive buffers with the empty bit set.
 */
typedef union _hw_enet_rdar
{
    uint32_t U;
    struct _hw_enet_rdar_bitfields
    {
        uint32_t RESERVED0 : 24;       /*!< [23:0]  */
        uint32_t RDAR : 1;             /*!< [24] Receive Descriptor Active */
        uint32_t RESERVED1 : 7;        /*!< [31:25]  */
    } B;
} hw_enet_rdar_t;

/*!
 * @name Constants and macros for entire ENET_RDAR register
 */
/*@{*/
#define HW_ENET_RDAR_ADDR(x)     ((uint32_t)(x) + 0x10U)

#define HW_ENET_RDAR(x)          (*(__IO hw_enet_rdar_t *) HW_ENET_RDAR_ADDR(x))
#define HW_ENET_RDAR_RD(x)       (HW_ENET_RDAR(x).U)
#define HW_ENET_RDAR_WR(x, v)    (HW_ENET_RDAR(x).U = (v))
#define HW_ENET_RDAR_SET(x, v)   (HW_ENET_RDAR_WR(x, HW_ENET_RDAR_RD(x) |  (v)))
#define HW_ENET_RDAR_CLR(x, v)   (HW_ENET_RDAR_WR(x, HW_ENET_RDAR_RD(x) & ~(v)))
#define HW_ENET_RDAR_TOG(x, v)   (HW_ENET_RDAR_WR(x, HW_ENET_RDAR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_RDAR bitfields
 */

/*!
 * @name Register ENET_RDAR, field RDAR[24] (RW)
 *
 * Always set to 1 when this register is written, regardless of the value
 * written. This field is cleared by the MAC device when no additional empty
 * descriptors remain in the receive ring. It is also cleared when ECR[ETHEREN] transitions
 * from set to cleared or when ECR[RESET] is set.
 */
/*@{*/
#define BP_ENET_RDAR_RDAR    (24U)         /*!< Bit position for ENET_RDAR_RDAR. */
#define BM_ENET_RDAR_RDAR    (0x01000000U) /*!< Bit mask for ENET_RDAR_RDAR. */
#define BS_ENET_RDAR_RDAR    (1U)          /*!< Bit field size in bits for ENET_RDAR_RDAR. */

/*! @brief Read current value of the ENET_RDAR_RDAR field. */
#define BR_ENET_RDAR_RDAR(x) (BITBAND_ACCESS32(HW_ENET_RDAR_ADDR(x), BP_ENET_RDAR_RDAR))

/*! @brief Format value for bitfield ENET_RDAR_RDAR. */
#define BF_ENET_RDAR_RDAR(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RDAR_RDAR) & BM_ENET_RDAR_RDAR)

/*! @brief Set the RDAR field to a new value. */
#define BW_ENET_RDAR_RDAR(x, v) (BITBAND_ACCESS32(HW_ENET_RDAR_ADDR(x), BP_ENET_RDAR_RDAR) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_TDAR - Transmit Descriptor Active Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_TDAR - Transmit Descriptor Active Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The TDAR is a command register that the user writes to indicate that the
 * transmit descriptor ring has been updated, that is, that transmit buffers have
 * been produced by the driver with the ready bit set in the buffer descriptor. The
 * TDAR register is cleared at reset, when ECR[ETHEREN] transitions from set to
 * cleared, or when ECR[RESET] is set.
 */
typedef union _hw_enet_tdar
{
    uint32_t U;
    struct _hw_enet_tdar_bitfields
    {
        uint32_t RESERVED0 : 24;       /*!< [23:0]  */
        uint32_t TDAR : 1;             /*!< [24] Transmit Descriptor Active */
        uint32_t RESERVED1 : 7;        /*!< [31:25]  */
    } B;
} hw_enet_tdar_t;

/*!
 * @name Constants and macros for entire ENET_TDAR register
 */
/*@{*/
#define HW_ENET_TDAR_ADDR(x)     ((uint32_t)(x) + 0x14U)

#define HW_ENET_TDAR(x)          (*(__IO hw_enet_tdar_t *) HW_ENET_TDAR_ADDR(x))
#define HW_ENET_TDAR_RD(x)       (HW_ENET_TDAR(x).U)
#define HW_ENET_TDAR_WR(x, v)    (HW_ENET_TDAR(x).U = (v))
#define HW_ENET_TDAR_SET(x, v)   (HW_ENET_TDAR_WR(x, HW_ENET_TDAR_RD(x) |  (v)))
#define HW_ENET_TDAR_CLR(x, v)   (HW_ENET_TDAR_WR(x, HW_ENET_TDAR_RD(x) & ~(v)))
#define HW_ENET_TDAR_TOG(x, v)   (HW_ENET_TDAR_WR(x, HW_ENET_TDAR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TDAR bitfields
 */

/*!
 * @name Register ENET_TDAR, field TDAR[24] (RW)
 *
 * Always set to 1 when this register is written, regardless of the value
 * written. This bit is cleared by the MAC device when no additional ready descriptors
 * remain in the transmit ring. Also cleared when ECR[ETHEREN] transitions from
 * set to cleared or when ECR[RESET] is set.
 */
/*@{*/
#define BP_ENET_TDAR_TDAR    (24U)         /*!< Bit position for ENET_TDAR_TDAR. */
#define BM_ENET_TDAR_TDAR    (0x01000000U) /*!< Bit mask for ENET_TDAR_TDAR. */
#define BS_ENET_TDAR_TDAR    (1U)          /*!< Bit field size in bits for ENET_TDAR_TDAR. */

/*! @brief Read current value of the ENET_TDAR_TDAR field. */
#define BR_ENET_TDAR_TDAR(x) (BITBAND_ACCESS32(HW_ENET_TDAR_ADDR(x), BP_ENET_TDAR_TDAR))

/*! @brief Format value for bitfield ENET_TDAR_TDAR. */
#define BF_ENET_TDAR_TDAR(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TDAR_TDAR) & BM_ENET_TDAR_TDAR)

/*! @brief Set the TDAR field to a new value. */
#define BW_ENET_TDAR_TDAR(x, v) (BITBAND_ACCESS32(HW_ENET_TDAR_ADDR(x), BP_ENET_TDAR_TDAR) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_ECR - Ethernet Control Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_ECR - Ethernet Control Register (RW)
 *
 * Reset value: 0xF0000000U
 *
 * ECR is a read/write user register, though hardware may also alter fields in
 * this register. It controls many of the high level features of the Ethernet MAC,
 * including legacy FEC support through the EN1588 field.
 */
typedef union _hw_enet_ecr
{
    uint32_t U;
    struct _hw_enet_ecr_bitfields
    {
        uint32_t RESET : 1;            /*!< [0] Ethernet MAC Reset */
        uint32_t ETHEREN : 1;          /*!< [1] Ethernet Enable */
        uint32_t MAGICEN : 1;          /*!< [2] Magic Packet Detection Enable */
        uint32_t SLEEP : 1;            /*!< [3] Sleep Mode Enable */
        uint32_t EN1588 : 1;           /*!< [4] EN1588 Enable */
        uint32_t RESERVED0 : 1;        /*!< [5]  */
        uint32_t DBGEN : 1;            /*!< [6] Debug Enable */
        uint32_t STOPEN : 1;           /*!< [7] STOPEN Signal Control */
        uint32_t DBSWP : 1;            /*!< [8] Descriptor Byte Swapping Enable */
        uint32_t RESERVED1 : 23;       /*!< [31:9]  */
    } B;
} hw_enet_ecr_t;

/*!
 * @name Constants and macros for entire ENET_ECR register
 */
/*@{*/
#define HW_ENET_ECR_ADDR(x)      ((uint32_t)(x) + 0x24U)

#define HW_ENET_ECR(x)           (*(__IO hw_enet_ecr_t *) HW_ENET_ECR_ADDR(x))
#define HW_ENET_ECR_RD(x)        (HW_ENET_ECR(x).U)
#define HW_ENET_ECR_WR(x, v)     (HW_ENET_ECR(x).U = (v))
#define HW_ENET_ECR_SET(x, v)    (HW_ENET_ECR_WR(x, HW_ENET_ECR_RD(x) |  (v)))
#define HW_ENET_ECR_CLR(x, v)    (HW_ENET_ECR_WR(x, HW_ENET_ECR_RD(x) & ~(v)))
#define HW_ENET_ECR_TOG(x, v)    (HW_ENET_ECR_WR(x, HW_ENET_ECR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_ECR bitfields
 */

/*!
 * @name Register ENET_ECR, field RESET[0] (RW)
 *
 * When this field is set, it clears the ETHEREN field.
 */
/*@{*/
#define BP_ENET_ECR_RESET    (0U)          /*!< Bit position for ENET_ECR_RESET. */
#define BM_ENET_ECR_RESET    (0x00000001U) /*!< Bit mask for ENET_ECR_RESET. */
#define BS_ENET_ECR_RESET    (1U)          /*!< Bit field size in bits for ENET_ECR_RESET. */

/*! @brief Read current value of the ENET_ECR_RESET field. */
#define BR_ENET_ECR_RESET(x) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_RESET))

/*! @brief Format value for bitfield ENET_ECR_RESET. */
#define BF_ENET_ECR_RESET(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ECR_RESET) & BM_ENET_ECR_RESET)

/*! @brief Set the RESET field to a new value. */
#define BW_ENET_ECR_RESET(x, v) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_RESET) = (v))
/*@}*/

/*!
 * @name Register ENET_ECR, field ETHEREN[1] (RW)
 *
 * Enables/disables the Ethernet MAC. When the MAC is disabled, the buffer
 * descriptors for an aborted transmit frame are not updated. The uDMA, buffer
 * descriptor, and FIFO control logic are reset, including the buffer descriptor and
 * FIFO pointers. Hardware clears this field under the following conditions: RESET
 * is set by software An error condition causes the EBERR field to set. ETHEREN
 * must be set at the very last step during ENET
 * configuration/setup/initialization, only after all other ENET-related registers have been configured. If ETHEREN
 * is cleared to 0 by software then then next time ETHEREN is set, the EIR
 * interrupts must cleared to 0 due to previous pending interrupts.
 *
 * Values:
 * - 0 - Reception immediately stops and transmission stops after a bad CRC is
 *     appended to any currently transmitted frame.
 * - 1 - MAC is enabled, and reception and transmission are possible.
 */
/*@{*/
#define BP_ENET_ECR_ETHEREN  (1U)          /*!< Bit position for ENET_ECR_ETHEREN. */
#define BM_ENET_ECR_ETHEREN  (0x00000002U) /*!< Bit mask for ENET_ECR_ETHEREN. */
#define BS_ENET_ECR_ETHEREN  (1U)          /*!< Bit field size in bits for ENET_ECR_ETHEREN. */

/*! @brief Read current value of the ENET_ECR_ETHEREN field. */
#define BR_ENET_ECR_ETHEREN(x) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_ETHEREN))

/*! @brief Format value for bitfield ENET_ECR_ETHEREN. */
#define BF_ENET_ECR_ETHEREN(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ECR_ETHEREN) & BM_ENET_ECR_ETHEREN)

/*! @brief Set the ETHEREN field to a new value. */
#define BW_ENET_ECR_ETHEREN(x, v) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_ETHEREN) = (v))
/*@}*/

/*!
 * @name Register ENET_ECR, field MAGICEN[2] (RW)
 *
 * Enables/disables magic packet detection. MAGICEN is relevant only if the
 * SLEEP field is set. If MAGICEN is set, changing the SLEEP field enables/disables
 * sleep mode and magic packet detection.
 *
 * Values:
 * - 0 - Magic detection logic disabled.
 * - 1 - The MAC core detects magic packets and asserts EIR[WAKEUP] when a frame
 *     is detected.
 */
/*@{*/
#define BP_ENET_ECR_MAGICEN  (2U)          /*!< Bit position for ENET_ECR_MAGICEN. */
#define BM_ENET_ECR_MAGICEN  (0x00000004U) /*!< Bit mask for ENET_ECR_MAGICEN. */
#define BS_ENET_ECR_MAGICEN  (1U)          /*!< Bit field size in bits for ENET_ECR_MAGICEN. */

/*! @brief Read current value of the ENET_ECR_MAGICEN field. */
#define BR_ENET_ECR_MAGICEN(x) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_MAGICEN))

/*! @brief Format value for bitfield ENET_ECR_MAGICEN. */
#define BF_ENET_ECR_MAGICEN(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ECR_MAGICEN) & BM_ENET_ECR_MAGICEN)

/*! @brief Set the MAGICEN field to a new value. */
#define BW_ENET_ECR_MAGICEN(x, v) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_MAGICEN) = (v))
/*@}*/

/*!
 * @name Register ENET_ECR, field SLEEP[3] (RW)
 *
 * Values:
 * - 0 - Normal operating mode.
 * - 1 - Sleep mode.
 */
/*@{*/
#define BP_ENET_ECR_SLEEP    (3U)          /*!< Bit position for ENET_ECR_SLEEP. */
#define BM_ENET_ECR_SLEEP    (0x00000008U) /*!< Bit mask for ENET_ECR_SLEEP. */
#define BS_ENET_ECR_SLEEP    (1U)          /*!< Bit field size in bits for ENET_ECR_SLEEP. */

/*! @brief Read current value of the ENET_ECR_SLEEP field. */
#define BR_ENET_ECR_SLEEP(x) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_SLEEP))

/*! @brief Format value for bitfield ENET_ECR_SLEEP. */
#define BF_ENET_ECR_SLEEP(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ECR_SLEEP) & BM_ENET_ECR_SLEEP)

/*! @brief Set the SLEEP field to a new value. */
#define BW_ENET_ECR_SLEEP(x, v) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_SLEEP) = (v))
/*@}*/

/*!
 * @name Register ENET_ECR, field EN1588[4] (RW)
 *
 * Enables enhanced functionality of the MAC.
 *
 * Values:
 * - 0 - Legacy FEC buffer descriptors and functions enabled.
 * - 1 - Enhanced frame time-stamping functions enabled.
 */
/*@{*/
#define BP_ENET_ECR_EN1588   (4U)          /*!< Bit position for ENET_ECR_EN1588. */
#define BM_ENET_ECR_EN1588   (0x00000010U) /*!< Bit mask for ENET_ECR_EN1588. */
#define BS_ENET_ECR_EN1588   (1U)          /*!< Bit field size in bits for ENET_ECR_EN1588. */

/*! @brief Read current value of the ENET_ECR_EN1588 field. */
#define BR_ENET_ECR_EN1588(x) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_EN1588))

/*! @brief Format value for bitfield ENET_ECR_EN1588. */
#define BF_ENET_ECR_EN1588(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ECR_EN1588) & BM_ENET_ECR_EN1588)

/*! @brief Set the EN1588 field to a new value. */
#define BW_ENET_ECR_EN1588(x, v) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_EN1588) = (v))
/*@}*/

/*!
 * @name Register ENET_ECR, field DBGEN[6] (RW)
 *
 * Enables the MAC to enter hardware freeze mode when the device enters debug
 * mode.
 *
 * Values:
 * - 0 - MAC continues operation in debug mode.
 * - 1 - MAC enters hardware freeze mode when the processor is in debug mode.
 */
/*@{*/
#define BP_ENET_ECR_DBGEN    (6U)          /*!< Bit position for ENET_ECR_DBGEN. */
#define BM_ENET_ECR_DBGEN    (0x00000040U) /*!< Bit mask for ENET_ECR_DBGEN. */
#define BS_ENET_ECR_DBGEN    (1U)          /*!< Bit field size in bits for ENET_ECR_DBGEN. */

/*! @brief Read current value of the ENET_ECR_DBGEN field. */
#define BR_ENET_ECR_DBGEN(x) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_DBGEN))

/*! @brief Format value for bitfield ENET_ECR_DBGEN. */
#define BF_ENET_ECR_DBGEN(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ECR_DBGEN) & BM_ENET_ECR_DBGEN)

/*! @brief Set the DBGEN field to a new value. */
#define BW_ENET_ECR_DBGEN(x, v) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_DBGEN) = (v))
/*@}*/

/*!
 * @name Register ENET_ECR, field STOPEN[7] (RW)
 *
 * Controls device behavior in doze mode. In doze mode, if this field is set
 * then all the clocks of the ENET assembly are disabled, except the RMII /MII
 * clock. Doze mode is similar to a conditional stop mode entry for the ENET assembly
 * depending on ECR[STOPEN]. If module clocks are gated in this mode, the module
 * can still wake the system after receiving a magic packet in stop mode. MAGICEN
 * must be set prior to entering sleep/stop mode.
 */
/*@{*/
#define BP_ENET_ECR_STOPEN   (7U)          /*!< Bit position for ENET_ECR_STOPEN. */
#define BM_ENET_ECR_STOPEN   (0x00000080U) /*!< Bit mask for ENET_ECR_STOPEN. */
#define BS_ENET_ECR_STOPEN   (1U)          /*!< Bit field size in bits for ENET_ECR_STOPEN. */

/*! @brief Read current value of the ENET_ECR_STOPEN field. */
#define BR_ENET_ECR_STOPEN(x) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_STOPEN))

/*! @brief Format value for bitfield ENET_ECR_STOPEN. */
#define BF_ENET_ECR_STOPEN(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ECR_STOPEN) & BM_ENET_ECR_STOPEN)

/*! @brief Set the STOPEN field to a new value. */
#define BW_ENET_ECR_STOPEN(x, v) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_STOPEN) = (v))
/*@}*/

/*!
 * @name Register ENET_ECR, field DBSWP[8] (RW)
 *
 * Swaps the byte locations of the buffer descriptors. This field must be
 * written to 1 after reset.
 *
 * Values:
 * - 0 - The buffer descriptor bytes are not swapped to support big-endian
 *     devices.
 * - 1 - The buffer descriptor bytes are swapped to support little-endian
 *     devices.
 */
/*@{*/
#define BP_ENET_ECR_DBSWP    (8U)          /*!< Bit position for ENET_ECR_DBSWP. */
#define BM_ENET_ECR_DBSWP    (0x00000100U) /*!< Bit mask for ENET_ECR_DBSWP. */
#define BS_ENET_ECR_DBSWP    (1U)          /*!< Bit field size in bits for ENET_ECR_DBSWP. */

/*! @brief Read current value of the ENET_ECR_DBSWP field. */
#define BR_ENET_ECR_DBSWP(x) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_DBSWP))

/*! @brief Format value for bitfield ENET_ECR_DBSWP. */
#define BF_ENET_ECR_DBSWP(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ECR_DBSWP) & BM_ENET_ECR_DBSWP)

/*! @brief Set the DBSWP field to a new value. */
#define BW_ENET_ECR_DBSWP(x, v) (BITBAND_ACCESS32(HW_ENET_ECR_ADDR(x), BP_ENET_ECR_DBSWP) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_MMFR - MII Management Frame Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_MMFR - MII Management Frame Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Writing to MMFR triggers a management frame transaction to the PHY device
 * unless MSCR is programmed to zero. If MSCR is changed from zero to non-zero
 * during a write to MMFR, an MII frame is generated with the data previously written
 * to the MMFR. This allows MMFR and MSCR to be programmed in either order if
 * MSCR is currently zero. If the MMFR register is written while frame generation is
 * in progress, the frame contents are altered. Software must use the EIR[MII]
 * interrupt indication to avoid writing to the MMFR register while frame
 * generation is in progress.
 */
typedef union _hw_enet_mmfr
{
    uint32_t U;
    struct _hw_enet_mmfr_bitfields
    {
        uint32_t DATA : 16;            /*!< [15:0] Management Frame Data */
        uint32_t TA : 2;               /*!< [17:16] Turn Around */
        uint32_t RA : 5;               /*!< [22:18] Register Address */
        uint32_t PA : 5;               /*!< [27:23] PHY Address */
        uint32_t OP : 2;               /*!< [29:28] Operation Code */
        uint32_t ST : 2;               /*!< [31:30] Start Of Frame Delimiter */
    } B;
} hw_enet_mmfr_t;

/*!
 * @name Constants and macros for entire ENET_MMFR register
 */
/*@{*/
#define HW_ENET_MMFR_ADDR(x)     ((uint32_t)(x) + 0x40U)

#define HW_ENET_MMFR(x)          (*(__IO hw_enet_mmfr_t *) HW_ENET_MMFR_ADDR(x))
#define HW_ENET_MMFR_RD(x)       (HW_ENET_MMFR(x).U)
#define HW_ENET_MMFR_WR(x, v)    (HW_ENET_MMFR(x).U = (v))
#define HW_ENET_MMFR_SET(x, v)   (HW_ENET_MMFR_WR(x, HW_ENET_MMFR_RD(x) |  (v)))
#define HW_ENET_MMFR_CLR(x, v)   (HW_ENET_MMFR_WR(x, HW_ENET_MMFR_RD(x) & ~(v)))
#define HW_ENET_MMFR_TOG(x, v)   (HW_ENET_MMFR_WR(x, HW_ENET_MMFR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_MMFR bitfields
 */

/*!
 * @name Register ENET_MMFR, field DATA[15:0] (RW)
 *
 * This is the field for data to be written to or read from the PHY register.
 */
/*@{*/
#define BP_ENET_MMFR_DATA    (0U)          /*!< Bit position for ENET_MMFR_DATA. */
#define BM_ENET_MMFR_DATA    (0x0000FFFFU) /*!< Bit mask for ENET_MMFR_DATA. */
#define BS_ENET_MMFR_DATA    (16U)         /*!< Bit field size in bits for ENET_MMFR_DATA. */

/*! @brief Read current value of the ENET_MMFR_DATA field. */
#define BR_ENET_MMFR_DATA(x) (HW_ENET_MMFR(x).B.DATA)

/*! @brief Format value for bitfield ENET_MMFR_DATA. */
#define BF_ENET_MMFR_DATA(v) ((uint32_t)((uint32_t)(v) << BP_ENET_MMFR_DATA) & BM_ENET_MMFR_DATA)

/*! @brief Set the DATA field to a new value. */
#define BW_ENET_MMFR_DATA(x, v) (HW_ENET_MMFR_WR(x, (HW_ENET_MMFR_RD(x) & ~BM_ENET_MMFR_DATA) | BF_ENET_MMFR_DATA(v)))
/*@}*/

/*!
 * @name Register ENET_MMFR, field TA[17:16] (RW)
 *
 * This field must be programmed to 10 to generate a valid MII management frame.
 */
/*@{*/
#define BP_ENET_MMFR_TA      (16U)         /*!< Bit position for ENET_MMFR_TA. */
#define BM_ENET_MMFR_TA      (0x00030000U) /*!< Bit mask for ENET_MMFR_TA. */
#define BS_ENET_MMFR_TA      (2U)          /*!< Bit field size in bits for ENET_MMFR_TA. */

/*! @brief Read current value of the ENET_MMFR_TA field. */
#define BR_ENET_MMFR_TA(x)   (HW_ENET_MMFR(x).B.TA)

/*! @brief Format value for bitfield ENET_MMFR_TA. */
#define BF_ENET_MMFR_TA(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_MMFR_TA) & BM_ENET_MMFR_TA)

/*! @brief Set the TA field to a new value. */
#define BW_ENET_MMFR_TA(x, v) (HW_ENET_MMFR_WR(x, (HW_ENET_MMFR_RD(x) & ~BM_ENET_MMFR_TA) | BF_ENET_MMFR_TA(v)))
/*@}*/

/*!
 * @name Register ENET_MMFR, field RA[22:18] (RW)
 *
 * Specifies one of up to 32 registers within the specified PHY device.
 */
/*@{*/
#define BP_ENET_MMFR_RA      (18U)         /*!< Bit position for ENET_MMFR_RA. */
#define BM_ENET_MMFR_RA      (0x007C0000U) /*!< Bit mask for ENET_MMFR_RA. */
#define BS_ENET_MMFR_RA      (5U)          /*!< Bit field size in bits for ENET_MMFR_RA. */

/*! @brief Read current value of the ENET_MMFR_RA field. */
#define BR_ENET_MMFR_RA(x)   (HW_ENET_MMFR(x).B.RA)

/*! @brief Format value for bitfield ENET_MMFR_RA. */
#define BF_ENET_MMFR_RA(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_MMFR_RA) & BM_ENET_MMFR_RA)

/*! @brief Set the RA field to a new value. */
#define BW_ENET_MMFR_RA(x, v) (HW_ENET_MMFR_WR(x, (HW_ENET_MMFR_RD(x) & ~BM_ENET_MMFR_RA) | BF_ENET_MMFR_RA(v)))
/*@}*/

/*!
 * @name Register ENET_MMFR, field PA[27:23] (RW)
 *
 * Specifies one of up to 32 attached PHY devices.
 */
/*@{*/
#define BP_ENET_MMFR_PA      (23U)         /*!< Bit position for ENET_MMFR_PA. */
#define BM_ENET_MMFR_PA      (0x0F800000U) /*!< Bit mask for ENET_MMFR_PA. */
#define BS_ENET_MMFR_PA      (5U)          /*!< Bit field size in bits for ENET_MMFR_PA. */

/*! @brief Read current value of the ENET_MMFR_PA field. */
#define BR_ENET_MMFR_PA(x)   (HW_ENET_MMFR(x).B.PA)

/*! @brief Format value for bitfield ENET_MMFR_PA. */
#define BF_ENET_MMFR_PA(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_MMFR_PA) & BM_ENET_MMFR_PA)

/*! @brief Set the PA field to a new value. */
#define BW_ENET_MMFR_PA(x, v) (HW_ENET_MMFR_WR(x, (HW_ENET_MMFR_RD(x) & ~BM_ENET_MMFR_PA) | BF_ENET_MMFR_PA(v)))
/*@}*/

/*!
 * @name Register ENET_MMFR, field OP[29:28] (RW)
 *
 * Determines the frame operation.
 *
 * Values:
 * - 00 - Write frame operation, but not MII compliant.
 * - 01 - Write frame operation for a valid MII management frame.
 * - 10 - Read frame operation for a valid MII management frame.
 * - 11 - Read frame operation, but not MII compliant.
 */
/*@{*/
#define BP_ENET_MMFR_OP      (28U)         /*!< Bit position for ENET_MMFR_OP. */
#define BM_ENET_MMFR_OP      (0x30000000U) /*!< Bit mask for ENET_MMFR_OP. */
#define BS_ENET_MMFR_OP      (2U)          /*!< Bit field size in bits for ENET_MMFR_OP. */

/*! @brief Read current value of the ENET_MMFR_OP field. */
#define BR_ENET_MMFR_OP(x)   (HW_ENET_MMFR(x).B.OP)

/*! @brief Format value for bitfield ENET_MMFR_OP. */
#define BF_ENET_MMFR_OP(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_MMFR_OP) & BM_ENET_MMFR_OP)

/*! @brief Set the OP field to a new value. */
#define BW_ENET_MMFR_OP(x, v) (HW_ENET_MMFR_WR(x, (HW_ENET_MMFR_RD(x) & ~BM_ENET_MMFR_OP) | BF_ENET_MMFR_OP(v)))
/*@}*/

/*!
 * @name Register ENET_MMFR, field ST[31:30] (RW)
 *
 * These fields must be programmed to 01 for a valid MII management frame.
 */
/*@{*/
#define BP_ENET_MMFR_ST      (30U)         /*!< Bit position for ENET_MMFR_ST. */
#define BM_ENET_MMFR_ST      (0xC0000000U) /*!< Bit mask for ENET_MMFR_ST. */
#define BS_ENET_MMFR_ST      (2U)          /*!< Bit field size in bits for ENET_MMFR_ST. */

/*! @brief Read current value of the ENET_MMFR_ST field. */
#define BR_ENET_MMFR_ST(x)   (HW_ENET_MMFR(x).B.ST)

/*! @brief Format value for bitfield ENET_MMFR_ST. */
#define BF_ENET_MMFR_ST(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_MMFR_ST) & BM_ENET_MMFR_ST)

/*! @brief Set the ST field to a new value. */
#define BW_ENET_MMFR_ST(x, v) (HW_ENET_MMFR_WR(x, (HW_ENET_MMFR_RD(x) & ~BM_ENET_MMFR_ST) | BF_ENET_MMFR_ST(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_MSCR - MII Speed Control Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_MSCR - MII Speed Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * MSCR provides control of the MII clock (MDC pin) frequency and allows a
 * preamble drop on the MII management frame. The MII_SPEED field must be programmed
 * with a value to provide an MDC frequency of less than or equal to 2.5 MHz to be
 * compliant with the IEEE 802.3 MII specification. The MII_SPEED must be set to
 * a non-zero value to source a read or write management frame. After the
 * management frame is complete, the MSCR register may optionally be cleared to turn
 * off MDC. The MDC signal generated has a 50% duty cycle except when MII_SPEED
 * changes during operation. This change takes effect following a rising or falling
 * edge of MDC. If the internal module clock is 25 MHz, programming this register
 * to 0x0000_0004 results in an MDC as stated in the following equation: 25 MHz
 * / ((4 + 1) x 2) = 2.5 MHz The following table shows the optimum values for
 * MII_SPEED as a function of internal module clock frequency. Programming Examples
 * for MSCR Internal MAC clock frequency MSCR [MII_SPEED] MDC frequency 25 MHz
 * 0x4 2.50 MHz 33 MHz 0x6 2.36 MHz 40 MHz 0x7 2.50 MHz 50 MHz 0x9 2.50 MHz 66 MHz
 * 0xD 2.36 MHz
 */
typedef union _hw_enet_mscr
{
    uint32_t U;
    struct _hw_enet_mscr_bitfields
    {
        uint32_t RESERVED0 : 1;        /*!< [0]  */
        uint32_t MII_SPEED : 6;        /*!< [6:1] MII Speed */
        uint32_t DIS_PRE : 1;          /*!< [7] Disable Preamble */
        uint32_t HOLDTIME : 3;         /*!< [10:8] Hold time On MDIO Output */
        uint32_t RESERVED1 : 21;       /*!< [31:11]  */
    } B;
} hw_enet_mscr_t;

/*!
 * @name Constants and macros for entire ENET_MSCR register
 */
/*@{*/
#define HW_ENET_MSCR_ADDR(x)     ((uint32_t)(x) + 0x44U)

#define HW_ENET_MSCR(x)          (*(__IO hw_enet_mscr_t *) HW_ENET_MSCR_ADDR(x))
#define HW_ENET_MSCR_RD(x)       (HW_ENET_MSCR(x).U)
#define HW_ENET_MSCR_WR(x, v)    (HW_ENET_MSCR(x).U = (v))
#define HW_ENET_MSCR_SET(x, v)   (HW_ENET_MSCR_WR(x, HW_ENET_MSCR_RD(x) |  (v)))
#define HW_ENET_MSCR_CLR(x, v)   (HW_ENET_MSCR_WR(x, HW_ENET_MSCR_RD(x) & ~(v)))
#define HW_ENET_MSCR_TOG(x, v)   (HW_ENET_MSCR_WR(x, HW_ENET_MSCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_MSCR bitfields
 */

/*!
 * @name Register ENET_MSCR, field MII_SPEED[6:1] (RW)
 *
 * Controls the frequency of the MII management interface clock (MDC) relative
 * to the internal module clock. A value of 0 in this field turns off MDC and
 * leaves it in low voltage state. Any non-zero value results in the MDC frequency
 * of: 1/((MII_SPEED + 1) x 2) of the internal module clock frequency
 */
/*@{*/
#define BP_ENET_MSCR_MII_SPEED (1U)        /*!< Bit position for ENET_MSCR_MII_SPEED. */
#define BM_ENET_MSCR_MII_SPEED (0x0000007EU) /*!< Bit mask for ENET_MSCR_MII_SPEED. */
#define BS_ENET_MSCR_MII_SPEED (6U)        /*!< Bit field size in bits for ENET_MSCR_MII_SPEED. */

/*! @brief Read current value of the ENET_MSCR_MII_SPEED field. */
#define BR_ENET_MSCR_MII_SPEED(x) (HW_ENET_MSCR(x).B.MII_SPEED)

/*! @brief Format value for bitfield ENET_MSCR_MII_SPEED. */
#define BF_ENET_MSCR_MII_SPEED(v) ((uint32_t)((uint32_t)(v) << BP_ENET_MSCR_MII_SPEED) & BM_ENET_MSCR_MII_SPEED)

/*! @brief Set the MII_SPEED field to a new value. */
#define BW_ENET_MSCR_MII_SPEED(x, v) (HW_ENET_MSCR_WR(x, (HW_ENET_MSCR_RD(x) & ~BM_ENET_MSCR_MII_SPEED) | BF_ENET_MSCR_MII_SPEED(v)))
/*@}*/

/*!
 * @name Register ENET_MSCR, field DIS_PRE[7] (RW)
 *
 * Enables/disables prepending a preamble to the MII management frame. The MII
 * standard allows the preamble to be dropped if the attached PHY devices do not
 * require it.
 *
 * Values:
 * - 0 - Preamble enabled.
 * - 1 - Preamble (32 ones) is not prepended to the MII management frame.
 */
/*@{*/
#define BP_ENET_MSCR_DIS_PRE (7U)          /*!< Bit position for ENET_MSCR_DIS_PRE. */
#define BM_ENET_MSCR_DIS_PRE (0x00000080U) /*!< Bit mask for ENET_MSCR_DIS_PRE. */
#define BS_ENET_MSCR_DIS_PRE (1U)          /*!< Bit field size in bits for ENET_MSCR_DIS_PRE. */

/*! @brief Read current value of the ENET_MSCR_DIS_PRE field. */
#define BR_ENET_MSCR_DIS_PRE(x) (BITBAND_ACCESS32(HW_ENET_MSCR_ADDR(x), BP_ENET_MSCR_DIS_PRE))

/*! @brief Format value for bitfield ENET_MSCR_DIS_PRE. */
#define BF_ENET_MSCR_DIS_PRE(v) ((uint32_t)((uint32_t)(v) << BP_ENET_MSCR_DIS_PRE) & BM_ENET_MSCR_DIS_PRE)

/*! @brief Set the DIS_PRE field to a new value. */
#define BW_ENET_MSCR_DIS_PRE(x, v) (BITBAND_ACCESS32(HW_ENET_MSCR_ADDR(x), BP_ENET_MSCR_DIS_PRE) = (v))
/*@}*/

/*!
 * @name Register ENET_MSCR, field HOLDTIME[10:8] (RW)
 *
 * IEEE802.3 clause 22 defines a minimum of 10 ns for the hold time on the MDIO
 * output. Depending on the host bus frequency, the setting may need to be
 * increased.
 *
 * Values:
 * - 000 - 1 internal module clock cycle
 * - 001 - 2 internal module clock cycles
 * - 010 - 3 internal module clock cycles
 * - 111 - 8 internal module clock cycles
 */
/*@{*/
#define BP_ENET_MSCR_HOLDTIME (8U)         /*!< Bit position for ENET_MSCR_HOLDTIME. */
#define BM_ENET_MSCR_HOLDTIME (0x00000700U) /*!< Bit mask for ENET_MSCR_HOLDTIME. */
#define BS_ENET_MSCR_HOLDTIME (3U)         /*!< Bit field size in bits for ENET_MSCR_HOLDTIME. */

/*! @brief Read current value of the ENET_MSCR_HOLDTIME field. */
#define BR_ENET_MSCR_HOLDTIME(x) (HW_ENET_MSCR(x).B.HOLDTIME)

/*! @brief Format value for bitfield ENET_MSCR_HOLDTIME. */
#define BF_ENET_MSCR_HOLDTIME(v) ((uint32_t)((uint32_t)(v) << BP_ENET_MSCR_HOLDTIME) & BM_ENET_MSCR_HOLDTIME)

/*! @brief Set the HOLDTIME field to a new value. */
#define BW_ENET_MSCR_HOLDTIME(x, v) (HW_ENET_MSCR_WR(x, (HW_ENET_MSCR_RD(x) & ~BM_ENET_MSCR_HOLDTIME) | BF_ENET_MSCR_HOLDTIME(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_MIBC - MIB Control Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_MIBC - MIB Control Register (RW)
 *
 * Reset value: 0xC0000000U
 *
 * MIBC is a read/write register controlling and observing the state of the MIB
 * block. Access this register to disable the MIB block operation or clear the
 * MIB counters. The MIB_DIS field resets to 1.
 */
typedef union _hw_enet_mibc
{
    uint32_t U;
    struct _hw_enet_mibc_bitfields
    {
        uint32_t RESERVED0 : 29;       /*!< [28:0]  */
        uint32_t MIB_CLEAR : 1;        /*!< [29] MIB Clear */
        uint32_t MIB_IDLE : 1;         /*!< [30] MIB Idle */
        uint32_t MIB_DIS : 1;          /*!< [31] Disable MIB Logic */
    } B;
} hw_enet_mibc_t;

/*!
 * @name Constants and macros for entire ENET_MIBC register
 */
/*@{*/
#define HW_ENET_MIBC_ADDR(x)     ((uint32_t)(x) + 0x64U)

#define HW_ENET_MIBC(x)          (*(__IO hw_enet_mibc_t *) HW_ENET_MIBC_ADDR(x))
#define HW_ENET_MIBC_RD(x)       (HW_ENET_MIBC(x).U)
#define HW_ENET_MIBC_WR(x, v)    (HW_ENET_MIBC(x).U = (v))
#define HW_ENET_MIBC_SET(x, v)   (HW_ENET_MIBC_WR(x, HW_ENET_MIBC_RD(x) |  (v)))
#define HW_ENET_MIBC_CLR(x, v)   (HW_ENET_MIBC_WR(x, HW_ENET_MIBC_RD(x) & ~(v)))
#define HW_ENET_MIBC_TOG(x, v)   (HW_ENET_MIBC_WR(x, HW_ENET_MIBC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_MIBC bitfields
 */

/*!
 * @name Register ENET_MIBC, field MIB_CLEAR[29] (RW)
 *
 * If set, all statistics counters are reset to 0. This field is not
 * self-clearing. To clear the MIB counters set and then clear the field.
 */
/*@{*/
#define BP_ENET_MIBC_MIB_CLEAR (29U)       /*!< Bit position for ENET_MIBC_MIB_CLEAR. */
#define BM_ENET_MIBC_MIB_CLEAR (0x20000000U) /*!< Bit mask for ENET_MIBC_MIB_CLEAR. */
#define BS_ENET_MIBC_MIB_CLEAR (1U)        /*!< Bit field size in bits for ENET_MIBC_MIB_CLEAR. */

/*! @brief Read current value of the ENET_MIBC_MIB_CLEAR field. */
#define BR_ENET_MIBC_MIB_CLEAR(x) (BITBAND_ACCESS32(HW_ENET_MIBC_ADDR(x), BP_ENET_MIBC_MIB_CLEAR))

/*! @brief Format value for bitfield ENET_MIBC_MIB_CLEAR. */
#define BF_ENET_MIBC_MIB_CLEAR(v) ((uint32_t)((uint32_t)(v) << BP_ENET_MIBC_MIB_CLEAR) & BM_ENET_MIBC_MIB_CLEAR)

/*! @brief Set the MIB_CLEAR field to a new value. */
#define BW_ENET_MIBC_MIB_CLEAR(x, v) (BITBAND_ACCESS32(HW_ENET_MIBC_ADDR(x), BP_ENET_MIBC_MIB_CLEAR) = (v))
/*@}*/

/*!
 * @name Register ENET_MIBC, field MIB_IDLE[30] (RO)
 *
 * If this status field is set, the MIB block is not currently updating any MIB
 * counters.
 */
/*@{*/
#define BP_ENET_MIBC_MIB_IDLE (30U)        /*!< Bit position for ENET_MIBC_MIB_IDLE. */
#define BM_ENET_MIBC_MIB_IDLE (0x40000000U) /*!< Bit mask for ENET_MIBC_MIB_IDLE. */
#define BS_ENET_MIBC_MIB_IDLE (1U)         /*!< Bit field size in bits for ENET_MIBC_MIB_IDLE. */

/*! @brief Read current value of the ENET_MIBC_MIB_IDLE field. */
#define BR_ENET_MIBC_MIB_IDLE(x) (BITBAND_ACCESS32(HW_ENET_MIBC_ADDR(x), BP_ENET_MIBC_MIB_IDLE))
/*@}*/

/*!
 * @name Register ENET_MIBC, field MIB_DIS[31] (RW)
 *
 * If this control field is set, the MIB logic halts and does not update any MIB
 * counters.
 */
/*@{*/
#define BP_ENET_MIBC_MIB_DIS (31U)         /*!< Bit position for ENET_MIBC_MIB_DIS. */
#define BM_ENET_MIBC_MIB_DIS (0x80000000U) /*!< Bit mask for ENET_MIBC_MIB_DIS. */
#define BS_ENET_MIBC_MIB_DIS (1U)          /*!< Bit field size in bits for ENET_MIBC_MIB_DIS. */

/*! @brief Read current value of the ENET_MIBC_MIB_DIS field. */
#define BR_ENET_MIBC_MIB_DIS(x) (BITBAND_ACCESS32(HW_ENET_MIBC_ADDR(x), BP_ENET_MIBC_MIB_DIS))

/*! @brief Format value for bitfield ENET_MIBC_MIB_DIS. */
#define BF_ENET_MIBC_MIB_DIS(v) ((uint32_t)((uint32_t)(v) << BP_ENET_MIBC_MIB_DIS) & BM_ENET_MIBC_MIB_DIS)

/*! @brief Set the MIB_DIS field to a new value. */
#define BW_ENET_MIBC_MIB_DIS(x, v) (BITBAND_ACCESS32(HW_ENET_MIBC_ADDR(x), BP_ENET_MIBC_MIB_DIS) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_RCR - Receive Control Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RCR - Receive Control Register (RW)
 *
 * Reset value: 0x05EE0001U
 */
typedef union _hw_enet_rcr
{
    uint32_t U;
    struct _hw_enet_rcr_bitfields
    {
        uint32_t LOOP : 1;             /*!< [0] Internal Loopback */
        uint32_t DRT : 1;              /*!< [1] Disable Receive On Transmit */
        uint32_t MII_MODE : 1;         /*!< [2] Media Independent Interface Mode */
        uint32_t PROM : 1;             /*!< [3] Promiscuous Mode */
        uint32_t BC_REJ : 1;           /*!< [4] Broadcast Frame Reject */
        uint32_t FCE : 1;              /*!< [5] Flow Control Enable */
        uint32_t RESERVED0 : 2;        /*!< [7:6]  */
        uint32_t RMII_MODE : 1;        /*!< [8] RMII Mode Enable */
        uint32_t RMII_10T : 1;         /*!< [9]  */
        uint32_t RESERVED1 : 2;        /*!< [11:10]  */
        uint32_t PADEN : 1;            /*!< [12] Enable Frame Padding Remove On Receive
                                        * */
        uint32_t PAUFWD : 1;           /*!< [13] Terminate/Forward Pause Frames */
        uint32_t CRCFWD : 1;           /*!< [14] Terminate/Forward Received CRC */
        uint32_t CFEN : 1;             /*!< [15] MAC Control Frame Enable */
        uint32_t MAX_FL : 14;          /*!< [29:16] Maximum Frame Length */
        uint32_t NLC : 1;              /*!< [30] Payload Length Check Disable */
        uint32_t GRS : 1;              /*!< [31] Graceful Receive Stopped */
    } B;
} hw_enet_rcr_t;

/*!
 * @name Constants and macros for entire ENET_RCR register
 */
/*@{*/
#define HW_ENET_RCR_ADDR(x)      ((uint32_t)(x) + 0x84U)

#define HW_ENET_RCR(x)           (*(__IO hw_enet_rcr_t *) HW_ENET_RCR_ADDR(x))
#define HW_ENET_RCR_RD(x)        (HW_ENET_RCR(x).U)
#define HW_ENET_RCR_WR(x, v)     (HW_ENET_RCR(x).U = (v))
#define HW_ENET_RCR_SET(x, v)    (HW_ENET_RCR_WR(x, HW_ENET_RCR_RD(x) |  (v)))
#define HW_ENET_RCR_CLR(x, v)    (HW_ENET_RCR_WR(x, HW_ENET_RCR_RD(x) & ~(v)))
#define HW_ENET_RCR_TOG(x, v)    (HW_ENET_RCR_WR(x, HW_ENET_RCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_RCR bitfields
 */

/*!
 * @name Register ENET_RCR, field LOOP[0] (RW)
 *
 * This is an MII internal loopback, therefore MII_MODE must be written to 1 and
 * RMII_MODE must be written to 0.
 *
 * Values:
 * - 0 - Loopback disabled.
 * - 1 - Transmitted frames are looped back internal to the device and transmit
 *     MII output signals are not asserted. DRT must be cleared.
 */
/*@{*/
#define BP_ENET_RCR_LOOP     (0U)          /*!< Bit position for ENET_RCR_LOOP. */
#define BM_ENET_RCR_LOOP     (0x00000001U) /*!< Bit mask for ENET_RCR_LOOP. */
#define BS_ENET_RCR_LOOP     (1U)          /*!< Bit field size in bits for ENET_RCR_LOOP. */

/*! @brief Read current value of the ENET_RCR_LOOP field. */
#define BR_ENET_RCR_LOOP(x)  (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_LOOP))

/*! @brief Format value for bitfield ENET_RCR_LOOP. */
#define BF_ENET_RCR_LOOP(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_LOOP) & BM_ENET_RCR_LOOP)

/*! @brief Set the LOOP field to a new value. */
#define BW_ENET_RCR_LOOP(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_LOOP) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field DRT[1] (RW)
 *
 * Values:
 * - 0 - Receive path operates independently of transmit. Used for full-duplex
 *     or to monitor transmit activity in half-duplex mode.
 * - 1 - Disable reception of frames while transmitting. Normally used for
 *     half-duplex mode.
 */
/*@{*/
#define BP_ENET_RCR_DRT      (1U)          /*!< Bit position for ENET_RCR_DRT. */
#define BM_ENET_RCR_DRT      (0x00000002U) /*!< Bit mask for ENET_RCR_DRT. */
#define BS_ENET_RCR_DRT      (1U)          /*!< Bit field size in bits for ENET_RCR_DRT. */

/*! @brief Read current value of the ENET_RCR_DRT field. */
#define BR_ENET_RCR_DRT(x)   (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_DRT))

/*! @brief Format value for bitfield ENET_RCR_DRT. */
#define BF_ENET_RCR_DRT(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_DRT) & BM_ENET_RCR_DRT)

/*! @brief Set the DRT field to a new value. */
#define BW_ENET_RCR_DRT(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_DRT) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field MII_MODE[2] (RW)
 *
 * This field must always be set.
 *
 * Values:
 * - 0 - Reserved.
 * - 1 - MII or RMII mode, as indicated by the RMII_MODE field.
 */
/*@{*/
#define BP_ENET_RCR_MII_MODE (2U)          /*!< Bit position for ENET_RCR_MII_MODE. */
#define BM_ENET_RCR_MII_MODE (0x00000004U) /*!< Bit mask for ENET_RCR_MII_MODE. */
#define BS_ENET_RCR_MII_MODE (1U)          /*!< Bit field size in bits for ENET_RCR_MII_MODE. */

/*! @brief Read current value of the ENET_RCR_MII_MODE field. */
#define BR_ENET_RCR_MII_MODE(x) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_MII_MODE))

/*! @brief Format value for bitfield ENET_RCR_MII_MODE. */
#define BF_ENET_RCR_MII_MODE(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_MII_MODE) & BM_ENET_RCR_MII_MODE)

/*! @brief Set the MII_MODE field to a new value. */
#define BW_ENET_RCR_MII_MODE(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_MII_MODE) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field PROM[3] (RW)
 *
 * All frames are accepted regardless of address matching.
 *
 * Values:
 * - 0 - Disabled.
 * - 1 - Enabled.
 */
/*@{*/
#define BP_ENET_RCR_PROM     (3U)          /*!< Bit position for ENET_RCR_PROM. */
#define BM_ENET_RCR_PROM     (0x00000008U) /*!< Bit mask for ENET_RCR_PROM. */
#define BS_ENET_RCR_PROM     (1U)          /*!< Bit field size in bits for ENET_RCR_PROM. */

/*! @brief Read current value of the ENET_RCR_PROM field. */
#define BR_ENET_RCR_PROM(x)  (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_PROM))

/*! @brief Format value for bitfield ENET_RCR_PROM. */
#define BF_ENET_RCR_PROM(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_PROM) & BM_ENET_RCR_PROM)

/*! @brief Set the PROM field to a new value. */
#define BW_ENET_RCR_PROM(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_PROM) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field BC_REJ[4] (RW)
 *
 * If set, frames with destination address (DA) equal to 0xFFFF_FFFF_FFFF are
 * rejected unless the PROM field is set. If BC_REJ and PROM are set, frames with
 * broadcast DA are accepted and the MISS (M) is set in the receive buffer
 * descriptor.
 */
/*@{*/
#define BP_ENET_RCR_BC_REJ   (4U)          /*!< Bit position for ENET_RCR_BC_REJ. */
#define BM_ENET_RCR_BC_REJ   (0x00000010U) /*!< Bit mask for ENET_RCR_BC_REJ. */
#define BS_ENET_RCR_BC_REJ   (1U)          /*!< Bit field size in bits for ENET_RCR_BC_REJ. */

/*! @brief Read current value of the ENET_RCR_BC_REJ field. */
#define BR_ENET_RCR_BC_REJ(x) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_BC_REJ))

/*! @brief Format value for bitfield ENET_RCR_BC_REJ. */
#define BF_ENET_RCR_BC_REJ(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_BC_REJ) & BM_ENET_RCR_BC_REJ)

/*! @brief Set the BC_REJ field to a new value. */
#define BW_ENET_RCR_BC_REJ(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_BC_REJ) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field FCE[5] (RW)
 *
 * If set, the receiver detects PAUSE frames. Upon PAUSE frame detection, the
 * transmitter stops transmitting data frames for a given duration.
 */
/*@{*/
#define BP_ENET_RCR_FCE      (5U)          /*!< Bit position for ENET_RCR_FCE. */
#define BM_ENET_RCR_FCE      (0x00000020U) /*!< Bit mask for ENET_RCR_FCE. */
#define BS_ENET_RCR_FCE      (1U)          /*!< Bit field size in bits for ENET_RCR_FCE. */

/*! @brief Read current value of the ENET_RCR_FCE field. */
#define BR_ENET_RCR_FCE(x)   (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_FCE))

/*! @brief Format value for bitfield ENET_RCR_FCE. */
#define BF_ENET_RCR_FCE(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_FCE) & BM_ENET_RCR_FCE)

/*! @brief Set the FCE field to a new value. */
#define BW_ENET_RCR_FCE(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_FCE) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field RMII_MODE[8] (RW)
 *
 * Specifies whether the MAC is configured for MII mode or RMII operation .
 *
 * Values:
 * - 0 - MAC configured for MII mode.
 * - 1 - MAC configured for RMII operation.
 */
/*@{*/
#define BP_ENET_RCR_RMII_MODE (8U)         /*!< Bit position for ENET_RCR_RMII_MODE. */
#define BM_ENET_RCR_RMII_MODE (0x00000100U) /*!< Bit mask for ENET_RCR_RMII_MODE. */
#define BS_ENET_RCR_RMII_MODE (1U)         /*!< Bit field size in bits for ENET_RCR_RMII_MODE. */

/*! @brief Read current value of the ENET_RCR_RMII_MODE field. */
#define BR_ENET_RCR_RMII_MODE(x) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_RMII_MODE))

/*! @brief Format value for bitfield ENET_RCR_RMII_MODE. */
#define BF_ENET_RCR_RMII_MODE(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_RMII_MODE) & BM_ENET_RCR_RMII_MODE)

/*! @brief Set the RMII_MODE field to a new value. */
#define BW_ENET_RCR_RMII_MODE(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_RMII_MODE) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field RMII_10T[9] (RW)
 *
 * Enables 10-Mbps mode of the RMII .
 *
 * Values:
 * - 0 - 100 Mbps operation.
 * - 1 - 10 Mbps operation.
 */
/*@{*/
#define BP_ENET_RCR_RMII_10T (9U)          /*!< Bit position for ENET_RCR_RMII_10T. */
#define BM_ENET_RCR_RMII_10T (0x00000200U) /*!< Bit mask for ENET_RCR_RMII_10T. */
#define BS_ENET_RCR_RMII_10T (1U)          /*!< Bit field size in bits for ENET_RCR_RMII_10T. */

/*! @brief Read current value of the ENET_RCR_RMII_10T field. */
#define BR_ENET_RCR_RMII_10T(x) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_RMII_10T))

/*! @brief Format value for bitfield ENET_RCR_RMII_10T. */
#define BF_ENET_RCR_RMII_10T(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_RMII_10T) & BM_ENET_RCR_RMII_10T)

/*! @brief Set the RMII_10T field to a new value. */
#define BW_ENET_RCR_RMII_10T(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_RMII_10T) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field PADEN[12] (RW)
 *
 * Specifies whether the MAC removes padding from received frames.
 *
 * Values:
 * - 0 - No padding is removed on receive by the MAC.
 * - 1 - Padding is removed from received frames.
 */
/*@{*/
#define BP_ENET_RCR_PADEN    (12U)         /*!< Bit position for ENET_RCR_PADEN. */
#define BM_ENET_RCR_PADEN    (0x00001000U) /*!< Bit mask for ENET_RCR_PADEN. */
#define BS_ENET_RCR_PADEN    (1U)          /*!< Bit field size in bits for ENET_RCR_PADEN. */

/*! @brief Read current value of the ENET_RCR_PADEN field. */
#define BR_ENET_RCR_PADEN(x) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_PADEN))

/*! @brief Format value for bitfield ENET_RCR_PADEN. */
#define BF_ENET_RCR_PADEN(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_PADEN) & BM_ENET_RCR_PADEN)

/*! @brief Set the PADEN field to a new value. */
#define BW_ENET_RCR_PADEN(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_PADEN) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field PAUFWD[13] (RW)
 *
 * Specifies whether pause frames are terminated or forwarded.
 *
 * Values:
 * - 0 - Pause frames are terminated and discarded in the MAC.
 * - 1 - Pause frames are forwarded to the user application.
 */
/*@{*/
#define BP_ENET_RCR_PAUFWD   (13U)         /*!< Bit position for ENET_RCR_PAUFWD. */
#define BM_ENET_RCR_PAUFWD   (0x00002000U) /*!< Bit mask for ENET_RCR_PAUFWD. */
#define BS_ENET_RCR_PAUFWD   (1U)          /*!< Bit field size in bits for ENET_RCR_PAUFWD. */

/*! @brief Read current value of the ENET_RCR_PAUFWD field. */
#define BR_ENET_RCR_PAUFWD(x) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_PAUFWD))

/*! @brief Format value for bitfield ENET_RCR_PAUFWD. */
#define BF_ENET_RCR_PAUFWD(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_PAUFWD) & BM_ENET_RCR_PAUFWD)

/*! @brief Set the PAUFWD field to a new value. */
#define BW_ENET_RCR_PAUFWD(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_PAUFWD) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field CRCFWD[14] (RW)
 *
 * Specifies whether the CRC field of received frames is transmitted or
 * stripped. If padding function is enabled (PADEN = 1), CRCFWD is ignored and the CRC
 * field is checked and always terminated and removed.
 *
 * Values:
 * - 0 - The CRC field of received frames is transmitted to the user application.
 * - 1 - The CRC field is stripped from the frame.
 */
/*@{*/
#define BP_ENET_RCR_CRCFWD   (14U)         /*!< Bit position for ENET_RCR_CRCFWD. */
#define BM_ENET_RCR_CRCFWD   (0x00004000U) /*!< Bit mask for ENET_RCR_CRCFWD. */
#define BS_ENET_RCR_CRCFWD   (1U)          /*!< Bit field size in bits for ENET_RCR_CRCFWD. */

/*! @brief Read current value of the ENET_RCR_CRCFWD field. */
#define BR_ENET_RCR_CRCFWD(x) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_CRCFWD))

/*! @brief Format value for bitfield ENET_RCR_CRCFWD. */
#define BF_ENET_RCR_CRCFWD(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_CRCFWD) & BM_ENET_RCR_CRCFWD)

/*! @brief Set the CRCFWD field to a new value. */
#define BW_ENET_RCR_CRCFWD(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_CRCFWD) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field CFEN[15] (RW)
 *
 * Enables/disables the MAC control frame.
 *
 * Values:
 * - 0 - MAC control frames with any opcode other than 0x0001 (pause frame) are
 *     accepted and forwarded to the client interface.
 * - 1 - MAC control frames with any opcode other than 0x0001 (pause frame) are
 *     silently discarded.
 */
/*@{*/
#define BP_ENET_RCR_CFEN     (15U)         /*!< Bit position for ENET_RCR_CFEN. */
#define BM_ENET_RCR_CFEN     (0x00008000U) /*!< Bit mask for ENET_RCR_CFEN. */
#define BS_ENET_RCR_CFEN     (1U)          /*!< Bit field size in bits for ENET_RCR_CFEN. */

/*! @brief Read current value of the ENET_RCR_CFEN field. */
#define BR_ENET_RCR_CFEN(x)  (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_CFEN))

/*! @brief Format value for bitfield ENET_RCR_CFEN. */
#define BF_ENET_RCR_CFEN(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_CFEN) & BM_ENET_RCR_CFEN)

/*! @brief Set the CFEN field to a new value. */
#define BW_ENET_RCR_CFEN(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_CFEN) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field MAX_FL[29:16] (RW)
 *
 * Resets to decimal 1518. Length is measured starting at DA and includes the
 * CRC at the end of the frame. Transmit frames longer than MAX_FL cause the BABT
 * interrupt to occur. Receive frames longer than MAX_FL cause the BABR interrupt
 * to occur and set the LG field in the end of frame receive buffer descriptor.
 * The recommended default value to be programmed is 1518 or 1522 if VLAN tags are
 * supported.
 */
/*@{*/
#define BP_ENET_RCR_MAX_FL   (16U)         /*!< Bit position for ENET_RCR_MAX_FL. */
#define BM_ENET_RCR_MAX_FL   (0x3FFF0000U) /*!< Bit mask for ENET_RCR_MAX_FL. */
#define BS_ENET_RCR_MAX_FL   (14U)         /*!< Bit field size in bits for ENET_RCR_MAX_FL. */

/*! @brief Read current value of the ENET_RCR_MAX_FL field. */
#define BR_ENET_RCR_MAX_FL(x) (HW_ENET_RCR(x).B.MAX_FL)

/*! @brief Format value for bitfield ENET_RCR_MAX_FL. */
#define BF_ENET_RCR_MAX_FL(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_MAX_FL) & BM_ENET_RCR_MAX_FL)

/*! @brief Set the MAX_FL field to a new value. */
#define BW_ENET_RCR_MAX_FL(x, v) (HW_ENET_RCR_WR(x, (HW_ENET_RCR_RD(x) & ~BM_ENET_RCR_MAX_FL) | BF_ENET_RCR_MAX_FL(v)))
/*@}*/

/*!
 * @name Register ENET_RCR, field NLC[30] (RW)
 *
 * Enables/disables a payload length check.
 *
 * Values:
 * - 0 - The payload length check is disabled.
 * - 1 - The core checks the frame's payload length with the frame length/type
 *     field. Errors are indicated in the EIR[PLC] field.
 */
/*@{*/
#define BP_ENET_RCR_NLC      (30U)         /*!< Bit position for ENET_RCR_NLC. */
#define BM_ENET_RCR_NLC      (0x40000000U) /*!< Bit mask for ENET_RCR_NLC. */
#define BS_ENET_RCR_NLC      (1U)          /*!< Bit field size in bits for ENET_RCR_NLC. */

/*! @brief Read current value of the ENET_RCR_NLC field. */
#define BR_ENET_RCR_NLC(x)   (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_NLC))

/*! @brief Format value for bitfield ENET_RCR_NLC. */
#define BF_ENET_RCR_NLC(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_RCR_NLC) & BM_ENET_RCR_NLC)

/*! @brief Set the NLC field to a new value. */
#define BW_ENET_RCR_NLC(x, v) (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_NLC) = (v))
/*@}*/

/*!
 * @name Register ENET_RCR, field GRS[31] (RO)
 *
 * Read-only status indicating that the MAC receive datapath is stopped.
 */
/*@{*/
#define BP_ENET_RCR_GRS      (31U)         /*!< Bit position for ENET_RCR_GRS. */
#define BM_ENET_RCR_GRS      (0x80000000U) /*!< Bit mask for ENET_RCR_GRS. */
#define BS_ENET_RCR_GRS      (1U)          /*!< Bit field size in bits for ENET_RCR_GRS. */

/*! @brief Read current value of the ENET_RCR_GRS field. */
#define BR_ENET_RCR_GRS(x)   (BITBAND_ACCESS32(HW_ENET_RCR_ADDR(x), BP_ENET_RCR_GRS))
/*@}*/

/*******************************************************************************
 * HW_ENET_TCR - Transmit Control Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_TCR - Transmit Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TCR is read/write and configures the transmit block. This register is cleared
 * at system reset. FDEN can only be modified when ECR[ETHEREN] is cleared.
 */
typedef union _hw_enet_tcr
{
    uint32_t U;
    struct _hw_enet_tcr_bitfields
    {
        uint32_t GTS : 1;              /*!< [0] Graceful Transmit Stop */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t FDEN : 1;             /*!< [2] Full-Duplex Enable */
        uint32_t TFC_PAUSE : 1;        /*!< [3] Transmit Frame Control Pause */
        uint32_t RFC_PAUSE : 1;        /*!< [4] Receive Frame Control Pause */
        uint32_t ADDSEL : 3;           /*!< [7:5] Source MAC Address Select On Transmit
                                        * */
        uint32_t ADDINS : 1;           /*!< [8] Set MAC Address On Transmit */
        uint32_t CRCFWD : 1;           /*!< [9] Forward Frame From Application With CRC
                                        * */
        uint32_t RESERVED1 : 22;       /*!< [31:10]  */
    } B;
} hw_enet_tcr_t;

/*!
 * @name Constants and macros for entire ENET_TCR register
 */
/*@{*/
#define HW_ENET_TCR_ADDR(x)      ((uint32_t)(x) + 0xC4U)

#define HW_ENET_TCR(x)           (*(__IO hw_enet_tcr_t *) HW_ENET_TCR_ADDR(x))
#define HW_ENET_TCR_RD(x)        (HW_ENET_TCR(x).U)
#define HW_ENET_TCR_WR(x, v)     (HW_ENET_TCR(x).U = (v))
#define HW_ENET_TCR_SET(x, v)    (HW_ENET_TCR_WR(x, HW_ENET_TCR_RD(x) |  (v)))
#define HW_ENET_TCR_CLR(x, v)    (HW_ENET_TCR_WR(x, HW_ENET_TCR_RD(x) & ~(v)))
#define HW_ENET_TCR_TOG(x, v)    (HW_ENET_TCR_WR(x, HW_ENET_TCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TCR bitfields
 */

/*!
 * @name Register ENET_TCR, field GTS[0] (RW)
 *
 * When this field is set, MAC stops transmission after any frame currently
 * transmitted is complete and EIR[GRA] is set. If frame transmission is not
 * currently underway, the GRA interrupt is asserted immediately. After transmission
 * finishes, clear GTS to restart. The next frame in the transmit FIFO is then
 * transmitted. If an early collision occurs during transmission when GTS is set,
 * transmission stops after the collision. The frame is transmitted again after GTS is
 * cleared. There may be old frames in the transmit FIFO that transmit when GTS
 * is reasserted. To avoid this, clear ECR[ETHEREN] following the GRA interrupt.
 */
/*@{*/
#define BP_ENET_TCR_GTS      (0U)          /*!< Bit position for ENET_TCR_GTS. */
#define BM_ENET_TCR_GTS      (0x00000001U) /*!< Bit mask for ENET_TCR_GTS. */
#define BS_ENET_TCR_GTS      (1U)          /*!< Bit field size in bits for ENET_TCR_GTS. */

/*! @brief Read current value of the ENET_TCR_GTS field. */
#define BR_ENET_TCR_GTS(x)   (BITBAND_ACCESS32(HW_ENET_TCR_ADDR(x), BP_ENET_TCR_GTS))

/*! @brief Format value for bitfield ENET_TCR_GTS. */
#define BF_ENET_TCR_GTS(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_TCR_GTS) & BM_ENET_TCR_GTS)

/*! @brief Set the GTS field to a new value. */
#define BW_ENET_TCR_GTS(x, v) (BITBAND_ACCESS32(HW_ENET_TCR_ADDR(x), BP_ENET_TCR_GTS) = (v))
/*@}*/

/*!
 * @name Register ENET_TCR, field FDEN[2] (RW)
 *
 * If this field is set, frames transmit independent of carrier sense and
 * collision inputs. Only modify this bit when ECR[ETHEREN] is cleared.
 */
/*@{*/
#define BP_ENET_TCR_FDEN     (2U)          /*!< Bit position for ENET_TCR_FDEN. */
#define BM_ENET_TCR_FDEN     (0x00000004U) /*!< Bit mask for ENET_TCR_FDEN. */
#define BS_ENET_TCR_FDEN     (1U)          /*!< Bit field size in bits for ENET_TCR_FDEN. */

/*! @brief Read current value of the ENET_TCR_FDEN field. */
#define BR_ENET_TCR_FDEN(x)  (BITBAND_ACCESS32(HW_ENET_TCR_ADDR(x), BP_ENET_TCR_FDEN))

/*! @brief Format value for bitfield ENET_TCR_FDEN. */
#define BF_ENET_TCR_FDEN(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_TCR_FDEN) & BM_ENET_TCR_FDEN)

/*! @brief Set the FDEN field to a new value. */
#define BW_ENET_TCR_FDEN(x, v) (BITBAND_ACCESS32(HW_ENET_TCR_ADDR(x), BP_ENET_TCR_FDEN) = (v))
/*@}*/

/*!
 * @name Register ENET_TCR, field TFC_PAUSE[3] (RW)
 *
 * Pauses frame transmission. When this field is set, EIR[GRA] is set. With
 * transmission of data frames stopped, the MAC transmits a MAC control PAUSE frame.
 * Next, the MAC clears TFC_PAUSE and resumes transmitting data frames. If the
 * transmitter pauses due to user assertion of GTS or reception of a PAUSE frame,
 * the MAC may continue transmitting a MAC control PAUSE frame.
 *
 * Values:
 * - 0 - No PAUSE frame transmitted.
 * - 1 - The MAC stops transmission of data frames after the current
 *     transmission is complete.
 */
/*@{*/
#define BP_ENET_TCR_TFC_PAUSE (3U)         /*!< Bit position for ENET_TCR_TFC_PAUSE. */
#define BM_ENET_TCR_TFC_PAUSE (0x00000008U) /*!< Bit mask for ENET_TCR_TFC_PAUSE. */
#define BS_ENET_TCR_TFC_PAUSE (1U)         /*!< Bit field size in bits for ENET_TCR_TFC_PAUSE. */

/*! @brief Read current value of the ENET_TCR_TFC_PAUSE field. */
#define BR_ENET_TCR_TFC_PAUSE(x) (BITBAND_ACCESS32(HW_ENET_TCR_ADDR(x), BP_ENET_TCR_TFC_PAUSE))

/*! @brief Format value for bitfield ENET_TCR_TFC_PAUSE. */
#define BF_ENET_TCR_TFC_PAUSE(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TCR_TFC_PAUSE) & BM_ENET_TCR_TFC_PAUSE)

/*! @brief Set the TFC_PAUSE field to a new value. */
#define BW_ENET_TCR_TFC_PAUSE(x, v) (BITBAND_ACCESS32(HW_ENET_TCR_ADDR(x), BP_ENET_TCR_TFC_PAUSE) = (v))
/*@}*/

/*!
 * @name Register ENET_TCR, field RFC_PAUSE[4] (RO)
 *
 * This status field is set when a full-duplex flow control pause frame is
 * received and the transmitter pauses for the duration defined in this pause frame.
 * This field automatically clears when the pause duration is complete.
 */
/*@{*/
#define BP_ENET_TCR_RFC_PAUSE (4U)         /*!< Bit position for ENET_TCR_RFC_PAUSE. */
#define BM_ENET_TCR_RFC_PAUSE (0x00000010U) /*!< Bit mask for ENET_TCR_RFC_PAUSE. */
#define BS_ENET_TCR_RFC_PAUSE (1U)         /*!< Bit field size in bits for ENET_TCR_RFC_PAUSE. */

/*! @brief Read current value of the ENET_TCR_RFC_PAUSE field. */
#define BR_ENET_TCR_RFC_PAUSE(x) (BITBAND_ACCESS32(HW_ENET_TCR_ADDR(x), BP_ENET_TCR_RFC_PAUSE))
/*@}*/

/*!
 * @name Register ENET_TCR, field ADDSEL[7:5] (RW)
 *
 * If ADDINS is set, indicates the MAC address that overwrites the source MAC
 * address.
 *
 * Values:
 * - 000 - Node MAC address programmed on PADDR1/2 registers.
 * - 100 - Reserved.
 * - 101 - Reserved.
 * - 110 - Reserved.
 */
/*@{*/
#define BP_ENET_TCR_ADDSEL   (5U)          /*!< Bit position for ENET_TCR_ADDSEL. */
#define BM_ENET_TCR_ADDSEL   (0x000000E0U) /*!< Bit mask for ENET_TCR_ADDSEL. */
#define BS_ENET_TCR_ADDSEL   (3U)          /*!< Bit field size in bits for ENET_TCR_ADDSEL. */

/*! @brief Read current value of the ENET_TCR_ADDSEL field. */
#define BR_ENET_TCR_ADDSEL(x) (HW_ENET_TCR(x).B.ADDSEL)

/*! @brief Format value for bitfield ENET_TCR_ADDSEL. */
#define BF_ENET_TCR_ADDSEL(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TCR_ADDSEL) & BM_ENET_TCR_ADDSEL)

/*! @brief Set the ADDSEL field to a new value. */
#define BW_ENET_TCR_ADDSEL(x, v) (HW_ENET_TCR_WR(x, (HW_ENET_TCR_RD(x) & ~BM_ENET_TCR_ADDSEL) | BF_ENET_TCR_ADDSEL(v)))
/*@}*/

/*!
 * @name Register ENET_TCR, field ADDINS[8] (RW)
 *
 * Values:
 * - 0 - The source MAC address is not modified by the MAC.
 * - 1 - The MAC overwrites the source MAC address with the programmed MAC
 *     address according to ADDSEL.
 */
/*@{*/
#define BP_ENET_TCR_ADDINS   (8U)          /*!< Bit position for ENET_TCR_ADDINS. */
#define BM_ENET_TCR_ADDINS   (0x00000100U) /*!< Bit mask for ENET_TCR_ADDINS. */
#define BS_ENET_TCR_ADDINS   (1U)          /*!< Bit field size in bits for ENET_TCR_ADDINS. */

/*! @brief Read current value of the ENET_TCR_ADDINS field. */
#define BR_ENET_TCR_ADDINS(x) (BITBAND_ACCESS32(HW_ENET_TCR_ADDR(x), BP_ENET_TCR_ADDINS))

/*! @brief Format value for bitfield ENET_TCR_ADDINS. */
#define BF_ENET_TCR_ADDINS(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TCR_ADDINS) & BM_ENET_TCR_ADDINS)

/*! @brief Set the ADDINS field to a new value. */
#define BW_ENET_TCR_ADDINS(x, v) (BITBAND_ACCESS32(HW_ENET_TCR_ADDR(x), BP_ENET_TCR_ADDINS) = (v))
/*@}*/

/*!
 * @name Register ENET_TCR, field CRCFWD[9] (RW)
 *
 * Values:
 * - 0 - TxBD[TC] controls whether the frame has a CRC from the application.
 * - 1 - The transmitter does not append any CRC to transmitted frames, as it is
 *     expecting a frame with CRC from the application.
 */
/*@{*/
#define BP_ENET_TCR_CRCFWD   (9U)          /*!< Bit position for ENET_TCR_CRCFWD. */
#define BM_ENET_TCR_CRCFWD   (0x00000200U) /*!< Bit mask for ENET_TCR_CRCFWD. */
#define BS_ENET_TCR_CRCFWD   (1U)          /*!< Bit field size in bits for ENET_TCR_CRCFWD. */

/*! @brief Read current value of the ENET_TCR_CRCFWD field. */
#define BR_ENET_TCR_CRCFWD(x) (BITBAND_ACCESS32(HW_ENET_TCR_ADDR(x), BP_ENET_TCR_CRCFWD))

/*! @brief Format value for bitfield ENET_TCR_CRCFWD. */
#define BF_ENET_TCR_CRCFWD(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TCR_CRCFWD) & BM_ENET_TCR_CRCFWD)

/*! @brief Set the CRCFWD field to a new value. */
#define BW_ENET_TCR_CRCFWD(x, v) (BITBAND_ACCESS32(HW_ENET_TCR_ADDR(x), BP_ENET_TCR_CRCFWD) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_PALR - Physical Address Lower Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_PALR - Physical Address Lower Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * PALR contains the lower 32 bits (bytes 0, 1, 2, 3) of the 48-bit address used
 * in the address recognition process to compare with the destination address
 * (DA) field of receive frames with an individual DA. In addition, this register
 * is used in bytes 0 through 3 of the six-byte source address field when
 * transmitting PAUSE frames. This register is not reset and you must initialize it.
 */
typedef union _hw_enet_palr
{
    uint32_t U;
    struct _hw_enet_palr_bitfields
    {
        uint32_t PADDR1 : 32;          /*!< [31:0] Pause Address */
    } B;
} hw_enet_palr_t;

/*!
 * @name Constants and macros for entire ENET_PALR register
 */
/*@{*/
#define HW_ENET_PALR_ADDR(x)     ((uint32_t)(x) + 0xE4U)

#define HW_ENET_PALR(x)          (*(__IO hw_enet_palr_t *) HW_ENET_PALR_ADDR(x))
#define HW_ENET_PALR_RD(x)       (HW_ENET_PALR(x).U)
#define HW_ENET_PALR_WR(x, v)    (HW_ENET_PALR(x).U = (v))
#define HW_ENET_PALR_SET(x, v)   (HW_ENET_PALR_WR(x, HW_ENET_PALR_RD(x) |  (v)))
#define HW_ENET_PALR_CLR(x, v)   (HW_ENET_PALR_WR(x, HW_ENET_PALR_RD(x) & ~(v)))
#define HW_ENET_PALR_TOG(x, v)   (HW_ENET_PALR_WR(x, HW_ENET_PALR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_PALR bitfields
 */

/*!
 * @name Register ENET_PALR, field PADDR1[31:0] (RW)
 *
 * Bytes 0 (bits 31:24), 1 (bits 23:16), 2 (bits 15:8), and 3 (bits 7:0) of the
 * 6-byte individual address are used for exact match and the source address
 * field in PAUSE frames.
 */
/*@{*/
#define BP_ENET_PALR_PADDR1  (0U)          /*!< Bit position for ENET_PALR_PADDR1. */
#define BM_ENET_PALR_PADDR1  (0xFFFFFFFFU) /*!< Bit mask for ENET_PALR_PADDR1. */
#define BS_ENET_PALR_PADDR1  (32U)         /*!< Bit field size in bits for ENET_PALR_PADDR1. */

/*! @brief Read current value of the ENET_PALR_PADDR1 field. */
#define BR_ENET_PALR_PADDR1(x) (HW_ENET_PALR(x).U)

/*! @brief Format value for bitfield ENET_PALR_PADDR1. */
#define BF_ENET_PALR_PADDR1(v) ((uint32_t)((uint32_t)(v) << BP_ENET_PALR_PADDR1) & BM_ENET_PALR_PADDR1)

/*! @brief Set the PADDR1 field to a new value. */
#define BW_ENET_PALR_PADDR1(x, v) (HW_ENET_PALR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_ENET_PAUR - Physical Address Upper Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_PAUR - Physical Address Upper Register (RW)
 *
 * Reset value: 0x00008808U
 *
 * PAUR contains the upper 16 bits (bytes 4 and 5) of the 48-bit address used in
 * the address recognition process to compare with the destination address (DA)
 * field of receive frames with an individual DA. In addition, this register is
 * used in bytes 4 and 5 of the six-byte source address field when transmitting
 * PAUSE frames. Bits 15:0 of PAUR contain a constant type field (0x8808) for
 * transmission of PAUSE frames. The upper 16 bits of this register are not reset and
 * you must initialize it.
 */
typedef union _hw_enet_paur
{
    uint32_t U;
    struct _hw_enet_paur_bitfields
    {
        uint32_t TYPE : 16;            /*!< [15:0] Type Field In PAUSE Frames */
        uint32_t PADDR2 : 16;          /*!< [31:16]  */
    } B;
} hw_enet_paur_t;

/*!
 * @name Constants and macros for entire ENET_PAUR register
 */
/*@{*/
#define HW_ENET_PAUR_ADDR(x)     ((uint32_t)(x) + 0xE8U)

#define HW_ENET_PAUR(x)          (*(__IO hw_enet_paur_t *) HW_ENET_PAUR_ADDR(x))
#define HW_ENET_PAUR_RD(x)       (HW_ENET_PAUR(x).U)
#define HW_ENET_PAUR_WR(x, v)    (HW_ENET_PAUR(x).U = (v))
#define HW_ENET_PAUR_SET(x, v)   (HW_ENET_PAUR_WR(x, HW_ENET_PAUR_RD(x) |  (v)))
#define HW_ENET_PAUR_CLR(x, v)   (HW_ENET_PAUR_WR(x, HW_ENET_PAUR_RD(x) & ~(v)))
#define HW_ENET_PAUR_TOG(x, v)   (HW_ENET_PAUR_WR(x, HW_ENET_PAUR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_PAUR bitfields
 */

/*!
 * @name Register ENET_PAUR, field TYPE[15:0] (RO)
 *
 * These fields have a constant value of 0x8808.
 */
/*@{*/
#define BP_ENET_PAUR_TYPE    (0U)          /*!< Bit position for ENET_PAUR_TYPE. */
#define BM_ENET_PAUR_TYPE    (0x0000FFFFU) /*!< Bit mask for ENET_PAUR_TYPE. */
#define BS_ENET_PAUR_TYPE    (16U)         /*!< Bit field size in bits for ENET_PAUR_TYPE. */

/*! @brief Read current value of the ENET_PAUR_TYPE field. */
#define BR_ENET_PAUR_TYPE(x) (HW_ENET_PAUR(x).B.TYPE)
/*@}*/

/*!
 * @name Register ENET_PAUR, field PADDR2[31:16] (RW)
 *
 * Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address used
 * for exact match, and the source address field in PAUSE frames.
 */
/*@{*/
#define BP_ENET_PAUR_PADDR2  (16U)         /*!< Bit position for ENET_PAUR_PADDR2. */
#define BM_ENET_PAUR_PADDR2  (0xFFFF0000U) /*!< Bit mask for ENET_PAUR_PADDR2. */
#define BS_ENET_PAUR_PADDR2  (16U)         /*!< Bit field size in bits for ENET_PAUR_PADDR2. */

/*! @brief Read current value of the ENET_PAUR_PADDR2 field. */
#define BR_ENET_PAUR_PADDR2(x) (HW_ENET_PAUR(x).B.PADDR2)

/*! @brief Format value for bitfield ENET_PAUR_PADDR2. */
#define BF_ENET_PAUR_PADDR2(v) ((uint32_t)((uint32_t)(v) << BP_ENET_PAUR_PADDR2) & BM_ENET_PAUR_PADDR2)

/*! @brief Set the PADDR2 field to a new value. */
#define BW_ENET_PAUR_PADDR2(x, v) (HW_ENET_PAUR_WR(x, (HW_ENET_PAUR_RD(x) & ~BM_ENET_PAUR_PADDR2) | BF_ENET_PAUR_PADDR2(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_OPD - Opcode/Pause Duration Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_OPD - Opcode/Pause Duration Register (RW)
 *
 * Reset value: 0x00010000U
 *
 * OPD is read/write accessible. This register contains the 16-bit opcode and
 * 16-bit pause duration fields used in transmission of a PAUSE frame. The opcode
 * field is a constant value, 0x0001. When another node detects a PAUSE frame,
 * that node pauses transmission for the duration specified in the pause duration
 * field. The lower 16 bits of this register are not reset and you must initialize
 * it.
 */
typedef union _hw_enet_opd
{
    uint32_t U;
    struct _hw_enet_opd_bitfields
    {
        uint32_t PAUSE_DUR : 16;       /*!< [15:0] Pause Duration */
        uint32_t OPCODE : 16;          /*!< [31:16] Opcode Field In PAUSE Frames */
    } B;
} hw_enet_opd_t;

/*!
 * @name Constants and macros for entire ENET_OPD register
 */
/*@{*/
#define HW_ENET_OPD_ADDR(x)      ((uint32_t)(x) + 0xECU)

#define HW_ENET_OPD(x)           (*(__IO hw_enet_opd_t *) HW_ENET_OPD_ADDR(x))
#define HW_ENET_OPD_RD(x)        (HW_ENET_OPD(x).U)
#define HW_ENET_OPD_WR(x, v)     (HW_ENET_OPD(x).U = (v))
#define HW_ENET_OPD_SET(x, v)    (HW_ENET_OPD_WR(x, HW_ENET_OPD_RD(x) |  (v)))
#define HW_ENET_OPD_CLR(x, v)    (HW_ENET_OPD_WR(x, HW_ENET_OPD_RD(x) & ~(v)))
#define HW_ENET_OPD_TOG(x, v)    (HW_ENET_OPD_WR(x, HW_ENET_OPD_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_OPD bitfields
 */

/*!
 * @name Register ENET_OPD, field PAUSE_DUR[15:0] (RW)
 *
 * Pause duration field used in PAUSE frames.
 */
/*@{*/
#define BP_ENET_OPD_PAUSE_DUR (0U)         /*!< Bit position for ENET_OPD_PAUSE_DUR. */
#define BM_ENET_OPD_PAUSE_DUR (0x0000FFFFU) /*!< Bit mask for ENET_OPD_PAUSE_DUR. */
#define BS_ENET_OPD_PAUSE_DUR (16U)        /*!< Bit field size in bits for ENET_OPD_PAUSE_DUR. */

/*! @brief Read current value of the ENET_OPD_PAUSE_DUR field. */
#define BR_ENET_OPD_PAUSE_DUR(x) (HW_ENET_OPD(x).B.PAUSE_DUR)

/*! @brief Format value for bitfield ENET_OPD_PAUSE_DUR. */
#define BF_ENET_OPD_PAUSE_DUR(v) ((uint32_t)((uint32_t)(v) << BP_ENET_OPD_PAUSE_DUR) & BM_ENET_OPD_PAUSE_DUR)

/*! @brief Set the PAUSE_DUR field to a new value. */
#define BW_ENET_OPD_PAUSE_DUR(x, v) (HW_ENET_OPD_WR(x, (HW_ENET_OPD_RD(x) & ~BM_ENET_OPD_PAUSE_DUR) | BF_ENET_OPD_PAUSE_DUR(v)))
/*@}*/

/*!
 * @name Register ENET_OPD, field OPCODE[31:16] (RO)
 *
 * These fields have a constant value of 0x0001.
 */
/*@{*/
#define BP_ENET_OPD_OPCODE   (16U)         /*!< Bit position for ENET_OPD_OPCODE. */
#define BM_ENET_OPD_OPCODE   (0xFFFF0000U) /*!< Bit mask for ENET_OPD_OPCODE. */
#define BS_ENET_OPD_OPCODE   (16U)         /*!< Bit field size in bits for ENET_OPD_OPCODE. */

/*! @brief Read current value of the ENET_OPD_OPCODE field. */
#define BR_ENET_OPD_OPCODE(x) (HW_ENET_OPD(x).B.OPCODE)
/*@}*/

/*******************************************************************************
 * HW_ENET_IAUR - Descriptor Individual Upper Address Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IAUR - Descriptor Individual Upper Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * IAUR contains the upper 32 bits of the 64-bit individual address hash table.
 * The address recognition process uses this table to check for a possible match
 * with the destination address (DA) field of receive frames with an individual
 * DA. This register is not reset and you must initialize it.
 */
typedef union _hw_enet_iaur
{
    uint32_t U;
    struct _hw_enet_iaur_bitfields
    {
        uint32_t IADDR1 : 32;          /*!< [31:0]  */
    } B;
} hw_enet_iaur_t;

/*!
 * @name Constants and macros for entire ENET_IAUR register
 */
/*@{*/
#define HW_ENET_IAUR_ADDR(x)     ((uint32_t)(x) + 0x118U)

#define HW_ENET_IAUR(x)          (*(__IO hw_enet_iaur_t *) HW_ENET_IAUR_ADDR(x))
#define HW_ENET_IAUR_RD(x)       (HW_ENET_IAUR(x).U)
#define HW_ENET_IAUR_WR(x, v)    (HW_ENET_IAUR(x).U = (v))
#define HW_ENET_IAUR_SET(x, v)   (HW_ENET_IAUR_WR(x, HW_ENET_IAUR_RD(x) |  (v)))
#define HW_ENET_IAUR_CLR(x, v)   (HW_ENET_IAUR_WR(x, HW_ENET_IAUR_RD(x) & ~(v)))
#define HW_ENET_IAUR_TOG(x, v)   (HW_ENET_IAUR_WR(x, HW_ENET_IAUR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_IAUR bitfields
 */

/*!
 * @name Register ENET_IAUR, field IADDR1[31:0] (RW)
 *
 * Contains the upper 32 bits of the 64-bit hash table used in the address
 * recognition process for receive frames with a unicast address. Bit 31 of IADDR1
 * contains hash index bit 63. Bit 0 of IADDR1 contains hash index bit 32.
 */
/*@{*/
#define BP_ENET_IAUR_IADDR1  (0U)          /*!< Bit position for ENET_IAUR_IADDR1. */
#define BM_ENET_IAUR_IADDR1  (0xFFFFFFFFU) /*!< Bit mask for ENET_IAUR_IADDR1. */
#define BS_ENET_IAUR_IADDR1  (32U)         /*!< Bit field size in bits for ENET_IAUR_IADDR1. */

/*! @brief Read current value of the ENET_IAUR_IADDR1 field. */
#define BR_ENET_IAUR_IADDR1(x) (HW_ENET_IAUR(x).U)

/*! @brief Format value for bitfield ENET_IAUR_IADDR1. */
#define BF_ENET_IAUR_IADDR1(v) ((uint32_t)((uint32_t)(v) << BP_ENET_IAUR_IADDR1) & BM_ENET_IAUR_IADDR1)

/*! @brief Set the IADDR1 field to a new value. */
#define BW_ENET_IAUR_IADDR1(x, v) (HW_ENET_IAUR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_ENET_IALR - Descriptor Individual Lower Address Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IALR - Descriptor Individual Lower Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * IALR contains the lower 32 bits of the 64-bit individual address hash table.
 * The address recognition process uses this table to check for a possible match
 * with the DA field of receive frames with an individual DA. This register is
 * not reset and you must initialize it.
 */
typedef union _hw_enet_ialr
{
    uint32_t U;
    struct _hw_enet_ialr_bitfields
    {
        uint32_t IADDR2 : 32;          /*!< [31:0]  */
    } B;
} hw_enet_ialr_t;

/*!
 * @name Constants and macros for entire ENET_IALR register
 */
/*@{*/
#define HW_ENET_IALR_ADDR(x)     ((uint32_t)(x) + 0x11CU)

#define HW_ENET_IALR(x)          (*(__IO hw_enet_ialr_t *) HW_ENET_IALR_ADDR(x))
#define HW_ENET_IALR_RD(x)       (HW_ENET_IALR(x).U)
#define HW_ENET_IALR_WR(x, v)    (HW_ENET_IALR(x).U = (v))
#define HW_ENET_IALR_SET(x, v)   (HW_ENET_IALR_WR(x, HW_ENET_IALR_RD(x) |  (v)))
#define HW_ENET_IALR_CLR(x, v)   (HW_ENET_IALR_WR(x, HW_ENET_IALR_RD(x) & ~(v)))
#define HW_ENET_IALR_TOG(x, v)   (HW_ENET_IALR_WR(x, HW_ENET_IALR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_IALR bitfields
 */

/*!
 * @name Register ENET_IALR, field IADDR2[31:0] (RW)
 *
 * Contains the lower 32 bits of the 64-bit hash table used in the address
 * recognition process for receive frames with a unicast address. Bit 31 of IADDR2
 * contains hash index bit 31. Bit 0 of IADDR2 contains hash index bit 0.
 */
/*@{*/
#define BP_ENET_IALR_IADDR2  (0U)          /*!< Bit position for ENET_IALR_IADDR2. */
#define BM_ENET_IALR_IADDR2  (0xFFFFFFFFU) /*!< Bit mask for ENET_IALR_IADDR2. */
#define BS_ENET_IALR_IADDR2  (32U)         /*!< Bit field size in bits for ENET_IALR_IADDR2. */

/*! @brief Read current value of the ENET_IALR_IADDR2 field. */
#define BR_ENET_IALR_IADDR2(x) (HW_ENET_IALR(x).U)

/*! @brief Format value for bitfield ENET_IALR_IADDR2. */
#define BF_ENET_IALR_IADDR2(v) ((uint32_t)((uint32_t)(v) << BP_ENET_IALR_IADDR2) & BM_ENET_IALR_IADDR2)

/*! @brief Set the IADDR2 field to a new value. */
#define BW_ENET_IALR_IADDR2(x, v) (HW_ENET_IALR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_ENET_GAUR - Descriptor Group Upper Address Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_GAUR - Descriptor Group Upper Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * GAUR contains the upper 32 bits of the 64-bit hash table used in the address
 * recognition process for receive frames with a multicast address. You must
 * initialize this register.
 */
typedef union _hw_enet_gaur
{
    uint32_t U;
    struct _hw_enet_gaur_bitfields
    {
        uint32_t GADDR1 : 32;          /*!< [31:0]  */
    } B;
} hw_enet_gaur_t;

/*!
 * @name Constants and macros for entire ENET_GAUR register
 */
/*@{*/
#define HW_ENET_GAUR_ADDR(x)     ((uint32_t)(x) + 0x120U)

#define HW_ENET_GAUR(x)          (*(__IO hw_enet_gaur_t *) HW_ENET_GAUR_ADDR(x))
#define HW_ENET_GAUR_RD(x)       (HW_ENET_GAUR(x).U)
#define HW_ENET_GAUR_WR(x, v)    (HW_ENET_GAUR(x).U = (v))
#define HW_ENET_GAUR_SET(x, v)   (HW_ENET_GAUR_WR(x, HW_ENET_GAUR_RD(x) |  (v)))
#define HW_ENET_GAUR_CLR(x, v)   (HW_ENET_GAUR_WR(x, HW_ENET_GAUR_RD(x) & ~(v)))
#define HW_ENET_GAUR_TOG(x, v)   (HW_ENET_GAUR_WR(x, HW_ENET_GAUR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_GAUR bitfields
 */

/*!
 * @name Register ENET_GAUR, field GADDR1[31:0] (RW)
 *
 * Contains the upper 32 bits of the 64-bit hash table used in the address
 * recognition process for receive frames with a multicast address. Bit 31 of GADDR1
 * contains hash index bit 63. Bit 0 of GADDR1 contains hash index bit 32.
 */
/*@{*/
#define BP_ENET_GAUR_GADDR1  (0U)          /*!< Bit position for ENET_GAUR_GADDR1. */
#define BM_ENET_GAUR_GADDR1  (0xFFFFFFFFU) /*!< Bit mask for ENET_GAUR_GADDR1. */
#define BS_ENET_GAUR_GADDR1  (32U)         /*!< Bit field size in bits for ENET_GAUR_GADDR1. */

/*! @brief Read current value of the ENET_GAUR_GADDR1 field. */
#define BR_ENET_GAUR_GADDR1(x) (HW_ENET_GAUR(x).U)

/*! @brief Format value for bitfield ENET_GAUR_GADDR1. */
#define BF_ENET_GAUR_GADDR1(v) ((uint32_t)((uint32_t)(v) << BP_ENET_GAUR_GADDR1) & BM_ENET_GAUR_GADDR1)

/*! @brief Set the GADDR1 field to a new value. */
#define BW_ENET_GAUR_GADDR1(x, v) (HW_ENET_GAUR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_ENET_GALR - Descriptor Group Lower Address Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_GALR - Descriptor Group Lower Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * GALR contains the lower 32 bits of the 64-bit hash table used in the address
 * recognition process for receive frames with a multicast address. You must
 * initialize this register.
 */
typedef union _hw_enet_galr
{
    uint32_t U;
    struct _hw_enet_galr_bitfields
    {
        uint32_t GADDR2 : 32;          /*!< [31:0]  */
    } B;
} hw_enet_galr_t;

/*!
 * @name Constants and macros for entire ENET_GALR register
 */
/*@{*/
#define HW_ENET_GALR_ADDR(x)     ((uint32_t)(x) + 0x124U)

#define HW_ENET_GALR(x)          (*(__IO hw_enet_galr_t *) HW_ENET_GALR_ADDR(x))
#define HW_ENET_GALR_RD(x)       (HW_ENET_GALR(x).U)
#define HW_ENET_GALR_WR(x, v)    (HW_ENET_GALR(x).U = (v))
#define HW_ENET_GALR_SET(x, v)   (HW_ENET_GALR_WR(x, HW_ENET_GALR_RD(x) |  (v)))
#define HW_ENET_GALR_CLR(x, v)   (HW_ENET_GALR_WR(x, HW_ENET_GALR_RD(x) & ~(v)))
#define HW_ENET_GALR_TOG(x, v)   (HW_ENET_GALR_WR(x, HW_ENET_GALR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_GALR bitfields
 */

/*!
 * @name Register ENET_GALR, field GADDR2[31:0] (RW)
 *
 * Contains the lower 32 bits of the 64-bit hash table used in the address
 * recognition process for receive frames with a multicast address. Bit 31 of GADDR2
 * contains hash index bit 31. Bit 0 of GADDR2 contains hash index bit 0.
 */
/*@{*/
#define BP_ENET_GALR_GADDR2  (0U)          /*!< Bit position for ENET_GALR_GADDR2. */
#define BM_ENET_GALR_GADDR2  (0xFFFFFFFFU) /*!< Bit mask for ENET_GALR_GADDR2. */
#define BS_ENET_GALR_GADDR2  (32U)         /*!< Bit field size in bits for ENET_GALR_GADDR2. */

/*! @brief Read current value of the ENET_GALR_GADDR2 field. */
#define BR_ENET_GALR_GADDR2(x) (HW_ENET_GALR(x).U)

/*! @brief Format value for bitfield ENET_GALR_GADDR2. */
#define BF_ENET_GALR_GADDR2(v) ((uint32_t)((uint32_t)(v) << BP_ENET_GALR_GADDR2) & BM_ENET_GALR_GADDR2)

/*! @brief Set the GADDR2 field to a new value. */
#define BW_ENET_GALR_GADDR2(x, v) (HW_ENET_GALR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_ENET_TFWR - Transmit FIFO Watermark Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_TFWR - Transmit FIFO Watermark Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * If TFWR[STRFWD] is cleared, TFWR[TFWR] controls the amount of data required
 * in the transmit FIFO before transmission of a frame can begin. This allows you
 * to minimize transmit latency (TFWR = 00 or 01) or allow for larger bus access
 * latency (TFWR = 11) due to contention for the system bus. Setting the
 * watermark to a high value minimizes the risk of transmit FIFO underrun due to
 * contention for the system bus. The byte counts associated with the TFWR field may need
 * to be modified to match a given system requirement. For example, worst case
 * bus access latency by the transmit data DMA channel. When the FIFO level
 * reaches the value the TFWR field and when the STR_FWD is set to '0', the MAC
 * transmit control logic starts frame transmission even before the end-of-frame is
 * available in the FIFO (cut-through operation). If a complete frame has a size
 * smaller than the threshold programmed with TFWR, the MAC also transmits the Frame
 * to the line. To enable store and forward on the Transmit path, set STR_FWD to
 * '1'. In this case, the MAC starts to transmit data only when a complete frame
 * is stored in the Transmit FIFO.
 */
typedef union _hw_enet_tfwr
{
    uint32_t U;
    struct _hw_enet_tfwr_bitfields
    {
        uint32_t TFWR : 6;             /*!< [5:0] Transmit FIFO Write */
        uint32_t RESERVED0 : 2;        /*!< [7:6]  */
        uint32_t STRFWD : 1;           /*!< [8] Store And Forward Enable */
        uint32_t RESERVED1 : 23;       /*!< [31:9]  */
    } B;
} hw_enet_tfwr_t;

/*!
 * @name Constants and macros for entire ENET_TFWR register
 */
/*@{*/
#define HW_ENET_TFWR_ADDR(x)     ((uint32_t)(x) + 0x144U)

#define HW_ENET_TFWR(x)          (*(__IO hw_enet_tfwr_t *) HW_ENET_TFWR_ADDR(x))
#define HW_ENET_TFWR_RD(x)       (HW_ENET_TFWR(x).U)
#define HW_ENET_TFWR_WR(x, v)    (HW_ENET_TFWR(x).U = (v))
#define HW_ENET_TFWR_SET(x, v)   (HW_ENET_TFWR_WR(x, HW_ENET_TFWR_RD(x) |  (v)))
#define HW_ENET_TFWR_CLR(x, v)   (HW_ENET_TFWR_WR(x, HW_ENET_TFWR_RD(x) & ~(v)))
#define HW_ENET_TFWR_TOG(x, v)   (HW_ENET_TFWR_WR(x, HW_ENET_TFWR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TFWR bitfields
 */

/*!
 * @name Register ENET_TFWR, field TFWR[5:0] (RW)
 *
 * If TFWR[STRFWD] is cleared, this field indicates the number of bytes, in
 * steps of 64 bytes, written to the transmit FIFO before transmission of a frame
 * begins. If a frame with less than the threshold is written, it is still sent
 * independently of this threshold setting. The threshold is relevant only if the
 * frame is larger than the threshold given. This chip may not support the maximum
 * number of bytes written shown below. See the chip-specific information for the
 * ENET module for this value.
 *
 * Values:
 * - 000000 - 64 bytes written.
 * - 000001 - 64 bytes written.
 * - 000010 - 128 bytes written.
 * - 000011 - 192 bytes written.
 * - 111110 - 3968 bytes written.
 * - 111111 - 4032 bytes written.
 */
/*@{*/
#define BP_ENET_TFWR_TFWR    (0U)          /*!< Bit position for ENET_TFWR_TFWR. */
#define BM_ENET_TFWR_TFWR    (0x0000003FU) /*!< Bit mask for ENET_TFWR_TFWR. */
#define BS_ENET_TFWR_TFWR    (6U)          /*!< Bit field size in bits for ENET_TFWR_TFWR. */

/*! @brief Read current value of the ENET_TFWR_TFWR field. */
#define BR_ENET_TFWR_TFWR(x) (HW_ENET_TFWR(x).B.TFWR)

/*! @brief Format value for bitfield ENET_TFWR_TFWR. */
#define BF_ENET_TFWR_TFWR(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TFWR_TFWR) & BM_ENET_TFWR_TFWR)

/*! @brief Set the TFWR field to a new value. */
#define BW_ENET_TFWR_TFWR(x, v) (HW_ENET_TFWR_WR(x, (HW_ENET_TFWR_RD(x) & ~BM_ENET_TFWR_TFWR) | BF_ENET_TFWR_TFWR(v)))
/*@}*/

/*!
 * @name Register ENET_TFWR, field STRFWD[8] (RW)
 *
 * Values:
 * - 0 - Reset. The transmission start threshold is programmed in TFWR[TFWR].
 * - 1 - Enabled.
 */
/*@{*/
#define BP_ENET_TFWR_STRFWD  (8U)          /*!< Bit position for ENET_TFWR_STRFWD. */
#define BM_ENET_TFWR_STRFWD  (0x00000100U) /*!< Bit mask for ENET_TFWR_STRFWD. */
#define BS_ENET_TFWR_STRFWD  (1U)          /*!< Bit field size in bits for ENET_TFWR_STRFWD. */

/*! @brief Read current value of the ENET_TFWR_STRFWD field. */
#define BR_ENET_TFWR_STRFWD(x) (BITBAND_ACCESS32(HW_ENET_TFWR_ADDR(x), BP_ENET_TFWR_STRFWD))

/*! @brief Format value for bitfield ENET_TFWR_STRFWD. */
#define BF_ENET_TFWR_STRFWD(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TFWR_STRFWD) & BM_ENET_TFWR_STRFWD)

/*! @brief Set the STRFWD field to a new value. */
#define BW_ENET_TFWR_STRFWD(x, v) (BITBAND_ACCESS32(HW_ENET_TFWR_ADDR(x), BP_ENET_TFWR_STRFWD) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_RDSR - Receive Descriptor Ring Start Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RDSR - Receive Descriptor Ring Start Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * RDSR points to the beginning of the circular receive buffer descriptor queue
 * in external memory. This pointer must be 64-bit aligned (bits 2-0 must be
 * zero); however, it is recommended to be 128-bit aligned, that is, evenly divisible
 * by 16. This register must be initialized prior to operation
 */
typedef union _hw_enet_rdsr
{
    uint32_t U;
    struct _hw_enet_rdsr_bitfields
    {
        uint32_t RESERVED0 : 3;        /*!< [2:0]  */
        uint32_t R_DES_START : 29;     /*!< [31:3]  */
    } B;
} hw_enet_rdsr_t;

/*!
 * @name Constants and macros for entire ENET_RDSR register
 */
/*@{*/
#define HW_ENET_RDSR_ADDR(x)     ((uint32_t)(x) + 0x180U)

#define HW_ENET_RDSR(x)          (*(__IO hw_enet_rdsr_t *) HW_ENET_RDSR_ADDR(x))
#define HW_ENET_RDSR_RD(x)       (HW_ENET_RDSR(x).U)
#define HW_ENET_RDSR_WR(x, v)    (HW_ENET_RDSR(x).U = (v))
#define HW_ENET_RDSR_SET(x, v)   (HW_ENET_RDSR_WR(x, HW_ENET_RDSR_RD(x) |  (v)))
#define HW_ENET_RDSR_CLR(x, v)   (HW_ENET_RDSR_WR(x, HW_ENET_RDSR_RD(x) & ~(v)))
#define HW_ENET_RDSR_TOG(x, v)   (HW_ENET_RDSR_WR(x, HW_ENET_RDSR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_RDSR bitfields
 */

/*!
 * @name Register ENET_RDSR, field R_DES_START[31:3] (RW)
 *
 * Pointer to the beginning of the receive buffer descriptor queue.
 */
/*@{*/
#define BP_ENET_RDSR_R_DES_START (3U)      /*!< Bit position for ENET_RDSR_R_DES_START. */
#define BM_ENET_RDSR_R_DES_START (0xFFFFFFF8U) /*!< Bit mask for ENET_RDSR_R_DES_START. */
#define BS_ENET_RDSR_R_DES_START (29U)     /*!< Bit field size in bits for ENET_RDSR_R_DES_START. */

/*! @brief Read current value of the ENET_RDSR_R_DES_START field. */
#define BR_ENET_RDSR_R_DES_START(x) (HW_ENET_RDSR(x).B.R_DES_START)

/*! @brief Format value for bitfield ENET_RDSR_R_DES_START. */
#define BF_ENET_RDSR_R_DES_START(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RDSR_R_DES_START) & BM_ENET_RDSR_R_DES_START)

/*! @brief Set the R_DES_START field to a new value. */
#define BW_ENET_RDSR_R_DES_START(x, v) (HW_ENET_RDSR_WR(x, (HW_ENET_RDSR_RD(x) & ~BM_ENET_RDSR_R_DES_START) | BF_ENET_RDSR_R_DES_START(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_TDSR - Transmit Buffer Descriptor Ring Start Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_TDSR - Transmit Buffer Descriptor Ring Start Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TDSR provides a pointer to the beginning of the circular transmit buffer
 * descriptor queue in external memory. This pointer must be 64-bit aligned (bits 2-0
 * must be zero); however, it is recommended to be 128-bit aligned, that is,
 * evenly divisible by 16. This register must be initialized prior to operation.
 */
typedef union _hw_enet_tdsr
{
    uint32_t U;
    struct _hw_enet_tdsr_bitfields
    {
        uint32_t RESERVED0 : 3;        /*!< [2:0]  */
        uint32_t X_DES_START : 29;     /*!< [31:3]  */
    } B;
} hw_enet_tdsr_t;

/*!
 * @name Constants and macros for entire ENET_TDSR register
 */
/*@{*/
#define HW_ENET_TDSR_ADDR(x)     ((uint32_t)(x) + 0x184U)

#define HW_ENET_TDSR(x)          (*(__IO hw_enet_tdsr_t *) HW_ENET_TDSR_ADDR(x))
#define HW_ENET_TDSR_RD(x)       (HW_ENET_TDSR(x).U)
#define HW_ENET_TDSR_WR(x, v)    (HW_ENET_TDSR(x).U = (v))
#define HW_ENET_TDSR_SET(x, v)   (HW_ENET_TDSR_WR(x, HW_ENET_TDSR_RD(x) |  (v)))
#define HW_ENET_TDSR_CLR(x, v)   (HW_ENET_TDSR_WR(x, HW_ENET_TDSR_RD(x) & ~(v)))
#define HW_ENET_TDSR_TOG(x, v)   (HW_ENET_TDSR_WR(x, HW_ENET_TDSR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TDSR bitfields
 */

/*!
 * @name Register ENET_TDSR, field X_DES_START[31:3] (RW)
 *
 * Pointer to the beginning of the transmit buffer descriptor queue.
 */
/*@{*/
#define BP_ENET_TDSR_X_DES_START (3U)      /*!< Bit position for ENET_TDSR_X_DES_START. */
#define BM_ENET_TDSR_X_DES_START (0xFFFFFFF8U) /*!< Bit mask for ENET_TDSR_X_DES_START. */
#define BS_ENET_TDSR_X_DES_START (29U)     /*!< Bit field size in bits for ENET_TDSR_X_DES_START. */

/*! @brief Read current value of the ENET_TDSR_X_DES_START field. */
#define BR_ENET_TDSR_X_DES_START(x) (HW_ENET_TDSR(x).B.X_DES_START)

/*! @brief Format value for bitfield ENET_TDSR_X_DES_START. */
#define BF_ENET_TDSR_X_DES_START(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TDSR_X_DES_START) & BM_ENET_TDSR_X_DES_START)

/*! @brief Set the X_DES_START field to a new value. */
#define BW_ENET_TDSR_X_DES_START(x, v) (HW_ENET_TDSR_WR(x, (HW_ENET_TDSR_RD(x) & ~BM_ENET_TDSR_X_DES_START) | BF_ENET_TDSR_X_DES_START(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_MRBR - Maximum Receive Buffer Size Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_MRBR - Maximum Receive Buffer Size Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MRBR is a user-programmable register that dictates the maximum size of
 * all receive buffers. This value should take into consideration that the receive
 * CRC is always written into the last receive buffer. To allow one maximum size
 * frame per buffer, MRBR must be set to RCR[MAX_FL] or larger. To properly align
 * the buffer, MRBR must be evenly divisible by 16. To ensure this, bits 3-0 are
 * set to zero by the device. To minimize bus usage (descriptor fetches), set
 * MRBR greater than or equal to 256 bytes. This register must be initialized
 * before operation.
 */
typedef union _hw_enet_mrbr
{
    uint32_t U;
    struct _hw_enet_mrbr_bitfields
    {
        uint32_t RESERVED0 : 4;        /*!< [3:0]  */
        uint32_t R_BUF_SIZE : 10;      /*!< [13:4]  */
        uint32_t RESERVED1 : 18;       /*!< [31:14]  */
    } B;
} hw_enet_mrbr_t;

/*!
 * @name Constants and macros for entire ENET_MRBR register
 */
/*@{*/
#define HW_ENET_MRBR_ADDR(x)     ((uint32_t)(x) + 0x188U)

#define HW_ENET_MRBR(x)          (*(__IO hw_enet_mrbr_t *) HW_ENET_MRBR_ADDR(x))
#define HW_ENET_MRBR_RD(x)       (HW_ENET_MRBR(x).U)
#define HW_ENET_MRBR_WR(x, v)    (HW_ENET_MRBR(x).U = (v))
#define HW_ENET_MRBR_SET(x, v)   (HW_ENET_MRBR_WR(x, HW_ENET_MRBR_RD(x) |  (v)))
#define HW_ENET_MRBR_CLR(x, v)   (HW_ENET_MRBR_WR(x, HW_ENET_MRBR_RD(x) & ~(v)))
#define HW_ENET_MRBR_TOG(x, v)   (HW_ENET_MRBR_WR(x, HW_ENET_MRBR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_MRBR bitfields
 */

/*!
 * @name Register ENET_MRBR, field R_BUF_SIZE[13:4] (RW)
 *
 * Receive buffer size in bytes.
 */
/*@{*/
#define BP_ENET_MRBR_R_BUF_SIZE (4U)       /*!< Bit position for ENET_MRBR_R_BUF_SIZE. */
#define BM_ENET_MRBR_R_BUF_SIZE (0x00003FF0U) /*!< Bit mask for ENET_MRBR_R_BUF_SIZE. */
#define BS_ENET_MRBR_R_BUF_SIZE (10U)      /*!< Bit field size in bits for ENET_MRBR_R_BUF_SIZE. */

/*! @brief Read current value of the ENET_MRBR_R_BUF_SIZE field. */
#define BR_ENET_MRBR_R_BUF_SIZE(x) (HW_ENET_MRBR(x).B.R_BUF_SIZE)

/*! @brief Format value for bitfield ENET_MRBR_R_BUF_SIZE. */
#define BF_ENET_MRBR_R_BUF_SIZE(v) ((uint32_t)((uint32_t)(v) << BP_ENET_MRBR_R_BUF_SIZE) & BM_ENET_MRBR_R_BUF_SIZE)

/*! @brief Set the R_BUF_SIZE field to a new value. */
#define BW_ENET_MRBR_R_BUF_SIZE(x, v) (HW_ENET_MRBR_WR(x, (HW_ENET_MRBR_RD(x) & ~BM_ENET_MRBR_R_BUF_SIZE) | BF_ENET_MRBR_R_BUF_SIZE(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_RSFL - Receive FIFO Section Full Threshold
 ******************************************************************************/

/*!
 * @brief HW_ENET_RSFL - Receive FIFO Section Full Threshold (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rsfl
{
    uint32_t U;
    struct _hw_enet_rsfl_bitfields
    {
        uint32_t RX_SECTION_FULL : 8;  /*!< [7:0] Value Of Receive FIFO
                                        * Section Full Threshold */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_enet_rsfl_t;

/*!
 * @name Constants and macros for entire ENET_RSFL register
 */
/*@{*/
#define HW_ENET_RSFL_ADDR(x)     ((uint32_t)(x) + 0x190U)

#define HW_ENET_RSFL(x)          (*(__IO hw_enet_rsfl_t *) HW_ENET_RSFL_ADDR(x))
#define HW_ENET_RSFL_RD(x)       (HW_ENET_RSFL(x).U)
#define HW_ENET_RSFL_WR(x, v)    (HW_ENET_RSFL(x).U = (v))
#define HW_ENET_RSFL_SET(x, v)   (HW_ENET_RSFL_WR(x, HW_ENET_RSFL_RD(x) |  (v)))
#define HW_ENET_RSFL_CLR(x, v)   (HW_ENET_RSFL_WR(x, HW_ENET_RSFL_RD(x) & ~(v)))
#define HW_ENET_RSFL_TOG(x, v)   (HW_ENET_RSFL_WR(x, HW_ENET_RSFL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_RSFL bitfields
 */

/*!
 * @name Register ENET_RSFL, field RX_SECTION_FULL[7:0] (RW)
 *
 * Value, in 64-bit words, of the receive FIFO section full threshold. Clear
 * this field to enable store and forward on the RX FIFO. When programming a value
 * greater than 0 (cut-through operation), it must be greater than
 * RAEM[RX_ALMOST_EMPTY]. When the FIFO level reaches the value in this field, data is available
 * in the Receive FIFO (cut-through operation).
 */
/*@{*/
#define BP_ENET_RSFL_RX_SECTION_FULL (0U)  /*!< Bit position for ENET_RSFL_RX_SECTION_FULL. */
#define BM_ENET_RSFL_RX_SECTION_FULL (0x000000FFU) /*!< Bit mask for ENET_RSFL_RX_SECTION_FULL. */
#define BS_ENET_RSFL_RX_SECTION_FULL (8U)  /*!< Bit field size in bits for ENET_RSFL_RX_SECTION_FULL. */

/*! @brief Read current value of the ENET_RSFL_RX_SECTION_FULL field. */
#define BR_ENET_RSFL_RX_SECTION_FULL(x) (HW_ENET_RSFL(x).B.RX_SECTION_FULL)

/*! @brief Format value for bitfield ENET_RSFL_RX_SECTION_FULL. */
#define BF_ENET_RSFL_RX_SECTION_FULL(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RSFL_RX_SECTION_FULL) & BM_ENET_RSFL_RX_SECTION_FULL)

/*! @brief Set the RX_SECTION_FULL field to a new value. */
#define BW_ENET_RSFL_RX_SECTION_FULL(x, v) (HW_ENET_RSFL_WR(x, (HW_ENET_RSFL_RD(x) & ~BM_ENET_RSFL_RX_SECTION_FULL) | BF_ENET_RSFL_RX_SECTION_FULL(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_RSEM - Receive FIFO Section Empty Threshold
 ******************************************************************************/

/*!
 * @brief HW_ENET_RSEM - Receive FIFO Section Empty Threshold (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rsem
{
    uint32_t U;
    struct _hw_enet_rsem_bitfields
    {
        uint32_t RX_SECTION_EMPTY : 8; /*!< [7:0] Value Of The Receive FIFO
                                        * Section Empty Threshold */
        uint32_t RESERVED0 : 8;        /*!< [15:8]  */
        uint32_t STAT_SECTION_EMPTY : 5; /*!< [20:16] RX Status FIFO Section
                                        * Empty Threshold */
        uint32_t RESERVED1 : 11;       /*!< [31:21]  */
    } B;
} hw_enet_rsem_t;

/*!
 * @name Constants and macros for entire ENET_RSEM register
 */
/*@{*/
#define HW_ENET_RSEM_ADDR(x)     ((uint32_t)(x) + 0x194U)

#define HW_ENET_RSEM(x)          (*(__IO hw_enet_rsem_t *) HW_ENET_RSEM_ADDR(x))
#define HW_ENET_RSEM_RD(x)       (HW_ENET_RSEM(x).U)
#define HW_ENET_RSEM_WR(x, v)    (HW_ENET_RSEM(x).U = (v))
#define HW_ENET_RSEM_SET(x, v)   (HW_ENET_RSEM_WR(x, HW_ENET_RSEM_RD(x) |  (v)))
#define HW_ENET_RSEM_CLR(x, v)   (HW_ENET_RSEM_WR(x, HW_ENET_RSEM_RD(x) & ~(v)))
#define HW_ENET_RSEM_TOG(x, v)   (HW_ENET_RSEM_WR(x, HW_ENET_RSEM_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_RSEM bitfields
 */

/*!
 * @name Register ENET_RSEM, field RX_SECTION_EMPTY[7:0] (RW)
 *
 * Value, in 64-bit words, of the receive FIFO section empty threshold. When the
 * FIFO has reached this level, a pause frame will be issued. A value of 0
 * disables automatic pause frame generation. When the FIFO level goes below the value
 * programmed in this field, an XON pause frame is issued to indicate the FIFO
 * congestion is cleared to the remote Ethernet client. The section-empty
 * threshold indications from both FIFOs are OR'ed to cause XOFF pause frame generation.
 */
/*@{*/
#define BP_ENET_RSEM_RX_SECTION_EMPTY (0U) /*!< Bit position for ENET_RSEM_RX_SECTION_EMPTY. */
#define BM_ENET_RSEM_RX_SECTION_EMPTY (0x000000FFU) /*!< Bit mask for ENET_RSEM_RX_SECTION_EMPTY. */
#define BS_ENET_RSEM_RX_SECTION_EMPTY (8U) /*!< Bit field size in bits for ENET_RSEM_RX_SECTION_EMPTY. */

/*! @brief Read current value of the ENET_RSEM_RX_SECTION_EMPTY field. */
#define BR_ENET_RSEM_RX_SECTION_EMPTY(x) (HW_ENET_RSEM(x).B.RX_SECTION_EMPTY)

/*! @brief Format value for bitfield ENET_RSEM_RX_SECTION_EMPTY. */
#define BF_ENET_RSEM_RX_SECTION_EMPTY(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RSEM_RX_SECTION_EMPTY) & BM_ENET_RSEM_RX_SECTION_EMPTY)

/*! @brief Set the RX_SECTION_EMPTY field to a new value. */
#define BW_ENET_RSEM_RX_SECTION_EMPTY(x, v) (HW_ENET_RSEM_WR(x, (HW_ENET_RSEM_RD(x) & ~BM_ENET_RSEM_RX_SECTION_EMPTY) | BF_ENET_RSEM_RX_SECTION_EMPTY(v)))
/*@}*/

/*!
 * @name Register ENET_RSEM, field STAT_SECTION_EMPTY[20:16] (RW)
 *
 * Defines number of frames in the receive FIFO, independent of its size, that
 * can be accepted. If the limit is reached, reception will continue normally,
 * however a pause frame will be triggered to indicate a possible congestion to the
 * remote device to avoid FIFO overflow. A value of 0 disables automatic pause
 * frame generation
 */
/*@{*/
#define BP_ENET_RSEM_STAT_SECTION_EMPTY (16U) /*!< Bit position for ENET_RSEM_STAT_SECTION_EMPTY. */
#define BM_ENET_RSEM_STAT_SECTION_EMPTY (0x001F0000U) /*!< Bit mask for ENET_RSEM_STAT_SECTION_EMPTY. */
#define BS_ENET_RSEM_STAT_SECTION_EMPTY (5U) /*!< Bit field size in bits for ENET_RSEM_STAT_SECTION_EMPTY. */

/*! @brief Read current value of the ENET_RSEM_STAT_SECTION_EMPTY field. */
#define BR_ENET_RSEM_STAT_SECTION_EMPTY(x) (HW_ENET_RSEM(x).B.STAT_SECTION_EMPTY)

/*! @brief Format value for bitfield ENET_RSEM_STAT_SECTION_EMPTY. */
#define BF_ENET_RSEM_STAT_SECTION_EMPTY(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RSEM_STAT_SECTION_EMPTY) & BM_ENET_RSEM_STAT_SECTION_EMPTY)

/*! @brief Set the STAT_SECTION_EMPTY field to a new value. */
#define BW_ENET_RSEM_STAT_SECTION_EMPTY(x, v) (HW_ENET_RSEM_WR(x, (HW_ENET_RSEM_RD(x) & ~BM_ENET_RSEM_STAT_SECTION_EMPTY) | BF_ENET_RSEM_STAT_SECTION_EMPTY(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_RAEM - Receive FIFO Almost Empty Threshold
 ******************************************************************************/

/*!
 * @brief HW_ENET_RAEM - Receive FIFO Almost Empty Threshold (RW)
 *
 * Reset value: 0x00000004U
 */
typedef union _hw_enet_raem
{
    uint32_t U;
    struct _hw_enet_raem_bitfields
    {
        uint32_t RX_ALMOST_EMPTY : 8;  /*!< [7:0] Value Of The Receive FIFO
                                        * Almost Empty Threshold */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_enet_raem_t;

/*!
 * @name Constants and macros for entire ENET_RAEM register
 */
/*@{*/
#define HW_ENET_RAEM_ADDR(x)     ((uint32_t)(x) + 0x198U)

#define HW_ENET_RAEM(x)          (*(__IO hw_enet_raem_t *) HW_ENET_RAEM_ADDR(x))
#define HW_ENET_RAEM_RD(x)       (HW_ENET_RAEM(x).U)
#define HW_ENET_RAEM_WR(x, v)    (HW_ENET_RAEM(x).U = (v))
#define HW_ENET_RAEM_SET(x, v)   (HW_ENET_RAEM_WR(x, HW_ENET_RAEM_RD(x) |  (v)))
#define HW_ENET_RAEM_CLR(x, v)   (HW_ENET_RAEM_WR(x, HW_ENET_RAEM_RD(x) & ~(v)))
#define HW_ENET_RAEM_TOG(x, v)   (HW_ENET_RAEM_WR(x, HW_ENET_RAEM_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_RAEM bitfields
 */

/*!
 * @name Register ENET_RAEM, field RX_ALMOST_EMPTY[7:0] (RW)
 *
 * Value, in 64-bit words, of the receive FIFO almost empty threshold. When the
 * FIFO level reaches the value programmed in this field and the end-of-frame has
 * not been received for the frame yet, the core receive read control stops FIFO
 * read (and subsequently stops transferring data to the MAC client
 * application). It continues to deliver the frame, if again more data than the threshold or
 * the end-of-frame is available in the FIFO. A minimum value of 4 should be set.
 */
/*@{*/
#define BP_ENET_RAEM_RX_ALMOST_EMPTY (0U)  /*!< Bit position for ENET_RAEM_RX_ALMOST_EMPTY. */
#define BM_ENET_RAEM_RX_ALMOST_EMPTY (0x000000FFU) /*!< Bit mask for ENET_RAEM_RX_ALMOST_EMPTY. */
#define BS_ENET_RAEM_RX_ALMOST_EMPTY (8U)  /*!< Bit field size in bits for ENET_RAEM_RX_ALMOST_EMPTY. */

/*! @brief Read current value of the ENET_RAEM_RX_ALMOST_EMPTY field. */
#define BR_ENET_RAEM_RX_ALMOST_EMPTY(x) (HW_ENET_RAEM(x).B.RX_ALMOST_EMPTY)

/*! @brief Format value for bitfield ENET_RAEM_RX_ALMOST_EMPTY. */
#define BF_ENET_RAEM_RX_ALMOST_EMPTY(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RAEM_RX_ALMOST_EMPTY) & BM_ENET_RAEM_RX_ALMOST_EMPTY)

/*! @brief Set the RX_ALMOST_EMPTY field to a new value. */
#define BW_ENET_RAEM_RX_ALMOST_EMPTY(x, v) (HW_ENET_RAEM_WR(x, (HW_ENET_RAEM_RD(x) & ~BM_ENET_RAEM_RX_ALMOST_EMPTY) | BF_ENET_RAEM_RX_ALMOST_EMPTY(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_RAFL - Receive FIFO Almost Full Threshold
 ******************************************************************************/

/*!
 * @brief HW_ENET_RAFL - Receive FIFO Almost Full Threshold (RW)
 *
 * Reset value: 0x00000004U
 */
typedef union _hw_enet_rafl
{
    uint32_t U;
    struct _hw_enet_rafl_bitfields
    {
        uint32_t RX_ALMOST_FULL : 8;   /*!< [7:0] Value Of The Receive FIFO
                                        * Almost Full Threshold */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_enet_rafl_t;

/*!
 * @name Constants and macros for entire ENET_RAFL register
 */
/*@{*/
#define HW_ENET_RAFL_ADDR(x)     ((uint32_t)(x) + 0x19CU)

#define HW_ENET_RAFL(x)          (*(__IO hw_enet_rafl_t *) HW_ENET_RAFL_ADDR(x))
#define HW_ENET_RAFL_RD(x)       (HW_ENET_RAFL(x).U)
#define HW_ENET_RAFL_WR(x, v)    (HW_ENET_RAFL(x).U = (v))
#define HW_ENET_RAFL_SET(x, v)   (HW_ENET_RAFL_WR(x, HW_ENET_RAFL_RD(x) |  (v)))
#define HW_ENET_RAFL_CLR(x, v)   (HW_ENET_RAFL_WR(x, HW_ENET_RAFL_RD(x) & ~(v)))
#define HW_ENET_RAFL_TOG(x, v)   (HW_ENET_RAFL_WR(x, HW_ENET_RAFL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_RAFL bitfields
 */

/*!
 * @name Register ENET_RAFL, field RX_ALMOST_FULL[7:0] (RW)
 *
 * Value, in 64-bit words, of the receive FIFO almost full threshold. When the
 * FIFO level comes close to the maximum, so that there is no more space for at
 * least RX_ALMOST_FULL number of words, the MAC stops writing data in the FIFO and
 * truncates the received frame to avoid FIFO overflow. The corresponding error
 * status will be set when the frame is delivered to the application. A minimum
 * value of 4 should be set.
 */
/*@{*/
#define BP_ENET_RAFL_RX_ALMOST_FULL (0U)   /*!< Bit position for ENET_RAFL_RX_ALMOST_FULL. */
#define BM_ENET_RAFL_RX_ALMOST_FULL (0x000000FFU) /*!< Bit mask for ENET_RAFL_RX_ALMOST_FULL. */
#define BS_ENET_RAFL_RX_ALMOST_FULL (8U)   /*!< Bit field size in bits for ENET_RAFL_RX_ALMOST_FULL. */

/*! @brief Read current value of the ENET_RAFL_RX_ALMOST_FULL field. */
#define BR_ENET_RAFL_RX_ALMOST_FULL(x) (HW_ENET_RAFL(x).B.RX_ALMOST_FULL)

/*! @brief Format value for bitfield ENET_RAFL_RX_ALMOST_FULL. */
#define BF_ENET_RAFL_RX_ALMOST_FULL(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RAFL_RX_ALMOST_FULL) & BM_ENET_RAFL_RX_ALMOST_FULL)

/*! @brief Set the RX_ALMOST_FULL field to a new value. */
#define BW_ENET_RAFL_RX_ALMOST_FULL(x, v) (HW_ENET_RAFL_WR(x, (HW_ENET_RAFL_RD(x) & ~BM_ENET_RAFL_RX_ALMOST_FULL) | BF_ENET_RAFL_RX_ALMOST_FULL(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_TSEM - Transmit FIFO Section Empty Threshold
 ******************************************************************************/

/*!
 * @brief HW_ENET_TSEM - Transmit FIFO Section Empty Threshold (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_tsem
{
    uint32_t U;
    struct _hw_enet_tsem_bitfields
    {
        uint32_t TX_SECTION_EMPTY : 8; /*!< [7:0] Value Of The Transmit FIFO
                                        * Section Empty Threshold */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_enet_tsem_t;

/*!
 * @name Constants and macros for entire ENET_TSEM register
 */
/*@{*/
#define HW_ENET_TSEM_ADDR(x)     ((uint32_t)(x) + 0x1A0U)

#define HW_ENET_TSEM(x)          (*(__IO hw_enet_tsem_t *) HW_ENET_TSEM_ADDR(x))
#define HW_ENET_TSEM_RD(x)       (HW_ENET_TSEM(x).U)
#define HW_ENET_TSEM_WR(x, v)    (HW_ENET_TSEM(x).U = (v))
#define HW_ENET_TSEM_SET(x, v)   (HW_ENET_TSEM_WR(x, HW_ENET_TSEM_RD(x) |  (v)))
#define HW_ENET_TSEM_CLR(x, v)   (HW_ENET_TSEM_WR(x, HW_ENET_TSEM_RD(x) & ~(v)))
#define HW_ENET_TSEM_TOG(x, v)   (HW_ENET_TSEM_WR(x, HW_ENET_TSEM_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TSEM bitfields
 */

/*!
 * @name Register ENET_TSEM, field TX_SECTION_EMPTY[7:0] (RW)
 *
 * Value, in 64-bit words, of the transmit FIFO section empty threshold. See
 * Transmit FIFOFour programmable thresholds are available which control the core
 * operation. for more information.
 */
/*@{*/
#define BP_ENET_TSEM_TX_SECTION_EMPTY (0U) /*!< Bit position for ENET_TSEM_TX_SECTION_EMPTY. */
#define BM_ENET_TSEM_TX_SECTION_EMPTY (0x000000FFU) /*!< Bit mask for ENET_TSEM_TX_SECTION_EMPTY. */
#define BS_ENET_TSEM_TX_SECTION_EMPTY (8U) /*!< Bit field size in bits for ENET_TSEM_TX_SECTION_EMPTY. */

/*! @brief Read current value of the ENET_TSEM_TX_SECTION_EMPTY field. */
#define BR_ENET_TSEM_TX_SECTION_EMPTY(x) (HW_ENET_TSEM(x).B.TX_SECTION_EMPTY)

/*! @brief Format value for bitfield ENET_TSEM_TX_SECTION_EMPTY. */
#define BF_ENET_TSEM_TX_SECTION_EMPTY(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TSEM_TX_SECTION_EMPTY) & BM_ENET_TSEM_TX_SECTION_EMPTY)

/*! @brief Set the TX_SECTION_EMPTY field to a new value. */
#define BW_ENET_TSEM_TX_SECTION_EMPTY(x, v) (HW_ENET_TSEM_WR(x, (HW_ENET_TSEM_RD(x) & ~BM_ENET_TSEM_TX_SECTION_EMPTY) | BF_ENET_TSEM_TX_SECTION_EMPTY(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_TAEM - Transmit FIFO Almost Empty Threshold
 ******************************************************************************/

/*!
 * @brief HW_ENET_TAEM - Transmit FIFO Almost Empty Threshold (RW)
 *
 * Reset value: 0x00000004U
 */
typedef union _hw_enet_taem
{
    uint32_t U;
    struct _hw_enet_taem_bitfields
    {
        uint32_t TX_ALMOST_EMPTY : 8;  /*!< [7:0] Value of Transmit FIFO
                                        * Almost Empty Threshold */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_enet_taem_t;

/*!
 * @name Constants and macros for entire ENET_TAEM register
 */
/*@{*/
#define HW_ENET_TAEM_ADDR(x)     ((uint32_t)(x) + 0x1A4U)

#define HW_ENET_TAEM(x)          (*(__IO hw_enet_taem_t *) HW_ENET_TAEM_ADDR(x))
#define HW_ENET_TAEM_RD(x)       (HW_ENET_TAEM(x).U)
#define HW_ENET_TAEM_WR(x, v)    (HW_ENET_TAEM(x).U = (v))
#define HW_ENET_TAEM_SET(x, v)   (HW_ENET_TAEM_WR(x, HW_ENET_TAEM_RD(x) |  (v)))
#define HW_ENET_TAEM_CLR(x, v)   (HW_ENET_TAEM_WR(x, HW_ENET_TAEM_RD(x) & ~(v)))
#define HW_ENET_TAEM_TOG(x, v)   (HW_ENET_TAEM_WR(x, HW_ENET_TAEM_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TAEM bitfields
 */

/*!
 * @name Register ENET_TAEM, field TX_ALMOST_EMPTY[7:0] (RW)
 *
 * Value, in 64-bit words, of the transmit FIFO almost empty threshold. When the
 * FIFO level reaches the value programmed in this field, and no end-of-frame is
 * available for the frame, the MAC transmit logic, to avoid FIFO underflow,
 * stops reading the FIFO and transmits a frame with an MII error indication. See
 * Transmit FIFOFour programmable thresholds are available which control the core
 * operation. for more information. A minimum value of 4 should be set.
 */
/*@{*/
#define BP_ENET_TAEM_TX_ALMOST_EMPTY (0U)  /*!< Bit position for ENET_TAEM_TX_ALMOST_EMPTY. */
#define BM_ENET_TAEM_TX_ALMOST_EMPTY (0x000000FFU) /*!< Bit mask for ENET_TAEM_TX_ALMOST_EMPTY. */
#define BS_ENET_TAEM_TX_ALMOST_EMPTY (8U)  /*!< Bit field size in bits for ENET_TAEM_TX_ALMOST_EMPTY. */

/*! @brief Read current value of the ENET_TAEM_TX_ALMOST_EMPTY field. */
#define BR_ENET_TAEM_TX_ALMOST_EMPTY(x) (HW_ENET_TAEM(x).B.TX_ALMOST_EMPTY)

/*! @brief Format value for bitfield ENET_TAEM_TX_ALMOST_EMPTY. */
#define BF_ENET_TAEM_TX_ALMOST_EMPTY(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TAEM_TX_ALMOST_EMPTY) & BM_ENET_TAEM_TX_ALMOST_EMPTY)

/*! @brief Set the TX_ALMOST_EMPTY field to a new value. */
#define BW_ENET_TAEM_TX_ALMOST_EMPTY(x, v) (HW_ENET_TAEM_WR(x, (HW_ENET_TAEM_RD(x) & ~BM_ENET_TAEM_TX_ALMOST_EMPTY) | BF_ENET_TAEM_TX_ALMOST_EMPTY(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_TAFL - Transmit FIFO Almost Full Threshold
 ******************************************************************************/

/*!
 * @brief HW_ENET_TAFL - Transmit FIFO Almost Full Threshold (RW)
 *
 * Reset value: 0x00000008U
 */
typedef union _hw_enet_tafl
{
    uint32_t U;
    struct _hw_enet_tafl_bitfields
    {
        uint32_t TX_ALMOST_FULL : 8;   /*!< [7:0] Value Of The Transmit FIFO
                                        * Almost Full Threshold */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_enet_tafl_t;

/*!
 * @name Constants and macros for entire ENET_TAFL register
 */
/*@{*/
#define HW_ENET_TAFL_ADDR(x)     ((uint32_t)(x) + 0x1A8U)

#define HW_ENET_TAFL(x)          (*(__IO hw_enet_tafl_t *) HW_ENET_TAFL_ADDR(x))
#define HW_ENET_TAFL_RD(x)       (HW_ENET_TAFL(x).U)
#define HW_ENET_TAFL_WR(x, v)    (HW_ENET_TAFL(x).U = (v))
#define HW_ENET_TAFL_SET(x, v)   (HW_ENET_TAFL_WR(x, HW_ENET_TAFL_RD(x) |  (v)))
#define HW_ENET_TAFL_CLR(x, v)   (HW_ENET_TAFL_WR(x, HW_ENET_TAFL_RD(x) & ~(v)))
#define HW_ENET_TAFL_TOG(x, v)   (HW_ENET_TAFL_WR(x, HW_ENET_TAFL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TAFL bitfields
 */

/*!
 * @name Register ENET_TAFL, field TX_ALMOST_FULL[7:0] (RW)
 *
 * Value, in 64-bit words, of the transmit FIFO almost full threshold. A minimum
 * value of six is required . A recommended value of at least 8 should be set
 * allowing a latency of two clock cycles to the application. If more latency is
 * required the value can be increased as necessary (latency = TAFL - 5). When the
 * FIFO level comes close to the maximum, so that there is no more space for at
 * least TX_ALMOST_FULL number of words, the pin ff_tx_rdy is deasserted. If the
 * application does not react on this signal, the FIFO write control logic, to
 * avoid FIFO overflow, truncates the current frame and sets the error status. As a
 * result, the frame will be transmitted with an GMII/MII error indication. See
 * Transmit FIFOFour programmable thresholds are available which control the core
 * operation. for more information. A FIFO overflow is a fatal error and requires
 * a global reset on the transmit datapath or at least deassertion of ETHEREN.
 */
/*@{*/
#define BP_ENET_TAFL_TX_ALMOST_FULL (0U)   /*!< Bit position for ENET_TAFL_TX_ALMOST_FULL. */
#define BM_ENET_TAFL_TX_ALMOST_FULL (0x000000FFU) /*!< Bit mask for ENET_TAFL_TX_ALMOST_FULL. */
#define BS_ENET_TAFL_TX_ALMOST_FULL (8U)   /*!< Bit field size in bits for ENET_TAFL_TX_ALMOST_FULL. */

/*! @brief Read current value of the ENET_TAFL_TX_ALMOST_FULL field. */
#define BR_ENET_TAFL_TX_ALMOST_FULL(x) (HW_ENET_TAFL(x).B.TX_ALMOST_FULL)

/*! @brief Format value for bitfield ENET_TAFL_TX_ALMOST_FULL. */
#define BF_ENET_TAFL_TX_ALMOST_FULL(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TAFL_TX_ALMOST_FULL) & BM_ENET_TAFL_TX_ALMOST_FULL)

/*! @brief Set the TX_ALMOST_FULL field to a new value. */
#define BW_ENET_TAFL_TX_ALMOST_FULL(x, v) (HW_ENET_TAFL_WR(x, (HW_ENET_TAFL_RD(x) & ~BM_ENET_TAFL_TX_ALMOST_FULL) | BF_ENET_TAFL_TX_ALMOST_FULL(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_TIPG - Transmit Inter-Packet Gap
 ******************************************************************************/

/*!
 * @brief HW_ENET_TIPG - Transmit Inter-Packet Gap (RW)
 *
 * Reset value: 0x0000000CU
 */
typedef union _hw_enet_tipg
{
    uint32_t U;
    struct _hw_enet_tipg_bitfields
    {
        uint32_t IPG : 5;              /*!< [4:0] Transmit Inter-Packet Gap */
        uint32_t RESERVED0 : 27;       /*!< [31:5]  */
    } B;
} hw_enet_tipg_t;

/*!
 * @name Constants and macros for entire ENET_TIPG register
 */
/*@{*/
#define HW_ENET_TIPG_ADDR(x)     ((uint32_t)(x) + 0x1ACU)

#define HW_ENET_TIPG(x)          (*(__IO hw_enet_tipg_t *) HW_ENET_TIPG_ADDR(x))
#define HW_ENET_TIPG_RD(x)       (HW_ENET_TIPG(x).U)
#define HW_ENET_TIPG_WR(x, v)    (HW_ENET_TIPG(x).U = (v))
#define HW_ENET_TIPG_SET(x, v)   (HW_ENET_TIPG_WR(x, HW_ENET_TIPG_RD(x) |  (v)))
#define HW_ENET_TIPG_CLR(x, v)   (HW_ENET_TIPG_WR(x, HW_ENET_TIPG_RD(x) & ~(v)))
#define HW_ENET_TIPG_TOG(x, v)   (HW_ENET_TIPG_WR(x, HW_ENET_TIPG_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TIPG bitfields
 */

/*!
 * @name Register ENET_TIPG, field IPG[4:0] (RW)
 *
 * Indicates the IPG, in bytes, between transmitted frames. Valid values range
 * from 8 to 27. If value is less than 8, the IPG is 8. If value is greater than
 * 27, the IPG is 27.
 */
/*@{*/
#define BP_ENET_TIPG_IPG     (0U)          /*!< Bit position for ENET_TIPG_IPG. */
#define BM_ENET_TIPG_IPG     (0x0000001FU) /*!< Bit mask for ENET_TIPG_IPG. */
#define BS_ENET_TIPG_IPG     (5U)          /*!< Bit field size in bits for ENET_TIPG_IPG. */

/*! @brief Read current value of the ENET_TIPG_IPG field. */
#define BR_ENET_TIPG_IPG(x)  (HW_ENET_TIPG(x).B.IPG)

/*! @brief Format value for bitfield ENET_TIPG_IPG. */
#define BF_ENET_TIPG_IPG(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_TIPG_IPG) & BM_ENET_TIPG_IPG)

/*! @brief Set the IPG field to a new value. */
#define BW_ENET_TIPG_IPG(x, v) (HW_ENET_TIPG_WR(x, (HW_ENET_TIPG_RD(x) & ~BM_ENET_TIPG_IPG) | BF_ENET_TIPG_IPG(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_FTRL - Frame Truncation Length
 ******************************************************************************/

/*!
 * @brief HW_ENET_FTRL - Frame Truncation Length (RW)
 *
 * Reset value: 0x000007FFU
 */
typedef union _hw_enet_ftrl
{
    uint32_t U;
    struct _hw_enet_ftrl_bitfields
    {
        uint32_t TRUNC_FL : 14;        /*!< [13:0] Frame Truncation Length */
        uint32_t RESERVED0 : 18;       /*!< [31:14]  */
    } B;
} hw_enet_ftrl_t;

/*!
 * @name Constants and macros for entire ENET_FTRL register
 */
/*@{*/
#define HW_ENET_FTRL_ADDR(x)     ((uint32_t)(x) + 0x1B0U)

#define HW_ENET_FTRL(x)          (*(__IO hw_enet_ftrl_t *) HW_ENET_FTRL_ADDR(x))
#define HW_ENET_FTRL_RD(x)       (HW_ENET_FTRL(x).U)
#define HW_ENET_FTRL_WR(x, v)    (HW_ENET_FTRL(x).U = (v))
#define HW_ENET_FTRL_SET(x, v)   (HW_ENET_FTRL_WR(x, HW_ENET_FTRL_RD(x) |  (v)))
#define HW_ENET_FTRL_CLR(x, v)   (HW_ENET_FTRL_WR(x, HW_ENET_FTRL_RD(x) & ~(v)))
#define HW_ENET_FTRL_TOG(x, v)   (HW_ENET_FTRL_WR(x, HW_ENET_FTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_FTRL bitfields
 */

/*!
 * @name Register ENET_FTRL, field TRUNC_FL[13:0] (RW)
 *
 * Indicates the value a receive frame is truncated, if it is greater than this
 * value. Must be greater than or equal to RCR[MAX_FL]. Truncation happens at
 * TRUNC_FL. However, when truncation occurs, the application (FIFO) may receive
 * less data, guaranteeing that it never receives more than the set limit.
 */
/*@{*/
#define BP_ENET_FTRL_TRUNC_FL (0U)         /*!< Bit position for ENET_FTRL_TRUNC_FL. */
#define BM_ENET_FTRL_TRUNC_FL (0x00003FFFU) /*!< Bit mask for ENET_FTRL_TRUNC_FL. */
#define BS_ENET_FTRL_TRUNC_FL (14U)        /*!< Bit field size in bits for ENET_FTRL_TRUNC_FL. */

/*! @brief Read current value of the ENET_FTRL_TRUNC_FL field. */
#define BR_ENET_FTRL_TRUNC_FL(x) (HW_ENET_FTRL(x).B.TRUNC_FL)

/*! @brief Format value for bitfield ENET_FTRL_TRUNC_FL. */
#define BF_ENET_FTRL_TRUNC_FL(v) ((uint32_t)((uint32_t)(v) << BP_ENET_FTRL_TRUNC_FL) & BM_ENET_FTRL_TRUNC_FL)

/*! @brief Set the TRUNC_FL field to a new value. */
#define BW_ENET_FTRL_TRUNC_FL(x, v) (HW_ENET_FTRL_WR(x, (HW_ENET_FTRL_RD(x) & ~BM_ENET_FTRL_TRUNC_FL) | BF_ENET_FTRL_TRUNC_FL(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_TACC - Transmit Accelerator Function Configuration
 ******************************************************************************/

/*!
 * @brief HW_ENET_TACC - Transmit Accelerator Function Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * TACC controls accelerator actions when sending frames. The register can be
 * changed before or after each frame, but it must remain unmodified during frame
 * writes into the transmit FIFO. The TFWR[STRFWD] field must be set to use the
 * checksum feature.
 */
typedef union _hw_enet_tacc
{
    uint32_t U;
    struct _hw_enet_tacc_bitfields
    {
        uint32_t SHIFT16 : 1;          /*!< [0] TX FIFO Shift-16 */
        uint32_t RESERVED0 : 2;        /*!< [2:1]  */
        uint32_t IPCHK : 1;            /*!< [3]  */
        uint32_t PROCHK : 1;           /*!< [4]  */
        uint32_t RESERVED1 : 27;       /*!< [31:5]  */
    } B;
} hw_enet_tacc_t;

/*!
 * @name Constants and macros for entire ENET_TACC register
 */
/*@{*/
#define HW_ENET_TACC_ADDR(x)     ((uint32_t)(x) + 0x1C0U)

#define HW_ENET_TACC(x)          (*(__IO hw_enet_tacc_t *) HW_ENET_TACC_ADDR(x))
#define HW_ENET_TACC_RD(x)       (HW_ENET_TACC(x).U)
#define HW_ENET_TACC_WR(x, v)    (HW_ENET_TACC(x).U = (v))
#define HW_ENET_TACC_SET(x, v)   (HW_ENET_TACC_WR(x, HW_ENET_TACC_RD(x) |  (v)))
#define HW_ENET_TACC_CLR(x, v)   (HW_ENET_TACC_WR(x, HW_ENET_TACC_RD(x) & ~(v)))
#define HW_ENET_TACC_TOG(x, v)   (HW_ENET_TACC_WR(x, HW_ENET_TACC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TACC bitfields
 */

/*!
 * @name Register ENET_TACC, field SHIFT16[0] (RW)
 *
 * Values:
 * - 0 - Disabled.
 * - 1 - Indicates to the transmit data FIFO that the written frames contain two
 *     additional octets before the frame data. This means the actual frame
 *     begins at bit 16 of the first word written into the FIFO. This function allows
 *     putting the frame payload on a 32-bit boundary in memory, as the 14-byte
 *     Ethernet header is extended to a 16-byte header.
 */
/*@{*/
#define BP_ENET_TACC_SHIFT16 (0U)          /*!< Bit position for ENET_TACC_SHIFT16. */
#define BM_ENET_TACC_SHIFT16 (0x00000001U) /*!< Bit mask for ENET_TACC_SHIFT16. */
#define BS_ENET_TACC_SHIFT16 (1U)          /*!< Bit field size in bits for ENET_TACC_SHIFT16. */

/*! @brief Read current value of the ENET_TACC_SHIFT16 field. */
#define BR_ENET_TACC_SHIFT16(x) (BITBAND_ACCESS32(HW_ENET_TACC_ADDR(x), BP_ENET_TACC_SHIFT16))

/*! @brief Format value for bitfield ENET_TACC_SHIFT16. */
#define BF_ENET_TACC_SHIFT16(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TACC_SHIFT16) & BM_ENET_TACC_SHIFT16)

/*! @brief Set the SHIFT16 field to a new value. */
#define BW_ENET_TACC_SHIFT16(x, v) (BITBAND_ACCESS32(HW_ENET_TACC_ADDR(x), BP_ENET_TACC_SHIFT16) = (v))
/*@}*/

/*!
 * @name Register ENET_TACC, field IPCHK[3] (RW)
 *
 * Enables insertion of IP header checksum.
 *
 * Values:
 * - 0 - Checksum is not inserted.
 * - 1 - If an IP frame is transmitted, the checksum is inserted automatically.
 *     The IP header checksum field must be cleared. If a non-IP frame is
 *     transmitted the frame is not modified.
 */
/*@{*/
#define BP_ENET_TACC_IPCHK   (3U)          /*!< Bit position for ENET_TACC_IPCHK. */
#define BM_ENET_TACC_IPCHK   (0x00000008U) /*!< Bit mask for ENET_TACC_IPCHK. */
#define BS_ENET_TACC_IPCHK   (1U)          /*!< Bit field size in bits for ENET_TACC_IPCHK. */

/*! @brief Read current value of the ENET_TACC_IPCHK field. */
#define BR_ENET_TACC_IPCHK(x) (BITBAND_ACCESS32(HW_ENET_TACC_ADDR(x), BP_ENET_TACC_IPCHK))

/*! @brief Format value for bitfield ENET_TACC_IPCHK. */
#define BF_ENET_TACC_IPCHK(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TACC_IPCHK) & BM_ENET_TACC_IPCHK)

/*! @brief Set the IPCHK field to a new value. */
#define BW_ENET_TACC_IPCHK(x, v) (BITBAND_ACCESS32(HW_ENET_TACC_ADDR(x), BP_ENET_TACC_IPCHK) = (v))
/*@}*/

/*!
 * @name Register ENET_TACC, field PROCHK[4] (RW)
 *
 * Enables insertion of protocol checksum.
 *
 * Values:
 * - 0 - Checksum not inserted.
 * - 1 - If an IP frame with a known protocol is transmitted, the checksum is
 *     inserted automatically into the frame. The checksum field must be cleared.
 *     The other frames are not modified.
 */
/*@{*/
#define BP_ENET_TACC_PROCHK  (4U)          /*!< Bit position for ENET_TACC_PROCHK. */
#define BM_ENET_TACC_PROCHK  (0x00000010U) /*!< Bit mask for ENET_TACC_PROCHK. */
#define BS_ENET_TACC_PROCHK  (1U)          /*!< Bit field size in bits for ENET_TACC_PROCHK. */

/*! @brief Read current value of the ENET_TACC_PROCHK field. */
#define BR_ENET_TACC_PROCHK(x) (BITBAND_ACCESS32(HW_ENET_TACC_ADDR(x), BP_ENET_TACC_PROCHK))

/*! @brief Format value for bitfield ENET_TACC_PROCHK. */
#define BF_ENET_TACC_PROCHK(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TACC_PROCHK) & BM_ENET_TACC_PROCHK)

/*! @brief Set the PROCHK field to a new value. */
#define BW_ENET_TACC_PROCHK(x, v) (BITBAND_ACCESS32(HW_ENET_TACC_ADDR(x), BP_ENET_TACC_PROCHK) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_RACC - Receive Accelerator Function Configuration
 ******************************************************************************/

/*!
 * @brief HW_ENET_RACC - Receive Accelerator Function Configuration (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_racc
{
    uint32_t U;
    struct _hw_enet_racc_bitfields
    {
        uint32_t PADREM : 1;           /*!< [0] Enable Padding Removal For Short IP
                                        * Frames */
        uint32_t IPDIS : 1;            /*!< [1] Enable Discard Of Frames With Wrong IPv4
                                        * Header Checksum */
        uint32_t PRODIS : 1;           /*!< [2] Enable Discard Of Frames With Wrong
                                        * Protocol Checksum */
        uint32_t RESERVED0 : 3;        /*!< [5:3]  */
        uint32_t LINEDIS : 1;          /*!< [6] Enable Discard Of Frames With MAC
                                        * Layer Errors */
        uint32_t SHIFT16 : 1;          /*!< [7] RX FIFO Shift-16 */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_enet_racc_t;

/*!
 * @name Constants and macros for entire ENET_RACC register
 */
/*@{*/
#define HW_ENET_RACC_ADDR(x)     ((uint32_t)(x) + 0x1C4U)

#define HW_ENET_RACC(x)          (*(__IO hw_enet_racc_t *) HW_ENET_RACC_ADDR(x))
#define HW_ENET_RACC_RD(x)       (HW_ENET_RACC(x).U)
#define HW_ENET_RACC_WR(x, v)    (HW_ENET_RACC(x).U = (v))
#define HW_ENET_RACC_SET(x, v)   (HW_ENET_RACC_WR(x, HW_ENET_RACC_RD(x) |  (v)))
#define HW_ENET_RACC_CLR(x, v)   (HW_ENET_RACC_WR(x, HW_ENET_RACC_RD(x) & ~(v)))
#define HW_ENET_RACC_TOG(x, v)   (HW_ENET_RACC_WR(x, HW_ENET_RACC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_RACC bitfields
 */

/*!
 * @name Register ENET_RACC, field PADREM[0] (RW)
 *
 * Values:
 * - 0 - Padding not removed.
 * - 1 - Any bytes following the IP payload section of the frame are removed
 *     from the frame.
 */
/*@{*/
#define BP_ENET_RACC_PADREM  (0U)          /*!< Bit position for ENET_RACC_PADREM. */
#define BM_ENET_RACC_PADREM  (0x00000001U) /*!< Bit mask for ENET_RACC_PADREM. */
#define BS_ENET_RACC_PADREM  (1U)          /*!< Bit field size in bits for ENET_RACC_PADREM. */

/*! @brief Read current value of the ENET_RACC_PADREM field. */
#define BR_ENET_RACC_PADREM(x) (BITBAND_ACCESS32(HW_ENET_RACC_ADDR(x), BP_ENET_RACC_PADREM))

/*! @brief Format value for bitfield ENET_RACC_PADREM. */
#define BF_ENET_RACC_PADREM(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RACC_PADREM) & BM_ENET_RACC_PADREM)

/*! @brief Set the PADREM field to a new value. */
#define BW_ENET_RACC_PADREM(x, v) (BITBAND_ACCESS32(HW_ENET_RACC_ADDR(x), BP_ENET_RACC_PADREM) = (v))
/*@}*/

/*!
 * @name Register ENET_RACC, field IPDIS[1] (RW)
 *
 * Values:
 * - 0 - Frames with wrong IPv4 header checksum are not discarded.
 * - 1 - If an IPv4 frame is received with a mismatching header checksum, the
 *     frame is discarded. IPv6 has no header checksum and is not affected by this
 *     setting. Discarding is only available when the RX FIFO operates in store
 *     and forward mode (RSFL cleared).
 */
/*@{*/
#define BP_ENET_RACC_IPDIS   (1U)          /*!< Bit position for ENET_RACC_IPDIS. */
#define BM_ENET_RACC_IPDIS   (0x00000002U) /*!< Bit mask for ENET_RACC_IPDIS. */
#define BS_ENET_RACC_IPDIS   (1U)          /*!< Bit field size in bits for ENET_RACC_IPDIS. */

/*! @brief Read current value of the ENET_RACC_IPDIS field. */
#define BR_ENET_RACC_IPDIS(x) (BITBAND_ACCESS32(HW_ENET_RACC_ADDR(x), BP_ENET_RACC_IPDIS))

/*! @brief Format value for bitfield ENET_RACC_IPDIS. */
#define BF_ENET_RACC_IPDIS(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RACC_IPDIS) & BM_ENET_RACC_IPDIS)

/*! @brief Set the IPDIS field to a new value. */
#define BW_ENET_RACC_IPDIS(x, v) (BITBAND_ACCESS32(HW_ENET_RACC_ADDR(x), BP_ENET_RACC_IPDIS) = (v))
/*@}*/

/*!
 * @name Register ENET_RACC, field PRODIS[2] (RW)
 *
 * Values:
 * - 0 - Frames with wrong checksum are not discarded.
 * - 1 - If a TCP/IP, UDP/IP, or ICMP/IP frame is received that has a wrong TCP,
 *     UDP, or ICMP checksum, the frame is discarded. Discarding is only
 *     available when the RX FIFO operates in store and forward mode (RSFL cleared).
 */
/*@{*/
#define BP_ENET_RACC_PRODIS  (2U)          /*!< Bit position for ENET_RACC_PRODIS. */
#define BM_ENET_RACC_PRODIS  (0x00000004U) /*!< Bit mask for ENET_RACC_PRODIS. */
#define BS_ENET_RACC_PRODIS  (1U)          /*!< Bit field size in bits for ENET_RACC_PRODIS. */

/*! @brief Read current value of the ENET_RACC_PRODIS field. */
#define BR_ENET_RACC_PRODIS(x) (BITBAND_ACCESS32(HW_ENET_RACC_ADDR(x), BP_ENET_RACC_PRODIS))

/*! @brief Format value for bitfield ENET_RACC_PRODIS. */
#define BF_ENET_RACC_PRODIS(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RACC_PRODIS) & BM_ENET_RACC_PRODIS)

/*! @brief Set the PRODIS field to a new value. */
#define BW_ENET_RACC_PRODIS(x, v) (BITBAND_ACCESS32(HW_ENET_RACC_ADDR(x), BP_ENET_RACC_PRODIS) = (v))
/*@}*/

/*!
 * @name Register ENET_RACC, field LINEDIS[6] (RW)
 *
 * Values:
 * - 0 - Frames with errors are not discarded.
 * - 1 - Any frame received with a CRC, length, or PHY error is automatically
 *     discarded and not forwarded to the user application interface.
 */
/*@{*/
#define BP_ENET_RACC_LINEDIS (6U)          /*!< Bit position for ENET_RACC_LINEDIS. */
#define BM_ENET_RACC_LINEDIS (0x00000040U) /*!< Bit mask for ENET_RACC_LINEDIS. */
#define BS_ENET_RACC_LINEDIS (1U)          /*!< Bit field size in bits for ENET_RACC_LINEDIS. */

/*! @brief Read current value of the ENET_RACC_LINEDIS field. */
#define BR_ENET_RACC_LINEDIS(x) (BITBAND_ACCESS32(HW_ENET_RACC_ADDR(x), BP_ENET_RACC_LINEDIS))

/*! @brief Format value for bitfield ENET_RACC_LINEDIS. */
#define BF_ENET_RACC_LINEDIS(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RACC_LINEDIS) & BM_ENET_RACC_LINEDIS)

/*! @brief Set the LINEDIS field to a new value. */
#define BW_ENET_RACC_LINEDIS(x, v) (BITBAND_ACCESS32(HW_ENET_RACC_ADDR(x), BP_ENET_RACC_LINEDIS) = (v))
/*@}*/

/*!
 * @name Register ENET_RACC, field SHIFT16[7] (RW)
 *
 * When this field is set, the actual frame data starts at bit 16 of the first
 * word read from the RX FIFO aligning the Ethernet payload on a 32-bit boundary.
 * This function only affects the FIFO storage and has no influence on the
 * statistics, which use the actual length of the frame received.
 *
 * Values:
 * - 0 - Disabled.
 * - 1 - Instructs the MAC to write two additional bytes in front of each frame
 *     received into the RX FIFO.
 */
/*@{*/
#define BP_ENET_RACC_SHIFT16 (7U)          /*!< Bit position for ENET_RACC_SHIFT16. */
#define BM_ENET_RACC_SHIFT16 (0x00000080U) /*!< Bit mask for ENET_RACC_SHIFT16. */
#define BS_ENET_RACC_SHIFT16 (1U)          /*!< Bit field size in bits for ENET_RACC_SHIFT16. */

/*! @brief Read current value of the ENET_RACC_SHIFT16 field. */
#define BR_ENET_RACC_SHIFT16(x) (BITBAND_ACCESS32(HW_ENET_RACC_ADDR(x), BP_ENET_RACC_SHIFT16))

/*! @brief Format value for bitfield ENET_RACC_SHIFT16. */
#define BF_ENET_RACC_SHIFT16(v) ((uint32_t)((uint32_t)(v) << BP_ENET_RACC_SHIFT16) & BM_ENET_RACC_SHIFT16)

/*! @brief Set the SHIFT16 field to a new value. */
#define BW_ENET_RACC_SHIFT16(x, v) (BITBAND_ACCESS32(HW_ENET_RACC_ADDR(x), BP_ENET_RACC_SHIFT16) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_PACKETS - Tx Packet Count Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_PACKETS - Tx Packet Count Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_packets
{
    uint32_t U;
    struct _hw_enet_rmon_t_packets_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_packets_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_PACKETS register
 */
/*@{*/
#define HW_ENET_RMON_T_PACKETS_ADDR(x) ((uint32_t)(x) + 0x204U)

#define HW_ENET_RMON_T_PACKETS(x) (*(__I hw_enet_rmon_t_packets_t *) HW_ENET_RMON_T_PACKETS_ADDR(x))
#define HW_ENET_RMON_T_PACKETS_RD(x) (HW_ENET_RMON_T_PACKETS(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_PACKETS bitfields
 */

/*!
 * @name Register ENET_RMON_T_PACKETS, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_PACKETS_TXPKTS (0U) /*!< Bit position for ENET_RMON_T_PACKETS_TXPKTS. */
#define BM_ENET_RMON_T_PACKETS_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_PACKETS_TXPKTS. */
#define BS_ENET_RMON_T_PACKETS_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_PACKETS_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_PACKETS_TXPKTS field. */
#define BR_ENET_RMON_T_PACKETS_TXPKTS(x) (HW_ENET_RMON_T_PACKETS(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_BC_PKT - Tx Broadcast Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_BC_PKT - Tx Broadcast Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * RMON Tx Broadcast Packets
 */
typedef union _hw_enet_rmon_t_bc_pkt
{
    uint32_t U;
    struct _hw_enet_rmon_t_bc_pkt_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Broadcast packets */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_bc_pkt_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_BC_PKT register
 */
/*@{*/
#define HW_ENET_RMON_T_BC_PKT_ADDR(x) ((uint32_t)(x) + 0x208U)

#define HW_ENET_RMON_T_BC_PKT(x) (*(__I hw_enet_rmon_t_bc_pkt_t *) HW_ENET_RMON_T_BC_PKT_ADDR(x))
#define HW_ENET_RMON_T_BC_PKT_RD(x) (HW_ENET_RMON_T_BC_PKT(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_BC_PKT bitfields
 */

/*!
 * @name Register ENET_RMON_T_BC_PKT, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_BC_PKT_TXPKTS (0U)  /*!< Bit position for ENET_RMON_T_BC_PKT_TXPKTS. */
#define BM_ENET_RMON_T_BC_PKT_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_BC_PKT_TXPKTS. */
#define BS_ENET_RMON_T_BC_PKT_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_BC_PKT_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_BC_PKT_TXPKTS field. */
#define BR_ENET_RMON_T_BC_PKT_TXPKTS(x) (HW_ENET_RMON_T_BC_PKT(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_MC_PKT - Tx Multicast Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_MC_PKT - Tx Multicast Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_mc_pkt
{
    uint32_t U;
    struct _hw_enet_rmon_t_mc_pkt_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Multicast packets */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_mc_pkt_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_MC_PKT register
 */
/*@{*/
#define HW_ENET_RMON_T_MC_PKT_ADDR(x) ((uint32_t)(x) + 0x20CU)

#define HW_ENET_RMON_T_MC_PKT(x) (*(__I hw_enet_rmon_t_mc_pkt_t *) HW_ENET_RMON_T_MC_PKT_ADDR(x))
#define HW_ENET_RMON_T_MC_PKT_RD(x) (HW_ENET_RMON_T_MC_PKT(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_MC_PKT bitfields
 */

/*!
 * @name Register ENET_RMON_T_MC_PKT, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_MC_PKT_TXPKTS (0U)  /*!< Bit position for ENET_RMON_T_MC_PKT_TXPKTS. */
#define BM_ENET_RMON_T_MC_PKT_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_MC_PKT_TXPKTS. */
#define BS_ENET_RMON_T_MC_PKT_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_MC_PKT_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_MC_PKT_TXPKTS field. */
#define BR_ENET_RMON_T_MC_PKT_TXPKTS(x) (HW_ENET_RMON_T_MC_PKT(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_CRC_ALIGN - Tx Packets with CRC/Align Error Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_CRC_ALIGN - Tx Packets with CRC/Align Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_crc_align
{
    uint32_t U;
    struct _hw_enet_rmon_t_crc_align_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packets with CRC/align error */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_crc_align_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_CRC_ALIGN register
 */
/*@{*/
#define HW_ENET_RMON_T_CRC_ALIGN_ADDR(x) ((uint32_t)(x) + 0x210U)

#define HW_ENET_RMON_T_CRC_ALIGN(x) (*(__I hw_enet_rmon_t_crc_align_t *) HW_ENET_RMON_T_CRC_ALIGN_ADDR(x))
#define HW_ENET_RMON_T_CRC_ALIGN_RD(x) (HW_ENET_RMON_T_CRC_ALIGN(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_CRC_ALIGN bitfields
 */

/*!
 * @name Register ENET_RMON_T_CRC_ALIGN, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_CRC_ALIGN_TXPKTS (0U) /*!< Bit position for ENET_RMON_T_CRC_ALIGN_TXPKTS. */
#define BM_ENET_RMON_T_CRC_ALIGN_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_CRC_ALIGN_TXPKTS. */
#define BS_ENET_RMON_T_CRC_ALIGN_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_CRC_ALIGN_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_CRC_ALIGN_TXPKTS field. */
#define BR_ENET_RMON_T_CRC_ALIGN_TXPKTS(x) (HW_ENET_RMON_T_CRC_ALIGN(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_UNDERSIZE - Tx Packets Less Than Bytes and Good CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_UNDERSIZE - Tx Packets Less Than Bytes and Good CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_undersize
{
    uint32_t U;
    struct _hw_enet_rmon_t_undersize_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_undersize_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_UNDERSIZE register
 */
/*@{*/
#define HW_ENET_RMON_T_UNDERSIZE_ADDR(x) ((uint32_t)(x) + 0x214U)

#define HW_ENET_RMON_T_UNDERSIZE(x) (*(__I hw_enet_rmon_t_undersize_t *) HW_ENET_RMON_T_UNDERSIZE_ADDR(x))
#define HW_ENET_RMON_T_UNDERSIZE_RD(x) (HW_ENET_RMON_T_UNDERSIZE(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_UNDERSIZE bitfields
 */

/*!
 * @name Register ENET_RMON_T_UNDERSIZE, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_UNDERSIZE_TXPKTS (0U) /*!< Bit position for ENET_RMON_T_UNDERSIZE_TXPKTS. */
#define BM_ENET_RMON_T_UNDERSIZE_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_UNDERSIZE_TXPKTS. */
#define BS_ENET_RMON_T_UNDERSIZE_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_UNDERSIZE_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_UNDERSIZE_TXPKTS field. */
#define BR_ENET_RMON_T_UNDERSIZE_TXPKTS(x) (HW_ENET_RMON_T_UNDERSIZE(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_OVERSIZE - Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_OVERSIZE - Tx Packets GT MAX_FL bytes and Good CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_oversize
{
    uint32_t U;
    struct _hw_enet_rmon_t_oversize_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_oversize_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_OVERSIZE register
 */
/*@{*/
#define HW_ENET_RMON_T_OVERSIZE_ADDR(x) ((uint32_t)(x) + 0x218U)

#define HW_ENET_RMON_T_OVERSIZE(x) (*(__I hw_enet_rmon_t_oversize_t *) HW_ENET_RMON_T_OVERSIZE_ADDR(x))
#define HW_ENET_RMON_T_OVERSIZE_RD(x) (HW_ENET_RMON_T_OVERSIZE(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_OVERSIZE bitfields
 */

/*!
 * @name Register ENET_RMON_T_OVERSIZE, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_OVERSIZE_TXPKTS (0U) /*!< Bit position for ENET_RMON_T_OVERSIZE_TXPKTS. */
#define BM_ENET_RMON_T_OVERSIZE_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_OVERSIZE_TXPKTS. */
#define BS_ENET_RMON_T_OVERSIZE_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_OVERSIZE_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_OVERSIZE_TXPKTS field. */
#define BR_ENET_RMON_T_OVERSIZE_TXPKTS(x) (HW_ENET_RMON_T_OVERSIZE(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_FRAG - Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_FRAG - Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_enet_rmon_t_frag
{
    uint32_t U;
    struct _hw_enet_rmon_t_frag_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_frag_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_FRAG register
 */
/*@{*/
#define HW_ENET_RMON_T_FRAG_ADDR(x) ((uint32_t)(x) + 0x21CU)

#define HW_ENET_RMON_T_FRAG(x)   (*(__I hw_enet_rmon_t_frag_t *) HW_ENET_RMON_T_FRAG_ADDR(x))
#define HW_ENET_RMON_T_FRAG_RD(x) (HW_ENET_RMON_T_FRAG(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_FRAG bitfields
 */

/*!
 * @name Register ENET_RMON_T_FRAG, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_FRAG_TXPKTS (0U)    /*!< Bit position for ENET_RMON_T_FRAG_TXPKTS. */
#define BM_ENET_RMON_T_FRAG_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_FRAG_TXPKTS. */
#define BS_ENET_RMON_T_FRAG_TXPKTS (16U)   /*!< Bit field size in bits for ENET_RMON_T_FRAG_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_FRAG_TXPKTS field. */
#define BR_ENET_RMON_T_FRAG_TXPKTS(x) (HW_ENET_RMON_T_FRAG(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_JAB - Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_JAB - Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_jab
{
    uint32_t U;
    struct _hw_enet_rmon_t_jab_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_jab_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_JAB register
 */
/*@{*/
#define HW_ENET_RMON_T_JAB_ADDR(x) ((uint32_t)(x) + 0x220U)

#define HW_ENET_RMON_T_JAB(x)    (*(__I hw_enet_rmon_t_jab_t *) HW_ENET_RMON_T_JAB_ADDR(x))
#define HW_ENET_RMON_T_JAB_RD(x) (HW_ENET_RMON_T_JAB(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_JAB bitfields
 */

/*!
 * @name Register ENET_RMON_T_JAB, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_JAB_TXPKTS (0U)     /*!< Bit position for ENET_RMON_T_JAB_TXPKTS. */
#define BM_ENET_RMON_T_JAB_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_JAB_TXPKTS. */
#define BS_ENET_RMON_T_JAB_TXPKTS (16U)    /*!< Bit field size in bits for ENET_RMON_T_JAB_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_JAB_TXPKTS field. */
#define BR_ENET_RMON_T_JAB_TXPKTS(x) (HW_ENET_RMON_T_JAB(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_COL - Tx Collision Count Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_COL - Tx Collision Count Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_col
{
    uint32_t U;
    struct _hw_enet_rmon_t_col_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_col_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_COL register
 */
/*@{*/
#define HW_ENET_RMON_T_COL_ADDR(x) ((uint32_t)(x) + 0x224U)

#define HW_ENET_RMON_T_COL(x)    (*(__I hw_enet_rmon_t_col_t *) HW_ENET_RMON_T_COL_ADDR(x))
#define HW_ENET_RMON_T_COL_RD(x) (HW_ENET_RMON_T_COL(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_COL bitfields
 */

/*!
 * @name Register ENET_RMON_T_COL, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_COL_TXPKTS (0U)     /*!< Bit position for ENET_RMON_T_COL_TXPKTS. */
#define BM_ENET_RMON_T_COL_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_COL_TXPKTS. */
#define BS_ENET_RMON_T_COL_TXPKTS (16U)    /*!< Bit field size in bits for ENET_RMON_T_COL_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_COL_TXPKTS field. */
#define BR_ENET_RMON_T_COL_TXPKTS(x) (HW_ENET_RMON_T_COL(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_P64 - Tx 64-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_P64 - Tx 64-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_enet_rmon_t_p64
{
    uint32_t U;
    struct _hw_enet_rmon_t_p64_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_p64_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_P64 register
 */
/*@{*/
#define HW_ENET_RMON_T_P64_ADDR(x) ((uint32_t)(x) + 0x228U)

#define HW_ENET_RMON_T_P64(x)    (*(__I hw_enet_rmon_t_p64_t *) HW_ENET_RMON_T_P64_ADDR(x))
#define HW_ENET_RMON_T_P64_RD(x) (HW_ENET_RMON_T_P64(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P64 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P64, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_P64_TXPKTS (0U)     /*!< Bit position for ENET_RMON_T_P64_TXPKTS. */
#define BM_ENET_RMON_T_P64_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_P64_TXPKTS. */
#define BS_ENET_RMON_T_P64_TXPKTS (16U)    /*!< Bit field size in bits for ENET_RMON_T_P64_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_P64_TXPKTS field. */
#define BR_ENET_RMON_T_P64_TXPKTS(x) (HW_ENET_RMON_T_P64(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_P65TO127 - Tx 65- to 127-byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_P65TO127 - Tx 65- to 127-byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_p65to127
{
    uint32_t U;
    struct _hw_enet_rmon_t_p65to127_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_p65to127_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_P65TO127 register
 */
/*@{*/
#define HW_ENET_RMON_T_P65TO127_ADDR(x) ((uint32_t)(x) + 0x22CU)

#define HW_ENET_RMON_T_P65TO127(x) (*(__I hw_enet_rmon_t_p65to127_t *) HW_ENET_RMON_T_P65TO127_ADDR(x))
#define HW_ENET_RMON_T_P65TO127_RD(x) (HW_ENET_RMON_T_P65TO127(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P65TO127 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P65TO127, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_P65TO127_TXPKTS (0U) /*!< Bit position for ENET_RMON_T_P65TO127_TXPKTS. */
#define BM_ENET_RMON_T_P65TO127_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_P65TO127_TXPKTS. */
#define BS_ENET_RMON_T_P65TO127_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_P65TO127_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_P65TO127_TXPKTS field. */
#define BR_ENET_RMON_T_P65TO127_TXPKTS(x) (HW_ENET_RMON_T_P65TO127(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_P128TO255 - Tx 128- to 255-byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_P128TO255 - Tx 128- to 255-byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_p128to255
{
    uint32_t U;
    struct _hw_enet_rmon_t_p128to255_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_p128to255_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_P128TO255 register
 */
/*@{*/
#define HW_ENET_RMON_T_P128TO255_ADDR(x) ((uint32_t)(x) + 0x230U)

#define HW_ENET_RMON_T_P128TO255(x) (*(__I hw_enet_rmon_t_p128to255_t *) HW_ENET_RMON_T_P128TO255_ADDR(x))
#define HW_ENET_RMON_T_P128TO255_RD(x) (HW_ENET_RMON_T_P128TO255(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P128TO255 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P128TO255, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_P128TO255_TXPKTS (0U) /*!< Bit position for ENET_RMON_T_P128TO255_TXPKTS. */
#define BM_ENET_RMON_T_P128TO255_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_P128TO255_TXPKTS. */
#define BS_ENET_RMON_T_P128TO255_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_P128TO255_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_P128TO255_TXPKTS field. */
#define BR_ENET_RMON_T_P128TO255_TXPKTS(x) (HW_ENET_RMON_T_P128TO255(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_P256TO511 - Tx 256- to 511-byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_P256TO511 - Tx 256- to 511-byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_p256to511
{
    uint32_t U;
    struct _hw_enet_rmon_t_p256to511_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_p256to511_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_P256TO511 register
 */
/*@{*/
#define HW_ENET_RMON_T_P256TO511_ADDR(x) ((uint32_t)(x) + 0x234U)

#define HW_ENET_RMON_T_P256TO511(x) (*(__I hw_enet_rmon_t_p256to511_t *) HW_ENET_RMON_T_P256TO511_ADDR(x))
#define HW_ENET_RMON_T_P256TO511_RD(x) (HW_ENET_RMON_T_P256TO511(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P256TO511 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P256TO511, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_P256TO511_TXPKTS (0U) /*!< Bit position for ENET_RMON_T_P256TO511_TXPKTS. */
#define BM_ENET_RMON_T_P256TO511_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_P256TO511_TXPKTS. */
#define BS_ENET_RMON_T_P256TO511_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_P256TO511_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_P256TO511_TXPKTS field. */
#define BR_ENET_RMON_T_P256TO511_TXPKTS(x) (HW_ENET_RMON_T_P256TO511(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_P512TO1023 - Tx 512- to 1023-byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_P512TO1023 - Tx 512- to 1023-byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
typedef union _hw_enet_rmon_t_p512to1023
{
    uint32_t U;
    struct _hw_enet_rmon_t_p512to1023_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_p512to1023_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_P512TO1023 register
 */
/*@{*/
#define HW_ENET_RMON_T_P512TO1023_ADDR(x) ((uint32_t)(x) + 0x238U)

#define HW_ENET_RMON_T_P512TO1023(x) (*(__I hw_enet_rmon_t_p512to1023_t *) HW_ENET_RMON_T_P512TO1023_ADDR(x))
#define HW_ENET_RMON_T_P512TO1023_RD(x) (HW_ENET_RMON_T_P512TO1023(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P512TO1023 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P512TO1023, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_P512TO1023_TXPKTS (0U) /*!< Bit position for ENET_RMON_T_P512TO1023_TXPKTS. */
#define BM_ENET_RMON_T_P512TO1023_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_P512TO1023_TXPKTS. */
#define BS_ENET_RMON_T_P512TO1023_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_P512TO1023_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_P512TO1023_TXPKTS field. */
#define BR_ENET_RMON_T_P512TO1023_TXPKTS(x) (HW_ENET_RMON_T_P512TO1023(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_P1024TO2047 - Tx 1024- to 2047-byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_P1024TO2047 - Tx 1024- to 2047-byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_p1024to2047
{
    uint32_t U;
    struct _hw_enet_rmon_t_p1024to2047_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_p1024to2047_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_P1024TO2047 register
 */
/*@{*/
#define HW_ENET_RMON_T_P1024TO2047_ADDR(x) ((uint32_t)(x) + 0x23CU)

#define HW_ENET_RMON_T_P1024TO2047(x) (*(__I hw_enet_rmon_t_p1024to2047_t *) HW_ENET_RMON_T_P1024TO2047_ADDR(x))
#define HW_ENET_RMON_T_P1024TO2047_RD(x) (HW_ENET_RMON_T_P1024TO2047(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P1024TO2047 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P1024TO2047, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_P1024TO2047_TXPKTS (0U) /*!< Bit position for ENET_RMON_T_P1024TO2047_TXPKTS. */
#define BM_ENET_RMON_T_P1024TO2047_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_P1024TO2047_TXPKTS. */
#define BS_ENET_RMON_T_P1024TO2047_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_P1024TO2047_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_P1024TO2047_TXPKTS field. */
#define BR_ENET_RMON_T_P1024TO2047_TXPKTS(x) (HW_ENET_RMON_T_P1024TO2047(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_P_GTE2048 - Tx Packets Greater Than 2048 Bytes Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_P_GTE2048 - Tx Packets Greater Than 2048 Bytes Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_p_gte2048
{
    uint32_t U;
    struct _hw_enet_rmon_t_p_gte2048_bitfields
    {
        uint32_t TXPKTS : 16;          /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_t_p_gte2048_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_P_GTE2048 register
 */
/*@{*/
#define HW_ENET_RMON_T_P_GTE2048_ADDR(x) ((uint32_t)(x) + 0x240U)

#define HW_ENET_RMON_T_P_GTE2048(x) (*(__I hw_enet_rmon_t_p_gte2048_t *) HW_ENET_RMON_T_P_GTE2048_ADDR(x))
#define HW_ENET_RMON_T_P_GTE2048_RD(x) (HW_ENET_RMON_T_P_GTE2048(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P_GTE2048 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P_GTE2048, field TXPKTS[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_P_GTE2048_TXPKTS (0U) /*!< Bit position for ENET_RMON_T_P_GTE2048_TXPKTS. */
#define BM_ENET_RMON_T_P_GTE2048_TXPKTS (0x0000FFFFU) /*!< Bit mask for ENET_RMON_T_P_GTE2048_TXPKTS. */
#define BS_ENET_RMON_T_P_GTE2048_TXPKTS (16U) /*!< Bit field size in bits for ENET_RMON_T_P_GTE2048_TXPKTS. */

/*! @brief Read current value of the ENET_RMON_T_P_GTE2048_TXPKTS field. */
#define BR_ENET_RMON_T_P_GTE2048_TXPKTS(x) (HW_ENET_RMON_T_P_GTE2048(x).B.TXPKTS)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_T_OCTETS - Tx Octets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_T_OCTETS - Tx Octets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_t_octets
{
    uint32_t U;
    struct _hw_enet_rmon_t_octets_bitfields
    {
        uint32_t TXOCTS : 32;          /*!< [31:0] Octet count */
    } B;
} hw_enet_rmon_t_octets_t;

/*!
 * @name Constants and macros for entire ENET_RMON_T_OCTETS register
 */
/*@{*/
#define HW_ENET_RMON_T_OCTETS_ADDR(x) ((uint32_t)(x) + 0x244U)

#define HW_ENET_RMON_T_OCTETS(x) (*(__I hw_enet_rmon_t_octets_t *) HW_ENET_RMON_T_OCTETS_ADDR(x))
#define HW_ENET_RMON_T_OCTETS_RD(x) (HW_ENET_RMON_T_OCTETS(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_OCTETS bitfields
 */

/*!
 * @name Register ENET_RMON_T_OCTETS, field TXOCTS[31:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_T_OCTETS_TXOCTS (0U)  /*!< Bit position for ENET_RMON_T_OCTETS_TXOCTS. */
#define BM_ENET_RMON_T_OCTETS_TXOCTS (0xFFFFFFFFU) /*!< Bit mask for ENET_RMON_T_OCTETS_TXOCTS. */
#define BS_ENET_RMON_T_OCTETS_TXOCTS (32U) /*!< Bit field size in bits for ENET_RMON_T_OCTETS_TXOCTS. */

/*! @brief Read current value of the ENET_RMON_T_OCTETS_TXOCTS field. */
#define BR_ENET_RMON_T_OCTETS_TXOCTS(x) (HW_ENET_RMON_T_OCTETS(x).U)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_T_FRAME_OK - Frames Transmitted OK Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_T_FRAME_OK - Frames Transmitted OK Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_t_frame_ok
{
    uint32_t U;
    struct _hw_enet_ieee_t_frame_ok_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_t_frame_ok_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_T_FRAME_OK register
 */
/*@{*/
#define HW_ENET_IEEE_T_FRAME_OK_ADDR(x) ((uint32_t)(x) + 0x24CU)

#define HW_ENET_IEEE_T_FRAME_OK(x) (*(__I hw_enet_ieee_t_frame_ok_t *) HW_ENET_IEEE_T_FRAME_OK_ADDR(x))
#define HW_ENET_IEEE_T_FRAME_OK_RD(x) (HW_ENET_IEEE_T_FRAME_OK(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_FRAME_OK bitfields
 */

/*!
 * @name Register ENET_IEEE_T_FRAME_OK, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_T_FRAME_OK_COUNT (0U) /*!< Bit position for ENET_IEEE_T_FRAME_OK_COUNT. */
#define BM_ENET_IEEE_T_FRAME_OK_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_T_FRAME_OK_COUNT. */
#define BS_ENET_IEEE_T_FRAME_OK_COUNT (16U) /*!< Bit field size in bits for ENET_IEEE_T_FRAME_OK_COUNT. */

/*! @brief Read current value of the ENET_IEEE_T_FRAME_OK_COUNT field. */
#define BR_ENET_IEEE_T_FRAME_OK_COUNT(x) (HW_ENET_IEEE_T_FRAME_OK(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_T_1COL - Frames Transmitted with Single Collision Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_T_1COL - Frames Transmitted with Single Collision Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_t_1col
{
    uint32_t U;
    struct _hw_enet_ieee_t_1col_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_t_1col_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_T_1COL register
 */
/*@{*/
#define HW_ENET_IEEE_T_1COL_ADDR(x) ((uint32_t)(x) + 0x250U)

#define HW_ENET_IEEE_T_1COL(x)   (*(__I hw_enet_ieee_t_1col_t *) HW_ENET_IEEE_T_1COL_ADDR(x))
#define HW_ENET_IEEE_T_1COL_RD(x) (HW_ENET_IEEE_T_1COL(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_1COL bitfields
 */

/*!
 * @name Register ENET_IEEE_T_1COL, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_T_1COL_COUNT (0U)     /*!< Bit position for ENET_IEEE_T_1COL_COUNT. */
#define BM_ENET_IEEE_T_1COL_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_T_1COL_COUNT. */
#define BS_ENET_IEEE_T_1COL_COUNT (16U)    /*!< Bit field size in bits for ENET_IEEE_T_1COL_COUNT. */

/*! @brief Read current value of the ENET_IEEE_T_1COL_COUNT field. */
#define BR_ENET_IEEE_T_1COL_COUNT(x) (HW_ENET_IEEE_T_1COL(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_T_MCOL - Frames Transmitted with Multiple Collisions Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_T_MCOL - Frames Transmitted with Multiple Collisions Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_t_mcol
{
    uint32_t U;
    struct _hw_enet_ieee_t_mcol_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_t_mcol_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_T_MCOL register
 */
/*@{*/
#define HW_ENET_IEEE_T_MCOL_ADDR(x) ((uint32_t)(x) + 0x254U)

#define HW_ENET_IEEE_T_MCOL(x)   (*(__I hw_enet_ieee_t_mcol_t *) HW_ENET_IEEE_T_MCOL_ADDR(x))
#define HW_ENET_IEEE_T_MCOL_RD(x) (HW_ENET_IEEE_T_MCOL(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_MCOL bitfields
 */

/*!
 * @name Register ENET_IEEE_T_MCOL, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_T_MCOL_COUNT (0U)     /*!< Bit position for ENET_IEEE_T_MCOL_COUNT. */
#define BM_ENET_IEEE_T_MCOL_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_T_MCOL_COUNT. */
#define BS_ENET_IEEE_T_MCOL_COUNT (16U)    /*!< Bit field size in bits for ENET_IEEE_T_MCOL_COUNT. */

/*! @brief Read current value of the ENET_IEEE_T_MCOL_COUNT field. */
#define BR_ENET_IEEE_T_MCOL_COUNT(x) (HW_ENET_IEEE_T_MCOL(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_T_DEF - Frames Transmitted after Deferral Delay Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_T_DEF - Frames Transmitted after Deferral Delay Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_t_def
{
    uint32_t U;
    struct _hw_enet_ieee_t_def_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_t_def_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_T_DEF register
 */
/*@{*/
#define HW_ENET_IEEE_T_DEF_ADDR(x) ((uint32_t)(x) + 0x258U)

#define HW_ENET_IEEE_T_DEF(x)    (*(__I hw_enet_ieee_t_def_t *) HW_ENET_IEEE_T_DEF_ADDR(x))
#define HW_ENET_IEEE_T_DEF_RD(x) (HW_ENET_IEEE_T_DEF(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_DEF bitfields
 */

/*!
 * @name Register ENET_IEEE_T_DEF, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_T_DEF_COUNT (0U)      /*!< Bit position for ENET_IEEE_T_DEF_COUNT. */
#define BM_ENET_IEEE_T_DEF_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_T_DEF_COUNT. */
#define BS_ENET_IEEE_T_DEF_COUNT (16U)     /*!< Bit field size in bits for ENET_IEEE_T_DEF_COUNT. */

/*! @brief Read current value of the ENET_IEEE_T_DEF_COUNT field. */
#define BR_ENET_IEEE_T_DEF_COUNT(x) (HW_ENET_IEEE_T_DEF(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_T_LCOL - Frames Transmitted with Late Collision Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_T_LCOL - Frames Transmitted with Late Collision Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_t_lcol
{
    uint32_t U;
    struct _hw_enet_ieee_t_lcol_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_t_lcol_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_T_LCOL register
 */
/*@{*/
#define HW_ENET_IEEE_T_LCOL_ADDR(x) ((uint32_t)(x) + 0x25CU)

#define HW_ENET_IEEE_T_LCOL(x)   (*(__I hw_enet_ieee_t_lcol_t *) HW_ENET_IEEE_T_LCOL_ADDR(x))
#define HW_ENET_IEEE_T_LCOL_RD(x) (HW_ENET_IEEE_T_LCOL(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_LCOL bitfields
 */

/*!
 * @name Register ENET_IEEE_T_LCOL, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_T_LCOL_COUNT (0U)     /*!< Bit position for ENET_IEEE_T_LCOL_COUNT. */
#define BM_ENET_IEEE_T_LCOL_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_T_LCOL_COUNT. */
#define BS_ENET_IEEE_T_LCOL_COUNT (16U)    /*!< Bit field size in bits for ENET_IEEE_T_LCOL_COUNT. */

/*! @brief Read current value of the ENET_IEEE_T_LCOL_COUNT field. */
#define BR_ENET_IEEE_T_LCOL_COUNT(x) (HW_ENET_IEEE_T_LCOL(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_T_EXCOL - Frames Transmitted with Excessive Collisions Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_T_EXCOL - Frames Transmitted with Excessive Collisions Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_t_excol
{
    uint32_t U;
    struct _hw_enet_ieee_t_excol_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_t_excol_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_T_EXCOL register
 */
/*@{*/
#define HW_ENET_IEEE_T_EXCOL_ADDR(x) ((uint32_t)(x) + 0x260U)

#define HW_ENET_IEEE_T_EXCOL(x)  (*(__I hw_enet_ieee_t_excol_t *) HW_ENET_IEEE_T_EXCOL_ADDR(x))
#define HW_ENET_IEEE_T_EXCOL_RD(x) (HW_ENET_IEEE_T_EXCOL(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_EXCOL bitfields
 */

/*!
 * @name Register ENET_IEEE_T_EXCOL, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_T_EXCOL_COUNT (0U)    /*!< Bit position for ENET_IEEE_T_EXCOL_COUNT. */
#define BM_ENET_IEEE_T_EXCOL_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_T_EXCOL_COUNT. */
#define BS_ENET_IEEE_T_EXCOL_COUNT (16U)   /*!< Bit field size in bits for ENET_IEEE_T_EXCOL_COUNT. */

/*! @brief Read current value of the ENET_IEEE_T_EXCOL_COUNT field. */
#define BR_ENET_IEEE_T_EXCOL_COUNT(x) (HW_ENET_IEEE_T_EXCOL(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_T_MACERR - Frames Transmitted with Tx FIFO Underrun Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_T_MACERR - Frames Transmitted with Tx FIFO Underrun Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_t_macerr
{
    uint32_t U;
    struct _hw_enet_ieee_t_macerr_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_t_macerr_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_T_MACERR register
 */
/*@{*/
#define HW_ENET_IEEE_T_MACERR_ADDR(x) ((uint32_t)(x) + 0x264U)

#define HW_ENET_IEEE_T_MACERR(x) (*(__I hw_enet_ieee_t_macerr_t *) HW_ENET_IEEE_T_MACERR_ADDR(x))
#define HW_ENET_IEEE_T_MACERR_RD(x) (HW_ENET_IEEE_T_MACERR(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_MACERR bitfields
 */

/*!
 * @name Register ENET_IEEE_T_MACERR, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_T_MACERR_COUNT (0U)   /*!< Bit position for ENET_IEEE_T_MACERR_COUNT. */
#define BM_ENET_IEEE_T_MACERR_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_T_MACERR_COUNT. */
#define BS_ENET_IEEE_T_MACERR_COUNT (16U)  /*!< Bit field size in bits for ENET_IEEE_T_MACERR_COUNT. */

/*! @brief Read current value of the ENET_IEEE_T_MACERR_COUNT field. */
#define BR_ENET_IEEE_T_MACERR_COUNT(x) (HW_ENET_IEEE_T_MACERR(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_T_CSERR - Frames Transmitted with Carrier Sense Error Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_T_CSERR - Frames Transmitted with Carrier Sense Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_t_cserr
{
    uint32_t U;
    struct _hw_enet_ieee_t_cserr_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_t_cserr_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_T_CSERR register
 */
/*@{*/
#define HW_ENET_IEEE_T_CSERR_ADDR(x) ((uint32_t)(x) + 0x268U)

#define HW_ENET_IEEE_T_CSERR(x)  (*(__I hw_enet_ieee_t_cserr_t *) HW_ENET_IEEE_T_CSERR_ADDR(x))
#define HW_ENET_IEEE_T_CSERR_RD(x) (HW_ENET_IEEE_T_CSERR(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_CSERR bitfields
 */

/*!
 * @name Register ENET_IEEE_T_CSERR, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_T_CSERR_COUNT (0U)    /*!< Bit position for ENET_IEEE_T_CSERR_COUNT. */
#define BM_ENET_IEEE_T_CSERR_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_T_CSERR_COUNT. */
#define BS_ENET_IEEE_T_CSERR_COUNT (16U)   /*!< Bit field size in bits for ENET_IEEE_T_CSERR_COUNT. */

/*! @brief Read current value of the ENET_IEEE_T_CSERR_COUNT field. */
#define BR_ENET_IEEE_T_CSERR_COUNT(x) (HW_ENET_IEEE_T_CSERR(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_T_FDXFC - Flow Control Pause Frames Transmitted Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_T_FDXFC - Flow Control Pause Frames Transmitted Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_t_fdxfc
{
    uint32_t U;
    struct _hw_enet_ieee_t_fdxfc_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_t_fdxfc_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_T_FDXFC register
 */
/*@{*/
#define HW_ENET_IEEE_T_FDXFC_ADDR(x) ((uint32_t)(x) + 0x270U)

#define HW_ENET_IEEE_T_FDXFC(x)  (*(__I hw_enet_ieee_t_fdxfc_t *) HW_ENET_IEEE_T_FDXFC_ADDR(x))
#define HW_ENET_IEEE_T_FDXFC_RD(x) (HW_ENET_IEEE_T_FDXFC(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_FDXFC bitfields
 */

/*!
 * @name Register ENET_IEEE_T_FDXFC, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_T_FDXFC_COUNT (0U)    /*!< Bit position for ENET_IEEE_T_FDXFC_COUNT. */
#define BM_ENET_IEEE_T_FDXFC_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_T_FDXFC_COUNT. */
#define BS_ENET_IEEE_T_FDXFC_COUNT (16U)   /*!< Bit field size in bits for ENET_IEEE_T_FDXFC_COUNT. */

/*! @brief Read current value of the ENET_IEEE_T_FDXFC_COUNT field. */
#define BR_ENET_IEEE_T_FDXFC_COUNT(x) (HW_ENET_IEEE_T_FDXFC(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_T_OCTETS_OK - Octet Count for Frames Transmitted w/o Error Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_T_OCTETS_OK - Octet Count for Frames Transmitted w/o Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Counts total octets (includes header and FCS fields).
 */
typedef union _hw_enet_ieee_t_octets_ok
{
    uint32_t U;
    struct _hw_enet_ieee_t_octets_ok_bitfields
    {
        uint32_t COUNT : 32;           /*!< [31:0] Octet count */
    } B;
} hw_enet_ieee_t_octets_ok_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_T_OCTETS_OK register
 */
/*@{*/
#define HW_ENET_IEEE_T_OCTETS_OK_ADDR(x) ((uint32_t)(x) + 0x274U)

#define HW_ENET_IEEE_T_OCTETS_OK(x) (*(__I hw_enet_ieee_t_octets_ok_t *) HW_ENET_IEEE_T_OCTETS_OK_ADDR(x))
#define HW_ENET_IEEE_T_OCTETS_OK_RD(x) (HW_ENET_IEEE_T_OCTETS_OK(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_OCTETS_OK bitfields
 */

/*!
 * @name Register ENET_IEEE_T_OCTETS_OK, field COUNT[31:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_T_OCTETS_OK_COUNT (0U) /*!< Bit position for ENET_IEEE_T_OCTETS_OK_COUNT. */
#define BM_ENET_IEEE_T_OCTETS_OK_COUNT (0xFFFFFFFFU) /*!< Bit mask for ENET_IEEE_T_OCTETS_OK_COUNT. */
#define BS_ENET_IEEE_T_OCTETS_OK_COUNT (32U) /*!< Bit field size in bits for ENET_IEEE_T_OCTETS_OK_COUNT. */

/*! @brief Read current value of the ENET_IEEE_T_OCTETS_OK_COUNT field. */
#define BR_ENET_IEEE_T_OCTETS_OK_COUNT(x) (HW_ENET_IEEE_T_OCTETS_OK(x).U)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_PACKETS - Rx Packet Count Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_PACKETS - Rx Packet Count Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_packets
{
    uint32_t U;
    struct _hw_enet_rmon_r_packets_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_packets_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_PACKETS register
 */
/*@{*/
#define HW_ENET_RMON_R_PACKETS_ADDR(x) ((uint32_t)(x) + 0x284U)

#define HW_ENET_RMON_R_PACKETS(x) (*(__I hw_enet_rmon_r_packets_t *) HW_ENET_RMON_R_PACKETS_ADDR(x))
#define HW_ENET_RMON_R_PACKETS_RD(x) (HW_ENET_RMON_R_PACKETS(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_PACKETS bitfields
 */

/*!
 * @name Register ENET_RMON_R_PACKETS, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_PACKETS_COUNT (0U)  /*!< Bit position for ENET_RMON_R_PACKETS_COUNT. */
#define BM_ENET_RMON_R_PACKETS_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_PACKETS_COUNT. */
#define BS_ENET_RMON_R_PACKETS_COUNT (16U) /*!< Bit field size in bits for ENET_RMON_R_PACKETS_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_PACKETS_COUNT field. */
#define BR_ENET_RMON_R_PACKETS_COUNT(x) (HW_ENET_RMON_R_PACKETS(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_BC_PKT - Rx Broadcast Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_BC_PKT - Rx Broadcast Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_bc_pkt
{
    uint32_t U;
    struct _hw_enet_rmon_r_bc_pkt_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_bc_pkt_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_BC_PKT register
 */
/*@{*/
#define HW_ENET_RMON_R_BC_PKT_ADDR(x) ((uint32_t)(x) + 0x288U)

#define HW_ENET_RMON_R_BC_PKT(x) (*(__I hw_enet_rmon_r_bc_pkt_t *) HW_ENET_RMON_R_BC_PKT_ADDR(x))
#define HW_ENET_RMON_R_BC_PKT_RD(x) (HW_ENET_RMON_R_BC_PKT(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_BC_PKT bitfields
 */

/*!
 * @name Register ENET_RMON_R_BC_PKT, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_BC_PKT_COUNT (0U)   /*!< Bit position for ENET_RMON_R_BC_PKT_COUNT. */
#define BM_ENET_RMON_R_BC_PKT_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_BC_PKT_COUNT. */
#define BS_ENET_RMON_R_BC_PKT_COUNT (16U)  /*!< Bit field size in bits for ENET_RMON_R_BC_PKT_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_BC_PKT_COUNT field. */
#define BR_ENET_RMON_R_BC_PKT_COUNT(x) (HW_ENET_RMON_R_BC_PKT(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_MC_PKT - Rx Multicast Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_MC_PKT - Rx Multicast Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_mc_pkt
{
    uint32_t U;
    struct _hw_enet_rmon_r_mc_pkt_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_mc_pkt_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_MC_PKT register
 */
/*@{*/
#define HW_ENET_RMON_R_MC_PKT_ADDR(x) ((uint32_t)(x) + 0x28CU)

#define HW_ENET_RMON_R_MC_PKT(x) (*(__I hw_enet_rmon_r_mc_pkt_t *) HW_ENET_RMON_R_MC_PKT_ADDR(x))
#define HW_ENET_RMON_R_MC_PKT_RD(x) (HW_ENET_RMON_R_MC_PKT(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_MC_PKT bitfields
 */

/*!
 * @name Register ENET_RMON_R_MC_PKT, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_MC_PKT_COUNT (0U)   /*!< Bit position for ENET_RMON_R_MC_PKT_COUNT. */
#define BM_ENET_RMON_R_MC_PKT_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_MC_PKT_COUNT. */
#define BS_ENET_RMON_R_MC_PKT_COUNT (16U)  /*!< Bit field size in bits for ENET_RMON_R_MC_PKT_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_MC_PKT_COUNT field. */
#define BR_ENET_RMON_R_MC_PKT_COUNT(x) (HW_ENET_RMON_R_MC_PKT(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_CRC_ALIGN - Rx Packets with CRC/Align Error Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_CRC_ALIGN - Rx Packets with CRC/Align Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_crc_align
{
    uint32_t U;
    struct _hw_enet_rmon_r_crc_align_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_crc_align_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_CRC_ALIGN register
 */
/*@{*/
#define HW_ENET_RMON_R_CRC_ALIGN_ADDR(x) ((uint32_t)(x) + 0x290U)

#define HW_ENET_RMON_R_CRC_ALIGN(x) (*(__I hw_enet_rmon_r_crc_align_t *) HW_ENET_RMON_R_CRC_ALIGN_ADDR(x))
#define HW_ENET_RMON_R_CRC_ALIGN_RD(x) (HW_ENET_RMON_R_CRC_ALIGN(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_CRC_ALIGN bitfields
 */

/*!
 * @name Register ENET_RMON_R_CRC_ALIGN, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_CRC_ALIGN_COUNT (0U) /*!< Bit position for ENET_RMON_R_CRC_ALIGN_COUNT. */
#define BM_ENET_RMON_R_CRC_ALIGN_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_CRC_ALIGN_COUNT. */
#define BS_ENET_RMON_R_CRC_ALIGN_COUNT (16U) /*!< Bit field size in bits for ENET_RMON_R_CRC_ALIGN_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_CRC_ALIGN_COUNT field. */
#define BR_ENET_RMON_R_CRC_ALIGN_COUNT(x) (HW_ENET_RMON_R_CRC_ALIGN(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_UNDERSIZE - Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_UNDERSIZE - Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_undersize
{
    uint32_t U;
    struct _hw_enet_rmon_r_undersize_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_undersize_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_UNDERSIZE register
 */
/*@{*/
#define HW_ENET_RMON_R_UNDERSIZE_ADDR(x) ((uint32_t)(x) + 0x294U)

#define HW_ENET_RMON_R_UNDERSIZE(x) (*(__I hw_enet_rmon_r_undersize_t *) HW_ENET_RMON_R_UNDERSIZE_ADDR(x))
#define HW_ENET_RMON_R_UNDERSIZE_RD(x) (HW_ENET_RMON_R_UNDERSIZE(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_UNDERSIZE bitfields
 */

/*!
 * @name Register ENET_RMON_R_UNDERSIZE, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_UNDERSIZE_COUNT (0U) /*!< Bit position for ENET_RMON_R_UNDERSIZE_COUNT. */
#define BM_ENET_RMON_R_UNDERSIZE_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_UNDERSIZE_COUNT. */
#define BS_ENET_RMON_R_UNDERSIZE_COUNT (16U) /*!< Bit field size in bits for ENET_RMON_R_UNDERSIZE_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_UNDERSIZE_COUNT field. */
#define BR_ENET_RMON_R_UNDERSIZE_COUNT(x) (HW_ENET_RMON_R_UNDERSIZE(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_OVERSIZE - Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_OVERSIZE - Rx Packets Greater Than MAX_FL and Good CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_oversize
{
    uint32_t U;
    struct _hw_enet_rmon_r_oversize_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_oversize_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_OVERSIZE register
 */
/*@{*/
#define HW_ENET_RMON_R_OVERSIZE_ADDR(x) ((uint32_t)(x) + 0x298U)

#define HW_ENET_RMON_R_OVERSIZE(x) (*(__I hw_enet_rmon_r_oversize_t *) HW_ENET_RMON_R_OVERSIZE_ADDR(x))
#define HW_ENET_RMON_R_OVERSIZE_RD(x) (HW_ENET_RMON_R_OVERSIZE(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_OVERSIZE bitfields
 */

/*!
 * @name Register ENET_RMON_R_OVERSIZE, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_OVERSIZE_COUNT (0U) /*!< Bit position for ENET_RMON_R_OVERSIZE_COUNT. */
#define BM_ENET_RMON_R_OVERSIZE_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_OVERSIZE_COUNT. */
#define BS_ENET_RMON_R_OVERSIZE_COUNT (16U) /*!< Bit field size in bits for ENET_RMON_R_OVERSIZE_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_OVERSIZE_COUNT field. */
#define BR_ENET_RMON_R_OVERSIZE_COUNT(x) (HW_ENET_RMON_R_OVERSIZE(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_FRAG - Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_FRAG - Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_frag
{
    uint32_t U;
    struct _hw_enet_rmon_r_frag_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_frag_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_FRAG register
 */
/*@{*/
#define HW_ENET_RMON_R_FRAG_ADDR(x) ((uint32_t)(x) + 0x29CU)

#define HW_ENET_RMON_R_FRAG(x)   (*(__I hw_enet_rmon_r_frag_t *) HW_ENET_RMON_R_FRAG_ADDR(x))
#define HW_ENET_RMON_R_FRAG_RD(x) (HW_ENET_RMON_R_FRAG(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_FRAG bitfields
 */

/*!
 * @name Register ENET_RMON_R_FRAG, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_FRAG_COUNT (0U)     /*!< Bit position for ENET_RMON_R_FRAG_COUNT. */
#define BM_ENET_RMON_R_FRAG_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_FRAG_COUNT. */
#define BS_ENET_RMON_R_FRAG_COUNT (16U)    /*!< Bit field size in bits for ENET_RMON_R_FRAG_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_FRAG_COUNT field. */
#define BR_ENET_RMON_R_FRAG_COUNT(x) (HW_ENET_RMON_R_FRAG(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_JAB - Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_JAB - Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_jab
{
    uint32_t U;
    struct _hw_enet_rmon_r_jab_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_jab_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_JAB register
 */
/*@{*/
#define HW_ENET_RMON_R_JAB_ADDR(x) ((uint32_t)(x) + 0x2A0U)

#define HW_ENET_RMON_R_JAB(x)    (*(__I hw_enet_rmon_r_jab_t *) HW_ENET_RMON_R_JAB_ADDR(x))
#define HW_ENET_RMON_R_JAB_RD(x) (HW_ENET_RMON_R_JAB(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_JAB bitfields
 */

/*!
 * @name Register ENET_RMON_R_JAB, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_JAB_COUNT (0U)      /*!< Bit position for ENET_RMON_R_JAB_COUNT. */
#define BM_ENET_RMON_R_JAB_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_JAB_COUNT. */
#define BS_ENET_RMON_R_JAB_COUNT (16U)     /*!< Bit field size in bits for ENET_RMON_R_JAB_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_JAB_COUNT field. */
#define BR_ENET_RMON_R_JAB_COUNT(x) (HW_ENET_RMON_R_JAB(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_P64 - Rx 64-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_P64 - Rx 64-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_p64
{
    uint32_t U;
    struct _hw_enet_rmon_r_p64_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_p64_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_P64 register
 */
/*@{*/
#define HW_ENET_RMON_R_P64_ADDR(x) ((uint32_t)(x) + 0x2A8U)

#define HW_ENET_RMON_R_P64(x)    (*(__I hw_enet_rmon_r_p64_t *) HW_ENET_RMON_R_P64_ADDR(x))
#define HW_ENET_RMON_R_P64_RD(x) (HW_ENET_RMON_R_P64(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P64 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P64, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_P64_COUNT (0U)      /*!< Bit position for ENET_RMON_R_P64_COUNT. */
#define BM_ENET_RMON_R_P64_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_P64_COUNT. */
#define BS_ENET_RMON_R_P64_COUNT (16U)     /*!< Bit field size in bits for ENET_RMON_R_P64_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_P64_COUNT field. */
#define BR_ENET_RMON_R_P64_COUNT(x) (HW_ENET_RMON_R_P64(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_P65TO127 - Rx 65- to 127-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_P65TO127 - Rx 65- to 127-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_p65to127
{
    uint32_t U;
    struct _hw_enet_rmon_r_p65to127_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_p65to127_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_P65TO127 register
 */
/*@{*/
#define HW_ENET_RMON_R_P65TO127_ADDR(x) ((uint32_t)(x) + 0x2ACU)

#define HW_ENET_RMON_R_P65TO127(x) (*(__I hw_enet_rmon_r_p65to127_t *) HW_ENET_RMON_R_P65TO127_ADDR(x))
#define HW_ENET_RMON_R_P65TO127_RD(x) (HW_ENET_RMON_R_P65TO127(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P65TO127 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P65TO127, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_P65TO127_COUNT (0U) /*!< Bit position for ENET_RMON_R_P65TO127_COUNT. */
#define BM_ENET_RMON_R_P65TO127_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_P65TO127_COUNT. */
#define BS_ENET_RMON_R_P65TO127_COUNT (16U) /*!< Bit field size in bits for ENET_RMON_R_P65TO127_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_P65TO127_COUNT field. */
#define BR_ENET_RMON_R_P65TO127_COUNT(x) (HW_ENET_RMON_R_P65TO127(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_P128TO255 - Rx 128- to 255-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_P128TO255 - Rx 128- to 255-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_p128to255
{
    uint32_t U;
    struct _hw_enet_rmon_r_p128to255_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_p128to255_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_P128TO255 register
 */
/*@{*/
#define HW_ENET_RMON_R_P128TO255_ADDR(x) ((uint32_t)(x) + 0x2B0U)

#define HW_ENET_RMON_R_P128TO255(x) (*(__I hw_enet_rmon_r_p128to255_t *) HW_ENET_RMON_R_P128TO255_ADDR(x))
#define HW_ENET_RMON_R_P128TO255_RD(x) (HW_ENET_RMON_R_P128TO255(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P128TO255 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P128TO255, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_P128TO255_COUNT (0U) /*!< Bit position for ENET_RMON_R_P128TO255_COUNT. */
#define BM_ENET_RMON_R_P128TO255_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_P128TO255_COUNT. */
#define BS_ENET_RMON_R_P128TO255_COUNT (16U) /*!< Bit field size in bits for ENET_RMON_R_P128TO255_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_P128TO255_COUNT field. */
#define BR_ENET_RMON_R_P128TO255_COUNT(x) (HW_ENET_RMON_R_P128TO255(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_P256TO511 - Rx 256- to 511-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_P256TO511 - Rx 256- to 511-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_p256to511
{
    uint32_t U;
    struct _hw_enet_rmon_r_p256to511_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_p256to511_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_P256TO511 register
 */
/*@{*/
#define HW_ENET_RMON_R_P256TO511_ADDR(x) ((uint32_t)(x) + 0x2B4U)

#define HW_ENET_RMON_R_P256TO511(x) (*(__I hw_enet_rmon_r_p256to511_t *) HW_ENET_RMON_R_P256TO511_ADDR(x))
#define HW_ENET_RMON_R_P256TO511_RD(x) (HW_ENET_RMON_R_P256TO511(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P256TO511 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P256TO511, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_P256TO511_COUNT (0U) /*!< Bit position for ENET_RMON_R_P256TO511_COUNT. */
#define BM_ENET_RMON_R_P256TO511_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_P256TO511_COUNT. */
#define BS_ENET_RMON_R_P256TO511_COUNT (16U) /*!< Bit field size in bits for ENET_RMON_R_P256TO511_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_P256TO511_COUNT field. */
#define BR_ENET_RMON_R_P256TO511_COUNT(x) (HW_ENET_RMON_R_P256TO511(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_P512TO1023 - Rx 512- to 1023-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_P512TO1023 - Rx 512- to 1023-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_p512to1023
{
    uint32_t U;
    struct _hw_enet_rmon_r_p512to1023_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_p512to1023_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_P512TO1023 register
 */
/*@{*/
#define HW_ENET_RMON_R_P512TO1023_ADDR(x) ((uint32_t)(x) + 0x2B8U)

#define HW_ENET_RMON_R_P512TO1023(x) (*(__I hw_enet_rmon_r_p512to1023_t *) HW_ENET_RMON_R_P512TO1023_ADDR(x))
#define HW_ENET_RMON_R_P512TO1023_RD(x) (HW_ENET_RMON_R_P512TO1023(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P512TO1023 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P512TO1023, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_P512TO1023_COUNT (0U) /*!< Bit position for ENET_RMON_R_P512TO1023_COUNT. */
#define BM_ENET_RMON_R_P512TO1023_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_P512TO1023_COUNT. */
#define BS_ENET_RMON_R_P512TO1023_COUNT (16U) /*!< Bit field size in bits for ENET_RMON_R_P512TO1023_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_P512TO1023_COUNT field. */
#define BR_ENET_RMON_R_P512TO1023_COUNT(x) (HW_ENET_RMON_R_P512TO1023(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_P1024TO2047 - Rx 1024- to 2047-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_P1024TO2047 - Rx 1024- to 2047-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_p1024to2047
{
    uint32_t U;
    struct _hw_enet_rmon_r_p1024to2047_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_p1024to2047_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_P1024TO2047 register
 */
/*@{*/
#define HW_ENET_RMON_R_P1024TO2047_ADDR(x) ((uint32_t)(x) + 0x2BCU)

#define HW_ENET_RMON_R_P1024TO2047(x) (*(__I hw_enet_rmon_r_p1024to2047_t *) HW_ENET_RMON_R_P1024TO2047_ADDR(x))
#define HW_ENET_RMON_R_P1024TO2047_RD(x) (HW_ENET_RMON_R_P1024TO2047(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P1024TO2047 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P1024TO2047, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_P1024TO2047_COUNT (0U) /*!< Bit position for ENET_RMON_R_P1024TO2047_COUNT. */
#define BM_ENET_RMON_R_P1024TO2047_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_P1024TO2047_COUNT. */
#define BS_ENET_RMON_R_P1024TO2047_COUNT (16U) /*!< Bit field size in bits for ENET_RMON_R_P1024TO2047_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_P1024TO2047_COUNT field. */
#define BR_ENET_RMON_R_P1024TO2047_COUNT(x) (HW_ENET_RMON_R_P1024TO2047(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_P_GTE2048 - Rx Packets Greater than 2048 Bytes Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_P_GTE2048 - Rx Packets Greater than 2048 Bytes Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_p_gte2048
{
    uint32_t U;
    struct _hw_enet_rmon_r_p_gte2048_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Packet count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_rmon_r_p_gte2048_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_P_GTE2048 register
 */
/*@{*/
#define HW_ENET_RMON_R_P_GTE2048_ADDR(x) ((uint32_t)(x) + 0x2C0U)

#define HW_ENET_RMON_R_P_GTE2048(x) (*(__I hw_enet_rmon_r_p_gte2048_t *) HW_ENET_RMON_R_P_GTE2048_ADDR(x))
#define HW_ENET_RMON_R_P_GTE2048_RD(x) (HW_ENET_RMON_R_P_GTE2048(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P_GTE2048 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P_GTE2048, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_P_GTE2048_COUNT (0U) /*!< Bit position for ENET_RMON_R_P_GTE2048_COUNT. */
#define BM_ENET_RMON_R_P_GTE2048_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_RMON_R_P_GTE2048_COUNT. */
#define BS_ENET_RMON_R_P_GTE2048_COUNT (16U) /*!< Bit field size in bits for ENET_RMON_R_P_GTE2048_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_P_GTE2048_COUNT field. */
#define BR_ENET_RMON_R_P_GTE2048_COUNT(x) (HW_ENET_RMON_R_P_GTE2048(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_RMON_R_OCTETS - Rx Octets Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_RMON_R_OCTETS - Rx Octets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_rmon_r_octets
{
    uint32_t U;
    struct _hw_enet_rmon_r_octets_bitfields
    {
        uint32_t COUNT : 32;           /*!< [31:0] Octet count */
    } B;
} hw_enet_rmon_r_octets_t;

/*!
 * @name Constants and macros for entire ENET_RMON_R_OCTETS register
 */
/*@{*/
#define HW_ENET_RMON_R_OCTETS_ADDR(x) ((uint32_t)(x) + 0x2C4U)

#define HW_ENET_RMON_R_OCTETS(x) (*(__I hw_enet_rmon_r_octets_t *) HW_ENET_RMON_R_OCTETS_ADDR(x))
#define HW_ENET_RMON_R_OCTETS_RD(x) (HW_ENET_RMON_R_OCTETS(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_OCTETS bitfields
 */

/*!
 * @name Register ENET_RMON_R_OCTETS, field COUNT[31:0] (RO)
 */
/*@{*/
#define BP_ENET_RMON_R_OCTETS_COUNT (0U)   /*!< Bit position for ENET_RMON_R_OCTETS_COUNT. */
#define BM_ENET_RMON_R_OCTETS_COUNT (0xFFFFFFFFU) /*!< Bit mask for ENET_RMON_R_OCTETS_COUNT. */
#define BS_ENET_RMON_R_OCTETS_COUNT (32U)  /*!< Bit field size in bits for ENET_RMON_R_OCTETS_COUNT. */

/*! @brief Read current value of the ENET_RMON_R_OCTETS_COUNT field. */
#define BR_ENET_RMON_R_OCTETS_COUNT(x) (HW_ENET_RMON_R_OCTETS(x).U)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_R_DROP - Frames not Counted Correctly Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_R_DROP - Frames not Counted Correctly Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Counter increments if a frame with invalid or missing SFD character is
 * detected and has been dropped. None of the other counters increments if this counter
 * increments.
 */
typedef union _hw_enet_ieee_r_drop
{
    uint32_t U;
    struct _hw_enet_ieee_r_drop_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_r_drop_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_R_DROP register
 */
/*@{*/
#define HW_ENET_IEEE_R_DROP_ADDR(x) ((uint32_t)(x) + 0x2C8U)

#define HW_ENET_IEEE_R_DROP(x)   (*(__I hw_enet_ieee_r_drop_t *) HW_ENET_IEEE_R_DROP_ADDR(x))
#define HW_ENET_IEEE_R_DROP_RD(x) (HW_ENET_IEEE_R_DROP(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_DROP bitfields
 */

/*!
 * @name Register ENET_IEEE_R_DROP, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_R_DROP_COUNT (0U)     /*!< Bit position for ENET_IEEE_R_DROP_COUNT. */
#define BM_ENET_IEEE_R_DROP_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_R_DROP_COUNT. */
#define BS_ENET_IEEE_R_DROP_COUNT (16U)    /*!< Bit field size in bits for ENET_IEEE_R_DROP_COUNT. */

/*! @brief Read current value of the ENET_IEEE_R_DROP_COUNT field. */
#define BR_ENET_IEEE_R_DROP_COUNT(x) (HW_ENET_IEEE_R_DROP(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_R_FRAME_OK - Frames Received OK Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_R_FRAME_OK - Frames Received OK Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_r_frame_ok
{
    uint32_t U;
    struct _hw_enet_ieee_r_frame_ok_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_r_frame_ok_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_R_FRAME_OK register
 */
/*@{*/
#define HW_ENET_IEEE_R_FRAME_OK_ADDR(x) ((uint32_t)(x) + 0x2CCU)

#define HW_ENET_IEEE_R_FRAME_OK(x) (*(__I hw_enet_ieee_r_frame_ok_t *) HW_ENET_IEEE_R_FRAME_OK_ADDR(x))
#define HW_ENET_IEEE_R_FRAME_OK_RD(x) (HW_ENET_IEEE_R_FRAME_OK(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_FRAME_OK bitfields
 */

/*!
 * @name Register ENET_IEEE_R_FRAME_OK, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_R_FRAME_OK_COUNT (0U) /*!< Bit position for ENET_IEEE_R_FRAME_OK_COUNT. */
#define BM_ENET_IEEE_R_FRAME_OK_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_R_FRAME_OK_COUNT. */
#define BS_ENET_IEEE_R_FRAME_OK_COUNT (16U) /*!< Bit field size in bits for ENET_IEEE_R_FRAME_OK_COUNT. */

/*! @brief Read current value of the ENET_IEEE_R_FRAME_OK_COUNT field. */
#define BR_ENET_IEEE_R_FRAME_OK_COUNT(x) (HW_ENET_IEEE_R_FRAME_OK(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_R_CRC - Frames Received with CRC Error Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_R_CRC - Frames Received with CRC Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_r_crc
{
    uint32_t U;
    struct _hw_enet_ieee_r_crc_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_r_crc_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_R_CRC register
 */
/*@{*/
#define HW_ENET_IEEE_R_CRC_ADDR(x) ((uint32_t)(x) + 0x2D0U)

#define HW_ENET_IEEE_R_CRC(x)    (*(__I hw_enet_ieee_r_crc_t *) HW_ENET_IEEE_R_CRC_ADDR(x))
#define HW_ENET_IEEE_R_CRC_RD(x) (HW_ENET_IEEE_R_CRC(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_CRC bitfields
 */

/*!
 * @name Register ENET_IEEE_R_CRC, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_R_CRC_COUNT (0U)      /*!< Bit position for ENET_IEEE_R_CRC_COUNT. */
#define BM_ENET_IEEE_R_CRC_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_R_CRC_COUNT. */
#define BS_ENET_IEEE_R_CRC_COUNT (16U)     /*!< Bit field size in bits for ENET_IEEE_R_CRC_COUNT. */

/*! @brief Read current value of the ENET_IEEE_R_CRC_COUNT field. */
#define BR_ENET_IEEE_R_CRC_COUNT(x) (HW_ENET_IEEE_R_CRC(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_R_ALIGN - Frames Received with Alignment Error Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_R_ALIGN - Frames Received with Alignment Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_r_align
{
    uint32_t U;
    struct _hw_enet_ieee_r_align_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_r_align_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_R_ALIGN register
 */
/*@{*/
#define HW_ENET_IEEE_R_ALIGN_ADDR(x) ((uint32_t)(x) + 0x2D4U)

#define HW_ENET_IEEE_R_ALIGN(x)  (*(__I hw_enet_ieee_r_align_t *) HW_ENET_IEEE_R_ALIGN_ADDR(x))
#define HW_ENET_IEEE_R_ALIGN_RD(x) (HW_ENET_IEEE_R_ALIGN(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_ALIGN bitfields
 */

/*!
 * @name Register ENET_IEEE_R_ALIGN, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_R_ALIGN_COUNT (0U)    /*!< Bit position for ENET_IEEE_R_ALIGN_COUNT. */
#define BM_ENET_IEEE_R_ALIGN_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_R_ALIGN_COUNT. */
#define BS_ENET_IEEE_R_ALIGN_COUNT (16U)   /*!< Bit field size in bits for ENET_IEEE_R_ALIGN_COUNT. */

/*! @brief Read current value of the ENET_IEEE_R_ALIGN_COUNT field. */
#define BR_ENET_IEEE_R_ALIGN_COUNT(x) (HW_ENET_IEEE_R_ALIGN(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_R_MACERR - Receive FIFO Overflow Count Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_R_MACERR - Receive FIFO Overflow Count Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_r_macerr
{
    uint32_t U;
    struct _hw_enet_ieee_r_macerr_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_r_macerr_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_R_MACERR register
 */
/*@{*/
#define HW_ENET_IEEE_R_MACERR_ADDR(x) ((uint32_t)(x) + 0x2D8U)

#define HW_ENET_IEEE_R_MACERR(x) (*(__I hw_enet_ieee_r_macerr_t *) HW_ENET_IEEE_R_MACERR_ADDR(x))
#define HW_ENET_IEEE_R_MACERR_RD(x) (HW_ENET_IEEE_R_MACERR(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_MACERR bitfields
 */

/*!
 * @name Register ENET_IEEE_R_MACERR, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_R_MACERR_COUNT (0U)   /*!< Bit position for ENET_IEEE_R_MACERR_COUNT. */
#define BM_ENET_IEEE_R_MACERR_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_R_MACERR_COUNT. */
#define BS_ENET_IEEE_R_MACERR_COUNT (16U)  /*!< Bit field size in bits for ENET_IEEE_R_MACERR_COUNT. */

/*! @brief Read current value of the ENET_IEEE_R_MACERR_COUNT field. */
#define BR_ENET_IEEE_R_MACERR_COUNT(x) (HW_ENET_IEEE_R_MACERR(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_R_FDXFC - Flow Control Pause Frames Received Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_R_FDXFC - Flow Control Pause Frames Received Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_r_fdxfc
{
    uint32_t U;
    struct _hw_enet_ieee_r_fdxfc_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Pause frame count */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_enet_ieee_r_fdxfc_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_R_FDXFC register
 */
/*@{*/
#define HW_ENET_IEEE_R_FDXFC_ADDR(x) ((uint32_t)(x) + 0x2DCU)

#define HW_ENET_IEEE_R_FDXFC(x)  (*(__I hw_enet_ieee_r_fdxfc_t *) HW_ENET_IEEE_R_FDXFC_ADDR(x))
#define HW_ENET_IEEE_R_FDXFC_RD(x) (HW_ENET_IEEE_R_FDXFC(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_FDXFC bitfields
 */

/*!
 * @name Register ENET_IEEE_R_FDXFC, field COUNT[15:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_R_FDXFC_COUNT (0U)    /*!< Bit position for ENET_IEEE_R_FDXFC_COUNT. */
#define BM_ENET_IEEE_R_FDXFC_COUNT (0x0000FFFFU) /*!< Bit mask for ENET_IEEE_R_FDXFC_COUNT. */
#define BS_ENET_IEEE_R_FDXFC_COUNT (16U)   /*!< Bit field size in bits for ENET_IEEE_R_FDXFC_COUNT. */

/*! @brief Read current value of the ENET_IEEE_R_FDXFC_COUNT field. */
#define BR_ENET_IEEE_R_FDXFC_COUNT(x) (HW_ENET_IEEE_R_FDXFC(x).B.COUNT)
/*@}*/

/*******************************************************************************
 * HW_ENET_IEEE_R_OCTETS_OK - Octet Count for Frames Received without Error Statistic Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_IEEE_R_OCTETS_OK - Octet Count for Frames Received without Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_ieee_r_octets_ok
{
    uint32_t U;
    struct _hw_enet_ieee_r_octets_ok_bitfields
    {
        uint32_t COUNT : 32;           /*!< [31:0] Octet count */
    } B;
} hw_enet_ieee_r_octets_ok_t;

/*!
 * @name Constants and macros for entire ENET_IEEE_R_OCTETS_OK register
 */
/*@{*/
#define HW_ENET_IEEE_R_OCTETS_OK_ADDR(x) ((uint32_t)(x) + 0x2E0U)

#define HW_ENET_IEEE_R_OCTETS_OK(x) (*(__I hw_enet_ieee_r_octets_ok_t *) HW_ENET_IEEE_R_OCTETS_OK_ADDR(x))
#define HW_ENET_IEEE_R_OCTETS_OK_RD(x) (HW_ENET_IEEE_R_OCTETS_OK(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_OCTETS_OK bitfields
 */

/*!
 * @name Register ENET_IEEE_R_OCTETS_OK, field COUNT[31:0] (RO)
 */
/*@{*/
#define BP_ENET_IEEE_R_OCTETS_OK_COUNT (0U) /*!< Bit position for ENET_IEEE_R_OCTETS_OK_COUNT. */
#define BM_ENET_IEEE_R_OCTETS_OK_COUNT (0xFFFFFFFFU) /*!< Bit mask for ENET_IEEE_R_OCTETS_OK_COUNT. */
#define BS_ENET_IEEE_R_OCTETS_OK_COUNT (32U) /*!< Bit field size in bits for ENET_IEEE_R_OCTETS_OK_COUNT. */

/*! @brief Read current value of the ENET_IEEE_R_OCTETS_OK_COUNT field. */
#define BR_ENET_IEEE_R_OCTETS_OK_COUNT(x) (HW_ENET_IEEE_R_OCTETS_OK(x).U)
/*@}*/

/*******************************************************************************
 * HW_ENET_ATCR - Adjustable Timer Control Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_ATCR - Adjustable Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * ATCR command fields can trigger the corresponding events directly. It is not
 * necessary to preserve any of the configuration fields when a command field is
 * set in the register, that is, no read-modify-write is required. The fields are
 * automatically cleared after the command completes.
 */
typedef union _hw_enet_atcr
{
    uint32_t U;
    struct _hw_enet_atcr_bitfields
    {
        uint32_t EN : 1;               /*!< [0] Enable Timer */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t OFFEN : 1;            /*!< [2] Enable One-Shot Offset Event */
        uint32_t OFFRST : 1;           /*!< [3] Reset Timer On Offset Event */
        uint32_t PEREN : 1;            /*!< [4] Enable Periodical Event */
        uint32_t RESERVED1 : 2;        /*!< [6:5]  */
        uint32_t PINPER : 1;           /*!< [7]  */
        uint32_t RESERVED2 : 1;        /*!< [8]  */
        uint32_t RESTART : 1;          /*!< [9] Reset Timer */
        uint32_t RESERVED3 : 1;        /*!< [10]  */
        uint32_t CAPTURE : 1;          /*!< [11] Capture Timer Value */
        uint32_t RESERVED4 : 1;        /*!< [12]  */
        uint32_t SLAVE : 1;            /*!< [13] Enable Timer Slave Mode */
        uint32_t RESERVED5 : 18;       /*!< [31:14]  */
    } B;
} hw_enet_atcr_t;

/*!
 * @name Constants and macros for entire ENET_ATCR register
 */
/*@{*/
#define HW_ENET_ATCR_ADDR(x)     ((uint32_t)(x) + 0x400U)

#define HW_ENET_ATCR(x)          (*(__IO hw_enet_atcr_t *) HW_ENET_ATCR_ADDR(x))
#define HW_ENET_ATCR_RD(x)       (HW_ENET_ATCR(x).U)
#define HW_ENET_ATCR_WR(x, v)    (HW_ENET_ATCR(x).U = (v))
#define HW_ENET_ATCR_SET(x, v)   (HW_ENET_ATCR_WR(x, HW_ENET_ATCR_RD(x) |  (v)))
#define HW_ENET_ATCR_CLR(x, v)   (HW_ENET_ATCR_WR(x, HW_ENET_ATCR_RD(x) & ~(v)))
#define HW_ENET_ATCR_TOG(x, v)   (HW_ENET_ATCR_WR(x, HW_ENET_ATCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_ATCR bitfields
 */

/*!
 * @name Register ENET_ATCR, field EN[0] (RW)
 *
 * Values:
 * - 0 - The timer stops at the current value.
 * - 1 - The timer starts incrementing.
 */
/*@{*/
#define BP_ENET_ATCR_EN      (0U)          /*!< Bit position for ENET_ATCR_EN. */
#define BM_ENET_ATCR_EN      (0x00000001U) /*!< Bit mask for ENET_ATCR_EN. */
#define BS_ENET_ATCR_EN      (1U)          /*!< Bit field size in bits for ENET_ATCR_EN. */

/*! @brief Read current value of the ENET_ATCR_EN field. */
#define BR_ENET_ATCR_EN(x)   (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_EN))

/*! @brief Format value for bitfield ENET_ATCR_EN. */
#define BF_ENET_ATCR_EN(v)   ((uint32_t)((uint32_t)(v) << BP_ENET_ATCR_EN) & BM_ENET_ATCR_EN)

/*! @brief Set the EN field to a new value. */
#define BW_ENET_ATCR_EN(x, v) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_EN) = (v))
/*@}*/

/*!
 * @name Register ENET_ATCR, field OFFEN[2] (RW)
 *
 * Values:
 * - 0 - Disable.
 * - 1 - The timer can be reset to zero when the given offset time is reached
 *     (offset event). The field is cleared when the offset event is reached, so no
 *     further event occurs until the field is set again. The timer offset value
 *     must be set before setting this field.
 */
/*@{*/
#define BP_ENET_ATCR_OFFEN   (2U)          /*!< Bit position for ENET_ATCR_OFFEN. */
#define BM_ENET_ATCR_OFFEN   (0x00000004U) /*!< Bit mask for ENET_ATCR_OFFEN. */
#define BS_ENET_ATCR_OFFEN   (1U)          /*!< Bit field size in bits for ENET_ATCR_OFFEN. */

/*! @brief Read current value of the ENET_ATCR_OFFEN field. */
#define BR_ENET_ATCR_OFFEN(x) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_OFFEN))

/*! @brief Format value for bitfield ENET_ATCR_OFFEN. */
#define BF_ENET_ATCR_OFFEN(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATCR_OFFEN) & BM_ENET_ATCR_OFFEN)

/*! @brief Set the OFFEN field to a new value. */
#define BW_ENET_ATCR_OFFEN(x, v) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_OFFEN) = (v))
/*@}*/

/*!
 * @name Register ENET_ATCR, field OFFRST[3] (RW)
 *
 * Values:
 * - 0 - The timer is not affected and no action occurs, besides clearing OFFEN,
 *     when the offset is reached.
 * - 1 - If OFFEN is set, the timer resets to zero when the offset setting is
 *     reached. The offset event does not cause a timer interrupt.
 */
/*@{*/
#define BP_ENET_ATCR_OFFRST  (3U)          /*!< Bit position for ENET_ATCR_OFFRST. */
#define BM_ENET_ATCR_OFFRST  (0x00000008U) /*!< Bit mask for ENET_ATCR_OFFRST. */
#define BS_ENET_ATCR_OFFRST  (1U)          /*!< Bit field size in bits for ENET_ATCR_OFFRST. */

/*! @brief Read current value of the ENET_ATCR_OFFRST field. */
#define BR_ENET_ATCR_OFFRST(x) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_OFFRST))

/*! @brief Format value for bitfield ENET_ATCR_OFFRST. */
#define BF_ENET_ATCR_OFFRST(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATCR_OFFRST) & BM_ENET_ATCR_OFFRST)

/*! @brief Set the OFFRST field to a new value. */
#define BW_ENET_ATCR_OFFRST(x, v) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_OFFRST) = (v))
/*@}*/

/*!
 * @name Register ENET_ATCR, field PEREN[4] (RW)
 *
 * Values:
 * - 0 - Disable.
 * - 1 - A period event interrupt can be generated (EIR[TS_TIMER]) and the event
 *     signal output is asserted when the timer wraps around according to the
 *     periodic setting ATPER. The timer period value must be set before setting
 *     this bit. Not all devices contain the event signal output. See the chip
 *     configuration details.
 */
/*@{*/
#define BP_ENET_ATCR_PEREN   (4U)          /*!< Bit position for ENET_ATCR_PEREN. */
#define BM_ENET_ATCR_PEREN   (0x00000010U) /*!< Bit mask for ENET_ATCR_PEREN. */
#define BS_ENET_ATCR_PEREN   (1U)          /*!< Bit field size in bits for ENET_ATCR_PEREN. */

/*! @brief Read current value of the ENET_ATCR_PEREN field. */
#define BR_ENET_ATCR_PEREN(x) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_PEREN))

/*! @brief Format value for bitfield ENET_ATCR_PEREN. */
#define BF_ENET_ATCR_PEREN(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATCR_PEREN) & BM_ENET_ATCR_PEREN)

/*! @brief Set the PEREN field to a new value. */
#define BW_ENET_ATCR_PEREN(x, v) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_PEREN) = (v))
/*@}*/

/*!
 * @name Register ENET_ATCR, field PINPER[7] (RW)
 *
 * Enables event signal output assertion on period event. Not all devices
 * contain the event signal output. See the chip configuration details.
 *
 * Values:
 * - 0 - Disable.
 * - 1 - Enable.
 */
/*@{*/
#define BP_ENET_ATCR_PINPER  (7U)          /*!< Bit position for ENET_ATCR_PINPER. */
#define BM_ENET_ATCR_PINPER  (0x00000080U) /*!< Bit mask for ENET_ATCR_PINPER. */
#define BS_ENET_ATCR_PINPER  (1U)          /*!< Bit field size in bits for ENET_ATCR_PINPER. */

/*! @brief Read current value of the ENET_ATCR_PINPER field. */
#define BR_ENET_ATCR_PINPER(x) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_PINPER))

/*! @brief Format value for bitfield ENET_ATCR_PINPER. */
#define BF_ENET_ATCR_PINPER(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATCR_PINPER) & BM_ENET_ATCR_PINPER)

/*! @brief Set the PINPER field to a new value. */
#define BW_ENET_ATCR_PINPER(x, v) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_PINPER) = (v))
/*@}*/

/*!
 * @name Register ENET_ATCR, field RESTART[9] (RW)
 *
 * Resets the timer to zero. This has no effect on the counter enable. If the
 * counter is enabled when this field is set, the timer is reset to zero and starts
 * counting from there. When set, all other fields are ignored during a write.
 */
/*@{*/
#define BP_ENET_ATCR_RESTART (9U)          /*!< Bit position for ENET_ATCR_RESTART. */
#define BM_ENET_ATCR_RESTART (0x00000200U) /*!< Bit mask for ENET_ATCR_RESTART. */
#define BS_ENET_ATCR_RESTART (1U)          /*!< Bit field size in bits for ENET_ATCR_RESTART. */

/*! @brief Read current value of the ENET_ATCR_RESTART field. */
#define BR_ENET_ATCR_RESTART(x) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_RESTART))

/*! @brief Format value for bitfield ENET_ATCR_RESTART. */
#define BF_ENET_ATCR_RESTART(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATCR_RESTART) & BM_ENET_ATCR_RESTART)

/*! @brief Set the RESTART field to a new value. */
#define BW_ENET_ATCR_RESTART(x, v) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_RESTART) = (v))
/*@}*/

/*!
 * @name Register ENET_ATCR, field CAPTURE[11] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - The current time is captured and can be read from the ATVR register.
 */
/*@{*/
#define BP_ENET_ATCR_CAPTURE (11U)         /*!< Bit position for ENET_ATCR_CAPTURE. */
#define BM_ENET_ATCR_CAPTURE (0x00000800U) /*!< Bit mask for ENET_ATCR_CAPTURE. */
#define BS_ENET_ATCR_CAPTURE (1U)          /*!< Bit field size in bits for ENET_ATCR_CAPTURE. */

/*! @brief Read current value of the ENET_ATCR_CAPTURE field. */
#define BR_ENET_ATCR_CAPTURE(x) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_CAPTURE))

/*! @brief Format value for bitfield ENET_ATCR_CAPTURE. */
#define BF_ENET_ATCR_CAPTURE(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATCR_CAPTURE) & BM_ENET_ATCR_CAPTURE)

/*! @brief Set the CAPTURE field to a new value. */
#define BW_ENET_ATCR_CAPTURE(x, v) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_CAPTURE) = (v))
/*@}*/

/*!
 * @name Register ENET_ATCR, field SLAVE[13] (RW)
 *
 * Values:
 * - 0 - The timer is active and all configuration fields in this register are
 *     relevant.
 * - 1 - The internal timer is disabled and the externally provided timer value
 *     is used. All other fields, except CAPTURE, in this register have no
 *     effect. CAPTURE can still be used to capture the current timer value.
 */
/*@{*/
#define BP_ENET_ATCR_SLAVE   (13U)         /*!< Bit position for ENET_ATCR_SLAVE. */
#define BM_ENET_ATCR_SLAVE   (0x00002000U) /*!< Bit mask for ENET_ATCR_SLAVE. */
#define BS_ENET_ATCR_SLAVE   (1U)          /*!< Bit field size in bits for ENET_ATCR_SLAVE. */

/*! @brief Read current value of the ENET_ATCR_SLAVE field. */
#define BR_ENET_ATCR_SLAVE(x) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_SLAVE))

/*! @brief Format value for bitfield ENET_ATCR_SLAVE. */
#define BF_ENET_ATCR_SLAVE(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATCR_SLAVE) & BM_ENET_ATCR_SLAVE)

/*! @brief Set the SLAVE field to a new value. */
#define BW_ENET_ATCR_SLAVE(x, v) (BITBAND_ACCESS32(HW_ENET_ATCR_ADDR(x), BP_ENET_ATCR_SLAVE) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_ATVR - Timer Value Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_ATVR - Timer Value Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_atvr
{
    uint32_t U;
    struct _hw_enet_atvr_bitfields
    {
        uint32_t ATIME : 32;           /*!< [31:0]  */
    } B;
} hw_enet_atvr_t;

/*!
 * @name Constants and macros for entire ENET_ATVR register
 */
/*@{*/
#define HW_ENET_ATVR_ADDR(x)     ((uint32_t)(x) + 0x404U)

#define HW_ENET_ATVR(x)          (*(__IO hw_enet_atvr_t *) HW_ENET_ATVR_ADDR(x))
#define HW_ENET_ATVR_RD(x)       (HW_ENET_ATVR(x).U)
#define HW_ENET_ATVR_WR(x, v)    (HW_ENET_ATVR(x).U = (v))
#define HW_ENET_ATVR_SET(x, v)   (HW_ENET_ATVR_WR(x, HW_ENET_ATVR_RD(x) |  (v)))
#define HW_ENET_ATVR_CLR(x, v)   (HW_ENET_ATVR_WR(x, HW_ENET_ATVR_RD(x) & ~(v)))
#define HW_ENET_ATVR_TOG(x, v)   (HW_ENET_ATVR_WR(x, HW_ENET_ATVR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_ATVR bitfields
 */

/*!
 * @name Register ENET_ATVR, field ATIME[31:0] (RW)
 *
 * A write sets the timer. A read returns the last captured value. To read the
 * current value, issue a capture command (set ATCR[CAPTURE]) prior to reading
 * this register.
 */
/*@{*/
#define BP_ENET_ATVR_ATIME   (0U)          /*!< Bit position for ENET_ATVR_ATIME. */
#define BM_ENET_ATVR_ATIME   (0xFFFFFFFFU) /*!< Bit mask for ENET_ATVR_ATIME. */
#define BS_ENET_ATVR_ATIME   (32U)         /*!< Bit field size in bits for ENET_ATVR_ATIME. */

/*! @brief Read current value of the ENET_ATVR_ATIME field. */
#define BR_ENET_ATVR_ATIME(x) (HW_ENET_ATVR(x).U)

/*! @brief Format value for bitfield ENET_ATVR_ATIME. */
#define BF_ENET_ATVR_ATIME(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATVR_ATIME) & BM_ENET_ATVR_ATIME)

/*! @brief Set the ATIME field to a new value. */
#define BW_ENET_ATVR_ATIME(x, v) (HW_ENET_ATVR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_ENET_ATOFF - Timer Offset Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_ATOFF - Timer Offset Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_atoff
{
    uint32_t U;
    struct _hw_enet_atoff_bitfields
    {
        uint32_t OFFSET : 32;          /*!< [31:0]  */
    } B;
} hw_enet_atoff_t;

/*!
 * @name Constants and macros for entire ENET_ATOFF register
 */
/*@{*/
#define HW_ENET_ATOFF_ADDR(x)    ((uint32_t)(x) + 0x408U)

#define HW_ENET_ATOFF(x)         (*(__IO hw_enet_atoff_t *) HW_ENET_ATOFF_ADDR(x))
#define HW_ENET_ATOFF_RD(x)      (HW_ENET_ATOFF(x).U)
#define HW_ENET_ATOFF_WR(x, v)   (HW_ENET_ATOFF(x).U = (v))
#define HW_ENET_ATOFF_SET(x, v)  (HW_ENET_ATOFF_WR(x, HW_ENET_ATOFF_RD(x) |  (v)))
#define HW_ENET_ATOFF_CLR(x, v)  (HW_ENET_ATOFF_WR(x, HW_ENET_ATOFF_RD(x) & ~(v)))
#define HW_ENET_ATOFF_TOG(x, v)  (HW_ENET_ATOFF_WR(x, HW_ENET_ATOFF_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_ATOFF bitfields
 */

/*!
 * @name Register ENET_ATOFF, field OFFSET[31:0] (RW)
 *
 * Offset value for one-shot event generation. When the timer reaches the value,
 * an event can be generated to reset the counter. If the increment value in
 * ATINC is given in true nanoseconds, this value is also given in true nanoseconds.
 */
/*@{*/
#define BP_ENET_ATOFF_OFFSET (0U)          /*!< Bit position for ENET_ATOFF_OFFSET. */
#define BM_ENET_ATOFF_OFFSET (0xFFFFFFFFU) /*!< Bit mask for ENET_ATOFF_OFFSET. */
#define BS_ENET_ATOFF_OFFSET (32U)         /*!< Bit field size in bits for ENET_ATOFF_OFFSET. */

/*! @brief Read current value of the ENET_ATOFF_OFFSET field. */
#define BR_ENET_ATOFF_OFFSET(x) (HW_ENET_ATOFF(x).U)

/*! @brief Format value for bitfield ENET_ATOFF_OFFSET. */
#define BF_ENET_ATOFF_OFFSET(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATOFF_OFFSET) & BM_ENET_ATOFF_OFFSET)

/*! @brief Set the OFFSET field to a new value. */
#define BW_ENET_ATOFF_OFFSET(x, v) (HW_ENET_ATOFF_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_ENET_ATPER - Timer Period Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_ATPER - Timer Period Register (RW)
 *
 * Reset value: 0x3B9ACA00U
 */
typedef union _hw_enet_atper
{
    uint32_t U;
    struct _hw_enet_atper_bitfields
    {
        uint32_t PERIOD : 32;          /*!< [31:0]  */
    } B;
} hw_enet_atper_t;

/*!
 * @name Constants and macros for entire ENET_ATPER register
 */
/*@{*/
#define HW_ENET_ATPER_ADDR(x)    ((uint32_t)(x) + 0x40CU)

#define HW_ENET_ATPER(x)         (*(__IO hw_enet_atper_t *) HW_ENET_ATPER_ADDR(x))
#define HW_ENET_ATPER_RD(x)      (HW_ENET_ATPER(x).U)
#define HW_ENET_ATPER_WR(x, v)   (HW_ENET_ATPER(x).U = (v))
#define HW_ENET_ATPER_SET(x, v)  (HW_ENET_ATPER_WR(x, HW_ENET_ATPER_RD(x) |  (v)))
#define HW_ENET_ATPER_CLR(x, v)  (HW_ENET_ATPER_WR(x, HW_ENET_ATPER_RD(x) & ~(v)))
#define HW_ENET_ATPER_TOG(x, v)  (HW_ENET_ATPER_WR(x, HW_ENET_ATPER_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_ATPER bitfields
 */

/*!
 * @name Register ENET_ATPER, field PERIOD[31:0] (RW)
 *
 * Value for generating periodic events. Each instance the timer reaches this
 * value, the period event occurs and the timer restarts. If the increment value in
 * ATINC is given in true nanoseconds, this value is also given in true
 * nanoseconds. The value should be initialized to 1,000,000,000 (1 x 10 9 ) to represent
 * a timer wrap around of one second. The increment value set in ATINC should be
 * set to the true nanoseconds of the period of clock ts_clk, hence implementing
 * a true 1 second counter.
 */
/*@{*/
#define BP_ENET_ATPER_PERIOD (0U)          /*!< Bit position for ENET_ATPER_PERIOD. */
#define BM_ENET_ATPER_PERIOD (0xFFFFFFFFU) /*!< Bit mask for ENET_ATPER_PERIOD. */
#define BS_ENET_ATPER_PERIOD (32U)         /*!< Bit field size in bits for ENET_ATPER_PERIOD. */

/*! @brief Read current value of the ENET_ATPER_PERIOD field. */
#define BR_ENET_ATPER_PERIOD(x) (HW_ENET_ATPER(x).U)

/*! @brief Format value for bitfield ENET_ATPER_PERIOD. */
#define BF_ENET_ATPER_PERIOD(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATPER_PERIOD) & BM_ENET_ATPER_PERIOD)

/*! @brief Set the PERIOD field to a new value. */
#define BW_ENET_ATPER_PERIOD(x, v) (HW_ENET_ATPER_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_ENET_ATCOR - Timer Correction Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_ATCOR - Timer Correction Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_atcor
{
    uint32_t U;
    struct _hw_enet_atcor_bitfields
    {
        uint32_t COR : 31;             /*!< [30:0] Correction Counter Wrap-Around Value */
        uint32_t RESERVED0 : 1;        /*!< [31]  */
    } B;
} hw_enet_atcor_t;

/*!
 * @name Constants and macros for entire ENET_ATCOR register
 */
/*@{*/
#define HW_ENET_ATCOR_ADDR(x)    ((uint32_t)(x) + 0x410U)

#define HW_ENET_ATCOR(x)         (*(__IO hw_enet_atcor_t *) HW_ENET_ATCOR_ADDR(x))
#define HW_ENET_ATCOR_RD(x)      (HW_ENET_ATCOR(x).U)
#define HW_ENET_ATCOR_WR(x, v)   (HW_ENET_ATCOR(x).U = (v))
#define HW_ENET_ATCOR_SET(x, v)  (HW_ENET_ATCOR_WR(x, HW_ENET_ATCOR_RD(x) |  (v)))
#define HW_ENET_ATCOR_CLR(x, v)  (HW_ENET_ATCOR_WR(x, HW_ENET_ATCOR_RD(x) & ~(v)))
#define HW_ENET_ATCOR_TOG(x, v)  (HW_ENET_ATCOR_WR(x, HW_ENET_ATCOR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_ATCOR bitfields
 */

/*!
 * @name Register ENET_ATCOR, field COR[30:0] (RW)
 *
 * Defines after how many timer clock cycles (ts_clk) the correction counter
 * should be reset and trigger a correction increment on the timer. The amount of
 * correction is defined in ATINC[INC_CORR]. A value of 0 disables the correction
 * counter and no corrections occur. This value is given in clock cycles, not in
 * nanoseconds as all other values.
 */
/*@{*/
#define BP_ENET_ATCOR_COR    (0U)          /*!< Bit position for ENET_ATCOR_COR. */
#define BM_ENET_ATCOR_COR    (0x7FFFFFFFU) /*!< Bit mask for ENET_ATCOR_COR. */
#define BS_ENET_ATCOR_COR    (31U)         /*!< Bit field size in bits for ENET_ATCOR_COR. */

/*! @brief Read current value of the ENET_ATCOR_COR field. */
#define BR_ENET_ATCOR_COR(x) (HW_ENET_ATCOR(x).B.COR)

/*! @brief Format value for bitfield ENET_ATCOR_COR. */
#define BF_ENET_ATCOR_COR(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATCOR_COR) & BM_ENET_ATCOR_COR)

/*! @brief Set the COR field to a new value. */
#define BW_ENET_ATCOR_COR(x, v) (HW_ENET_ATCOR_WR(x, (HW_ENET_ATCOR_RD(x) & ~BM_ENET_ATCOR_COR) | BF_ENET_ATCOR_COR(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_ATINC - Time-Stamping Clock Period Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_ATINC - Time-Stamping Clock Period Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_atinc
{
    uint32_t U;
    struct _hw_enet_atinc_bitfields
    {
        uint32_t INC : 7;              /*!< [6:0] Clock Period Of The Timestamping Clock
                                        * (ts_clk) In Nanoseconds */
        uint32_t RESERVED0 : 1;        /*!< [7]  */
        uint32_t INC_CORR : 7;         /*!< [14:8] Correction Increment Value */
        uint32_t RESERVED1 : 17;       /*!< [31:15]  */
    } B;
} hw_enet_atinc_t;

/*!
 * @name Constants and macros for entire ENET_ATINC register
 */
/*@{*/
#define HW_ENET_ATINC_ADDR(x)    ((uint32_t)(x) + 0x414U)

#define HW_ENET_ATINC(x)         (*(__IO hw_enet_atinc_t *) HW_ENET_ATINC_ADDR(x))
#define HW_ENET_ATINC_RD(x)      (HW_ENET_ATINC(x).U)
#define HW_ENET_ATINC_WR(x, v)   (HW_ENET_ATINC(x).U = (v))
#define HW_ENET_ATINC_SET(x, v)  (HW_ENET_ATINC_WR(x, HW_ENET_ATINC_RD(x) |  (v)))
#define HW_ENET_ATINC_CLR(x, v)  (HW_ENET_ATINC_WR(x, HW_ENET_ATINC_RD(x) & ~(v)))
#define HW_ENET_ATINC_TOG(x, v)  (HW_ENET_ATINC_WR(x, HW_ENET_ATINC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_ATINC bitfields
 */

/*!
 * @name Register ENET_ATINC, field INC[6:0] (RW)
 *
 * The timer increments by this amount each clock cycle. For example, set to 10
 * for 100 MHz, 8 for 125 MHz, 5 for 200 MHz. For highest precision, use a value
 * that is an integer fraction of the period set in ATPER.
 */
/*@{*/
#define BP_ENET_ATINC_INC    (0U)          /*!< Bit position for ENET_ATINC_INC. */
#define BM_ENET_ATINC_INC    (0x0000007FU) /*!< Bit mask for ENET_ATINC_INC. */
#define BS_ENET_ATINC_INC    (7U)          /*!< Bit field size in bits for ENET_ATINC_INC. */

/*! @brief Read current value of the ENET_ATINC_INC field. */
#define BR_ENET_ATINC_INC(x) (HW_ENET_ATINC(x).B.INC)

/*! @brief Format value for bitfield ENET_ATINC_INC. */
#define BF_ENET_ATINC_INC(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATINC_INC) & BM_ENET_ATINC_INC)

/*! @brief Set the INC field to a new value. */
#define BW_ENET_ATINC_INC(x, v) (HW_ENET_ATINC_WR(x, (HW_ENET_ATINC_RD(x) & ~BM_ENET_ATINC_INC) | BF_ENET_ATINC_INC(v)))
/*@}*/

/*!
 * @name Register ENET_ATINC, field INC_CORR[14:8] (RW)
 *
 * This value is added every time the correction timer expires (every clock
 * cycle given in ATCOR). A value less than INC slows down the timer. A value greater
 * than INC speeds up the timer.
 */
/*@{*/
#define BP_ENET_ATINC_INC_CORR (8U)        /*!< Bit position for ENET_ATINC_INC_CORR. */
#define BM_ENET_ATINC_INC_CORR (0x00007F00U) /*!< Bit mask for ENET_ATINC_INC_CORR. */
#define BS_ENET_ATINC_INC_CORR (7U)        /*!< Bit field size in bits for ENET_ATINC_INC_CORR. */

/*! @brief Read current value of the ENET_ATINC_INC_CORR field. */
#define BR_ENET_ATINC_INC_CORR(x) (HW_ENET_ATINC(x).B.INC_CORR)

/*! @brief Format value for bitfield ENET_ATINC_INC_CORR. */
#define BF_ENET_ATINC_INC_CORR(v) ((uint32_t)((uint32_t)(v) << BP_ENET_ATINC_INC_CORR) & BM_ENET_ATINC_INC_CORR)

/*! @brief Set the INC_CORR field to a new value. */
#define BW_ENET_ATINC_INC_CORR(x, v) (HW_ENET_ATINC_WR(x, (HW_ENET_ATINC_RD(x) & ~BM_ENET_ATINC_INC_CORR) | BF_ENET_ATINC_INC_CORR(v)))
/*@}*/

/*******************************************************************************
 * HW_ENET_ATSTMP - Timestamp of Last Transmitted Frame
 ******************************************************************************/

/*!
 * @brief HW_ENET_ATSTMP - Timestamp of Last Transmitted Frame (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_atstmp
{
    uint32_t U;
    struct _hw_enet_atstmp_bitfields
    {
        uint32_t TIMESTAMP : 32;       /*!< [31:0]  */
    } B;
} hw_enet_atstmp_t;

/*!
 * @name Constants and macros for entire ENET_ATSTMP register
 */
/*@{*/
#define HW_ENET_ATSTMP_ADDR(x)   ((uint32_t)(x) + 0x418U)

#define HW_ENET_ATSTMP(x)        (*(__I hw_enet_atstmp_t *) HW_ENET_ATSTMP_ADDR(x))
#define HW_ENET_ATSTMP_RD(x)     (HW_ENET_ATSTMP(x).U)
/*@}*/

/*
 * Constants & macros for individual ENET_ATSTMP bitfields
 */

/*!
 * @name Register ENET_ATSTMP, field TIMESTAMP[31:0] (RO)
 *
 * Timestamp of the last frame transmitted by the core that had TxBD[TS] set .
 * This register is only valid when EIR[TS_AVAIL] is set.
 */
/*@{*/
#define BP_ENET_ATSTMP_TIMESTAMP (0U)      /*!< Bit position for ENET_ATSTMP_TIMESTAMP. */
#define BM_ENET_ATSTMP_TIMESTAMP (0xFFFFFFFFU) /*!< Bit mask for ENET_ATSTMP_TIMESTAMP. */
#define BS_ENET_ATSTMP_TIMESTAMP (32U)     /*!< Bit field size in bits for ENET_ATSTMP_TIMESTAMP. */

/*! @brief Read current value of the ENET_ATSTMP_TIMESTAMP field. */
#define BR_ENET_ATSTMP_TIMESTAMP(x) (HW_ENET_ATSTMP(x).U)
/*@}*/

/*******************************************************************************
 * HW_ENET_TGSR - Timer Global Status Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_TGSR - Timer Global Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_tgsr
{
    uint32_t U;
    struct _hw_enet_tgsr_bitfields
    {
        uint32_t TF0 : 1;              /*!< [0] Copy Of Timer Flag For Channel 0 */
        uint32_t TF1 : 1;              /*!< [1] Copy Of Timer Flag For Channel 1 */
        uint32_t TF2 : 1;              /*!< [2] Copy Of Timer Flag For Channel 2 */
        uint32_t TF3 : 1;              /*!< [3] Copy Of Timer Flag For Channel 3 */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_enet_tgsr_t;

/*!
 * @name Constants and macros for entire ENET_TGSR register
 */
/*@{*/
#define HW_ENET_TGSR_ADDR(x)     ((uint32_t)(x) + 0x604U)

#define HW_ENET_TGSR(x)          (*(__IO hw_enet_tgsr_t *) HW_ENET_TGSR_ADDR(x))
#define HW_ENET_TGSR_RD(x)       (HW_ENET_TGSR(x).U)
#define HW_ENET_TGSR_WR(x, v)    (HW_ENET_TGSR(x).U = (v))
#define HW_ENET_TGSR_SET(x, v)   (HW_ENET_TGSR_WR(x, HW_ENET_TGSR_RD(x) |  (v)))
#define HW_ENET_TGSR_CLR(x, v)   (HW_ENET_TGSR_WR(x, HW_ENET_TGSR_RD(x) & ~(v)))
#define HW_ENET_TGSR_TOG(x, v)   (HW_ENET_TGSR_WR(x, HW_ENET_TGSR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TGSR bitfields
 */

/*!
 * @name Register ENET_TGSR, field TF0[0] (W1C)
 *
 * Values:
 * - 0 - Timer Flag for Channel 0 is clear
 * - 1 - Timer Flag for Channel 0 is set
 */
/*@{*/
#define BP_ENET_TGSR_TF0     (0U)          /*!< Bit position for ENET_TGSR_TF0. */
#define BM_ENET_TGSR_TF0     (0x00000001U) /*!< Bit mask for ENET_TGSR_TF0. */
#define BS_ENET_TGSR_TF0     (1U)          /*!< Bit field size in bits for ENET_TGSR_TF0. */

/*! @brief Read current value of the ENET_TGSR_TF0 field. */
#define BR_ENET_TGSR_TF0(x)  (BITBAND_ACCESS32(HW_ENET_TGSR_ADDR(x), BP_ENET_TGSR_TF0))

/*! @brief Format value for bitfield ENET_TGSR_TF0. */
#define BF_ENET_TGSR_TF0(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_TGSR_TF0) & BM_ENET_TGSR_TF0)

/*! @brief Set the TF0 field to a new value. */
#define BW_ENET_TGSR_TF0(x, v) (BITBAND_ACCESS32(HW_ENET_TGSR_ADDR(x), BP_ENET_TGSR_TF0) = (v))
/*@}*/

/*!
 * @name Register ENET_TGSR, field TF1[1] (W1C)
 *
 * Values:
 * - 0 - Timer Flag for Channel 1 is clear
 * - 1 - Timer Flag for Channel 1 is set
 */
/*@{*/
#define BP_ENET_TGSR_TF1     (1U)          /*!< Bit position for ENET_TGSR_TF1. */
#define BM_ENET_TGSR_TF1     (0x00000002U) /*!< Bit mask for ENET_TGSR_TF1. */
#define BS_ENET_TGSR_TF1     (1U)          /*!< Bit field size in bits for ENET_TGSR_TF1. */

/*! @brief Read current value of the ENET_TGSR_TF1 field. */
#define BR_ENET_TGSR_TF1(x)  (BITBAND_ACCESS32(HW_ENET_TGSR_ADDR(x), BP_ENET_TGSR_TF1))

/*! @brief Format value for bitfield ENET_TGSR_TF1. */
#define BF_ENET_TGSR_TF1(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_TGSR_TF1) & BM_ENET_TGSR_TF1)

/*! @brief Set the TF1 field to a new value. */
#define BW_ENET_TGSR_TF1(x, v) (BITBAND_ACCESS32(HW_ENET_TGSR_ADDR(x), BP_ENET_TGSR_TF1) = (v))
/*@}*/

/*!
 * @name Register ENET_TGSR, field TF2[2] (W1C)
 *
 * Values:
 * - 0 - Timer Flag for Channel 2 is clear
 * - 1 - Timer Flag for Channel 2 is set
 */
/*@{*/
#define BP_ENET_TGSR_TF2     (2U)          /*!< Bit position for ENET_TGSR_TF2. */
#define BM_ENET_TGSR_TF2     (0x00000004U) /*!< Bit mask for ENET_TGSR_TF2. */
#define BS_ENET_TGSR_TF2     (1U)          /*!< Bit field size in bits for ENET_TGSR_TF2. */

/*! @brief Read current value of the ENET_TGSR_TF2 field. */
#define BR_ENET_TGSR_TF2(x)  (BITBAND_ACCESS32(HW_ENET_TGSR_ADDR(x), BP_ENET_TGSR_TF2))

/*! @brief Format value for bitfield ENET_TGSR_TF2. */
#define BF_ENET_TGSR_TF2(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_TGSR_TF2) & BM_ENET_TGSR_TF2)

/*! @brief Set the TF2 field to a new value. */
#define BW_ENET_TGSR_TF2(x, v) (BITBAND_ACCESS32(HW_ENET_TGSR_ADDR(x), BP_ENET_TGSR_TF2) = (v))
/*@}*/

/*!
 * @name Register ENET_TGSR, field TF3[3] (W1C)
 *
 * Values:
 * - 0 - Timer Flag for Channel 3 is clear
 * - 1 - Timer Flag for Channel 3 is set
 */
/*@{*/
#define BP_ENET_TGSR_TF3     (3U)          /*!< Bit position for ENET_TGSR_TF3. */
#define BM_ENET_TGSR_TF3     (0x00000008U) /*!< Bit mask for ENET_TGSR_TF3. */
#define BS_ENET_TGSR_TF3     (1U)          /*!< Bit field size in bits for ENET_TGSR_TF3. */

/*! @brief Read current value of the ENET_TGSR_TF3 field. */
#define BR_ENET_TGSR_TF3(x)  (BITBAND_ACCESS32(HW_ENET_TGSR_ADDR(x), BP_ENET_TGSR_TF3))

/*! @brief Format value for bitfield ENET_TGSR_TF3. */
#define BF_ENET_TGSR_TF3(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_TGSR_TF3) & BM_ENET_TGSR_TF3)

/*! @brief Set the TF3 field to a new value. */
#define BW_ENET_TGSR_TF3(x, v) (BITBAND_ACCESS32(HW_ENET_TGSR_ADDR(x), BP_ENET_TGSR_TF3) = (v))
/*@}*/

/*******************************************************************************
 * HW_ENET_TCSRn - Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_TCSRn - Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_tcsrn
{
    uint32_t U;
    struct _hw_enet_tcsrn_bitfields
    {
        uint32_t TDRE : 1;             /*!< [0] Timer DMA Request Enable */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t TMODE : 4;            /*!< [5:2] Timer Mode */
        uint32_t TIE : 1;              /*!< [6] Timer Interrupt Enable */
        uint32_t TF : 1;               /*!< [7] Timer Flag */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_enet_tcsrn_t;

/*!
 * @name Constants and macros for entire ENET_TCSRn register
 */
/*@{*/
#define HW_ENET_TCSRn_COUNT (4U)

#define HW_ENET_TCSRn_ADDR(x, n) ((uint32_t)(x) + 0x608U + (0x8U * (n)))

#define HW_ENET_TCSRn(x, n)      (*(__IO hw_enet_tcsrn_t *) HW_ENET_TCSRn_ADDR(x, n))
#define HW_ENET_TCSRn_RD(x, n)   (HW_ENET_TCSRn(x, n).U)
#define HW_ENET_TCSRn_WR(x, n, v) (HW_ENET_TCSRn(x, n).U = (v))
#define HW_ENET_TCSRn_SET(x, n, v) (HW_ENET_TCSRn_WR(x, n, HW_ENET_TCSRn_RD(x, n) |  (v)))
#define HW_ENET_TCSRn_CLR(x, n, v) (HW_ENET_TCSRn_WR(x, n, HW_ENET_TCSRn_RD(x, n) & ~(v)))
#define HW_ENET_TCSRn_TOG(x, n, v) (HW_ENET_TCSRn_WR(x, n, HW_ENET_TCSRn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TCSRn bitfields
 */

/*!
 * @name Register ENET_TCSRn, field TDRE[0] (RW)
 *
 * Values:
 * - 0 - DMA request is disabled
 * - 1 - DMA request is enabled
 */
/*@{*/
#define BP_ENET_TCSRn_TDRE   (0U)          /*!< Bit position for ENET_TCSRn_TDRE. */
#define BM_ENET_TCSRn_TDRE   (0x00000001U) /*!< Bit mask for ENET_TCSRn_TDRE. */
#define BS_ENET_TCSRn_TDRE   (1U)          /*!< Bit field size in bits for ENET_TCSRn_TDRE. */

/*! @brief Read current value of the ENET_TCSRn_TDRE field. */
#define BR_ENET_TCSRn_TDRE(x, n) (BITBAND_ACCESS32(HW_ENET_TCSRn_ADDR(x, n), BP_ENET_TCSRn_TDRE))

/*! @brief Format value for bitfield ENET_TCSRn_TDRE. */
#define BF_ENET_TCSRn_TDRE(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TCSRn_TDRE) & BM_ENET_TCSRn_TDRE)

/*! @brief Set the TDRE field to a new value. */
#define BW_ENET_TCSRn_TDRE(x, n, v) (BITBAND_ACCESS32(HW_ENET_TCSRn_ADDR(x, n), BP_ENET_TCSRn_TDRE) = (v))
/*@}*/

/*!
 * @name Register ENET_TCSRn, field TMODE[5:2] (RW)
 *
 * Updating the Timer Mode field takes a few cycles to register because it is
 * synchronized to the 1588 clock. The version of Timer Mode returned on a read is
 * from the 1588 clock domain. When changing Timer Mode, always disable the
 * channel and read this register to verify the channel is disabled first.
 *
 * Values:
 * - 0000 - Timer Channel is disabled.
 * - 0001 - Timer Channel is configured for Input Capture on rising edge
 * - 0010 - Timer Channel is configured for Input Capture on falling edge
 * - 0011 - Timer Channel is configured for Input Capture on both edges
 * - 0100 - Timer Channel is configured for Output Compare - software only
 * - 0101 - Timer Channel is configured for Output Compare - toggle output on
 *     compare
 * - 0110 - Timer Channel is configured for Output Compare - clear output on
 *     compare
 * - 0111 - Timer Channel is configured for Output Compare - set output on
 *     compare
 * - 1000 - Reserved
 * - 1010 - Timer Channel is configured for Output Compare - clear output on
 *     compare, set output on overflow
 * - 10x1 - Timer Channel is configured for Output Compare - set output on
 *     compare, clear output on overflow
 * - 1100 - Reserved
 * - 1110 - Timer Channel is configured for Output Compare - pulse output low on
 *     compare for one 1588 clock cycle
 * - 1111 - Timer Channel is configured for Output Compare - pulse output high
 *     on compare for one 1588 clock cycle
 */
/*@{*/
#define BP_ENET_TCSRn_TMODE  (2U)          /*!< Bit position for ENET_TCSRn_TMODE. */
#define BM_ENET_TCSRn_TMODE  (0x0000003CU) /*!< Bit mask for ENET_TCSRn_TMODE. */
#define BS_ENET_TCSRn_TMODE  (4U)          /*!< Bit field size in bits for ENET_TCSRn_TMODE. */

/*! @brief Read current value of the ENET_TCSRn_TMODE field. */
#define BR_ENET_TCSRn_TMODE(x, n) (HW_ENET_TCSRn(x, n).B.TMODE)

/*! @brief Format value for bitfield ENET_TCSRn_TMODE. */
#define BF_ENET_TCSRn_TMODE(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TCSRn_TMODE) & BM_ENET_TCSRn_TMODE)

/*! @brief Set the TMODE field to a new value. */
#define BW_ENET_TCSRn_TMODE(x, n, v) (HW_ENET_TCSRn_WR(x, n, (HW_ENET_TCSRn_RD(x, n) & ~BM_ENET_TCSRn_TMODE) | BF_ENET_TCSRn_TMODE(v)))
/*@}*/

/*!
 * @name Register ENET_TCSRn, field TIE[6] (RW)
 *
 * Values:
 * - 0 - Interrupt is disabled
 * - 1 - Interrupt is enabled
 */
/*@{*/
#define BP_ENET_TCSRn_TIE    (6U)          /*!< Bit position for ENET_TCSRn_TIE. */
#define BM_ENET_TCSRn_TIE    (0x00000040U) /*!< Bit mask for ENET_TCSRn_TIE. */
#define BS_ENET_TCSRn_TIE    (1U)          /*!< Bit field size in bits for ENET_TCSRn_TIE. */

/*! @brief Read current value of the ENET_TCSRn_TIE field. */
#define BR_ENET_TCSRn_TIE(x, n) (BITBAND_ACCESS32(HW_ENET_TCSRn_ADDR(x, n), BP_ENET_TCSRn_TIE))

/*! @brief Format value for bitfield ENET_TCSRn_TIE. */
#define BF_ENET_TCSRn_TIE(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TCSRn_TIE) & BM_ENET_TCSRn_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_ENET_TCSRn_TIE(x, n, v) (BITBAND_ACCESS32(HW_ENET_TCSRn_ADDR(x, n), BP_ENET_TCSRn_TIE) = (v))
/*@}*/

/*!
 * @name Register ENET_TCSRn, field TF[7] (W1C)
 *
 * Sets when input capture or output compare occurs. This flag is double
 * buffered between the module clock and 1588 clock domains. When this field is 1, it
 * can be cleared to 0 by writing 1 to it.
 *
 * Values:
 * - 0 - Input Capture or Output Compare has not occurred
 * - 1 - Input Capture or Output Compare has occurred
 */
/*@{*/
#define BP_ENET_TCSRn_TF     (7U)          /*!< Bit position for ENET_TCSRn_TF. */
#define BM_ENET_TCSRn_TF     (0x00000080U) /*!< Bit mask for ENET_TCSRn_TF. */
#define BS_ENET_TCSRn_TF     (1U)          /*!< Bit field size in bits for ENET_TCSRn_TF. */

/*! @brief Read current value of the ENET_TCSRn_TF field. */
#define BR_ENET_TCSRn_TF(x, n) (BITBAND_ACCESS32(HW_ENET_TCSRn_ADDR(x, n), BP_ENET_TCSRn_TF))

/*! @brief Format value for bitfield ENET_TCSRn_TF. */
#define BF_ENET_TCSRn_TF(v)  ((uint32_t)((uint32_t)(v) << BP_ENET_TCSRn_TF) & BM_ENET_TCSRn_TF)

/*! @brief Set the TF field to a new value. */
#define BW_ENET_TCSRn_TF(x, n, v) (BITBAND_ACCESS32(HW_ENET_TCSRn_ADDR(x, n), BP_ENET_TCSRn_TF) = (v))
/*@}*/
/*******************************************************************************
 * HW_ENET_TCCRn - Timer Compare Capture Register
 ******************************************************************************/

/*!
 * @brief HW_ENET_TCCRn - Timer Compare Capture Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_enet_tccrn
{
    uint32_t U;
    struct _hw_enet_tccrn_bitfields
    {
        uint32_t TCC : 32;             /*!< [31:0] Timer Capture Compare */
    } B;
} hw_enet_tccrn_t;

/*!
 * @name Constants and macros for entire ENET_TCCRn register
 */
/*@{*/
#define HW_ENET_TCCRn_COUNT (4U)

#define HW_ENET_TCCRn_ADDR(x, n) ((uint32_t)(x) + 0x60CU + (0x8U * (n)))

#define HW_ENET_TCCRn(x, n)      (*(__IO hw_enet_tccrn_t *) HW_ENET_TCCRn_ADDR(x, n))
#define HW_ENET_TCCRn_RD(x, n)   (HW_ENET_TCCRn(x, n).U)
#define HW_ENET_TCCRn_WR(x, n, v) (HW_ENET_TCCRn(x, n).U = (v))
#define HW_ENET_TCCRn_SET(x, n, v) (HW_ENET_TCCRn_WR(x, n, HW_ENET_TCCRn_RD(x, n) |  (v)))
#define HW_ENET_TCCRn_CLR(x, n, v) (HW_ENET_TCCRn_WR(x, n, HW_ENET_TCCRn_RD(x, n) & ~(v)))
#define HW_ENET_TCCRn_TOG(x, n, v) (HW_ENET_TCCRn_WR(x, n, HW_ENET_TCCRn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual ENET_TCCRn bitfields
 */

/*!
 * @name Register ENET_TCCRn, field TCC[31:0] (RW)
 *
 * This register is double buffered between the module clock and 1588 clock
 * domains. When configured for compare, the 1588 clock domain updates with the value
 * in the module clock domain whenever the Timer Channel is first enabled and on
 * each subsequent compare. Write to this register with the first compare value
 * before enabling the Timer Channel. When the Timer Channel is enabled, write
 * the second compare value either immediately, or at least before the first
 * compare occurs. After each compare, write the next compare value before the previous
 * compare occurs and before clearing the Timer Flag. The compare occurs one
 * 1588 clock cycle after the IEEE 1588 Counter increments past the compare value in
 * the 1588 clock domain. If the compare value is less than the value of the
 * 1588 Counter when the Timer Channel is first enabled, then the compare does not
 * occur until following the next overflow of the 1588 Counter. If the compare
 * value is greater than the IEEE 1588 Counter when the 1588 Counter overflows, or
 * the compare value is less than the value of the IEEE 1588 Counter after the
 * overflow, then the compare occurs one 1588 clock cycle following the overflow.
 * When configured for Capture, the value of the IEEE 1588 Counter is captured into
 * the 1588 clock domain and then updated into the module clock domain, provided
 * the Timer Flag is clear. Always read the capture value before clearing the
 * Timer Flag.
 */
/*@{*/
#define BP_ENET_TCCRn_TCC    (0U)          /*!< Bit position for ENET_TCCRn_TCC. */
#define BM_ENET_TCCRn_TCC    (0xFFFFFFFFU) /*!< Bit mask for ENET_TCCRn_TCC. */
#define BS_ENET_TCCRn_TCC    (32U)         /*!< Bit field size in bits for ENET_TCCRn_TCC. */

/*! @brief Read current value of the ENET_TCCRn_TCC field. */
#define BR_ENET_TCCRn_TCC(x, n) (HW_ENET_TCCRn(x, n).U)

/*! @brief Format value for bitfield ENET_TCCRn_TCC. */
#define BF_ENET_TCCRn_TCC(v) ((uint32_t)((uint32_t)(v) << BP_ENET_TCCRn_TCC) & BM_ENET_TCCRn_TCC)

/*! @brief Set the TCC field to a new value. */
#define BW_ENET_TCCRn_TCC(x, n, v) (HW_ENET_TCCRn_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * hw_enet_t - module struct
 ******************************************************************************/
/*!
 * @brief All ENET module registers.
 */
#pragma pack(1)
typedef struct _hw_enet
{
    uint8_t _reserved0[4];
    __IO hw_enet_eir_t EIR;                /*!< [0x4] Interrupt Event Register */
    __IO hw_enet_eimr_t EIMR;              /*!< [0x8] Interrupt Mask Register */
    uint8_t _reserved1[4];
    __IO hw_enet_rdar_t RDAR;              /*!< [0x10] Receive Descriptor Active Register */
    __IO hw_enet_tdar_t TDAR;              /*!< [0x14] Transmit Descriptor Active Register */
    uint8_t _reserved2[12];
    __IO hw_enet_ecr_t ECR;                /*!< [0x24] Ethernet Control Register */
    uint8_t _reserved3[24];
    __IO hw_enet_mmfr_t MMFR;              /*!< [0x40] MII Management Frame Register */
    __IO hw_enet_mscr_t MSCR;              /*!< [0x44] MII Speed Control Register */
    uint8_t _reserved4[28];
    __IO hw_enet_mibc_t MIBC;              /*!< [0x64] MIB Control Register */
    uint8_t _reserved5[28];
    __IO hw_enet_rcr_t RCR;                /*!< [0x84] Receive Control Register */
    uint8_t _reserved6[60];
    __IO hw_enet_tcr_t TCR;                /*!< [0xC4] Transmit Control Register */
    uint8_t _reserved7[28];
    __IO hw_enet_palr_t PALR;              /*!< [0xE4] Physical Address Lower Register */
    __IO hw_enet_paur_t PAUR;              /*!< [0xE8] Physical Address Upper Register */
    __IO hw_enet_opd_t OPD;                /*!< [0xEC] Opcode/Pause Duration Register */
    uint8_t _reserved8[40];
    __IO hw_enet_iaur_t IAUR;              /*!< [0x118] Descriptor Individual Upper Address Register */
    __IO hw_enet_ialr_t IALR;              /*!< [0x11C] Descriptor Individual Lower Address Register */
    __IO hw_enet_gaur_t GAUR;              /*!< [0x120] Descriptor Group Upper Address Register */
    __IO hw_enet_galr_t GALR;              /*!< [0x124] Descriptor Group Lower Address Register */
    uint8_t _reserved9[28];
    __IO hw_enet_tfwr_t TFWR;              /*!< [0x144] Transmit FIFO Watermark Register */
    uint8_t _reserved10[56];
    __IO hw_enet_rdsr_t RDSR;              /*!< [0x180] Receive Descriptor Ring Start Register */
    __IO hw_enet_tdsr_t TDSR;              /*!< [0x184] Transmit Buffer Descriptor Ring Start Register */
    __IO hw_enet_mrbr_t MRBR;              /*!< [0x188] Maximum Receive Buffer Size Register */
    uint8_t _reserved11[4];
    __IO hw_enet_rsfl_t RSFL;              /*!< [0x190] Receive FIFO Section Full Threshold */
    __IO hw_enet_rsem_t RSEM;              /*!< [0x194] Receive FIFO Section Empty Threshold */
    __IO hw_enet_raem_t RAEM;              /*!< [0x198] Receive FIFO Almost Empty Threshold */
    __IO hw_enet_rafl_t RAFL;              /*!< [0x19C] Receive FIFO Almost Full Threshold */
    __IO hw_enet_tsem_t TSEM;              /*!< [0x1A0] Transmit FIFO Section Empty Threshold */
    __IO hw_enet_taem_t TAEM;              /*!< [0x1A4] Transmit FIFO Almost Empty Threshold */
    __IO hw_enet_tafl_t TAFL;              /*!< [0x1A8] Transmit FIFO Almost Full Threshold */
    __IO hw_enet_tipg_t TIPG;              /*!< [0x1AC] Transmit Inter-Packet Gap */
    __IO hw_enet_ftrl_t FTRL;              /*!< [0x1B0] Frame Truncation Length */
    uint8_t _reserved12[12];
    __IO hw_enet_tacc_t TACC;              /*!< [0x1C0] Transmit Accelerator Function Configuration */
    __IO hw_enet_racc_t RACC;              /*!< [0x1C4] Receive Accelerator Function Configuration */
    uint8_t _reserved13[60];
    __I hw_enet_rmon_t_packets_t RMON_T_PACKETS; /*!< [0x204] Tx Packet Count Statistic Register */
    __I hw_enet_rmon_t_bc_pkt_t RMON_T_BC_PKT; /*!< [0x208] Tx Broadcast Packets Statistic Register */
    __I hw_enet_rmon_t_mc_pkt_t RMON_T_MC_PKT; /*!< [0x20C] Tx Multicast Packets Statistic Register */
    __I hw_enet_rmon_t_crc_align_t RMON_T_CRC_ALIGN; /*!< [0x210] Tx Packets with CRC/Align Error Statistic Register */
    __I hw_enet_rmon_t_undersize_t RMON_T_UNDERSIZE; /*!< [0x214] Tx Packets Less Than Bytes and Good CRC Statistic Register */
    __I hw_enet_rmon_t_oversize_t RMON_T_OVERSIZE; /*!< [0x218] Tx Packets GT MAX_FL bytes and Good CRC Statistic Register */
    __I hw_enet_rmon_t_frag_t RMON_T_FRAG; /*!< [0x21C] Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register */
    __I hw_enet_rmon_t_jab_t RMON_T_JAB;   /*!< [0x220] Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register */
    __I hw_enet_rmon_t_col_t RMON_T_COL;   /*!< [0x224] Tx Collision Count Statistic Register */
    __I hw_enet_rmon_t_p64_t RMON_T_P64;   /*!< [0x228] Tx 64-Byte Packets Statistic Register */
    __I hw_enet_rmon_t_p65to127_t RMON_T_P65TO127; /*!< [0x22C] Tx 65- to 127-byte Packets Statistic Register */
    __I hw_enet_rmon_t_p128to255_t RMON_T_P128TO255; /*!< [0x230] Tx 128- to 255-byte Packets Statistic Register */
    __I hw_enet_rmon_t_p256to511_t RMON_T_P256TO511; /*!< [0x234] Tx 256- to 511-byte Packets Statistic Register */
    __I hw_enet_rmon_t_p512to1023_t RMON_T_P512TO1023; /*!< [0x238] Tx 512- to 1023-byte Packets Statistic Register */
    __I hw_enet_rmon_t_p1024to2047_t RMON_T_P1024TO2047; /*!< [0x23C] Tx 1024- to 2047-byte Packets Statistic Register */
    __I hw_enet_rmon_t_p_gte2048_t RMON_T_P_GTE2048; /*!< [0x240] Tx Packets Greater Than 2048 Bytes Statistic Register */
    __I hw_enet_rmon_t_octets_t RMON_T_OCTETS; /*!< [0x244] Tx Octets Statistic Register */
    uint8_t _reserved14[4];
    __I hw_enet_ieee_t_frame_ok_t IEEE_T_FRAME_OK; /*!< [0x24C] Frames Transmitted OK Statistic Register */
    __I hw_enet_ieee_t_1col_t IEEE_T_1COL; /*!< [0x250] Frames Transmitted with Single Collision Statistic Register */
    __I hw_enet_ieee_t_mcol_t IEEE_T_MCOL; /*!< [0x254] Frames Transmitted with Multiple Collisions Statistic Register */
    __I hw_enet_ieee_t_def_t IEEE_T_DEF;   /*!< [0x258] Frames Transmitted after Deferral Delay Statistic Register */
    __I hw_enet_ieee_t_lcol_t IEEE_T_LCOL; /*!< [0x25C] Frames Transmitted with Late Collision Statistic Register */
    __I hw_enet_ieee_t_excol_t IEEE_T_EXCOL; /*!< [0x260] Frames Transmitted with Excessive Collisions Statistic Register */
    __I hw_enet_ieee_t_macerr_t IEEE_T_MACERR; /*!< [0x264] Frames Transmitted with Tx FIFO Underrun Statistic Register */
    __I hw_enet_ieee_t_cserr_t IEEE_T_CSERR; /*!< [0x268] Frames Transmitted with Carrier Sense Error Statistic Register */
    uint8_t _reserved15[4];
    __I hw_enet_ieee_t_fdxfc_t IEEE_T_FDXFC; /*!< [0x270] Flow Control Pause Frames Transmitted Statistic Register */
    __I hw_enet_ieee_t_octets_ok_t IEEE_T_OCTETS_OK; /*!< [0x274] Octet Count for Frames Transmitted w/o Error Statistic Register */
    uint8_t _reserved16[12];
    __I hw_enet_rmon_r_packets_t RMON_R_PACKETS; /*!< [0x284] Rx Packet Count Statistic Register */
    __I hw_enet_rmon_r_bc_pkt_t RMON_R_BC_PKT; /*!< [0x288] Rx Broadcast Packets Statistic Register */
    __I hw_enet_rmon_r_mc_pkt_t RMON_R_MC_PKT; /*!< [0x28C] Rx Multicast Packets Statistic Register */
    __I hw_enet_rmon_r_crc_align_t RMON_R_CRC_ALIGN; /*!< [0x290] Rx Packets with CRC/Align Error Statistic Register */
    __I hw_enet_rmon_r_undersize_t RMON_R_UNDERSIZE; /*!< [0x294] Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register */
    __I hw_enet_rmon_r_oversize_t RMON_R_OVERSIZE; /*!< [0x298] Rx Packets Greater Than MAX_FL and Good CRC Statistic Register */
    __I hw_enet_rmon_r_frag_t RMON_R_FRAG; /*!< [0x29C] Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register */
    __I hw_enet_rmon_r_jab_t RMON_R_JAB;   /*!< [0x2A0] Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register */
    uint8_t _reserved17[4];
    __I hw_enet_rmon_r_p64_t RMON_R_P64;   /*!< [0x2A8] Rx 64-Byte Packets Statistic Register */
    __I hw_enet_rmon_r_p65to127_t RMON_R_P65TO127; /*!< [0x2AC] Rx 65- to 127-Byte Packets Statistic Register */
    __I hw_enet_rmon_r_p128to255_t RMON_R_P128TO255; /*!< [0x2B0] Rx 128- to 255-Byte Packets Statistic Register */
    __I hw_enet_rmon_r_p256to511_t RMON_R_P256TO511; /*!< [0x2B4] Rx 256- to 511-Byte Packets Statistic Register */
    __I hw_enet_rmon_r_p512to1023_t RMON_R_P512TO1023; /*!< [0x2B8] Rx 512- to 1023-Byte Packets Statistic Register */
    __I hw_enet_rmon_r_p1024to2047_t RMON_R_P1024TO2047; /*!< [0x2BC] Rx 1024- to 2047-Byte Packets Statistic Register */
    __I hw_enet_rmon_r_p_gte2048_t RMON_R_P_GTE2048; /*!< [0x2C0] Rx Packets Greater than 2048 Bytes Statistic Register */
    __I hw_enet_rmon_r_octets_t RMON_R_OCTETS; /*!< [0x2C4] Rx Octets Statistic Register */
    __I hw_enet_ieee_r_drop_t IEEE_R_DROP; /*!< [0x2C8] Frames not Counted Correctly Statistic Register */
    __I hw_enet_ieee_r_frame_ok_t IEEE_R_FRAME_OK; /*!< [0x2CC] Frames Received OK Statistic Register */
    __I hw_enet_ieee_r_crc_t IEEE_R_CRC;   /*!< [0x2D0] Frames Received with CRC Error Statistic Register */
    __I hw_enet_ieee_r_align_t IEEE_R_ALIGN; /*!< [0x2D4] Frames Received with Alignment Error Statistic Register */
    __I hw_enet_ieee_r_macerr_t IEEE_R_MACERR; /*!< [0x2D8] Receive FIFO Overflow Count Statistic Register */
    __I hw_enet_ieee_r_fdxfc_t IEEE_R_FDXFC; /*!< [0x2DC] Flow Control Pause Frames Received Statistic Register */
    __I hw_enet_ieee_r_octets_ok_t IEEE_R_OCTETS_OK; /*!< [0x2E0] Octet Count for Frames Received without Error Statistic Register */
    uint8_t _reserved18[284];
    __IO hw_enet_atcr_t ATCR;              /*!< [0x400] Adjustable Timer Control Register */
    __IO hw_enet_atvr_t ATVR;              /*!< [0x404] Timer Value Register */
    __IO hw_enet_atoff_t ATOFF;            /*!< [0x408] Timer Offset Register */
    __IO hw_enet_atper_t ATPER;            /*!< [0x40C] Timer Period Register */
    __IO hw_enet_atcor_t ATCOR;            /*!< [0x410] Timer Correction Register */
    __IO hw_enet_atinc_t ATINC;            /*!< [0x414] Time-Stamping Clock Period Register */
    __I hw_enet_atstmp_t ATSTMP;           /*!< [0x418] Timestamp of Last Transmitted Frame */
    uint8_t _reserved19[488];
    __IO hw_enet_tgsr_t TGSR;              /*!< [0x604] Timer Global Status Register */
    struct {
        __IO hw_enet_tcsrn_t TCSRn;        /*!< [0x608] Timer Control Status Register */
        __IO hw_enet_tccrn_t TCCRn;        /*!< [0x60C] Timer Compare Capture Register */
    } CHANNEL[4];
} hw_enet_t;
#pragma pack()

/*! @brief Macro to access all ENET registers. */
/*! @param x ENET module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_ENET_REGS(ENET_BASE)</code>. */
#define HW_ENET_REGS(x) (*(hw_enet_t *)(x))

/*
 * MK64F12 EWM
 *
 * External Watchdog Monitor
 *
 * Registers defined in this header file:
 * - HW_EWM_CTRL - Control Register
 * - HW_EWM_SERV - Service Register
 * - HW_EWM_CMPL - Compare Low Register
 * - HW_EWM_CMPH - Compare High Register
 *
 * - hw_ewm_t - Struct containing all module registers.
 */

#define HW_EWM_INSTANCE_COUNT (1U) /*!< Number of instances of the EWM module. */
#define HW_EWM (0U) /*!< Instance number for EWM. */

/*******************************************************************************
 * HW_EWM_CTRL - Control Register
 ******************************************************************************/

/*!
 * @brief HW_EWM_CTRL - Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CTRL register is cleared by any reset. INEN, ASSIN and EWMEN bits can be
 * written once after a CPU reset. Modifying these bits more than once, generates
 * a bus transfer error.
 */
typedef union _hw_ewm_ctrl
{
    uint8_t U;
    struct _hw_ewm_ctrl_bitfields
    {
        uint8_t EWMEN : 1;             /*!< [0] EWM enable. */
        uint8_t ASSIN : 1;             /*!< [1] EWM_in's Assertion State Select. */
        uint8_t INEN : 1;              /*!< [2] Input Enable. */
        uint8_t INTEN : 1;             /*!< [3] Interrupt Enable. */
        uint8_t RESERVED0 : 4;         /*!< [7:4]  */
    } B;
} hw_ewm_ctrl_t;

/*!
 * @name Constants and macros for entire EWM_CTRL register
 */
/*@{*/
#define HW_EWM_CTRL_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_EWM_CTRL(x)           (*(__IO hw_ewm_ctrl_t *) HW_EWM_CTRL_ADDR(x))
#define HW_EWM_CTRL_RD(x)        (HW_EWM_CTRL(x).U)
#define HW_EWM_CTRL_WR(x, v)     (HW_EWM_CTRL(x).U = (v))
#define HW_EWM_CTRL_SET(x, v)    (HW_EWM_CTRL_WR(x, HW_EWM_CTRL_RD(x) |  (v)))
#define HW_EWM_CTRL_CLR(x, v)    (HW_EWM_CTRL_WR(x, HW_EWM_CTRL_RD(x) & ~(v)))
#define HW_EWM_CTRL_TOG(x, v)    (HW_EWM_CTRL_WR(x, HW_EWM_CTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual EWM_CTRL bitfields
 */

/*!
 * @name Register EWM_CTRL, field EWMEN[0] (RW)
 *
 * This bit when set, enables the EWM module. This resets the EWM counter to
 * zero and deasserts the EWM_out signal. Clearing EWMEN bit disables the EWM, and
 * therefore it cannot be enabled until a reset occurs, due to the write-once
 * nature of this bit.
 */
/*@{*/
#define BP_EWM_CTRL_EWMEN    (0U)          /*!< Bit position for EWM_CTRL_EWMEN. */
#define BM_EWM_CTRL_EWMEN    (0x01U)       /*!< Bit mask for EWM_CTRL_EWMEN. */
#define BS_EWM_CTRL_EWMEN    (1U)          /*!< Bit field size in bits for EWM_CTRL_EWMEN. */

/*! @brief Read current value of the EWM_CTRL_EWMEN field. */
#define BR_EWM_CTRL_EWMEN(x) (BITBAND_ACCESS8(HW_EWM_CTRL_ADDR(x), BP_EWM_CTRL_EWMEN))

/*! @brief Format value for bitfield EWM_CTRL_EWMEN. */
#define BF_EWM_CTRL_EWMEN(v) ((uint8_t)((uint8_t)(v) << BP_EWM_CTRL_EWMEN) & BM_EWM_CTRL_EWMEN)

/*! @brief Set the EWMEN field to a new value. */
#define BW_EWM_CTRL_EWMEN(x, v) (BITBAND_ACCESS8(HW_EWM_CTRL_ADDR(x), BP_EWM_CTRL_EWMEN) = (v))
/*@}*/

/*!
 * @name Register EWM_CTRL, field ASSIN[1] (RW)
 *
 * Default assert state of the EWM_in signal is logic zero. Setting ASSIN bit
 * inverts the assert state to a logic one.
 */
/*@{*/
#define BP_EWM_CTRL_ASSIN    (1U)          /*!< Bit position for EWM_CTRL_ASSIN. */
#define BM_EWM_CTRL_ASSIN    (0x02U)       /*!< Bit mask for EWM_CTRL_ASSIN. */
#define BS_EWM_CTRL_ASSIN    (1U)          /*!< Bit field size in bits for EWM_CTRL_ASSIN. */

/*! @brief Read current value of the EWM_CTRL_ASSIN field. */
#define BR_EWM_CTRL_ASSIN(x) (BITBAND_ACCESS8(HW_EWM_CTRL_ADDR(x), BP_EWM_CTRL_ASSIN))

/*! @brief Format value for bitfield EWM_CTRL_ASSIN. */
#define BF_EWM_CTRL_ASSIN(v) ((uint8_t)((uint8_t)(v) << BP_EWM_CTRL_ASSIN) & BM_EWM_CTRL_ASSIN)

/*! @brief Set the ASSIN field to a new value. */
#define BW_EWM_CTRL_ASSIN(x, v) (BITBAND_ACCESS8(HW_EWM_CTRL_ADDR(x), BP_EWM_CTRL_ASSIN) = (v))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INEN[2] (RW)
 *
 * This bit when set, enables the EWM_in port.
 */
/*@{*/
#define BP_EWM_CTRL_INEN     (2U)          /*!< Bit position for EWM_CTRL_INEN. */
#define BM_EWM_CTRL_INEN     (0x04U)       /*!< Bit mask for EWM_CTRL_INEN. */
#define BS_EWM_CTRL_INEN     (1U)          /*!< Bit field size in bits for EWM_CTRL_INEN. */

/*! @brief Read current value of the EWM_CTRL_INEN field. */
#define BR_EWM_CTRL_INEN(x)  (BITBAND_ACCESS8(HW_EWM_CTRL_ADDR(x), BP_EWM_CTRL_INEN))

/*! @brief Format value for bitfield EWM_CTRL_INEN. */
#define BF_EWM_CTRL_INEN(v)  ((uint8_t)((uint8_t)(v) << BP_EWM_CTRL_INEN) & BM_EWM_CTRL_INEN)

/*! @brief Set the INEN field to a new value. */
#define BW_EWM_CTRL_INEN(x, v) (BITBAND_ACCESS8(HW_EWM_CTRL_ADDR(x), BP_EWM_CTRL_INEN) = (v))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INTEN[3] (RW)
 *
 * This bit when set and EWM_out is asserted, an interrupt request is generated.
 * To de-assert interrupt request, user should clear this bit by writing 0.
 */
/*@{*/
#define BP_EWM_CTRL_INTEN    (3U)          /*!< Bit position for EWM_CTRL_INTEN. */
#define BM_EWM_CTRL_INTEN    (0x08U)       /*!< Bit mask for EWM_CTRL_INTEN. */
#define BS_EWM_CTRL_INTEN    (1U)          /*!< Bit field size in bits for EWM_CTRL_INTEN. */

/*! @brief Read current value of the EWM_CTRL_INTEN field. */
#define BR_EWM_CTRL_INTEN(x) (BITBAND_ACCESS8(HW_EWM_CTRL_ADDR(x), BP_EWM_CTRL_INTEN))

/*! @brief Format value for bitfield EWM_CTRL_INTEN. */
#define BF_EWM_CTRL_INTEN(v) ((uint8_t)((uint8_t)(v) << BP_EWM_CTRL_INTEN) & BM_EWM_CTRL_INTEN)

/*! @brief Set the INTEN field to a new value. */
#define BW_EWM_CTRL_INTEN(x, v) (BITBAND_ACCESS8(HW_EWM_CTRL_ADDR(x), BP_EWM_CTRL_INTEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_EWM_SERV - Service Register
 ******************************************************************************/

/*!
 * @brief HW_EWM_SERV - Service Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The SERV register provides the interface from the CPU to the EWM module. It
 * is write-only and reads of this register return zero.
 */
typedef union _hw_ewm_serv
{
    uint8_t U;
    struct _hw_ewm_serv_bitfields
    {
        uint8_t SERVICE : 8;           /*!< [7:0]  */
    } B;
} hw_ewm_serv_t;

/*!
 * @name Constants and macros for entire EWM_SERV register
 */
/*@{*/
#define HW_EWM_SERV_ADDR(x)      ((uint32_t)(x) + 0x1U)

#define HW_EWM_SERV(x)           (*(__O hw_ewm_serv_t *) HW_EWM_SERV_ADDR(x))
#define HW_EWM_SERV_RD(x)        (HW_EWM_SERV(x).U)
#define HW_EWM_SERV_WR(x, v)     (HW_EWM_SERV(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual EWM_SERV bitfields
 */

/*!
 * @name Register EWM_SERV, field SERVICE[7:0] (WORZ)
 *
 * The EWM service mechanism requires the CPU to write two values to the SERV
 * register: a first data byte of 0xB4, followed by a second data byte of 0x2C. The
 * EWM service is illegal if either of the following conditions is true. The
 * first or second data byte is not written correctly. The second data byte is not
 * written within a fixed number of peripheral bus cycles of the first data byte.
 * This fixed number of cycles is called EWM_service_time.
 */
/*@{*/
#define BP_EWM_SERV_SERVICE  (0U)          /*!< Bit position for EWM_SERV_SERVICE. */
#define BM_EWM_SERV_SERVICE  (0xFFU)       /*!< Bit mask for EWM_SERV_SERVICE. */
#define BS_EWM_SERV_SERVICE  (8U)          /*!< Bit field size in bits for EWM_SERV_SERVICE. */

/*! @brief Format value for bitfield EWM_SERV_SERVICE. */
#define BF_EWM_SERV_SERVICE(v) ((uint8_t)((uint8_t)(v) << BP_EWM_SERV_SERVICE) & BM_EWM_SERV_SERVICE)

/*! @brief Set the SERVICE field to a new value. */
#define BW_EWM_SERV_SERVICE(x, v) (HW_EWM_SERV_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_EWM_CMPL - Compare Low Register
 ******************************************************************************/

/*!
 * @brief HW_EWM_CMPL - Compare Low Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CMPL register is reset to zero after a CPU reset. This provides no
 * minimum time for the CPU to service the EWM counter. This register can be written
 * only once after a CPU reset. Writing this register more than once generates a
 * bus transfer error.
 */
typedef union _hw_ewm_cmpl
{
    uint8_t U;
    struct _hw_ewm_cmpl_bitfields
    {
        uint8_t COMPAREL : 8;          /*!< [7:0]  */
    } B;
} hw_ewm_cmpl_t;

/*!
 * @name Constants and macros for entire EWM_CMPL register
 */
/*@{*/
#define HW_EWM_CMPL_ADDR(x)      ((uint32_t)(x) + 0x2U)

#define HW_EWM_CMPL(x)           (*(__IO hw_ewm_cmpl_t *) HW_EWM_CMPL_ADDR(x))
#define HW_EWM_CMPL_RD(x)        (HW_EWM_CMPL(x).U)
#define HW_EWM_CMPL_WR(x, v)     (HW_EWM_CMPL(x).U = (v))
#define HW_EWM_CMPL_SET(x, v)    (HW_EWM_CMPL_WR(x, HW_EWM_CMPL_RD(x) |  (v)))
#define HW_EWM_CMPL_CLR(x, v)    (HW_EWM_CMPL_WR(x, HW_EWM_CMPL_RD(x) & ~(v)))
#define HW_EWM_CMPL_TOG(x, v)    (HW_EWM_CMPL_WR(x, HW_EWM_CMPL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual EWM_CMPL bitfields
 */

/*!
 * @name Register EWM_CMPL, field COMPAREL[7:0] (RW)
 *
 * To prevent runaway code from changing this field, software should write to
 * this field after a CPU reset even if the (default) minimum service time is
 * required.
 */
/*@{*/
#define BP_EWM_CMPL_COMPAREL (0U)          /*!< Bit position for EWM_CMPL_COMPAREL. */
#define BM_EWM_CMPL_COMPAREL (0xFFU)       /*!< Bit mask for EWM_CMPL_COMPAREL. */
#define BS_EWM_CMPL_COMPAREL (8U)          /*!< Bit field size in bits for EWM_CMPL_COMPAREL. */

/*! @brief Read current value of the EWM_CMPL_COMPAREL field. */
#define BR_EWM_CMPL_COMPAREL(x) (HW_EWM_CMPL(x).U)

/*! @brief Format value for bitfield EWM_CMPL_COMPAREL. */
#define BF_EWM_CMPL_COMPAREL(v) ((uint8_t)((uint8_t)(v) << BP_EWM_CMPL_COMPAREL) & BM_EWM_CMPL_COMPAREL)

/*! @brief Set the COMPAREL field to a new value. */
#define BW_EWM_CMPL_COMPAREL(x, v) (HW_EWM_CMPL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_EWM_CMPH - Compare High Register
 ******************************************************************************/

/*!
 * @brief HW_EWM_CMPH - Compare High Register (RW)
 *
 * Reset value: 0xFFU
 *
 * The CMPH register is reset to 0xFF after a CPU reset. This provides a maximum
 * of 256 clocks time, for the CPU to service the EWM counter. This register can
 * be written only once after a CPU reset. Writing this register more than once
 * generates a bus transfer error. The valid values for CMPH are up to 0xFE
 * because the EWM counter never expires when CMPH = 0xFF. The expiration happens only
 * if EWM counter is greater than CMPH.
 */
typedef union _hw_ewm_cmph
{
    uint8_t U;
    struct _hw_ewm_cmph_bitfields
    {
        uint8_t COMPAREH : 8;          /*!< [7:0]  */
    } B;
} hw_ewm_cmph_t;

/*!
 * @name Constants and macros for entire EWM_CMPH register
 */
/*@{*/
#define HW_EWM_CMPH_ADDR(x)      ((uint32_t)(x) + 0x3U)

#define HW_EWM_CMPH(x)           (*(__IO hw_ewm_cmph_t *) HW_EWM_CMPH_ADDR(x))
#define HW_EWM_CMPH_RD(x)        (HW_EWM_CMPH(x).U)
#define HW_EWM_CMPH_WR(x, v)     (HW_EWM_CMPH(x).U = (v))
#define HW_EWM_CMPH_SET(x, v)    (HW_EWM_CMPH_WR(x, HW_EWM_CMPH_RD(x) |  (v)))
#define HW_EWM_CMPH_CLR(x, v)    (HW_EWM_CMPH_WR(x, HW_EWM_CMPH_RD(x) & ~(v)))
#define HW_EWM_CMPH_TOG(x, v)    (HW_EWM_CMPH_WR(x, HW_EWM_CMPH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual EWM_CMPH bitfields
 */

/*!
 * @name Register EWM_CMPH, field COMPAREH[7:0] (RW)
 *
 * To prevent runaway code from changing this field, software should write to
 * this field after a CPU reset even if the (default) maximum service time is
 * required.
 */
/*@{*/
#define BP_EWM_CMPH_COMPAREH (0U)          /*!< Bit position for EWM_CMPH_COMPAREH. */
#define BM_EWM_CMPH_COMPAREH (0xFFU)       /*!< Bit mask for EWM_CMPH_COMPAREH. */
#define BS_EWM_CMPH_COMPAREH (8U)          /*!< Bit field size in bits for EWM_CMPH_COMPAREH. */

/*! @brief Read current value of the EWM_CMPH_COMPAREH field. */
#define BR_EWM_CMPH_COMPAREH(x) (HW_EWM_CMPH(x).U)

/*! @brief Format value for bitfield EWM_CMPH_COMPAREH. */
#define BF_EWM_CMPH_COMPAREH(v) ((uint8_t)((uint8_t)(v) << BP_EWM_CMPH_COMPAREH) & BM_EWM_CMPH_COMPAREH)

/*! @brief Set the COMPAREH field to a new value. */
#define BW_EWM_CMPH_COMPAREH(x, v) (HW_EWM_CMPH_WR(x, v))
/*@}*/

/*******************************************************************************
 * hw_ewm_t - module struct
 ******************************************************************************/
/*!
 * @brief All EWM module registers.
 */
#pragma pack(1)
typedef struct _hw_ewm
{
    __IO hw_ewm_ctrl_t CTRL;               /*!< [0x0] Control Register */
    __O hw_ewm_serv_t SERV;                /*!< [0x1] Service Register */
    __IO hw_ewm_cmpl_t CMPL;               /*!< [0x2] Compare Low Register */
    __IO hw_ewm_cmph_t CMPH;               /*!< [0x3] Compare High Register */
} hw_ewm_t;
#pragma pack()

/*! @brief Macro to access all EWM registers. */
/*! @param x EWM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_EWM_REGS(EWM_BASE)</code>. */
#define HW_EWM_REGS(x) (*(hw_ewm_t *)(x))

/*
 * MK64F12 FB
 *
 * FlexBus external bus interface
 *
 * Registers defined in this header file:
 * - HW_FB_CSARn - Chip Select Address Register
 * - HW_FB_CSMRn - Chip Select Mask Register
 * - HW_FB_CSCRn - Chip Select Control Register
 * - HW_FB_CSPMCR - Chip Select port Multiplexing Control Register
 *
 * - hw_fb_t - Struct containing all module registers.
 */

#define HW_FB_INSTANCE_COUNT (1U) /*!< Number of instances of the FB module. */
#define HW_FB (0U) /*!< Instance number for FB. */

/*******************************************************************************
 * HW_FB_CSARn - Chip Select Address Register
 ******************************************************************************/

/*!
 * @brief HW_FB_CSARn - Chip Select Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies the associated chip-select's base address.
 */
typedef union _hw_fb_csarn
{
    uint32_t U;
    struct _hw_fb_csarn_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t BA : 16;              /*!< [31:16] Base Address */
    } B;
} hw_fb_csarn_t;

/*!
 * @name Constants and macros for entire FB_CSARn register
 */
/*@{*/
#define HW_FB_CSARn_COUNT (6U)

#define HW_FB_CSARn_ADDR(x, n)   ((uint32_t)(x) + 0x0U + (0xCU * (n)))

#define HW_FB_CSARn(x, n)        (*(__IO hw_fb_csarn_t *) HW_FB_CSARn_ADDR(x, n))
#define HW_FB_CSARn_RD(x, n)     (HW_FB_CSARn(x, n).U)
#define HW_FB_CSARn_WR(x, n, v)  (HW_FB_CSARn(x, n).U = (v))
#define HW_FB_CSARn_SET(x, n, v) (HW_FB_CSARn_WR(x, n, HW_FB_CSARn_RD(x, n) |  (v)))
#define HW_FB_CSARn_CLR(x, n, v) (HW_FB_CSARn_WR(x, n, HW_FB_CSARn_RD(x, n) & ~(v)))
#define HW_FB_CSARn_TOG(x, n, v) (HW_FB_CSARn_WR(x, n, HW_FB_CSARn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FB_CSARn bitfields
 */

/*!
 * @name Register FB_CSARn, field BA[31:16] (RW)
 *
 * Defines the base address for memory dedicated to the associated chip-select.
 * BA is compared to bits 31-16 on the internal address bus to determine if the
 * associated chip-select's memory is being accessed. Because the FlexBus module
 * is one of the slaves connected to the crossbar switch, it is only accessible
 * within a certain memory range. See the chip memory map for the applicable
 * FlexBus "expansion" address range for which the chip-selects can be active. Set the
 * CSARn and CSMRn registers appropriately before accessing this region.
 */
/*@{*/
#define BP_FB_CSARn_BA       (16U)         /*!< Bit position for FB_CSARn_BA. */
#define BM_FB_CSARn_BA       (0xFFFF0000U) /*!< Bit mask for FB_CSARn_BA. */
#define BS_FB_CSARn_BA       (16U)         /*!< Bit field size in bits for FB_CSARn_BA. */

/*! @brief Read current value of the FB_CSARn_BA field. */
#define BR_FB_CSARn_BA(x, n) (HW_FB_CSARn(x, n).B.BA)

/*! @brief Format value for bitfield FB_CSARn_BA. */
#define BF_FB_CSARn_BA(v)    ((uint32_t)((uint32_t)(v) << BP_FB_CSARn_BA) & BM_FB_CSARn_BA)

/*! @brief Set the BA field to a new value. */
#define BW_FB_CSARn_BA(x, n, v) (HW_FB_CSARn_WR(x, n, (HW_FB_CSARn_RD(x, n) & ~BM_FB_CSARn_BA) | BF_FB_CSARn_BA(v)))
/*@}*/
/*******************************************************************************
 * HW_FB_CSMRn - Chip Select Mask Register
 ******************************************************************************/

/*!
 * @brief HW_FB_CSMRn - Chip Select Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies the address mask and allowable access types for the associated
 * chip-select.
 */
typedef union _hw_fb_csmrn
{
    uint32_t U;
    struct _hw_fb_csmrn_bitfields
    {
        uint32_t V : 1;                /*!< [0] Valid */
        uint32_t RESERVED0 : 7;        /*!< [7:1]  */
        uint32_t WP : 1;               /*!< [8] Write Protect */
        uint32_t RESERVED1 : 7;        /*!< [15:9]  */
        uint32_t BAM : 16;             /*!< [31:16] Base Address Mask */
    } B;
} hw_fb_csmrn_t;

/*!
 * @name Constants and macros for entire FB_CSMRn register
 */
/*@{*/
#define HW_FB_CSMRn_COUNT (6U)

#define HW_FB_CSMRn_ADDR(x, n)   ((uint32_t)(x) + 0x4U + (0xCU * (n)))

#define HW_FB_CSMRn(x, n)        (*(__IO hw_fb_csmrn_t *) HW_FB_CSMRn_ADDR(x, n))
#define HW_FB_CSMRn_RD(x, n)     (HW_FB_CSMRn(x, n).U)
#define HW_FB_CSMRn_WR(x, n, v)  (HW_FB_CSMRn(x, n).U = (v))
#define HW_FB_CSMRn_SET(x, n, v) (HW_FB_CSMRn_WR(x, n, HW_FB_CSMRn_RD(x, n) |  (v)))
#define HW_FB_CSMRn_CLR(x, n, v) (HW_FB_CSMRn_WR(x, n, HW_FB_CSMRn_RD(x, n) & ~(v)))
#define HW_FB_CSMRn_TOG(x, n, v) (HW_FB_CSMRn_WR(x, n, HW_FB_CSMRn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FB_CSMRn bitfields
 */

/*!
 * @name Register FB_CSMRn, field V[0] (RW)
 *
 * Specifies whether the corresponding CSAR, CSMR, and CSCR contents are valid.
 * Programmed chip-selects do not assert until the V bit is 1b (except for
 * FB_CS0, which acts as the global chip-select). At reset, FB_CS0 will fire for any
 * access to the FlexBus memory region. CSMR0[V] must be set as part of the chip
 * select initialization sequence to allow other chip selects to function as
 * programmed.
 *
 * Values:
 * - 0 - Chip-select is invalid.
 * - 1 - Chip-select is valid.
 */
/*@{*/
#define BP_FB_CSMRn_V        (0U)          /*!< Bit position for FB_CSMRn_V. */
#define BM_FB_CSMRn_V        (0x00000001U) /*!< Bit mask for FB_CSMRn_V. */
#define BS_FB_CSMRn_V        (1U)          /*!< Bit field size in bits for FB_CSMRn_V. */

/*! @brief Read current value of the FB_CSMRn_V field. */
#define BR_FB_CSMRn_V(x, n)  (BITBAND_ACCESS32(HW_FB_CSMRn_ADDR(x, n), BP_FB_CSMRn_V))

/*! @brief Format value for bitfield FB_CSMRn_V. */
#define BF_FB_CSMRn_V(v)     ((uint32_t)((uint32_t)(v) << BP_FB_CSMRn_V) & BM_FB_CSMRn_V)

/*! @brief Set the V field to a new value. */
#define BW_FB_CSMRn_V(x, n, v) (BITBAND_ACCESS32(HW_FB_CSMRn_ADDR(x, n), BP_FB_CSMRn_V) = (v))
/*@}*/

/*!
 * @name Register FB_CSMRn, field WP[8] (RW)
 *
 * Controls write accesses to the address range in the corresponding CSAR.
 *
 * Values:
 * - 0 - Write accesses are allowed.
 * - 1 - Write accesses are not allowed. Attempting to write to the range of
 *     addresses for which the WP bit is set results in a bus error termination of
 *     the internal cycle and no external cycle.
 */
/*@{*/
#define BP_FB_CSMRn_WP       (8U)          /*!< Bit position for FB_CSMRn_WP. */
#define BM_FB_CSMRn_WP       (0x00000100U) /*!< Bit mask for FB_CSMRn_WP. */
#define BS_FB_CSMRn_WP       (1U)          /*!< Bit field size in bits for FB_CSMRn_WP. */

/*! @brief Read current value of the FB_CSMRn_WP field. */
#define BR_FB_CSMRn_WP(x, n) (BITBAND_ACCESS32(HW_FB_CSMRn_ADDR(x, n), BP_FB_CSMRn_WP))

/*! @brief Format value for bitfield FB_CSMRn_WP. */
#define BF_FB_CSMRn_WP(v)    ((uint32_t)((uint32_t)(v) << BP_FB_CSMRn_WP) & BM_FB_CSMRn_WP)

/*! @brief Set the WP field to a new value. */
#define BW_FB_CSMRn_WP(x, n, v) (BITBAND_ACCESS32(HW_FB_CSMRn_ADDR(x, n), BP_FB_CSMRn_WP) = (v))
/*@}*/

/*!
 * @name Register FB_CSMRn, field BAM[31:16] (RW)
 *
 * Defines the associated chip-select's block size by masking address bits.
 *
 * Values:
 * - 0 - The corresponding address bit in CSAR is used in the chip-select decode.
 * - 1 - The corresponding address bit in CSAR is a don't care in the
 *     chip-select decode.
 */
/*@{*/
#define BP_FB_CSMRn_BAM      (16U)         /*!< Bit position for FB_CSMRn_BAM. */
#define BM_FB_CSMRn_BAM      (0xFFFF0000U) /*!< Bit mask for FB_CSMRn_BAM. */
#define BS_FB_CSMRn_BAM      (16U)         /*!< Bit field size in bits for FB_CSMRn_BAM. */

/*! @brief Read current value of the FB_CSMRn_BAM field. */
#define BR_FB_CSMRn_BAM(x, n) (HW_FB_CSMRn(x, n).B.BAM)

/*! @brief Format value for bitfield FB_CSMRn_BAM. */
#define BF_FB_CSMRn_BAM(v)   ((uint32_t)((uint32_t)(v) << BP_FB_CSMRn_BAM) & BM_FB_CSMRn_BAM)

/*! @brief Set the BAM field to a new value. */
#define BW_FB_CSMRn_BAM(x, n, v) (HW_FB_CSMRn_WR(x, n, (HW_FB_CSMRn_RD(x, n) & ~BM_FB_CSMRn_BAM) | BF_FB_CSMRn_BAM(v)))
/*@}*/
/*******************************************************************************
 * HW_FB_CSCRn - Chip Select Control Register
 ******************************************************************************/

/*!
 * @brief HW_FB_CSCRn - Chip Select Control Register (RW)
 *
 * Reset value: 0x003FFC00U
 *
 * Controls the auto-acknowledge, address setup and hold times, port size, burst
 * capability, and number of wait states for the associated chip select. To
 * support the global chip-select (FB_CS0), the CSCR0 reset values differ from the
 * other CSCRs. The reset value of CSCR0 is as follows: Bits 31-24 are 0b Bit 23-3
 * are chip-dependent Bits 3-0 are 0b See the chip configuration details for your
 * particular chip for information on the exact CSCR0 reset value.
 */
typedef union _hw_fb_cscrn
{
    uint32_t U;
    struct _hw_fb_cscrn_bitfields
    {
        uint32_t RESERVED0 : 3;        /*!< [2:0]  */
        uint32_t BSTW : 1;             /*!< [3] Burst-Write Enable */
        uint32_t BSTR : 1;             /*!< [4] Burst-Read Enable */
        uint32_t BEM : 1;              /*!< [5] Byte-Enable Mode */
        uint32_t PS : 2;               /*!< [7:6] Port Size */
        uint32_t AA : 1;               /*!< [8] Auto-Acknowledge Enable */
        uint32_t BLS : 1;              /*!< [9] Byte-Lane Shift */
        uint32_t WS : 6;               /*!< [15:10] Wait States */
        uint32_t WRAH : 2;             /*!< [17:16] Write Address Hold or Deselect */
        uint32_t RDAH : 2;             /*!< [19:18] Read Address Hold or Deselect */
        uint32_t ASET : 2;             /*!< [21:20] Address Setup */
        uint32_t EXTS : 1;             /*!< [22]  */
        uint32_t SWSEN : 1;            /*!< [23] Secondary Wait State Enable */
        uint32_t RESERVED1 : 2;        /*!< [25:24]  */
        uint32_t SWS : 6;              /*!< [31:26] Secondary Wait States */
    } B;
} hw_fb_cscrn_t;

/*!
 * @name Constants and macros for entire FB_CSCRn register
 */
/*@{*/
#define HW_FB_CSCRn_COUNT (6U)

#define HW_FB_CSCRn_ADDR(x, n)   ((uint32_t)(x) + 0x8U + (0xCU * (n)))

#define HW_FB_CSCRn(x, n)        (*(__IO hw_fb_cscrn_t *) HW_FB_CSCRn_ADDR(x, n))
#define HW_FB_CSCRn_RD(x, n)     (HW_FB_CSCRn(x, n).U)
#define HW_FB_CSCRn_WR(x, n, v)  (HW_FB_CSCRn(x, n).U = (v))
#define HW_FB_CSCRn_SET(x, n, v) (HW_FB_CSCRn_WR(x, n, HW_FB_CSCRn_RD(x, n) |  (v)))
#define HW_FB_CSCRn_CLR(x, n, v) (HW_FB_CSCRn_WR(x, n, HW_FB_CSCRn_RD(x, n) & ~(v)))
#define HW_FB_CSCRn_TOG(x, n, v) (HW_FB_CSCRn_WR(x, n, HW_FB_CSCRn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FB_CSCRn bitfields
 */

/*!
 * @name Register FB_CSCRn, field BSTW[3] (RW)
 *
 * Specifies whether burst writes are enabled for memory associated with each
 * chip select.
 *
 * Values:
 * - 0 - Disabled. Data exceeding the specified port size is broken into
 *     individual, port-sized, non-burst writes. For example, a 32-bit write to an 8-bit
 *     port takes four byte writes.
 * - 1 - Enabled. Enables burst write of data larger than the specified port
 *     size, including 32-bit writes to 8- and 16-bit ports, 16-bit writes to 8-bit
 *     ports, and line writes to 8-, 16-, and 32-bit ports.
 */
/*@{*/
#define BP_FB_CSCRn_BSTW     (3U)          /*!< Bit position for FB_CSCRn_BSTW. */
#define BM_FB_CSCRn_BSTW     (0x00000008U) /*!< Bit mask for FB_CSCRn_BSTW. */
#define BS_FB_CSCRn_BSTW     (1U)          /*!< Bit field size in bits for FB_CSCRn_BSTW. */

/*! @brief Read current value of the FB_CSCRn_BSTW field. */
#define BR_FB_CSCRn_BSTW(x, n) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_BSTW))

/*! @brief Format value for bitfield FB_CSCRn_BSTW. */
#define BF_FB_CSCRn_BSTW(v)  ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_BSTW) & BM_FB_CSCRn_BSTW)

/*! @brief Set the BSTW field to a new value. */
#define BW_FB_CSCRn_BSTW(x, n, v) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_BSTW) = (v))
/*@}*/

/*!
 * @name Register FB_CSCRn, field BSTR[4] (RW)
 *
 * Specifies whether burst reads are enabled for memory associated with each
 * chip select.
 *
 * Values:
 * - 0 - Disabled. Data exceeding the specified port size is broken into
 *     individual, port-sized, non-burst reads. For example, a 32-bit read from an 8-bit
 *     port is broken into four 8-bit reads.
 * - 1 - Enabled. Enables data burst reads larger than the specified port size,
 *     including 32-bit reads from 8- and 16-bit ports, 16-bit reads from 8-bit
 *     ports, and line reads from 8-, 16-, and 32-bit ports.
 */
/*@{*/
#define BP_FB_CSCRn_BSTR     (4U)          /*!< Bit position for FB_CSCRn_BSTR. */
#define BM_FB_CSCRn_BSTR     (0x00000010U) /*!< Bit mask for FB_CSCRn_BSTR. */
#define BS_FB_CSCRn_BSTR     (1U)          /*!< Bit field size in bits for FB_CSCRn_BSTR. */

/*! @brief Read current value of the FB_CSCRn_BSTR field. */
#define BR_FB_CSCRn_BSTR(x, n) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_BSTR))

/*! @brief Format value for bitfield FB_CSCRn_BSTR. */
#define BF_FB_CSCRn_BSTR(v)  ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_BSTR) & BM_FB_CSCRn_BSTR)

/*! @brief Set the BSTR field to a new value. */
#define BW_FB_CSCRn_BSTR(x, n, v) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_BSTR) = (v))
/*@}*/

/*!
 * @name Register FB_CSCRn, field BEM[5] (RW)
 *
 * Specifies whether the corresponding FB_BE is asserted for read accesses.
 * Certain memories have byte enables that must be asserted during reads and writes.
 * Write 1b to the BEM bit in the relevant CSCR to provide the appropriate mode
 * of byte enable support for these SRAMs.
 *
 * Values:
 * - 0 - FB_BE is asserted for data write only.
 * - 1 - FB_BE is asserted for data read and write accesses.
 */
/*@{*/
#define BP_FB_CSCRn_BEM      (5U)          /*!< Bit position for FB_CSCRn_BEM. */
#define BM_FB_CSCRn_BEM      (0x00000020U) /*!< Bit mask for FB_CSCRn_BEM. */
#define BS_FB_CSCRn_BEM      (1U)          /*!< Bit field size in bits for FB_CSCRn_BEM. */

/*! @brief Read current value of the FB_CSCRn_BEM field. */
#define BR_FB_CSCRn_BEM(x, n) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_BEM))

/*! @brief Format value for bitfield FB_CSCRn_BEM. */
#define BF_FB_CSCRn_BEM(v)   ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_BEM) & BM_FB_CSCRn_BEM)

/*! @brief Set the BEM field to a new value. */
#define BW_FB_CSCRn_BEM(x, n, v) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_BEM) = (v))
/*@}*/

/*!
 * @name Register FB_CSCRn, field PS[7:6] (RW)
 *
 * Specifies the data port width of the associated chip-select, and determines
 * where data is driven during write cycles and where data is sampled during read
 * cycles.
 *
 * Values:
 * - 00 - 32-bit port size. Valid data is sampled and driven on FB_D[31:0].
 * - 01 - 8-bit port size. Valid data is sampled and driven on FB_D[31:24] when
 *     BLS is 0b, or FB_D[7:0] when BLS is 1b.
 */
/*@{*/
#define BP_FB_CSCRn_PS       (6U)          /*!< Bit position for FB_CSCRn_PS. */
#define BM_FB_CSCRn_PS       (0x000000C0U) /*!< Bit mask for FB_CSCRn_PS. */
#define BS_FB_CSCRn_PS       (2U)          /*!< Bit field size in bits for FB_CSCRn_PS. */

/*! @brief Read current value of the FB_CSCRn_PS field. */
#define BR_FB_CSCRn_PS(x, n) (HW_FB_CSCRn(x, n).B.PS)

/*! @brief Format value for bitfield FB_CSCRn_PS. */
#define BF_FB_CSCRn_PS(v)    ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_PS) & BM_FB_CSCRn_PS)

/*! @brief Set the PS field to a new value. */
#define BW_FB_CSCRn_PS(x, n, v) (HW_FB_CSCRn_WR(x, n, (HW_FB_CSCRn_RD(x, n) & ~BM_FB_CSCRn_PS) | BF_FB_CSCRn_PS(v)))
/*@}*/

/*!
 * @name Register FB_CSCRn, field AA[8] (RW)
 *
 * Asserts the internal transfer acknowledge for accesses specified by the
 * chip-select address. If AA is 1b for a corresponding FB_CSn and the external system
 * asserts an external FB_TA before the wait-state countdown asserts the
 * internal FB_TA, the cycle is terminated. Burst cycles increment the address bus
 * between each internal termination. This field must be 1b if CSPMCR disables FB_TA.
 *
 * Values:
 * - 0 - Disabled. No internal transfer acknowledge is asserted and the cycle is
 *     terminated externally.
 * - 1 - Enabled. Internal transfer acknowledge is asserted as specified by WS.
 */
/*@{*/
#define BP_FB_CSCRn_AA       (8U)          /*!< Bit position for FB_CSCRn_AA. */
#define BM_FB_CSCRn_AA       (0x00000100U) /*!< Bit mask for FB_CSCRn_AA. */
#define BS_FB_CSCRn_AA       (1U)          /*!< Bit field size in bits for FB_CSCRn_AA. */

/*! @brief Read current value of the FB_CSCRn_AA field. */
#define BR_FB_CSCRn_AA(x, n) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_AA))

/*! @brief Format value for bitfield FB_CSCRn_AA. */
#define BF_FB_CSCRn_AA(v)    ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_AA) & BM_FB_CSCRn_AA)

/*! @brief Set the AA field to a new value. */
#define BW_FB_CSCRn_AA(x, n, v) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_AA) = (v))
/*@}*/

/*!
 * @name Register FB_CSCRn, field BLS[9] (RW)
 *
 * Specifies if data on FB_AD appears left-aligned or right-aligned during the
 * data phase of a FlexBus access.
 *
 * Values:
 * - 0 - Not shifted. Data is left-aligned on FB_AD.
 * - 1 - Shifted. Data is right-aligned on FB_AD.
 */
/*@{*/
#define BP_FB_CSCRn_BLS      (9U)          /*!< Bit position for FB_CSCRn_BLS. */
#define BM_FB_CSCRn_BLS      (0x00000200U) /*!< Bit mask for FB_CSCRn_BLS. */
#define BS_FB_CSCRn_BLS      (1U)          /*!< Bit field size in bits for FB_CSCRn_BLS. */

/*! @brief Read current value of the FB_CSCRn_BLS field. */
#define BR_FB_CSCRn_BLS(x, n) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_BLS))

/*! @brief Format value for bitfield FB_CSCRn_BLS. */
#define BF_FB_CSCRn_BLS(v)   ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_BLS) & BM_FB_CSCRn_BLS)

/*! @brief Set the BLS field to a new value. */
#define BW_FB_CSCRn_BLS(x, n, v) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_BLS) = (v))
/*@}*/

/*!
 * @name Register FB_CSCRn, field WS[15:10] (RW)
 *
 * Specifies the number of wait states inserted after FlexBus asserts the
 * associated chip-select and before an internal transfer acknowledge is generated (WS
 * = 00h inserts 0 wait states, ..., WS = 3Fh inserts 63 wait states).
 */
/*@{*/
#define BP_FB_CSCRn_WS       (10U)         /*!< Bit position for FB_CSCRn_WS. */
#define BM_FB_CSCRn_WS       (0x0000FC00U) /*!< Bit mask for FB_CSCRn_WS. */
#define BS_FB_CSCRn_WS       (6U)          /*!< Bit field size in bits for FB_CSCRn_WS. */

/*! @brief Read current value of the FB_CSCRn_WS field. */
#define BR_FB_CSCRn_WS(x, n) (HW_FB_CSCRn(x, n).B.WS)

/*! @brief Format value for bitfield FB_CSCRn_WS. */
#define BF_FB_CSCRn_WS(v)    ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_WS) & BM_FB_CSCRn_WS)

/*! @brief Set the WS field to a new value. */
#define BW_FB_CSCRn_WS(x, n, v) (HW_FB_CSCRn_WR(x, n, (HW_FB_CSCRn_RD(x, n) & ~BM_FB_CSCRn_WS) | BF_FB_CSCRn_WS(v)))
/*@}*/

/*!
 * @name Register FB_CSCRn, field WRAH[17:16] (RW)
 *
 * Controls the address, data, and attribute hold time after the termination of
 * a write cycle that hits in the associated chip-select's address space. The
 * hold time applies only at the end of a transfer. Therefore, during a burst
 * transfer or a transfer to a port size smaller than the transfer size, the hold time
 * is only added after the last bus cycle.
 *
 * Values:
 * - 00 - 1 cycle (default for all but FB_CS0 )
 * - 01 - 2 cycles
 * - 10 - 3 cycles
 * - 11 - 4 cycles (default for FB_CS0 )
 */
/*@{*/
#define BP_FB_CSCRn_WRAH     (16U)         /*!< Bit position for FB_CSCRn_WRAH. */
#define BM_FB_CSCRn_WRAH     (0x00030000U) /*!< Bit mask for FB_CSCRn_WRAH. */
#define BS_FB_CSCRn_WRAH     (2U)          /*!< Bit field size in bits for FB_CSCRn_WRAH. */

/*! @brief Read current value of the FB_CSCRn_WRAH field. */
#define BR_FB_CSCRn_WRAH(x, n) (HW_FB_CSCRn(x, n).B.WRAH)

/*! @brief Format value for bitfield FB_CSCRn_WRAH. */
#define BF_FB_CSCRn_WRAH(v)  ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_WRAH) & BM_FB_CSCRn_WRAH)

/*! @brief Set the WRAH field to a new value. */
#define BW_FB_CSCRn_WRAH(x, n, v) (HW_FB_CSCRn_WR(x, n, (HW_FB_CSCRn_RD(x, n) & ~BM_FB_CSCRn_WRAH) | BF_FB_CSCRn_WRAH(v)))
/*@}*/

/*!
 * @name Register FB_CSCRn, field RDAH[19:18] (RW)
 *
 * Controls the address and attribute hold time after the termination during a
 * read cycle that hits in the associated chip-select's address space. The hold
 * time applies only at the end of a transfer. Therefore, during a burst transfer
 * or a transfer to a port size smaller than the transfer size, the hold time is
 * only added after the last bus cycle. The number of cycles the address and
 * attributes are held after FB_CSn deassertion depends on the value of the AA bit.
 *
 * Values:
 * - 00 - When AA is 0b, 1 cycle. When AA is 1b, 0 cycles.
 * - 01 - When AA is 0b, 2 cycles. When AA is 1b, 1 cycle.
 * - 10 - When AA is 0b, 3 cycles. When AA is 1b, 2 cycles.
 * - 11 - When AA is 0b, 4 cycles. When AA is 1b, 3 cycles.
 */
/*@{*/
#define BP_FB_CSCRn_RDAH     (18U)         /*!< Bit position for FB_CSCRn_RDAH. */
#define BM_FB_CSCRn_RDAH     (0x000C0000U) /*!< Bit mask for FB_CSCRn_RDAH. */
#define BS_FB_CSCRn_RDAH     (2U)          /*!< Bit field size in bits for FB_CSCRn_RDAH. */

/*! @brief Read current value of the FB_CSCRn_RDAH field. */
#define BR_FB_CSCRn_RDAH(x, n) (HW_FB_CSCRn(x, n).B.RDAH)

/*! @brief Format value for bitfield FB_CSCRn_RDAH. */
#define BF_FB_CSCRn_RDAH(v)  ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_RDAH) & BM_FB_CSCRn_RDAH)

/*! @brief Set the RDAH field to a new value. */
#define BW_FB_CSCRn_RDAH(x, n, v) (HW_FB_CSCRn_WR(x, n, (HW_FB_CSCRn_RD(x, n) & ~BM_FB_CSCRn_RDAH) | BF_FB_CSCRn_RDAH(v)))
/*@}*/

/*!
 * @name Register FB_CSCRn, field ASET[21:20] (RW)
 *
 * Controls when the chip-select is asserted with respect to assertion of a
 * valid address and attributes.
 *
 * Values:
 * - 00 - Assert FB_CSn on the first rising clock edge after the address is
 *     asserted (default for all but FB_CS0 ).
 * - 01 - Assert FB_CSn on the second rising clock edge after the address is
 *     asserted.
 * - 10 - Assert FB_CSn on the third rising clock edge after the address is
 *     asserted.
 * - 11 - Assert FB_CSn on the fourth rising clock edge after the address is
 *     asserted (default for FB_CS0 ).
 */
/*@{*/
#define BP_FB_CSCRn_ASET     (20U)         /*!< Bit position for FB_CSCRn_ASET. */
#define BM_FB_CSCRn_ASET     (0x00300000U) /*!< Bit mask for FB_CSCRn_ASET. */
#define BS_FB_CSCRn_ASET     (2U)          /*!< Bit field size in bits for FB_CSCRn_ASET. */

/*! @brief Read current value of the FB_CSCRn_ASET field. */
#define BR_FB_CSCRn_ASET(x, n) (HW_FB_CSCRn(x, n).B.ASET)

/*! @brief Format value for bitfield FB_CSCRn_ASET. */
#define BF_FB_CSCRn_ASET(v)  ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_ASET) & BM_FB_CSCRn_ASET)

/*! @brief Set the ASET field to a new value. */
#define BW_FB_CSCRn_ASET(x, n, v) (HW_FB_CSCRn_WR(x, n, (HW_FB_CSCRn_RD(x, n) & ~BM_FB_CSCRn_ASET) | BF_FB_CSCRn_ASET(v)))
/*@}*/

/*!
 * @name Register FB_CSCRn, field EXTS[22] (RW)
 *
 * Extended Transfer Start/Extended Address Latch Enable Controls how long FB_TS
 * /FB_ALE is asserted.
 *
 * Values:
 * - 0 - Disabled. FB_TS /FB_ALE asserts for one bus clock cycle.
 * - 1 - Enabled. FB_TS /FB_ALE remains asserted until the first positive clock
 *     edge after FB_CSn asserts.
 */
/*@{*/
#define BP_FB_CSCRn_EXTS     (22U)         /*!< Bit position for FB_CSCRn_EXTS. */
#define BM_FB_CSCRn_EXTS     (0x00400000U) /*!< Bit mask for FB_CSCRn_EXTS. */
#define BS_FB_CSCRn_EXTS     (1U)          /*!< Bit field size in bits for FB_CSCRn_EXTS. */

/*! @brief Read current value of the FB_CSCRn_EXTS field. */
#define BR_FB_CSCRn_EXTS(x, n) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_EXTS))

/*! @brief Format value for bitfield FB_CSCRn_EXTS. */
#define BF_FB_CSCRn_EXTS(v)  ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_EXTS) & BM_FB_CSCRn_EXTS)

/*! @brief Set the EXTS field to a new value. */
#define BW_FB_CSCRn_EXTS(x, n, v) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_EXTS) = (v))
/*@}*/

/*!
 * @name Register FB_CSCRn, field SWSEN[23] (RW)
 *
 * Values:
 * - 0 - Disabled. A number of wait states (specified by WS) are inserted before
 *     an internal transfer acknowledge is generated for all transfers.
 * - 1 - Enabled. A number of wait states (specified by SWS) are inserted before
 *     an internal transfer acknowledge is generated for burst transfer
 *     secondary terminations.
 */
/*@{*/
#define BP_FB_CSCRn_SWSEN    (23U)         /*!< Bit position for FB_CSCRn_SWSEN. */
#define BM_FB_CSCRn_SWSEN    (0x00800000U) /*!< Bit mask for FB_CSCRn_SWSEN. */
#define BS_FB_CSCRn_SWSEN    (1U)          /*!< Bit field size in bits for FB_CSCRn_SWSEN. */

/*! @brief Read current value of the FB_CSCRn_SWSEN field. */
#define BR_FB_CSCRn_SWSEN(x, n) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_SWSEN))

/*! @brief Format value for bitfield FB_CSCRn_SWSEN. */
#define BF_FB_CSCRn_SWSEN(v) ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_SWSEN) & BM_FB_CSCRn_SWSEN)

/*! @brief Set the SWSEN field to a new value. */
#define BW_FB_CSCRn_SWSEN(x, n, v) (BITBAND_ACCESS32(HW_FB_CSCRn_ADDR(x, n), BP_FB_CSCRn_SWSEN) = (v))
/*@}*/

/*!
 * @name Register FB_CSCRn, field SWS[31:26] (RW)
 *
 * Used only when the SWSEN bit is 1b. Specifies the number of wait states
 * inserted before an internal transfer acknowledge is generated for a burst transfer
 * (except for the first termination, which is controlled by WS).
 */
/*@{*/
#define BP_FB_CSCRn_SWS      (26U)         /*!< Bit position for FB_CSCRn_SWS. */
#define BM_FB_CSCRn_SWS      (0xFC000000U) /*!< Bit mask for FB_CSCRn_SWS. */
#define BS_FB_CSCRn_SWS      (6U)          /*!< Bit field size in bits for FB_CSCRn_SWS. */

/*! @brief Read current value of the FB_CSCRn_SWS field. */
#define BR_FB_CSCRn_SWS(x, n) (HW_FB_CSCRn(x, n).B.SWS)

/*! @brief Format value for bitfield FB_CSCRn_SWS. */
#define BF_FB_CSCRn_SWS(v)   ((uint32_t)((uint32_t)(v) << BP_FB_CSCRn_SWS) & BM_FB_CSCRn_SWS)

/*! @brief Set the SWS field to a new value. */
#define BW_FB_CSCRn_SWS(x, n, v) (HW_FB_CSCRn_WR(x, n, (HW_FB_CSCRn_RD(x, n) & ~BM_FB_CSCRn_SWS) | BF_FB_CSCRn_SWS(v)))
/*@}*/

/*******************************************************************************
 * HW_FB_CSPMCR - Chip Select port Multiplexing Control Register
 ******************************************************************************/

/*!
 * @brief HW_FB_CSPMCR - Chip Select port Multiplexing Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Controls the multiplexing of the FlexBus signals. A bus error occurs when you
 * do any of the following: Write to a reserved address Write to a reserved
 * field in this register, or Access this register using a size other than 32 bits.
 */
typedef union _hw_fb_cspmcr
{
    uint32_t U;
    struct _hw_fb_cspmcr_bitfields
    {
        uint32_t RESERVED0 : 12;       /*!< [11:0]  */
        uint32_t GROUP5 : 4;           /*!< [15:12] FlexBus Signal Group 5 Multiplex
                                        * control */
        uint32_t GROUP4 : 4;           /*!< [19:16] FlexBus Signal Group 4 Multiplex
                                        * control */
        uint32_t GROUP3 : 4;           /*!< [23:20] FlexBus Signal Group 3 Multiplex
                                        * control */
        uint32_t GROUP2 : 4;           /*!< [27:24] FlexBus Signal Group 2 Multiplex
                                        * control */
        uint32_t GROUP1 : 4;           /*!< [31:28] FlexBus Signal Group 1 Multiplex
                                        * control */
    } B;
} hw_fb_cspmcr_t;

/*!
 * @name Constants and macros for entire FB_CSPMCR register
 */
/*@{*/
#define HW_FB_CSPMCR_ADDR(x)     ((uint32_t)(x) + 0x60U)

#define HW_FB_CSPMCR(x)          (*(__IO hw_fb_cspmcr_t *) HW_FB_CSPMCR_ADDR(x))
#define HW_FB_CSPMCR_RD(x)       (HW_FB_CSPMCR(x).U)
#define HW_FB_CSPMCR_WR(x, v)    (HW_FB_CSPMCR(x).U = (v))
#define HW_FB_CSPMCR_SET(x, v)   (HW_FB_CSPMCR_WR(x, HW_FB_CSPMCR_RD(x) |  (v)))
#define HW_FB_CSPMCR_CLR(x, v)   (HW_FB_CSPMCR_WR(x, HW_FB_CSPMCR_RD(x) & ~(v)))
#define HW_FB_CSPMCR_TOG(x, v)   (HW_FB_CSPMCR_WR(x, HW_FB_CSPMCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FB_CSPMCR bitfields
 */

/*!
 * @name Register FB_CSPMCR, field GROUP5[15:12] (RW)
 *
 * Controls the multiplexing of the FB_TA , FB_CS3 , and FB_BE_7_0 signals. When
 * GROUP5 is not 0000b, you must write 1b to the CSCR[AA] bit. Otherwise, the
 * bus hangs during a transfer.
 *
 * Values:
 * - 0000 - FB_TA
 * - 0001 - FB_CS3 . You must also write 1b to CSCR[AA].
 * - 0010 - FB_BE_7_0 . You must also write 1b to CSCR[AA].
 */
/*@{*/
#define BP_FB_CSPMCR_GROUP5  (12U)         /*!< Bit position for FB_CSPMCR_GROUP5. */
#define BM_FB_CSPMCR_GROUP5  (0x0000F000U) /*!< Bit mask for FB_CSPMCR_GROUP5. */
#define BS_FB_CSPMCR_GROUP5  (4U)          /*!< Bit field size in bits for FB_CSPMCR_GROUP5. */

/*! @brief Read current value of the FB_CSPMCR_GROUP5 field. */
#define BR_FB_CSPMCR_GROUP5(x) (HW_FB_CSPMCR(x).B.GROUP5)

/*! @brief Format value for bitfield FB_CSPMCR_GROUP5. */
#define BF_FB_CSPMCR_GROUP5(v) ((uint32_t)((uint32_t)(v) << BP_FB_CSPMCR_GROUP5) & BM_FB_CSPMCR_GROUP5)

/*! @brief Set the GROUP5 field to a new value. */
#define BW_FB_CSPMCR_GROUP5(x, v) (HW_FB_CSPMCR_WR(x, (HW_FB_CSPMCR_RD(x) & ~BM_FB_CSPMCR_GROUP5) | BF_FB_CSPMCR_GROUP5(v)))
/*@}*/

/*!
 * @name Register FB_CSPMCR, field GROUP4[19:16] (RW)
 *
 * Controls the multiplexing of the FB_TBST , FB_CS2 , and FB_BE_15_8 signals.
 *
 * Values:
 * - 0000 - FB_TBST
 * - 0001 - FB_CS2
 * - 0010 - FB_BE_15_8
 */
/*@{*/
#define BP_FB_CSPMCR_GROUP4  (16U)         /*!< Bit position for FB_CSPMCR_GROUP4. */
#define BM_FB_CSPMCR_GROUP4  (0x000F0000U) /*!< Bit mask for FB_CSPMCR_GROUP4. */
#define BS_FB_CSPMCR_GROUP4  (4U)          /*!< Bit field size in bits for FB_CSPMCR_GROUP4. */

/*! @brief Read current value of the FB_CSPMCR_GROUP4 field. */
#define BR_FB_CSPMCR_GROUP4(x) (HW_FB_CSPMCR(x).B.GROUP4)

/*! @brief Format value for bitfield FB_CSPMCR_GROUP4. */
#define BF_FB_CSPMCR_GROUP4(v) ((uint32_t)((uint32_t)(v) << BP_FB_CSPMCR_GROUP4) & BM_FB_CSPMCR_GROUP4)

/*! @brief Set the GROUP4 field to a new value. */
#define BW_FB_CSPMCR_GROUP4(x, v) (HW_FB_CSPMCR_WR(x, (HW_FB_CSPMCR_RD(x) & ~BM_FB_CSPMCR_GROUP4) | BF_FB_CSPMCR_GROUP4(v)))
/*@}*/

/*!
 * @name Register FB_CSPMCR, field GROUP3[23:20] (RW)
 *
 * Controls the multiplexing of the FB_CS5 , FB_TSIZ1, and FB_BE_23_16 signals.
 *
 * Values:
 * - 0000 - FB_CS5
 * - 0001 - FB_TSIZ1
 * - 0010 - FB_BE_23_16
 */
/*@{*/
#define BP_FB_CSPMCR_GROUP3  (20U)         /*!< Bit position for FB_CSPMCR_GROUP3. */
#define BM_FB_CSPMCR_GROUP3  (0x00F00000U) /*!< Bit mask for FB_CSPMCR_GROUP3. */
#define BS_FB_CSPMCR_GROUP3  (4U)          /*!< Bit field size in bits for FB_CSPMCR_GROUP3. */

/*! @brief Read current value of the FB_CSPMCR_GROUP3 field. */
#define BR_FB_CSPMCR_GROUP3(x) (HW_FB_CSPMCR(x).B.GROUP3)

/*! @brief Format value for bitfield FB_CSPMCR_GROUP3. */
#define BF_FB_CSPMCR_GROUP3(v) ((uint32_t)((uint32_t)(v) << BP_FB_CSPMCR_GROUP3) & BM_FB_CSPMCR_GROUP3)

/*! @brief Set the GROUP3 field to a new value. */
#define BW_FB_CSPMCR_GROUP3(x, v) (HW_FB_CSPMCR_WR(x, (HW_FB_CSPMCR_RD(x) & ~BM_FB_CSPMCR_GROUP3) | BF_FB_CSPMCR_GROUP3(v)))
/*@}*/

/*!
 * @name Register FB_CSPMCR, field GROUP2[27:24] (RW)
 *
 * Controls the multiplexing of the FB_CS4 , FB_TSIZ0, and FB_BE_31_24 signals.
 *
 * Values:
 * - 0000 - FB_CS4
 * - 0001 - FB_TSIZ0
 * - 0010 - FB_BE_31_24
 */
/*@{*/
#define BP_FB_CSPMCR_GROUP2  (24U)         /*!< Bit position for FB_CSPMCR_GROUP2. */
#define BM_FB_CSPMCR_GROUP2  (0x0F000000U) /*!< Bit mask for FB_CSPMCR_GROUP2. */
#define BS_FB_CSPMCR_GROUP2  (4U)          /*!< Bit field size in bits for FB_CSPMCR_GROUP2. */

/*! @brief Read current value of the FB_CSPMCR_GROUP2 field. */
#define BR_FB_CSPMCR_GROUP2(x) (HW_FB_CSPMCR(x).B.GROUP2)

/*! @brief Format value for bitfield FB_CSPMCR_GROUP2. */
#define BF_FB_CSPMCR_GROUP2(v) ((uint32_t)((uint32_t)(v) << BP_FB_CSPMCR_GROUP2) & BM_FB_CSPMCR_GROUP2)

/*! @brief Set the GROUP2 field to a new value. */
#define BW_FB_CSPMCR_GROUP2(x, v) (HW_FB_CSPMCR_WR(x, (HW_FB_CSPMCR_RD(x) & ~BM_FB_CSPMCR_GROUP2) | BF_FB_CSPMCR_GROUP2(v)))
/*@}*/

/*!
 * @name Register FB_CSPMCR, field GROUP1[31:28] (RW)
 *
 * Controls the multiplexing of the FB_ALE, FB_CS1 , and FB_TS signals.
 *
 * Values:
 * - 0000 - FB_ALE
 * - 0001 - FB_CS1
 * - 0010 - FB_TS
 */
/*@{*/
#define BP_FB_CSPMCR_GROUP1  (28U)         /*!< Bit position for FB_CSPMCR_GROUP1. */
#define BM_FB_CSPMCR_GROUP1  (0xF0000000U) /*!< Bit mask for FB_CSPMCR_GROUP1. */
#define BS_FB_CSPMCR_GROUP1  (4U)          /*!< Bit field size in bits for FB_CSPMCR_GROUP1. */

/*! @brief Read current value of the FB_CSPMCR_GROUP1 field. */
#define BR_FB_CSPMCR_GROUP1(x) (HW_FB_CSPMCR(x).B.GROUP1)

/*! @brief Format value for bitfield FB_CSPMCR_GROUP1. */
#define BF_FB_CSPMCR_GROUP1(v) ((uint32_t)((uint32_t)(v) << BP_FB_CSPMCR_GROUP1) & BM_FB_CSPMCR_GROUP1)

/*! @brief Set the GROUP1 field to a new value. */
#define BW_FB_CSPMCR_GROUP1(x, v) (HW_FB_CSPMCR_WR(x, (HW_FB_CSPMCR_RD(x) & ~BM_FB_CSPMCR_GROUP1) | BF_FB_CSPMCR_GROUP1(v)))
/*@}*/

/*******************************************************************************
 * hw_fb_t - module struct
 ******************************************************************************/
/*!
 * @brief All FB module registers.
 */
#pragma pack(1)
typedef struct _hw_fb
{
    struct {
        __IO hw_fb_csarn_t CSARn;          /*!< [0x0] Chip Select Address Register */
        __IO hw_fb_csmrn_t CSMRn;          /*!< [0x4] Chip Select Mask Register */
        __IO hw_fb_cscrn_t CSCRn;          /*!< [0x8] Chip Select Control Register */
    } CS[6];
    uint8_t _reserved0[24];
    __IO hw_fb_cspmcr_t CSPMCR;            /*!< [0x60] Chip Select port Multiplexing Control Register */
} hw_fb_t;
#pragma pack()

/*! @brief Macro to access all FB registers. */
/*! @param x FB module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_FB_REGS(FB_BASE)</code>. */
#define HW_FB_REGS(x)  (*(hw_fb_t *)(x))

/*
 * MK64F12 FMC
 *
 * Flash Memory Controller
 *
 * Registers defined in this header file:
 * - HW_FMC_PFAPR - Flash Access Protection Register
 * - HW_FMC_PFB0CR - Flash Bank 0 Control Register
 * - HW_FMC_PFB1CR - Flash Bank 1 Control Register
 * - HW_FMC_TAGVDW0Sn - Cache Tag Storage
 * - HW_FMC_TAGVDW1Sn - Cache Tag Storage
 * - HW_FMC_TAGVDW2Sn - Cache Tag Storage
 * - HW_FMC_TAGVDW3Sn - Cache Tag Storage
 * - HW_FMC_DATAW0SnU - Cache Data Storage (upper word)
 * - HW_FMC_DATAW0SnL - Cache Data Storage (lower word)
 * - HW_FMC_DATAW1SnU - Cache Data Storage (upper word)
 * - HW_FMC_DATAW1SnL - Cache Data Storage (lower word)
 * - HW_FMC_DATAW2SnU - Cache Data Storage (upper word)
 * - HW_FMC_DATAW2SnL - Cache Data Storage (lower word)
 * - HW_FMC_DATAW3SnU - Cache Data Storage (upper word)
 * - HW_FMC_DATAW3SnL - Cache Data Storage (lower word)
 *
 * - hw_fmc_t - Struct containing all module registers.
 */

#define HW_FMC_INSTANCE_COUNT (1U) /*!< Number of instances of the FMC module. */
#define HW_FMC (0U) /*!< Instance number for FMC. */

/*******************************************************************************
 * HW_FMC_PFAPR - Flash Access Protection Register
 ******************************************************************************/

/*!
 * @brief HW_FMC_PFAPR - Flash Access Protection Register (RW)
 *
 * Reset value: 0x00F8003FU
 */
typedef union _hw_fmc_pfapr
{
    uint32_t U;
    struct _hw_fmc_pfapr_bitfields
    {
        uint32_t M0AP : 2;             /*!< [1:0] Master 0 Access Protection */
        uint32_t M1AP : 2;             /*!< [3:2] Master 1 Access Protection */
        uint32_t M2AP : 2;             /*!< [5:4] Master 2 Access Protection */
        uint32_t M3AP : 2;             /*!< [7:6] Master 3 Access Protection */
        uint32_t M4AP : 2;             /*!< [9:8] Master 4 Access Protection */
        uint32_t M5AP : 2;             /*!< [11:10] Master 5 Access Protection */
        uint32_t M6AP : 2;             /*!< [13:12] Master 6 Access Protection */
        uint32_t M7AP : 2;             /*!< [15:14] Master 7 Access Protection */
        uint32_t M0PFD : 1;            /*!< [16] Master 0 Prefetch Disable */
        uint32_t M1PFD : 1;            /*!< [17] Master 1 Prefetch Disable */
        uint32_t M2PFD : 1;            /*!< [18] Master 2 Prefetch Disable */
        uint32_t M3PFD : 1;            /*!< [19] Master 3 Prefetch Disable */
        uint32_t M4PFD : 1;            /*!< [20] Master 4 Prefetch Disable */
        uint32_t M5PFD : 1;            /*!< [21] Master 5 Prefetch Disable */
        uint32_t M6PFD : 1;            /*!< [22] Master 6 Prefetch Disable */
        uint32_t M7PFD : 1;            /*!< [23] Master 7 Prefetch Disable */
        uint32_t RESERVED0 : 8;        /*!< [31:24]  */
    } B;
} hw_fmc_pfapr_t;

/*!
 * @name Constants and macros for entire FMC_PFAPR register
 */
/*@{*/
#define HW_FMC_PFAPR_ADDR(x)     ((uint32_t)(x) + 0x0U)

#define HW_FMC_PFAPR(x)          (*(__IO hw_fmc_pfapr_t *) HW_FMC_PFAPR_ADDR(x))
#define HW_FMC_PFAPR_RD(x)       (HW_FMC_PFAPR(x).U)
#define HW_FMC_PFAPR_WR(x, v)    (HW_FMC_PFAPR(x).U = (v))
#define HW_FMC_PFAPR_SET(x, v)   (HW_FMC_PFAPR_WR(x, HW_FMC_PFAPR_RD(x) |  (v)))
#define HW_FMC_PFAPR_CLR(x, v)   (HW_FMC_PFAPR_WR(x, HW_FMC_PFAPR_RD(x) & ~(v)))
#define HW_FMC_PFAPR_TOG(x, v)   (HW_FMC_PFAPR_WR(x, HW_FMC_PFAPR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_PFAPR bitfields
 */

/*!
 * @name Register FMC_PFAPR, field M0AP[1:0] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
#define BP_FMC_PFAPR_M0AP    (0U)          /*!< Bit position for FMC_PFAPR_M0AP. */
#define BM_FMC_PFAPR_M0AP    (0x00000003U) /*!< Bit mask for FMC_PFAPR_M0AP. */
#define BS_FMC_PFAPR_M0AP    (2U)          /*!< Bit field size in bits for FMC_PFAPR_M0AP. */

/*! @brief Read current value of the FMC_PFAPR_M0AP field. */
#define BR_FMC_PFAPR_M0AP(x) (HW_FMC_PFAPR(x).B.M0AP)

/*! @brief Format value for bitfield FMC_PFAPR_M0AP. */
#define BF_FMC_PFAPR_M0AP(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M0AP) & BM_FMC_PFAPR_M0AP)

/*! @brief Set the M0AP field to a new value. */
#define BW_FMC_PFAPR_M0AP(x, v) (HW_FMC_PFAPR_WR(x, (HW_FMC_PFAPR_RD(x) & ~BM_FMC_PFAPR_M0AP) | BF_FMC_PFAPR_M0AP(v)))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M1AP[3:2] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
#define BP_FMC_PFAPR_M1AP    (2U)          /*!< Bit position for FMC_PFAPR_M1AP. */
#define BM_FMC_PFAPR_M1AP    (0x0000000CU) /*!< Bit mask for FMC_PFAPR_M1AP. */
#define BS_FMC_PFAPR_M1AP    (2U)          /*!< Bit field size in bits for FMC_PFAPR_M1AP. */

/*! @brief Read current value of the FMC_PFAPR_M1AP field. */
#define BR_FMC_PFAPR_M1AP(x) (HW_FMC_PFAPR(x).B.M1AP)

/*! @brief Format value for bitfield FMC_PFAPR_M1AP. */
#define BF_FMC_PFAPR_M1AP(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M1AP) & BM_FMC_PFAPR_M1AP)

/*! @brief Set the M1AP field to a new value. */
#define BW_FMC_PFAPR_M1AP(x, v) (HW_FMC_PFAPR_WR(x, (HW_FMC_PFAPR_RD(x) & ~BM_FMC_PFAPR_M1AP) | BF_FMC_PFAPR_M1AP(v)))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M2AP[5:4] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
#define BP_FMC_PFAPR_M2AP    (4U)          /*!< Bit position for FMC_PFAPR_M2AP. */
#define BM_FMC_PFAPR_M2AP    (0x00000030U) /*!< Bit mask for FMC_PFAPR_M2AP. */
#define BS_FMC_PFAPR_M2AP    (2U)          /*!< Bit field size in bits for FMC_PFAPR_M2AP. */

/*! @brief Read current value of the FMC_PFAPR_M2AP field. */
#define BR_FMC_PFAPR_M2AP(x) (HW_FMC_PFAPR(x).B.M2AP)

/*! @brief Format value for bitfield FMC_PFAPR_M2AP. */
#define BF_FMC_PFAPR_M2AP(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M2AP) & BM_FMC_PFAPR_M2AP)

/*! @brief Set the M2AP field to a new value. */
#define BW_FMC_PFAPR_M2AP(x, v) (HW_FMC_PFAPR_WR(x, (HW_FMC_PFAPR_RD(x) & ~BM_FMC_PFAPR_M2AP) | BF_FMC_PFAPR_M2AP(v)))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M3AP[7:6] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
#define BP_FMC_PFAPR_M3AP    (6U)          /*!< Bit position for FMC_PFAPR_M3AP. */
#define BM_FMC_PFAPR_M3AP    (0x000000C0U) /*!< Bit mask for FMC_PFAPR_M3AP. */
#define BS_FMC_PFAPR_M3AP    (2U)          /*!< Bit field size in bits for FMC_PFAPR_M3AP. */

/*! @brief Read current value of the FMC_PFAPR_M3AP field. */
#define BR_FMC_PFAPR_M3AP(x) (HW_FMC_PFAPR(x).B.M3AP)

/*! @brief Format value for bitfield FMC_PFAPR_M3AP. */
#define BF_FMC_PFAPR_M3AP(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M3AP) & BM_FMC_PFAPR_M3AP)

/*! @brief Set the M3AP field to a new value. */
#define BW_FMC_PFAPR_M3AP(x, v) (HW_FMC_PFAPR_WR(x, (HW_FMC_PFAPR_RD(x) & ~BM_FMC_PFAPR_M3AP) | BF_FMC_PFAPR_M3AP(v)))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M4AP[9:8] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
#define BP_FMC_PFAPR_M4AP    (8U)          /*!< Bit position for FMC_PFAPR_M4AP. */
#define BM_FMC_PFAPR_M4AP    (0x00000300U) /*!< Bit mask for FMC_PFAPR_M4AP. */
#define BS_FMC_PFAPR_M4AP    (2U)          /*!< Bit field size in bits for FMC_PFAPR_M4AP. */

/*! @brief Read current value of the FMC_PFAPR_M4AP field. */
#define BR_FMC_PFAPR_M4AP(x) (HW_FMC_PFAPR(x).B.M4AP)

/*! @brief Format value for bitfield FMC_PFAPR_M4AP. */
#define BF_FMC_PFAPR_M4AP(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M4AP) & BM_FMC_PFAPR_M4AP)

/*! @brief Set the M4AP field to a new value. */
#define BW_FMC_PFAPR_M4AP(x, v) (HW_FMC_PFAPR_WR(x, (HW_FMC_PFAPR_RD(x) & ~BM_FMC_PFAPR_M4AP) | BF_FMC_PFAPR_M4AP(v)))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M5AP[11:10] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
#define BP_FMC_PFAPR_M5AP    (10U)         /*!< Bit position for FMC_PFAPR_M5AP. */
#define BM_FMC_PFAPR_M5AP    (0x00000C00U) /*!< Bit mask for FMC_PFAPR_M5AP. */
#define BS_FMC_PFAPR_M5AP    (2U)          /*!< Bit field size in bits for FMC_PFAPR_M5AP. */

/*! @brief Read current value of the FMC_PFAPR_M5AP field. */
#define BR_FMC_PFAPR_M5AP(x) (HW_FMC_PFAPR(x).B.M5AP)

/*! @brief Format value for bitfield FMC_PFAPR_M5AP. */
#define BF_FMC_PFAPR_M5AP(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M5AP) & BM_FMC_PFAPR_M5AP)

/*! @brief Set the M5AP field to a new value. */
#define BW_FMC_PFAPR_M5AP(x, v) (HW_FMC_PFAPR_WR(x, (HW_FMC_PFAPR_RD(x) & ~BM_FMC_PFAPR_M5AP) | BF_FMC_PFAPR_M5AP(v)))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M6AP[13:12] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
#define BP_FMC_PFAPR_M6AP    (12U)         /*!< Bit position for FMC_PFAPR_M6AP. */
#define BM_FMC_PFAPR_M6AP    (0x00003000U) /*!< Bit mask for FMC_PFAPR_M6AP. */
#define BS_FMC_PFAPR_M6AP    (2U)          /*!< Bit field size in bits for FMC_PFAPR_M6AP. */

/*! @brief Read current value of the FMC_PFAPR_M6AP field. */
#define BR_FMC_PFAPR_M6AP(x) (HW_FMC_PFAPR(x).B.M6AP)

/*! @brief Format value for bitfield FMC_PFAPR_M6AP. */
#define BF_FMC_PFAPR_M6AP(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M6AP) & BM_FMC_PFAPR_M6AP)

/*! @brief Set the M6AP field to a new value. */
#define BW_FMC_PFAPR_M6AP(x, v) (HW_FMC_PFAPR_WR(x, (HW_FMC_PFAPR_RD(x) & ~BM_FMC_PFAPR_M6AP) | BF_FMC_PFAPR_M6AP(v)))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M7AP[15:14] (RW)
 *
 * This field controls whether read and write access to the flash are allowed
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master.
 * - 01 - Only read accesses may be performed by this master.
 * - 10 - Only write accesses may be performed by this master.
 * - 11 - Both read and write accesses may be performed by this master.
 */
/*@{*/
#define BP_FMC_PFAPR_M7AP    (14U)         /*!< Bit position for FMC_PFAPR_M7AP. */
#define BM_FMC_PFAPR_M7AP    (0x0000C000U) /*!< Bit mask for FMC_PFAPR_M7AP. */
#define BS_FMC_PFAPR_M7AP    (2U)          /*!< Bit field size in bits for FMC_PFAPR_M7AP. */

/*! @brief Read current value of the FMC_PFAPR_M7AP field. */
#define BR_FMC_PFAPR_M7AP(x) (HW_FMC_PFAPR(x).B.M7AP)

/*! @brief Format value for bitfield FMC_PFAPR_M7AP. */
#define BF_FMC_PFAPR_M7AP(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M7AP) & BM_FMC_PFAPR_M7AP)

/*! @brief Set the M7AP field to a new value. */
#define BW_FMC_PFAPR_M7AP(x, v) (HW_FMC_PFAPR_WR(x, (HW_FMC_PFAPR_RD(x) & ~BM_FMC_PFAPR_M7AP) | BF_FMC_PFAPR_M7AP(v)))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M0PFD[16] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
#define BP_FMC_PFAPR_M0PFD   (16U)         /*!< Bit position for FMC_PFAPR_M0PFD. */
#define BM_FMC_PFAPR_M0PFD   (0x00010000U) /*!< Bit mask for FMC_PFAPR_M0PFD. */
#define BS_FMC_PFAPR_M0PFD   (1U)          /*!< Bit field size in bits for FMC_PFAPR_M0PFD. */

/*! @brief Read current value of the FMC_PFAPR_M0PFD field. */
#define BR_FMC_PFAPR_M0PFD(x) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M0PFD))

/*! @brief Format value for bitfield FMC_PFAPR_M0PFD. */
#define BF_FMC_PFAPR_M0PFD(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M0PFD) & BM_FMC_PFAPR_M0PFD)

/*! @brief Set the M0PFD field to a new value. */
#define BW_FMC_PFAPR_M0PFD(x, v) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M0PFD) = (v))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M1PFD[17] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
#define BP_FMC_PFAPR_M1PFD   (17U)         /*!< Bit position for FMC_PFAPR_M1PFD. */
#define BM_FMC_PFAPR_M1PFD   (0x00020000U) /*!< Bit mask for FMC_PFAPR_M1PFD. */
#define BS_FMC_PFAPR_M1PFD   (1U)          /*!< Bit field size in bits for FMC_PFAPR_M1PFD. */

/*! @brief Read current value of the FMC_PFAPR_M1PFD field. */
#define BR_FMC_PFAPR_M1PFD(x) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M1PFD))

/*! @brief Format value for bitfield FMC_PFAPR_M1PFD. */
#define BF_FMC_PFAPR_M1PFD(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M1PFD) & BM_FMC_PFAPR_M1PFD)

/*! @brief Set the M1PFD field to a new value. */
#define BW_FMC_PFAPR_M1PFD(x, v) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M1PFD) = (v))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M2PFD[18] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
#define BP_FMC_PFAPR_M2PFD   (18U)         /*!< Bit position for FMC_PFAPR_M2PFD. */
#define BM_FMC_PFAPR_M2PFD   (0x00040000U) /*!< Bit mask for FMC_PFAPR_M2PFD. */
#define BS_FMC_PFAPR_M2PFD   (1U)          /*!< Bit field size in bits for FMC_PFAPR_M2PFD. */

/*! @brief Read current value of the FMC_PFAPR_M2PFD field. */
#define BR_FMC_PFAPR_M2PFD(x) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M2PFD))

/*! @brief Format value for bitfield FMC_PFAPR_M2PFD. */
#define BF_FMC_PFAPR_M2PFD(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M2PFD) & BM_FMC_PFAPR_M2PFD)

/*! @brief Set the M2PFD field to a new value. */
#define BW_FMC_PFAPR_M2PFD(x, v) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M2PFD) = (v))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M3PFD[19] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
#define BP_FMC_PFAPR_M3PFD   (19U)         /*!< Bit position for FMC_PFAPR_M3PFD. */
#define BM_FMC_PFAPR_M3PFD   (0x00080000U) /*!< Bit mask for FMC_PFAPR_M3PFD. */
#define BS_FMC_PFAPR_M3PFD   (1U)          /*!< Bit field size in bits for FMC_PFAPR_M3PFD. */

/*! @brief Read current value of the FMC_PFAPR_M3PFD field. */
#define BR_FMC_PFAPR_M3PFD(x) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M3PFD))

/*! @brief Format value for bitfield FMC_PFAPR_M3PFD. */
#define BF_FMC_PFAPR_M3PFD(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M3PFD) & BM_FMC_PFAPR_M3PFD)

/*! @brief Set the M3PFD field to a new value. */
#define BW_FMC_PFAPR_M3PFD(x, v) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M3PFD) = (v))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M4PFD[20] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
#define BP_FMC_PFAPR_M4PFD   (20U)         /*!< Bit position for FMC_PFAPR_M4PFD. */
#define BM_FMC_PFAPR_M4PFD   (0x00100000U) /*!< Bit mask for FMC_PFAPR_M4PFD. */
#define BS_FMC_PFAPR_M4PFD   (1U)          /*!< Bit field size in bits for FMC_PFAPR_M4PFD. */

/*! @brief Read current value of the FMC_PFAPR_M4PFD field. */
#define BR_FMC_PFAPR_M4PFD(x) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M4PFD))

/*! @brief Format value for bitfield FMC_PFAPR_M4PFD. */
#define BF_FMC_PFAPR_M4PFD(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M4PFD) & BM_FMC_PFAPR_M4PFD)

/*! @brief Set the M4PFD field to a new value. */
#define BW_FMC_PFAPR_M4PFD(x, v) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M4PFD) = (v))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M5PFD[21] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
#define BP_FMC_PFAPR_M5PFD   (21U)         /*!< Bit position for FMC_PFAPR_M5PFD. */
#define BM_FMC_PFAPR_M5PFD   (0x00200000U) /*!< Bit mask for FMC_PFAPR_M5PFD. */
#define BS_FMC_PFAPR_M5PFD   (1U)          /*!< Bit field size in bits for FMC_PFAPR_M5PFD. */

/*! @brief Read current value of the FMC_PFAPR_M5PFD field. */
#define BR_FMC_PFAPR_M5PFD(x) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M5PFD))

/*! @brief Format value for bitfield FMC_PFAPR_M5PFD. */
#define BF_FMC_PFAPR_M5PFD(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M5PFD) & BM_FMC_PFAPR_M5PFD)

/*! @brief Set the M5PFD field to a new value. */
#define BW_FMC_PFAPR_M5PFD(x, v) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M5PFD) = (v))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M6PFD[22] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
#define BP_FMC_PFAPR_M6PFD   (22U)         /*!< Bit position for FMC_PFAPR_M6PFD. */
#define BM_FMC_PFAPR_M6PFD   (0x00400000U) /*!< Bit mask for FMC_PFAPR_M6PFD. */
#define BS_FMC_PFAPR_M6PFD   (1U)          /*!< Bit field size in bits for FMC_PFAPR_M6PFD. */

/*! @brief Read current value of the FMC_PFAPR_M6PFD field. */
#define BR_FMC_PFAPR_M6PFD(x) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M6PFD))

/*! @brief Format value for bitfield FMC_PFAPR_M6PFD. */
#define BF_FMC_PFAPR_M6PFD(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M6PFD) & BM_FMC_PFAPR_M6PFD)

/*! @brief Set the M6PFD field to a new value. */
#define BW_FMC_PFAPR_M6PFD(x, v) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M6PFD) = (v))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M7PFD[23] (RW)
 *
 * These bits control whether prefetching is enabled based on the logical number
 * of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
#define BP_FMC_PFAPR_M7PFD   (23U)         /*!< Bit position for FMC_PFAPR_M7PFD. */
#define BM_FMC_PFAPR_M7PFD   (0x00800000U) /*!< Bit mask for FMC_PFAPR_M7PFD. */
#define BS_FMC_PFAPR_M7PFD   (1U)          /*!< Bit field size in bits for FMC_PFAPR_M7PFD. */

/*! @brief Read current value of the FMC_PFAPR_M7PFD field. */
#define BR_FMC_PFAPR_M7PFD(x) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M7PFD))

/*! @brief Format value for bitfield FMC_PFAPR_M7PFD. */
#define BF_FMC_PFAPR_M7PFD(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFAPR_M7PFD) & BM_FMC_PFAPR_M7PFD)

/*! @brief Set the M7PFD field to a new value. */
#define BW_FMC_PFAPR_M7PFD(x, v) (BITBAND_ACCESS32(HW_FMC_PFAPR_ADDR(x), BP_FMC_PFAPR_M7PFD) = (v))
/*@}*/

/*******************************************************************************
 * HW_FMC_PFB0CR - Flash Bank 0 Control Register
 ******************************************************************************/

/*!
 * @brief HW_FMC_PFB0CR - Flash Bank 0 Control Register (RW)
 *
 * Reset value: 0x3004001FU
 */
typedef union _hw_fmc_pfb0cr
{
    uint32_t U;
    struct _hw_fmc_pfb0cr_bitfields
    {
        uint32_t B0SEBE : 1;           /*!< [0] Bank 0 Single Entry Buffer Enable */
        uint32_t B0IPE : 1;            /*!< [1] Bank 0 Instruction Prefetch Enable */
        uint32_t B0DPE : 1;            /*!< [2] Bank 0 Data Prefetch Enable */
        uint32_t B0ICE : 1;            /*!< [3] Bank 0 Instruction Cache Enable */
        uint32_t B0DCE : 1;            /*!< [4] Bank 0 Data Cache Enable */
        uint32_t CRC : 3;              /*!< [7:5] Cache Replacement Control */
        uint32_t RESERVED0 : 9;        /*!< [16:8]  */
        uint32_t B0MW : 2;             /*!< [18:17] Bank 0 Memory Width */
        uint32_t S_B_INV : 1;          /*!< [19] Invalidate Prefetch Speculation
                                        * Buffer */
        uint32_t CINV_WAY : 4;         /*!< [23:20] Cache Invalidate Way x */
        uint32_t CLCK_WAY : 4;         /*!< [27:24] Cache Lock Way x */
        uint32_t B0RWSC : 4;           /*!< [31:28] Bank 0 Read Wait State Control */
    } B;
} hw_fmc_pfb0cr_t;

/*!
 * @name Constants and macros for entire FMC_PFB0CR register
 */
/*@{*/
#define HW_FMC_PFB0CR_ADDR(x)    ((uint32_t)(x) + 0x4U)

#define HW_FMC_PFB0CR(x)         (*(__IO hw_fmc_pfb0cr_t *) HW_FMC_PFB0CR_ADDR(x))
#define HW_FMC_PFB0CR_RD(x)      (HW_FMC_PFB0CR(x).U)
#define HW_FMC_PFB0CR_WR(x, v)   (HW_FMC_PFB0CR(x).U = (v))
#define HW_FMC_PFB0CR_SET(x, v)  (HW_FMC_PFB0CR_WR(x, HW_FMC_PFB0CR_RD(x) |  (v)))
#define HW_FMC_PFB0CR_CLR(x, v)  (HW_FMC_PFB0CR_WR(x, HW_FMC_PFB0CR_RD(x) & ~(v)))
#define HW_FMC_PFB0CR_TOG(x, v)  (HW_FMC_PFB0CR_WR(x, HW_FMC_PFB0CR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_PFB0CR bitfields
 */

/*!
 * @name Register FMC_PFB0CR, field B0SEBE[0] (RW)
 *
 * This bit controls whether the single entry page buffer is enabled in response
 * to flash read accesses. Its operation is independent from bank 1's cache. A
 * high-to-low transition of this enable forces the page buffer to be invalidated.
 *
 * Values:
 * - 0 - Single entry buffer is disabled.
 * - 1 - Single entry buffer is enabled.
 */
/*@{*/
#define BP_FMC_PFB0CR_B0SEBE (0U)          /*!< Bit position for FMC_PFB0CR_B0SEBE. */
#define BM_FMC_PFB0CR_B0SEBE (0x00000001U) /*!< Bit mask for FMC_PFB0CR_B0SEBE. */
#define BS_FMC_PFB0CR_B0SEBE (1U)          /*!< Bit field size in bits for FMC_PFB0CR_B0SEBE. */

/*! @brief Read current value of the FMC_PFB0CR_B0SEBE field. */
#define BR_FMC_PFB0CR_B0SEBE(x) (BITBAND_ACCESS32(HW_FMC_PFB0CR_ADDR(x), BP_FMC_PFB0CR_B0SEBE))

/*! @brief Format value for bitfield FMC_PFB0CR_B0SEBE. */
#define BF_FMC_PFB0CR_B0SEBE(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB0CR_B0SEBE) & BM_FMC_PFB0CR_B0SEBE)

/*! @brief Set the B0SEBE field to a new value. */
#define BW_FMC_PFB0CR_B0SEBE(x, v) (BITBAND_ACCESS32(HW_FMC_PFB0CR_ADDR(x), BP_FMC_PFB0CR_B0SEBE) = (v))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0IPE[1] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to instruction fetches.
 *
 * Values:
 * - 0 - Do not prefetch in response to instruction fetches.
 * - 1 - Enable prefetches in response to instruction fetches.
 */
/*@{*/
#define BP_FMC_PFB0CR_B0IPE  (1U)          /*!< Bit position for FMC_PFB0CR_B0IPE. */
#define BM_FMC_PFB0CR_B0IPE  (0x00000002U) /*!< Bit mask for FMC_PFB0CR_B0IPE. */
#define BS_FMC_PFB0CR_B0IPE  (1U)          /*!< Bit field size in bits for FMC_PFB0CR_B0IPE. */

/*! @brief Read current value of the FMC_PFB0CR_B0IPE field. */
#define BR_FMC_PFB0CR_B0IPE(x) (BITBAND_ACCESS32(HW_FMC_PFB0CR_ADDR(x), BP_FMC_PFB0CR_B0IPE))

/*! @brief Format value for bitfield FMC_PFB0CR_B0IPE. */
#define BF_FMC_PFB0CR_B0IPE(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB0CR_B0IPE) & BM_FMC_PFB0CR_B0IPE)

/*! @brief Set the B0IPE field to a new value. */
#define BW_FMC_PFB0CR_B0IPE(x, v) (BITBAND_ACCESS32(HW_FMC_PFB0CR_ADDR(x), BP_FMC_PFB0CR_B0IPE) = (v))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0DPE[2] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to data references.
 *
 * Values:
 * - 0 - Do not prefetch in response to data references.
 * - 1 - Enable prefetches in response to data references.
 */
/*@{*/
#define BP_FMC_PFB0CR_B0DPE  (2U)          /*!< Bit position for FMC_PFB0CR_B0DPE. */
#define BM_FMC_PFB0CR_B0DPE  (0x00000004U) /*!< Bit mask for FMC_PFB0CR_B0DPE. */
#define BS_FMC_PFB0CR_B0DPE  (1U)          /*!< Bit field size in bits for FMC_PFB0CR_B0DPE. */

/*! @brief Read current value of the FMC_PFB0CR_B0DPE field. */
#define BR_FMC_PFB0CR_B0DPE(x) (BITBAND_ACCESS32(HW_FMC_PFB0CR_ADDR(x), BP_FMC_PFB0CR_B0DPE))

/*! @brief Format value for bitfield FMC_PFB0CR_B0DPE. */
#define BF_FMC_PFB0CR_B0DPE(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB0CR_B0DPE) & BM_FMC_PFB0CR_B0DPE)

/*! @brief Set the B0DPE field to a new value. */
#define BW_FMC_PFB0CR_B0DPE(x, v) (BITBAND_ACCESS32(HW_FMC_PFB0CR_ADDR(x), BP_FMC_PFB0CR_B0DPE) = (v))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0ICE[3] (RW)
 *
 * This bit controls whether instruction fetches are loaded into the cache.
 *
 * Values:
 * - 0 - Do not cache instruction fetches.
 * - 1 - Cache instruction fetches.
 */
/*@{*/
#define BP_FMC_PFB0CR_B0ICE  (3U)          /*!< Bit position for FMC_PFB0CR_B0ICE. */
#define BM_FMC_PFB0CR_B0ICE  (0x00000008U) /*!< Bit mask for FMC_PFB0CR_B0ICE. */
#define BS_FMC_PFB0CR_B0ICE  (1U)          /*!< Bit field size in bits for FMC_PFB0CR_B0ICE. */

/*! @brief Read current value of the FMC_PFB0CR_B0ICE field. */
#define BR_FMC_PFB0CR_B0ICE(x) (BITBAND_ACCESS32(HW_FMC_PFB0CR_ADDR(x), BP_FMC_PFB0CR_B0ICE))

/*! @brief Format value for bitfield FMC_PFB0CR_B0ICE. */
#define BF_FMC_PFB0CR_B0ICE(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB0CR_B0ICE) & BM_FMC_PFB0CR_B0ICE)

/*! @brief Set the B0ICE field to a new value. */
#define BW_FMC_PFB0CR_B0ICE(x, v) (BITBAND_ACCESS32(HW_FMC_PFB0CR_ADDR(x), BP_FMC_PFB0CR_B0ICE) = (v))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0DCE[4] (RW)
 *
 * This bit controls whether data references are loaded into the cache.
 *
 * Values:
 * - 0 - Do not cache data references.
 * - 1 - Cache data references.
 */
/*@{*/
#define BP_FMC_PFB0CR_B0DCE  (4U)          /*!< Bit position for FMC_PFB0CR_B0DCE. */
#define BM_FMC_PFB0CR_B0DCE  (0x00000010U) /*!< Bit mask for FMC_PFB0CR_B0DCE. */
#define BS_FMC_PFB0CR_B0DCE  (1U)          /*!< Bit field size in bits for FMC_PFB0CR_B0DCE. */

/*! @brief Read current value of the FMC_PFB0CR_B0DCE field. */
#define BR_FMC_PFB0CR_B0DCE(x) (BITBAND_ACCESS32(HW_FMC_PFB0CR_ADDR(x), BP_FMC_PFB0CR_B0DCE))

/*! @brief Format value for bitfield FMC_PFB0CR_B0DCE. */
#define BF_FMC_PFB0CR_B0DCE(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB0CR_B0DCE) & BM_FMC_PFB0CR_B0DCE)

/*! @brief Set the B0DCE field to a new value. */
#define BW_FMC_PFB0CR_B0DCE(x, v) (BITBAND_ACCESS32(HW_FMC_PFB0CR_ADDR(x), BP_FMC_PFB0CR_B0DCE) = (v))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field CRC[7:5] (RW)
 *
 * This 3-bit field defines the replacement algorithm for accesses that are
 * cached.
 *
 * Values:
 * - 000 - LRU replacement algorithm per set across all four ways
 * - 001 - Reserved
 * - 010 - Independent LRU with ways [0-1] for ifetches, [2-3] for data
 * - 011 - Independent LRU with ways [0-2] for ifetches, [3] for data
 * - 1xx - Reserved
 */
/*@{*/
#define BP_FMC_PFB0CR_CRC    (5U)          /*!< Bit position for FMC_PFB0CR_CRC. */
#define BM_FMC_PFB0CR_CRC    (0x000000E0U) /*!< Bit mask for FMC_PFB0CR_CRC. */
#define BS_FMC_PFB0CR_CRC    (3U)          /*!< Bit field size in bits for FMC_PFB0CR_CRC. */

/*! @brief Read current value of the FMC_PFB0CR_CRC field. */
#define BR_FMC_PFB0CR_CRC(x) (HW_FMC_PFB0CR(x).B.CRC)

/*! @brief Format value for bitfield FMC_PFB0CR_CRC. */
#define BF_FMC_PFB0CR_CRC(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB0CR_CRC) & BM_FMC_PFB0CR_CRC)

/*! @brief Set the CRC field to a new value. */
#define BW_FMC_PFB0CR_CRC(x, v) (HW_FMC_PFB0CR_WR(x, (HW_FMC_PFB0CR_RD(x) & ~BM_FMC_PFB0CR_CRC) | BF_FMC_PFB0CR_CRC(v)))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0MW[18:17] (RO)
 *
 * This read-only field defines the width of the bank 0 memory.
 *
 * Values:
 * - 00 - 32 bits
 * - 01 - 64 bits
 * - 10 - 128 bits
 * - 11 - Reserved
 */
/*@{*/
#define BP_FMC_PFB0CR_B0MW   (17U)         /*!< Bit position for FMC_PFB0CR_B0MW. */
#define BM_FMC_PFB0CR_B0MW   (0x00060000U) /*!< Bit mask for FMC_PFB0CR_B0MW. */
#define BS_FMC_PFB0CR_B0MW   (2U)          /*!< Bit field size in bits for FMC_PFB0CR_B0MW. */

/*! @brief Read current value of the FMC_PFB0CR_B0MW field. */
#define BR_FMC_PFB0CR_B0MW(x) (HW_FMC_PFB0CR(x).B.B0MW)
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field S_B_INV[19] (WORZ)
 *
 * This bit determines if the FMC's prefetch speculation buffer and the single
 * entry page buffer are to be invalidated (cleared). When this bit is written,
 * the speculation buffer and single entry buffer are immediately cleared. This bit
 * always reads as zero.
 *
 * Values:
 * - 0 - Speculation buffer and single entry buffer are not affected.
 * - 1 - Invalidate (clear) speculation buffer and single entry buffer.
 */
/*@{*/
#define BP_FMC_PFB0CR_S_B_INV (19U)        /*!< Bit position for FMC_PFB0CR_S_B_INV. */
#define BM_FMC_PFB0CR_S_B_INV (0x00080000U) /*!< Bit mask for FMC_PFB0CR_S_B_INV. */
#define BS_FMC_PFB0CR_S_B_INV (1U)         /*!< Bit field size in bits for FMC_PFB0CR_S_B_INV. */

/*! @brief Format value for bitfield FMC_PFB0CR_S_B_INV. */
#define BF_FMC_PFB0CR_S_B_INV(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB0CR_S_B_INV) & BM_FMC_PFB0CR_S_B_INV)

/*! @brief Set the S_B_INV field to a new value. */
#define BW_FMC_PFB0CR_S_B_INV(x, v) (BITBAND_ACCESS32(HW_FMC_PFB0CR_ADDR(x), BP_FMC_PFB0CR_S_B_INV) = (v))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field CINV_WAY[23:20] (WORZ)
 *
 * These bits determine if the given cache way is to be invalidated (cleared).
 * When a bit within this field is written, the corresponding cache way is
 * immediately invalidated: the way's tag, data, and valid contents are cleared. This
 * field always reads as zero. Cache invalidation takes precedence over locking.
 * The cache is invalidated by system reset. System software is required to
 * maintain memory coherency when any segment of the flash memory is programmed or
 * erased. Accordingly, cache invalidations must occur after a programming or erase
 * event is completed and before the new memory image is accessed. The bit setting
 * definitions are for each bit in the field.
 *
 * Values:
 * - 0 - No cache way invalidation for the corresponding cache
 * - 1 - Invalidate cache way for the corresponding cache: clear the tag, data,
 *     and vld bits of ways selected
 */
/*@{*/
#define BP_FMC_PFB0CR_CINV_WAY (20U)       /*!< Bit position for FMC_PFB0CR_CINV_WAY. */
#define BM_FMC_PFB0CR_CINV_WAY (0x00F00000U) /*!< Bit mask for FMC_PFB0CR_CINV_WAY. */
#define BS_FMC_PFB0CR_CINV_WAY (4U)        /*!< Bit field size in bits for FMC_PFB0CR_CINV_WAY. */

/*! @brief Format value for bitfield FMC_PFB0CR_CINV_WAY. */
#define BF_FMC_PFB0CR_CINV_WAY(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB0CR_CINV_WAY) & BM_FMC_PFB0CR_CINV_WAY)

/*! @brief Set the CINV_WAY field to a new value. */
#define BW_FMC_PFB0CR_CINV_WAY(x, v) (HW_FMC_PFB0CR_WR(x, (HW_FMC_PFB0CR_RD(x) & ~BM_FMC_PFB0CR_CINV_WAY) | BF_FMC_PFB0CR_CINV_WAY(v)))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field CLCK_WAY[27:24] (RW)
 *
 * These bits determine if the given cache way is locked such that its contents
 * will not be displaced by future misses. The bit setting definitions are for
 * each bit in the field.
 *
 * Values:
 * - 0 - Cache way is unlocked and may be displaced
 * - 1 - Cache way is locked and its contents are not displaced
 */
/*@{*/
#define BP_FMC_PFB0CR_CLCK_WAY (24U)       /*!< Bit position for FMC_PFB0CR_CLCK_WAY. */
#define BM_FMC_PFB0CR_CLCK_WAY (0x0F000000U) /*!< Bit mask for FMC_PFB0CR_CLCK_WAY. */
#define BS_FMC_PFB0CR_CLCK_WAY (4U)        /*!< Bit field size in bits for FMC_PFB0CR_CLCK_WAY. */

/*! @brief Read current value of the FMC_PFB0CR_CLCK_WAY field. */
#define BR_FMC_PFB0CR_CLCK_WAY(x) (HW_FMC_PFB0CR(x).B.CLCK_WAY)

/*! @brief Format value for bitfield FMC_PFB0CR_CLCK_WAY. */
#define BF_FMC_PFB0CR_CLCK_WAY(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB0CR_CLCK_WAY) & BM_FMC_PFB0CR_CLCK_WAY)

/*! @brief Set the CLCK_WAY field to a new value. */
#define BW_FMC_PFB0CR_CLCK_WAY(x, v) (HW_FMC_PFB0CR_WR(x, (HW_FMC_PFB0CR_RD(x) & ~BM_FMC_PFB0CR_CLCK_WAY) | BF_FMC_PFB0CR_CLCK_WAY(v)))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0RWSC[31:28] (RO)
 *
 * This read-only field defines the number of wait states required to access the
 * bank 0 flash memory. The relationship between the read access time of the
 * flash array (expressed in system clock cycles) and RWSC is defined as: Access
 * time of flash array [system clocks] = RWSC + 1 The FMC automatically calculates
 * this value based on the ratio of the system clock speed to the flash clock
 * speed. For example, when this ratio is 4:1, the field's value is 3h.
 */
/*@{*/
#define BP_FMC_PFB0CR_B0RWSC (28U)         /*!< Bit position for FMC_PFB0CR_B0RWSC. */
#define BM_FMC_PFB0CR_B0RWSC (0xF0000000U) /*!< Bit mask for FMC_PFB0CR_B0RWSC. */
#define BS_FMC_PFB0CR_B0RWSC (4U)          /*!< Bit field size in bits for FMC_PFB0CR_B0RWSC. */

/*! @brief Read current value of the FMC_PFB0CR_B0RWSC field. */
#define BR_FMC_PFB0CR_B0RWSC(x) (HW_FMC_PFB0CR(x).B.B0RWSC)
/*@}*/

/*******************************************************************************
 * HW_FMC_PFB1CR - Flash Bank 1 Control Register
 ******************************************************************************/

/*!
 * @brief HW_FMC_PFB1CR - Flash Bank 1 Control Register (RW)
 *
 * Reset value: 0x3004001FU
 *
 * This register has a format similar to that for PFB0CR, except it controls the
 * operation of flash bank 1, and the "global" cache control fields are empty.
 */
typedef union _hw_fmc_pfb1cr
{
    uint32_t U;
    struct _hw_fmc_pfb1cr_bitfields
    {
        uint32_t B1SEBE : 1;           /*!< [0] Bank 1 Single Entry Buffer Enable */
        uint32_t B1IPE : 1;            /*!< [1] Bank 1 Instruction Prefetch Enable */
        uint32_t B1DPE : 1;            /*!< [2] Bank 1 Data Prefetch Enable */
        uint32_t B1ICE : 1;            /*!< [3] Bank 1 Instruction Cache Enable */
        uint32_t B1DCE : 1;            /*!< [4] Bank 1 Data Cache Enable */
        uint32_t RESERVED0 : 12;       /*!< [16:5]  */
        uint32_t B1MW : 2;             /*!< [18:17] Bank 1 Memory Width */
        uint32_t RESERVED1 : 9;        /*!< [27:19]  */
        uint32_t B1RWSC : 4;           /*!< [31:28] Bank 1 Read Wait State Control */
    } B;
} hw_fmc_pfb1cr_t;

/*!
 * @name Constants and macros for entire FMC_PFB1CR register
 */
/*@{*/
#define HW_FMC_PFB1CR_ADDR(x)    ((uint32_t)(x) + 0x8U)

#define HW_FMC_PFB1CR(x)         (*(__IO hw_fmc_pfb1cr_t *) HW_FMC_PFB1CR_ADDR(x))
#define HW_FMC_PFB1CR_RD(x)      (HW_FMC_PFB1CR(x).U)
#define HW_FMC_PFB1CR_WR(x, v)   (HW_FMC_PFB1CR(x).U = (v))
#define HW_FMC_PFB1CR_SET(x, v)  (HW_FMC_PFB1CR_WR(x, HW_FMC_PFB1CR_RD(x) |  (v)))
#define HW_FMC_PFB1CR_CLR(x, v)  (HW_FMC_PFB1CR_WR(x, HW_FMC_PFB1CR_RD(x) & ~(v)))
#define HW_FMC_PFB1CR_TOG(x, v)  (HW_FMC_PFB1CR_WR(x, HW_FMC_PFB1CR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_PFB1CR bitfields
 */

/*!
 * @name Register FMC_PFB1CR, field B1SEBE[0] (RW)
 *
 * This bit controls whether the single entry buffer is enabled in response to
 * flash read accesses. Its operation is independent from bank 0's cache. A
 * high-to-low transition of this enable forces the page buffer to be invalidated.
 *
 * Values:
 * - 0 - Single entry buffer is disabled.
 * - 1 - Single entry buffer is enabled.
 */
/*@{*/
#define BP_FMC_PFB1CR_B1SEBE (0U)          /*!< Bit position for FMC_PFB1CR_B1SEBE. */
#define BM_FMC_PFB1CR_B1SEBE (0x00000001U) /*!< Bit mask for FMC_PFB1CR_B1SEBE. */
#define BS_FMC_PFB1CR_B1SEBE (1U)          /*!< Bit field size in bits for FMC_PFB1CR_B1SEBE. */

/*! @brief Read current value of the FMC_PFB1CR_B1SEBE field. */
#define BR_FMC_PFB1CR_B1SEBE(x) (BITBAND_ACCESS32(HW_FMC_PFB1CR_ADDR(x), BP_FMC_PFB1CR_B1SEBE))

/*! @brief Format value for bitfield FMC_PFB1CR_B1SEBE. */
#define BF_FMC_PFB1CR_B1SEBE(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB1CR_B1SEBE) & BM_FMC_PFB1CR_B1SEBE)

/*! @brief Set the B1SEBE field to a new value. */
#define BW_FMC_PFB1CR_B1SEBE(x, v) (BITBAND_ACCESS32(HW_FMC_PFB1CR_ADDR(x), BP_FMC_PFB1CR_B1SEBE) = (v))
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1IPE[1] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to instruction fetches.
 *
 * Values:
 * - 0 - Do not prefetch in response to instruction fetches.
 * - 1 - Enable prefetches in response to instruction fetches.
 */
/*@{*/
#define BP_FMC_PFB1CR_B1IPE  (1U)          /*!< Bit position for FMC_PFB1CR_B1IPE. */
#define BM_FMC_PFB1CR_B1IPE  (0x00000002U) /*!< Bit mask for FMC_PFB1CR_B1IPE. */
#define BS_FMC_PFB1CR_B1IPE  (1U)          /*!< Bit field size in bits for FMC_PFB1CR_B1IPE. */

/*! @brief Read current value of the FMC_PFB1CR_B1IPE field. */
#define BR_FMC_PFB1CR_B1IPE(x) (BITBAND_ACCESS32(HW_FMC_PFB1CR_ADDR(x), BP_FMC_PFB1CR_B1IPE))

/*! @brief Format value for bitfield FMC_PFB1CR_B1IPE. */
#define BF_FMC_PFB1CR_B1IPE(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB1CR_B1IPE) & BM_FMC_PFB1CR_B1IPE)

/*! @brief Set the B1IPE field to a new value. */
#define BW_FMC_PFB1CR_B1IPE(x, v) (BITBAND_ACCESS32(HW_FMC_PFB1CR_ADDR(x), BP_FMC_PFB1CR_B1IPE) = (v))
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1DPE[2] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to data references.
 *
 * Values:
 * - 0 - Do not prefetch in response to data references.
 * - 1 - Enable prefetches in response to data references.
 */
/*@{*/
#define BP_FMC_PFB1CR_B1DPE  (2U)          /*!< Bit position for FMC_PFB1CR_B1DPE. */
#define BM_FMC_PFB1CR_B1DPE  (0x00000004U) /*!< Bit mask for FMC_PFB1CR_B1DPE. */
#define BS_FMC_PFB1CR_B1DPE  (1U)          /*!< Bit field size in bits for FMC_PFB1CR_B1DPE. */

/*! @brief Read current value of the FMC_PFB1CR_B1DPE field. */
#define BR_FMC_PFB1CR_B1DPE(x) (BITBAND_ACCESS32(HW_FMC_PFB1CR_ADDR(x), BP_FMC_PFB1CR_B1DPE))

/*! @brief Format value for bitfield FMC_PFB1CR_B1DPE. */
#define BF_FMC_PFB1CR_B1DPE(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB1CR_B1DPE) & BM_FMC_PFB1CR_B1DPE)

/*! @brief Set the B1DPE field to a new value. */
#define BW_FMC_PFB1CR_B1DPE(x, v) (BITBAND_ACCESS32(HW_FMC_PFB1CR_ADDR(x), BP_FMC_PFB1CR_B1DPE) = (v))
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1ICE[3] (RW)
 *
 * This bit controls whether instruction fetches are loaded into the cache.
 *
 * Values:
 * - 0 - Do not cache instruction fetches.
 * - 1 - Cache instruction fetches.
 */
/*@{*/
#define BP_FMC_PFB1CR_B1ICE  (3U)          /*!< Bit position for FMC_PFB1CR_B1ICE. */
#define BM_FMC_PFB1CR_B1ICE  (0x00000008U) /*!< Bit mask for FMC_PFB1CR_B1ICE. */
#define BS_FMC_PFB1CR_B1ICE  (1U)          /*!< Bit field size in bits for FMC_PFB1CR_B1ICE. */

/*! @brief Read current value of the FMC_PFB1CR_B1ICE field. */
#define BR_FMC_PFB1CR_B1ICE(x) (BITBAND_ACCESS32(HW_FMC_PFB1CR_ADDR(x), BP_FMC_PFB1CR_B1ICE))

/*! @brief Format value for bitfield FMC_PFB1CR_B1ICE. */
#define BF_FMC_PFB1CR_B1ICE(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB1CR_B1ICE) & BM_FMC_PFB1CR_B1ICE)

/*! @brief Set the B1ICE field to a new value. */
#define BW_FMC_PFB1CR_B1ICE(x, v) (BITBAND_ACCESS32(HW_FMC_PFB1CR_ADDR(x), BP_FMC_PFB1CR_B1ICE) = (v))
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1DCE[4] (RW)
 *
 * This bit controls whether data references are loaded into the cache.
 *
 * Values:
 * - 0 - Do not cache data references.
 * - 1 - Cache data references.
 */
/*@{*/
#define BP_FMC_PFB1CR_B1DCE  (4U)          /*!< Bit position for FMC_PFB1CR_B1DCE. */
#define BM_FMC_PFB1CR_B1DCE  (0x00000010U) /*!< Bit mask for FMC_PFB1CR_B1DCE. */
#define BS_FMC_PFB1CR_B1DCE  (1U)          /*!< Bit field size in bits for FMC_PFB1CR_B1DCE. */

/*! @brief Read current value of the FMC_PFB1CR_B1DCE field. */
#define BR_FMC_PFB1CR_B1DCE(x) (BITBAND_ACCESS32(HW_FMC_PFB1CR_ADDR(x), BP_FMC_PFB1CR_B1DCE))

/*! @brief Format value for bitfield FMC_PFB1CR_B1DCE. */
#define BF_FMC_PFB1CR_B1DCE(v) ((uint32_t)((uint32_t)(v) << BP_FMC_PFB1CR_B1DCE) & BM_FMC_PFB1CR_B1DCE)

/*! @brief Set the B1DCE field to a new value. */
#define BW_FMC_PFB1CR_B1DCE(x, v) (BITBAND_ACCESS32(HW_FMC_PFB1CR_ADDR(x), BP_FMC_PFB1CR_B1DCE) = (v))
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1MW[18:17] (RO)
 *
 * This read-only field defines the width of the bank 1 memory.
 *
 * Values:
 * - 00 - 32 bits
 * - 01 - 64 bits
 * - 10 - 128 bits
 * - 11 - Reserved
 */
/*@{*/
#define BP_FMC_PFB1CR_B1MW   (17U)         /*!< Bit position for FMC_PFB1CR_B1MW. */
#define BM_FMC_PFB1CR_B1MW   (0x00060000U) /*!< Bit mask for FMC_PFB1CR_B1MW. */
#define BS_FMC_PFB1CR_B1MW   (2U)          /*!< Bit field size in bits for FMC_PFB1CR_B1MW. */

/*! @brief Read current value of the FMC_PFB1CR_B1MW field. */
#define BR_FMC_PFB1CR_B1MW(x) (HW_FMC_PFB1CR(x).B.B1MW)
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1RWSC[31:28] (RO)
 *
 * This read-only field defines the number of wait states required to access the
 * bank 1 flash memory. The relationship between the read access time of the
 * flash array (expressed in system clock cycles) and RWSC is defined as: Access
 * time of flash array [system clocks] = RWSC + 1 The FMC automatically calculates
 * this value based on the ratio of the system clock speed to the flash clock
 * speed. For example, when this ratio is 4:1, the field's value is 3h.
 */
/*@{*/
#define BP_FMC_PFB1CR_B1RWSC (28U)         /*!< Bit position for FMC_PFB1CR_B1RWSC. */
#define BM_FMC_PFB1CR_B1RWSC (0xF0000000U) /*!< Bit mask for FMC_PFB1CR_B1RWSC. */
#define BS_FMC_PFB1CR_B1RWSC (4U)          /*!< Bit field size in bits for FMC_PFB1CR_B1RWSC. */

/*! @brief Read current value of the FMC_PFB1CR_B1RWSC field. */
#define BR_FMC_PFB1CR_B1RWSC(x) (HW_FMC_PFB1CR(x).B.B1RWSC)
/*@}*/

/*******************************************************************************
 * HW_FMC_TAGVDW0Sn - Cache Tag Storage
 ******************************************************************************/

/*!
 * @brief HW_FMC_TAGVDW0Sn - Cache Tag Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache is a 4-way, set-associative cache with 4 sets. The ways are
 * numbered 0-3 and the sets are numbered 0-3. In TAGVDWxSy, x denotes the way, and y
 * denotes the set. This section represents tag/vld information for all sets in the
 * indicated way.
 */
typedef union _hw_fmc_tagvdw0sn
{
    uint32_t U;
    struct _hw_fmc_tagvdw0sn_bitfields
    {
        uint32_t valid : 1;            /*!< [0] 1-bit valid for cache entry */
        uint32_t RESERVED0 : 4;        /*!< [4:1]  */
        uint32_t tag : 14;             /*!< [18:5] 14-bit tag for cache entry */
        uint32_t RESERVED1 : 13;       /*!< [31:19]  */
    } B;
} hw_fmc_tagvdw0sn_t;

/*!
 * @name Constants and macros for entire FMC_TAGVDW0Sn register
 */
/*@{*/
#define HW_FMC_TAGVDW0Sn_COUNT (4U)

#define HW_FMC_TAGVDW0Sn_ADDR(x, n) ((uint32_t)(x) + 0x100U + (0x4U * (n)))

#define HW_FMC_TAGVDW0Sn(x, n)   (*(__IO hw_fmc_tagvdw0sn_t *) HW_FMC_TAGVDW0Sn_ADDR(x, n))
#define HW_FMC_TAGVDW0Sn_RD(x, n) (HW_FMC_TAGVDW0Sn(x, n).U)
#define HW_FMC_TAGVDW0Sn_WR(x, n, v) (HW_FMC_TAGVDW0Sn(x, n).U = (v))
#define HW_FMC_TAGVDW0Sn_SET(x, n, v) (HW_FMC_TAGVDW0Sn_WR(x, n, HW_FMC_TAGVDW0Sn_RD(x, n) |  (v)))
#define HW_FMC_TAGVDW0Sn_CLR(x, n, v) (HW_FMC_TAGVDW0Sn_WR(x, n, HW_FMC_TAGVDW0Sn_RD(x, n) & ~(v)))
#define HW_FMC_TAGVDW0Sn_TOG(x, n, v) (HW_FMC_TAGVDW0Sn_WR(x, n, HW_FMC_TAGVDW0Sn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_TAGVDW0Sn bitfields
 */

/*!
 * @name Register FMC_TAGVDW0Sn, field valid[0] (RW)
 */
/*@{*/
#define BP_FMC_TAGVDW0Sn_valid (0U)        /*!< Bit position for FMC_TAGVDW0Sn_valid. */
#define BM_FMC_TAGVDW0Sn_valid (0x00000001U) /*!< Bit mask for FMC_TAGVDW0Sn_valid. */
#define BS_FMC_TAGVDW0Sn_valid (1U)        /*!< Bit field size in bits for FMC_TAGVDW0Sn_valid. */

/*! @brief Read current value of the FMC_TAGVDW0Sn_valid field. */
#define BR_FMC_TAGVDW0Sn_valid(x, n) (BITBAND_ACCESS32(HW_FMC_TAGVDW0Sn_ADDR(x, n), BP_FMC_TAGVDW0Sn_valid))

/*! @brief Format value for bitfield FMC_TAGVDW0Sn_valid. */
#define BF_FMC_TAGVDW0Sn_valid(v) ((uint32_t)((uint32_t)(v) << BP_FMC_TAGVDW0Sn_valid) & BM_FMC_TAGVDW0Sn_valid)

/*! @brief Set the valid field to a new value. */
#define BW_FMC_TAGVDW0Sn_valid(x, n, v) (BITBAND_ACCESS32(HW_FMC_TAGVDW0Sn_ADDR(x, n), BP_FMC_TAGVDW0Sn_valid) = (v))
/*@}*/

/*!
 * @name Register FMC_TAGVDW0Sn, field tag[18:5] (RW)
 */
/*@{*/
#define BP_FMC_TAGVDW0Sn_tag (5U)          /*!< Bit position for FMC_TAGVDW0Sn_tag. */
#define BM_FMC_TAGVDW0Sn_tag (0x0007FFE0U) /*!< Bit mask for FMC_TAGVDW0Sn_tag. */
#define BS_FMC_TAGVDW0Sn_tag (14U)         /*!< Bit field size in bits for FMC_TAGVDW0Sn_tag. */

/*! @brief Read current value of the FMC_TAGVDW0Sn_tag field. */
#define BR_FMC_TAGVDW0Sn_tag(x, n) (HW_FMC_TAGVDW0Sn(x, n).B.tag)

/*! @brief Format value for bitfield FMC_TAGVDW0Sn_tag. */
#define BF_FMC_TAGVDW0Sn_tag(v) ((uint32_t)((uint32_t)(v) << BP_FMC_TAGVDW0Sn_tag) & BM_FMC_TAGVDW0Sn_tag)

/*! @brief Set the tag field to a new value. */
#define BW_FMC_TAGVDW0Sn_tag(x, n, v) (HW_FMC_TAGVDW0Sn_WR(x, n, (HW_FMC_TAGVDW0Sn_RD(x, n) & ~BM_FMC_TAGVDW0Sn_tag) | BF_FMC_TAGVDW0Sn_tag(v)))
/*@}*/

/*******************************************************************************
 * HW_FMC_TAGVDW1Sn - Cache Tag Storage
 ******************************************************************************/

/*!
 * @brief HW_FMC_TAGVDW1Sn - Cache Tag Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache is a 4-way, set-associative cache with 4 sets. The ways are
 * numbered 0-3 and the sets are numbered 0-3. In TAGVDWxSy, x denotes the way, and y
 * denotes the set. This section represents tag/vld information for all sets in the
 * indicated way.
 */
typedef union _hw_fmc_tagvdw1sn
{
    uint32_t U;
    struct _hw_fmc_tagvdw1sn_bitfields
    {
        uint32_t valid : 1;            /*!< [0] 1-bit valid for cache entry */
        uint32_t RESERVED0 : 4;        /*!< [4:1]  */
        uint32_t tag : 14;             /*!< [18:5] 14-bit tag for cache entry */
        uint32_t RESERVED1 : 13;       /*!< [31:19]  */
    } B;
} hw_fmc_tagvdw1sn_t;

/*!
 * @name Constants and macros for entire FMC_TAGVDW1Sn register
 */
/*@{*/
#define HW_FMC_TAGVDW1Sn_COUNT (4U)

#define HW_FMC_TAGVDW1Sn_ADDR(x, n) ((uint32_t)(x) + 0x110U + (0x4U * (n)))

#define HW_FMC_TAGVDW1Sn(x, n)   (*(__IO hw_fmc_tagvdw1sn_t *) HW_FMC_TAGVDW1Sn_ADDR(x, n))
#define HW_FMC_TAGVDW1Sn_RD(x, n) (HW_FMC_TAGVDW1Sn(x, n).U)
#define HW_FMC_TAGVDW1Sn_WR(x, n, v) (HW_FMC_TAGVDW1Sn(x, n).U = (v))
#define HW_FMC_TAGVDW1Sn_SET(x, n, v) (HW_FMC_TAGVDW1Sn_WR(x, n, HW_FMC_TAGVDW1Sn_RD(x, n) |  (v)))
#define HW_FMC_TAGVDW1Sn_CLR(x, n, v) (HW_FMC_TAGVDW1Sn_WR(x, n, HW_FMC_TAGVDW1Sn_RD(x, n) & ~(v)))
#define HW_FMC_TAGVDW1Sn_TOG(x, n, v) (HW_FMC_TAGVDW1Sn_WR(x, n, HW_FMC_TAGVDW1Sn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_TAGVDW1Sn bitfields
 */

/*!
 * @name Register FMC_TAGVDW1Sn, field valid[0] (RW)
 */
/*@{*/
#define BP_FMC_TAGVDW1Sn_valid (0U)        /*!< Bit position for FMC_TAGVDW1Sn_valid. */
#define BM_FMC_TAGVDW1Sn_valid (0x00000001U) /*!< Bit mask for FMC_TAGVDW1Sn_valid. */
#define BS_FMC_TAGVDW1Sn_valid (1U)        /*!< Bit field size in bits for FMC_TAGVDW1Sn_valid. */

/*! @brief Read current value of the FMC_TAGVDW1Sn_valid field. */
#define BR_FMC_TAGVDW1Sn_valid(x, n) (BITBAND_ACCESS32(HW_FMC_TAGVDW1Sn_ADDR(x, n), BP_FMC_TAGVDW1Sn_valid))

/*! @brief Format value for bitfield FMC_TAGVDW1Sn_valid. */
#define BF_FMC_TAGVDW1Sn_valid(v) ((uint32_t)((uint32_t)(v) << BP_FMC_TAGVDW1Sn_valid) & BM_FMC_TAGVDW1Sn_valid)

/*! @brief Set the valid field to a new value. */
#define BW_FMC_TAGVDW1Sn_valid(x, n, v) (BITBAND_ACCESS32(HW_FMC_TAGVDW1Sn_ADDR(x, n), BP_FMC_TAGVDW1Sn_valid) = (v))
/*@}*/

/*!
 * @name Register FMC_TAGVDW1Sn, field tag[18:5] (RW)
 */
/*@{*/
#define BP_FMC_TAGVDW1Sn_tag (5U)          /*!< Bit position for FMC_TAGVDW1Sn_tag. */
#define BM_FMC_TAGVDW1Sn_tag (0x0007FFE0U) /*!< Bit mask for FMC_TAGVDW1Sn_tag. */
#define BS_FMC_TAGVDW1Sn_tag (14U)         /*!< Bit field size in bits for FMC_TAGVDW1Sn_tag. */

/*! @brief Read current value of the FMC_TAGVDW1Sn_tag field. */
#define BR_FMC_TAGVDW1Sn_tag(x, n) (HW_FMC_TAGVDW1Sn(x, n).B.tag)

/*! @brief Format value for bitfield FMC_TAGVDW1Sn_tag. */
#define BF_FMC_TAGVDW1Sn_tag(v) ((uint32_t)((uint32_t)(v) << BP_FMC_TAGVDW1Sn_tag) & BM_FMC_TAGVDW1Sn_tag)

/*! @brief Set the tag field to a new value. */
#define BW_FMC_TAGVDW1Sn_tag(x, n, v) (HW_FMC_TAGVDW1Sn_WR(x, n, (HW_FMC_TAGVDW1Sn_RD(x, n) & ~BM_FMC_TAGVDW1Sn_tag) | BF_FMC_TAGVDW1Sn_tag(v)))
/*@}*/

/*******************************************************************************
 * HW_FMC_TAGVDW2Sn - Cache Tag Storage
 ******************************************************************************/

/*!
 * @brief HW_FMC_TAGVDW2Sn - Cache Tag Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache is a 4-way, set-associative cache with 4 sets. The ways are
 * numbered 0-3 and the sets are numbered 0-3. In TAGVDWxSy, x denotes the way, and y
 * denotes the set. This section represents tag/vld information for all sets in the
 * indicated way.
 */
typedef union _hw_fmc_tagvdw2sn
{
    uint32_t U;
    struct _hw_fmc_tagvdw2sn_bitfields
    {
        uint32_t valid : 1;            /*!< [0] 1-bit valid for cache entry */
        uint32_t RESERVED0 : 4;        /*!< [4:1]  */
        uint32_t tag : 14;             /*!< [18:5] 14-bit tag for cache entry */
        uint32_t RESERVED1 : 13;       /*!< [31:19]  */
    } B;
} hw_fmc_tagvdw2sn_t;

/*!
 * @name Constants and macros for entire FMC_TAGVDW2Sn register
 */
/*@{*/
#define HW_FMC_TAGVDW2Sn_COUNT (4U)

#define HW_FMC_TAGVDW2Sn_ADDR(x, n) ((uint32_t)(x) + 0x120U + (0x4U * (n)))

#define HW_FMC_TAGVDW2Sn(x, n)   (*(__IO hw_fmc_tagvdw2sn_t *) HW_FMC_TAGVDW2Sn_ADDR(x, n))
#define HW_FMC_TAGVDW2Sn_RD(x, n) (HW_FMC_TAGVDW2Sn(x, n).U)
#define HW_FMC_TAGVDW2Sn_WR(x, n, v) (HW_FMC_TAGVDW2Sn(x, n).U = (v))
#define HW_FMC_TAGVDW2Sn_SET(x, n, v) (HW_FMC_TAGVDW2Sn_WR(x, n, HW_FMC_TAGVDW2Sn_RD(x, n) |  (v)))
#define HW_FMC_TAGVDW2Sn_CLR(x, n, v) (HW_FMC_TAGVDW2Sn_WR(x, n, HW_FMC_TAGVDW2Sn_RD(x, n) & ~(v)))
#define HW_FMC_TAGVDW2Sn_TOG(x, n, v) (HW_FMC_TAGVDW2Sn_WR(x, n, HW_FMC_TAGVDW2Sn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_TAGVDW2Sn bitfields
 */

/*!
 * @name Register FMC_TAGVDW2Sn, field valid[0] (RW)
 */
/*@{*/
#define BP_FMC_TAGVDW2Sn_valid (0U)        /*!< Bit position for FMC_TAGVDW2Sn_valid. */
#define BM_FMC_TAGVDW2Sn_valid (0x00000001U) /*!< Bit mask for FMC_TAGVDW2Sn_valid. */
#define BS_FMC_TAGVDW2Sn_valid (1U)        /*!< Bit field size in bits for FMC_TAGVDW2Sn_valid. */

/*! @brief Read current value of the FMC_TAGVDW2Sn_valid field. */
#define BR_FMC_TAGVDW2Sn_valid(x, n) (BITBAND_ACCESS32(HW_FMC_TAGVDW2Sn_ADDR(x, n), BP_FMC_TAGVDW2Sn_valid))

/*! @brief Format value for bitfield FMC_TAGVDW2Sn_valid. */
#define BF_FMC_TAGVDW2Sn_valid(v) ((uint32_t)((uint32_t)(v) << BP_FMC_TAGVDW2Sn_valid) & BM_FMC_TAGVDW2Sn_valid)

/*! @brief Set the valid field to a new value. */
#define BW_FMC_TAGVDW2Sn_valid(x, n, v) (BITBAND_ACCESS32(HW_FMC_TAGVDW2Sn_ADDR(x, n), BP_FMC_TAGVDW2Sn_valid) = (v))
/*@}*/

/*!
 * @name Register FMC_TAGVDW2Sn, field tag[18:5] (RW)
 */
/*@{*/
#define BP_FMC_TAGVDW2Sn_tag (5U)          /*!< Bit position for FMC_TAGVDW2Sn_tag. */
#define BM_FMC_TAGVDW2Sn_tag (0x0007FFE0U) /*!< Bit mask for FMC_TAGVDW2Sn_tag. */
#define BS_FMC_TAGVDW2Sn_tag (14U)         /*!< Bit field size in bits for FMC_TAGVDW2Sn_tag. */

/*! @brief Read current value of the FMC_TAGVDW2Sn_tag field. */
#define BR_FMC_TAGVDW2Sn_tag(x, n) (HW_FMC_TAGVDW2Sn(x, n).B.tag)

/*! @brief Format value for bitfield FMC_TAGVDW2Sn_tag. */
#define BF_FMC_TAGVDW2Sn_tag(v) ((uint32_t)((uint32_t)(v) << BP_FMC_TAGVDW2Sn_tag) & BM_FMC_TAGVDW2Sn_tag)

/*! @brief Set the tag field to a new value. */
#define BW_FMC_TAGVDW2Sn_tag(x, n, v) (HW_FMC_TAGVDW2Sn_WR(x, n, (HW_FMC_TAGVDW2Sn_RD(x, n) & ~BM_FMC_TAGVDW2Sn_tag) | BF_FMC_TAGVDW2Sn_tag(v)))
/*@}*/

/*******************************************************************************
 * HW_FMC_TAGVDW3Sn - Cache Tag Storage
 ******************************************************************************/

/*!
 * @brief HW_FMC_TAGVDW3Sn - Cache Tag Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache is a 4-way, set-associative cache with 4 sets. The ways are
 * numbered 0-3 and the sets are numbered 0-3. In TAGVDWxSy, x denotes the way, and y
 * denotes the set. This section represents tag/vld information for all sets in the
 * indicated way.
 */
typedef union _hw_fmc_tagvdw3sn
{
    uint32_t U;
    struct _hw_fmc_tagvdw3sn_bitfields
    {
        uint32_t valid : 1;            /*!< [0] 1-bit valid for cache entry */
        uint32_t RESERVED0 : 4;        /*!< [4:1]  */
        uint32_t tag : 14;             /*!< [18:5] 14-bit tag for cache entry */
        uint32_t RESERVED1 : 13;       /*!< [31:19]  */
    } B;
} hw_fmc_tagvdw3sn_t;

/*!
 * @name Constants and macros for entire FMC_TAGVDW3Sn register
 */
/*@{*/
#define HW_FMC_TAGVDW3Sn_COUNT (4U)

#define HW_FMC_TAGVDW3Sn_ADDR(x, n) ((uint32_t)(x) + 0x130U + (0x4U * (n)))

#define HW_FMC_TAGVDW3Sn(x, n)   (*(__IO hw_fmc_tagvdw3sn_t *) HW_FMC_TAGVDW3Sn_ADDR(x, n))
#define HW_FMC_TAGVDW3Sn_RD(x, n) (HW_FMC_TAGVDW3Sn(x, n).U)
#define HW_FMC_TAGVDW3Sn_WR(x, n, v) (HW_FMC_TAGVDW3Sn(x, n).U = (v))
#define HW_FMC_TAGVDW3Sn_SET(x, n, v) (HW_FMC_TAGVDW3Sn_WR(x, n, HW_FMC_TAGVDW3Sn_RD(x, n) |  (v)))
#define HW_FMC_TAGVDW3Sn_CLR(x, n, v) (HW_FMC_TAGVDW3Sn_WR(x, n, HW_FMC_TAGVDW3Sn_RD(x, n) & ~(v)))
#define HW_FMC_TAGVDW3Sn_TOG(x, n, v) (HW_FMC_TAGVDW3Sn_WR(x, n, HW_FMC_TAGVDW3Sn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_TAGVDW3Sn bitfields
 */

/*!
 * @name Register FMC_TAGVDW3Sn, field valid[0] (RW)
 */
/*@{*/
#define BP_FMC_TAGVDW3Sn_valid (0U)        /*!< Bit position for FMC_TAGVDW3Sn_valid. */
#define BM_FMC_TAGVDW3Sn_valid (0x00000001U) /*!< Bit mask for FMC_TAGVDW3Sn_valid. */
#define BS_FMC_TAGVDW3Sn_valid (1U)        /*!< Bit field size in bits for FMC_TAGVDW3Sn_valid. */

/*! @brief Read current value of the FMC_TAGVDW3Sn_valid field. */
#define BR_FMC_TAGVDW3Sn_valid(x, n) (BITBAND_ACCESS32(HW_FMC_TAGVDW3Sn_ADDR(x, n), BP_FMC_TAGVDW3Sn_valid))

/*! @brief Format value for bitfield FMC_TAGVDW3Sn_valid. */
#define BF_FMC_TAGVDW3Sn_valid(v) ((uint32_t)((uint32_t)(v) << BP_FMC_TAGVDW3Sn_valid) & BM_FMC_TAGVDW3Sn_valid)

/*! @brief Set the valid field to a new value. */
#define BW_FMC_TAGVDW3Sn_valid(x, n, v) (BITBAND_ACCESS32(HW_FMC_TAGVDW3Sn_ADDR(x, n), BP_FMC_TAGVDW3Sn_valid) = (v))
/*@}*/

/*!
 * @name Register FMC_TAGVDW3Sn, field tag[18:5] (RW)
 */
/*@{*/
#define BP_FMC_TAGVDW3Sn_tag (5U)          /*!< Bit position for FMC_TAGVDW3Sn_tag. */
#define BM_FMC_TAGVDW3Sn_tag (0x0007FFE0U) /*!< Bit mask for FMC_TAGVDW3Sn_tag. */
#define BS_FMC_TAGVDW3Sn_tag (14U)         /*!< Bit field size in bits for FMC_TAGVDW3Sn_tag. */

/*! @brief Read current value of the FMC_TAGVDW3Sn_tag field. */
#define BR_FMC_TAGVDW3Sn_tag(x, n) (HW_FMC_TAGVDW3Sn(x, n).B.tag)

/*! @brief Format value for bitfield FMC_TAGVDW3Sn_tag. */
#define BF_FMC_TAGVDW3Sn_tag(v) ((uint32_t)((uint32_t)(v) << BP_FMC_TAGVDW3Sn_tag) & BM_FMC_TAGVDW3Sn_tag)

/*! @brief Set the tag field to a new value. */
#define BW_FMC_TAGVDW3Sn_tag(x, n, v) (HW_FMC_TAGVDW3Sn_WR(x, n, (HW_FMC_TAGVDW3Sn_RD(x, n) & ~BM_FMC_TAGVDW3Sn_tag) | BF_FMC_TAGVDW3Sn_tag(v)))
/*@}*/

/*******************************************************************************
 * HW_FMC_DATAW0SnU - Cache Data Storage (upper word)
 ******************************************************************************/

/*!
 * @brief HW_FMC_DATAW0SnU - Cache Data Storage (upper word) (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of 64-bit entries is a 4-way, set-associative cache with 4 sets.
 * The ways are numbered 0-3 and the sets are numbered 0-3. In DATAWxSyU and
 * DATAWxSyL, x denotes the way, y denotes the set, and U and L represent upper and
 * lower word, respectively. This section represents data for the upper word (bits
 * [63:32]) of all sets in the indicated way.
 */
typedef union _hw_fmc_dataw0snu
{
    uint32_t U;
    struct _hw_fmc_dataw0snu_bitfields
    {
        uint32_t data : 32;            /*!< [31:0] Bits [63:32] of data entry */
    } B;
} hw_fmc_dataw0snu_t;

/*!
 * @name Constants and macros for entire FMC_DATAW0SnU register
 */
/*@{*/
#define HW_FMC_DATAW0SnU_COUNT (4U)

#define HW_FMC_DATAW0SnU_ADDR(x, n) ((uint32_t)(x) + 0x200U + (0x8U * (n)))

#define HW_FMC_DATAW0SnU(x, n)   (*(__IO hw_fmc_dataw0snu_t *) HW_FMC_DATAW0SnU_ADDR(x, n))
#define HW_FMC_DATAW0SnU_RD(x, n) (HW_FMC_DATAW0SnU(x, n).U)
#define HW_FMC_DATAW0SnU_WR(x, n, v) (HW_FMC_DATAW0SnU(x, n).U = (v))
#define HW_FMC_DATAW0SnU_SET(x, n, v) (HW_FMC_DATAW0SnU_WR(x, n, HW_FMC_DATAW0SnU_RD(x, n) |  (v)))
#define HW_FMC_DATAW0SnU_CLR(x, n, v) (HW_FMC_DATAW0SnU_WR(x, n, HW_FMC_DATAW0SnU_RD(x, n) & ~(v)))
#define HW_FMC_DATAW0SnU_TOG(x, n, v) (HW_FMC_DATAW0SnU_WR(x, n, HW_FMC_DATAW0SnU_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_DATAW0SnU bitfields
 */

/*!
 * @name Register FMC_DATAW0SnU, field data[31:0] (RW)
 */
/*@{*/
#define BP_FMC_DATAW0SnU_data (0U)         /*!< Bit position for FMC_DATAW0SnU_data. */
#define BM_FMC_DATAW0SnU_data (0xFFFFFFFFU) /*!< Bit mask for FMC_DATAW0SnU_data. */
#define BS_FMC_DATAW0SnU_data (32U)        /*!< Bit field size in bits for FMC_DATAW0SnU_data. */

/*! @brief Read current value of the FMC_DATAW0SnU_data field. */
#define BR_FMC_DATAW0SnU_data(x, n) (HW_FMC_DATAW0SnU(x, n).U)

/*! @brief Format value for bitfield FMC_DATAW0SnU_data. */
#define BF_FMC_DATAW0SnU_data(v) ((uint32_t)((uint32_t)(v) << BP_FMC_DATAW0SnU_data) & BM_FMC_DATAW0SnU_data)

/*! @brief Set the data field to a new value. */
#define BW_FMC_DATAW0SnU_data(x, n, v) (HW_FMC_DATAW0SnU_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_FMC_DATAW0SnL - Cache Data Storage (lower word)
 ******************************************************************************/

/*!
 * @brief HW_FMC_DATAW0SnL - Cache Data Storage (lower word) (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of 64-bit entries is a 4-way, set-associative cache with 4 sets.
 * The ways are numbered 0-3 and the sets are numbered 0-3. In DATAWxSyU and
 * DATAWxSyL, x denotes the way, y denotes the set, and U and L represent upper and
 * lower word, respectively. This section represents data for the lower word (bits
 * [31:0]) of all sets in the indicated way.
 */
typedef union _hw_fmc_dataw0snl
{
    uint32_t U;
    struct _hw_fmc_dataw0snl_bitfields
    {
        uint32_t data : 32;            /*!< [31:0] Bits [31:0] of data entry */
    } B;
} hw_fmc_dataw0snl_t;

/*!
 * @name Constants and macros for entire FMC_DATAW0SnL register
 */
/*@{*/
#define HW_FMC_DATAW0SnL_COUNT (4U)

#define HW_FMC_DATAW0SnL_ADDR(x, n) ((uint32_t)(x) + 0x204U + (0x8U * (n)))

#define HW_FMC_DATAW0SnL(x, n)   (*(__IO hw_fmc_dataw0snl_t *) HW_FMC_DATAW0SnL_ADDR(x, n))
#define HW_FMC_DATAW0SnL_RD(x, n) (HW_FMC_DATAW0SnL(x, n).U)
#define HW_FMC_DATAW0SnL_WR(x, n, v) (HW_FMC_DATAW0SnL(x, n).U = (v))
#define HW_FMC_DATAW0SnL_SET(x, n, v) (HW_FMC_DATAW0SnL_WR(x, n, HW_FMC_DATAW0SnL_RD(x, n) |  (v)))
#define HW_FMC_DATAW0SnL_CLR(x, n, v) (HW_FMC_DATAW0SnL_WR(x, n, HW_FMC_DATAW0SnL_RD(x, n) & ~(v)))
#define HW_FMC_DATAW0SnL_TOG(x, n, v) (HW_FMC_DATAW0SnL_WR(x, n, HW_FMC_DATAW0SnL_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_DATAW0SnL bitfields
 */

/*!
 * @name Register FMC_DATAW0SnL, field data[31:0] (RW)
 */
/*@{*/
#define BP_FMC_DATAW0SnL_data (0U)         /*!< Bit position for FMC_DATAW0SnL_data. */
#define BM_FMC_DATAW0SnL_data (0xFFFFFFFFU) /*!< Bit mask for FMC_DATAW0SnL_data. */
#define BS_FMC_DATAW0SnL_data (32U)        /*!< Bit field size in bits for FMC_DATAW0SnL_data. */

/*! @brief Read current value of the FMC_DATAW0SnL_data field. */
#define BR_FMC_DATAW0SnL_data(x, n) (HW_FMC_DATAW0SnL(x, n).U)

/*! @brief Format value for bitfield FMC_DATAW0SnL_data. */
#define BF_FMC_DATAW0SnL_data(v) ((uint32_t)((uint32_t)(v) << BP_FMC_DATAW0SnL_data) & BM_FMC_DATAW0SnL_data)

/*! @brief Set the data field to a new value. */
#define BW_FMC_DATAW0SnL_data(x, n, v) (HW_FMC_DATAW0SnL_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * HW_FMC_DATAW1SnU - Cache Data Storage (upper word)
 ******************************************************************************/

/*!
 * @brief HW_FMC_DATAW1SnU - Cache Data Storage (upper word) (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of 64-bit entries is a 4-way, set-associative cache with 4 sets.
 * The ways are numbered 0-3 and the sets are numbered 0-3. In DATAWxSyU and
 * DATAWxSyL, x denotes the way, y denotes the set, and U and L represent upper and
 * lower word, respectively. This section represents data for the upper word (bits
 * [63:32]) of all sets in the indicated way.
 */
typedef union _hw_fmc_dataw1snu
{
    uint32_t U;
    struct _hw_fmc_dataw1snu_bitfields
    {
        uint32_t data : 32;            /*!< [31:0] Bits [63:32] of data entry */
    } B;
} hw_fmc_dataw1snu_t;

/*!
 * @name Constants and macros for entire FMC_DATAW1SnU register
 */
/*@{*/
#define HW_FMC_DATAW1SnU_COUNT (4U)

#define HW_FMC_DATAW1SnU_ADDR(x, n) ((uint32_t)(x) + 0x220U + (0x8U * (n)))

#define HW_FMC_DATAW1SnU(x, n)   (*(__IO hw_fmc_dataw1snu_t *) HW_FMC_DATAW1SnU_ADDR(x, n))
#define HW_FMC_DATAW1SnU_RD(x, n) (HW_FMC_DATAW1SnU(x, n).U)
#define HW_FMC_DATAW1SnU_WR(x, n, v) (HW_FMC_DATAW1SnU(x, n).U = (v))
#define HW_FMC_DATAW1SnU_SET(x, n, v) (HW_FMC_DATAW1SnU_WR(x, n, HW_FMC_DATAW1SnU_RD(x, n) |  (v)))
#define HW_FMC_DATAW1SnU_CLR(x, n, v) (HW_FMC_DATAW1SnU_WR(x, n, HW_FMC_DATAW1SnU_RD(x, n) & ~(v)))
#define HW_FMC_DATAW1SnU_TOG(x, n, v) (HW_FMC_DATAW1SnU_WR(x, n, HW_FMC_DATAW1SnU_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_DATAW1SnU bitfields
 */

/*!
 * @name Register FMC_DATAW1SnU, field data[31:0] (RW)
 */
/*@{*/
#define BP_FMC_DATAW1SnU_data (0U)         /*!< Bit position for FMC_DATAW1SnU_data. */
#define BM_FMC_DATAW1SnU_data (0xFFFFFFFFU) /*!< Bit mask for FMC_DATAW1SnU_data. */
#define BS_FMC_DATAW1SnU_data (32U)        /*!< Bit field size in bits for FMC_DATAW1SnU_data. */

/*! @brief Read current value of the FMC_DATAW1SnU_data field. */
#define BR_FMC_DATAW1SnU_data(x, n) (HW_FMC_DATAW1SnU(x, n).U)

/*! @brief Format value for bitfield FMC_DATAW1SnU_data. */
#define BF_FMC_DATAW1SnU_data(v) ((uint32_t)((uint32_t)(v) << BP_FMC_DATAW1SnU_data) & BM_FMC_DATAW1SnU_data)

/*! @brief Set the data field to a new value. */
#define BW_FMC_DATAW1SnU_data(x, n, v) (HW_FMC_DATAW1SnU_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_FMC_DATAW1SnL - Cache Data Storage (lower word)
 ******************************************************************************/

/*!
 * @brief HW_FMC_DATAW1SnL - Cache Data Storage (lower word) (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of 64-bit entries is a 4-way, set-associative cache with 4 sets.
 * The ways are numbered 0-3 and the sets are numbered 0-3. In DATAWxSyU and
 * DATAWxSyL, x denotes the way, y denotes the set, and U and L represent upper and
 * lower word, respectively. This section represents data for the lower word (bits
 * [31:0]) of all sets in the indicated way.
 */
typedef union _hw_fmc_dataw1snl
{
    uint32_t U;
    struct _hw_fmc_dataw1snl_bitfields
    {
        uint32_t data : 32;            /*!< [31:0] Bits [31:0] of data entry */
    } B;
} hw_fmc_dataw1snl_t;

/*!
 * @name Constants and macros for entire FMC_DATAW1SnL register
 */
/*@{*/
#define HW_FMC_DATAW1SnL_COUNT (4U)

#define HW_FMC_DATAW1SnL_ADDR(x, n) ((uint32_t)(x) + 0x224U + (0x8U * (n)))

#define HW_FMC_DATAW1SnL(x, n)   (*(__IO hw_fmc_dataw1snl_t *) HW_FMC_DATAW1SnL_ADDR(x, n))
#define HW_FMC_DATAW1SnL_RD(x, n) (HW_FMC_DATAW1SnL(x, n).U)
#define HW_FMC_DATAW1SnL_WR(x, n, v) (HW_FMC_DATAW1SnL(x, n).U = (v))
#define HW_FMC_DATAW1SnL_SET(x, n, v) (HW_FMC_DATAW1SnL_WR(x, n, HW_FMC_DATAW1SnL_RD(x, n) |  (v)))
#define HW_FMC_DATAW1SnL_CLR(x, n, v) (HW_FMC_DATAW1SnL_WR(x, n, HW_FMC_DATAW1SnL_RD(x, n) & ~(v)))
#define HW_FMC_DATAW1SnL_TOG(x, n, v) (HW_FMC_DATAW1SnL_WR(x, n, HW_FMC_DATAW1SnL_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_DATAW1SnL bitfields
 */

/*!
 * @name Register FMC_DATAW1SnL, field data[31:0] (RW)
 */
/*@{*/
#define BP_FMC_DATAW1SnL_data (0U)         /*!< Bit position for FMC_DATAW1SnL_data. */
#define BM_FMC_DATAW1SnL_data (0xFFFFFFFFU) /*!< Bit mask for FMC_DATAW1SnL_data. */
#define BS_FMC_DATAW1SnL_data (32U)        /*!< Bit field size in bits for FMC_DATAW1SnL_data. */

/*! @brief Read current value of the FMC_DATAW1SnL_data field. */
#define BR_FMC_DATAW1SnL_data(x, n) (HW_FMC_DATAW1SnL(x, n).U)

/*! @brief Format value for bitfield FMC_DATAW1SnL_data. */
#define BF_FMC_DATAW1SnL_data(v) ((uint32_t)((uint32_t)(v) << BP_FMC_DATAW1SnL_data) & BM_FMC_DATAW1SnL_data)

/*! @brief Set the data field to a new value. */
#define BW_FMC_DATAW1SnL_data(x, n, v) (HW_FMC_DATAW1SnL_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * HW_FMC_DATAW2SnU - Cache Data Storage (upper word)
 ******************************************************************************/

/*!
 * @brief HW_FMC_DATAW2SnU - Cache Data Storage (upper word) (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of 64-bit entries is a 4-way, set-associative cache with 4 sets.
 * The ways are numbered 0-3 and the sets are numbered 0-3. In DATAWxSyU and
 * DATAWxSyL, x denotes the way, y denotes the set, and U and L represent upper and
 * lower word, respectively. This section represents data for the upper word (bits
 * [63:32]) of all sets in the indicated way.
 */
typedef union _hw_fmc_dataw2snu
{
    uint32_t U;
    struct _hw_fmc_dataw2snu_bitfields
    {
        uint32_t data : 32;            /*!< [31:0] Bits [63:32] of data entry */
    } B;
} hw_fmc_dataw2snu_t;

/*!
 * @name Constants and macros for entire FMC_DATAW2SnU register
 */
/*@{*/
#define HW_FMC_DATAW2SnU_COUNT (4U)

#define HW_FMC_DATAW2SnU_ADDR(x, n) ((uint32_t)(x) + 0x240U + (0x8U * (n)))

#define HW_FMC_DATAW2SnU(x, n)   (*(__IO hw_fmc_dataw2snu_t *) HW_FMC_DATAW2SnU_ADDR(x, n))
#define HW_FMC_DATAW2SnU_RD(x, n) (HW_FMC_DATAW2SnU(x, n).U)
#define HW_FMC_DATAW2SnU_WR(x, n, v) (HW_FMC_DATAW2SnU(x, n).U = (v))
#define HW_FMC_DATAW2SnU_SET(x, n, v) (HW_FMC_DATAW2SnU_WR(x, n, HW_FMC_DATAW2SnU_RD(x, n) |  (v)))
#define HW_FMC_DATAW2SnU_CLR(x, n, v) (HW_FMC_DATAW2SnU_WR(x, n, HW_FMC_DATAW2SnU_RD(x, n) & ~(v)))
#define HW_FMC_DATAW2SnU_TOG(x, n, v) (HW_FMC_DATAW2SnU_WR(x, n, HW_FMC_DATAW2SnU_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_DATAW2SnU bitfields
 */

/*!
 * @name Register FMC_DATAW2SnU, field data[31:0] (RW)
 */
/*@{*/
#define BP_FMC_DATAW2SnU_data (0U)         /*!< Bit position for FMC_DATAW2SnU_data. */
#define BM_FMC_DATAW2SnU_data (0xFFFFFFFFU) /*!< Bit mask for FMC_DATAW2SnU_data. */
#define BS_FMC_DATAW2SnU_data (32U)        /*!< Bit field size in bits for FMC_DATAW2SnU_data. */

/*! @brief Read current value of the FMC_DATAW2SnU_data field. */
#define BR_FMC_DATAW2SnU_data(x, n) (HW_FMC_DATAW2SnU(x, n).U)

/*! @brief Format value for bitfield FMC_DATAW2SnU_data. */
#define BF_FMC_DATAW2SnU_data(v) ((uint32_t)((uint32_t)(v) << BP_FMC_DATAW2SnU_data) & BM_FMC_DATAW2SnU_data)

/*! @brief Set the data field to a new value. */
#define BW_FMC_DATAW2SnU_data(x, n, v) (HW_FMC_DATAW2SnU_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_FMC_DATAW2SnL - Cache Data Storage (lower word)
 ******************************************************************************/

/*!
 * @brief HW_FMC_DATAW2SnL - Cache Data Storage (lower word) (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of 64-bit entries is a 4-way, set-associative cache with 4 sets.
 * The ways are numbered 0-3 and the sets are numbered 0-3. In DATAWxSyU and
 * DATAWxSyL, x denotes the way, y denotes the set, and U and L represent upper and
 * lower word, respectively. This section represents data for the lower word (bits
 * [31:0]) of all sets in the indicated way.
 */
typedef union _hw_fmc_dataw2snl
{
    uint32_t U;
    struct _hw_fmc_dataw2snl_bitfields
    {
        uint32_t data : 32;            /*!< [31:0] Bits [31:0] of data entry */
    } B;
} hw_fmc_dataw2snl_t;

/*!
 * @name Constants and macros for entire FMC_DATAW2SnL register
 */
/*@{*/
#define HW_FMC_DATAW2SnL_COUNT (4U)

#define HW_FMC_DATAW2SnL_ADDR(x, n) ((uint32_t)(x) + 0x244U + (0x8U * (n)))

#define HW_FMC_DATAW2SnL(x, n)   (*(__IO hw_fmc_dataw2snl_t *) HW_FMC_DATAW2SnL_ADDR(x, n))
#define HW_FMC_DATAW2SnL_RD(x, n) (HW_FMC_DATAW2SnL(x, n).U)
#define HW_FMC_DATAW2SnL_WR(x, n, v) (HW_FMC_DATAW2SnL(x, n).U = (v))
#define HW_FMC_DATAW2SnL_SET(x, n, v) (HW_FMC_DATAW2SnL_WR(x, n, HW_FMC_DATAW2SnL_RD(x, n) |  (v)))
#define HW_FMC_DATAW2SnL_CLR(x, n, v) (HW_FMC_DATAW2SnL_WR(x, n, HW_FMC_DATAW2SnL_RD(x, n) & ~(v)))
#define HW_FMC_DATAW2SnL_TOG(x, n, v) (HW_FMC_DATAW2SnL_WR(x, n, HW_FMC_DATAW2SnL_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_DATAW2SnL bitfields
 */

/*!
 * @name Register FMC_DATAW2SnL, field data[31:0] (RW)
 */
/*@{*/
#define BP_FMC_DATAW2SnL_data (0U)         /*!< Bit position for FMC_DATAW2SnL_data. */
#define BM_FMC_DATAW2SnL_data (0xFFFFFFFFU) /*!< Bit mask for FMC_DATAW2SnL_data. */
#define BS_FMC_DATAW2SnL_data (32U)        /*!< Bit field size in bits for FMC_DATAW2SnL_data. */

/*! @brief Read current value of the FMC_DATAW2SnL_data field. */
#define BR_FMC_DATAW2SnL_data(x, n) (HW_FMC_DATAW2SnL(x, n).U)

/*! @brief Format value for bitfield FMC_DATAW2SnL_data. */
#define BF_FMC_DATAW2SnL_data(v) ((uint32_t)((uint32_t)(v) << BP_FMC_DATAW2SnL_data) & BM_FMC_DATAW2SnL_data)

/*! @brief Set the data field to a new value. */
#define BW_FMC_DATAW2SnL_data(x, n, v) (HW_FMC_DATAW2SnL_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * HW_FMC_DATAW3SnU - Cache Data Storage (upper word)
 ******************************************************************************/

/*!
 * @brief HW_FMC_DATAW3SnU - Cache Data Storage (upper word) (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of 64-bit entries is a 4-way, set-associative cache with 4 sets.
 * The ways are numbered 0-3 and the sets are numbered 0-3. In DATAWxSyU and
 * DATAWxSyL, x denotes the way, y denotes the set, and U and L represent upper and
 * lower word, respectively. This section represents data for the upper word (bits
 * [63:32]) of all sets in the indicated way.
 */
typedef union _hw_fmc_dataw3snu
{
    uint32_t U;
    struct _hw_fmc_dataw3snu_bitfields
    {
        uint32_t data : 32;            /*!< [31:0] Bits [63:32] of data entry */
    } B;
} hw_fmc_dataw3snu_t;

/*!
 * @name Constants and macros for entire FMC_DATAW3SnU register
 */
/*@{*/
#define HW_FMC_DATAW3SnU_COUNT (4U)

#define HW_FMC_DATAW3SnU_ADDR(x, n) ((uint32_t)(x) + 0x260U + (0x8U * (n)))

#define HW_FMC_DATAW3SnU(x, n)   (*(__IO hw_fmc_dataw3snu_t *) HW_FMC_DATAW3SnU_ADDR(x, n))
#define HW_FMC_DATAW3SnU_RD(x, n) (HW_FMC_DATAW3SnU(x, n).U)
#define HW_FMC_DATAW3SnU_WR(x, n, v) (HW_FMC_DATAW3SnU(x, n).U = (v))
#define HW_FMC_DATAW3SnU_SET(x, n, v) (HW_FMC_DATAW3SnU_WR(x, n, HW_FMC_DATAW3SnU_RD(x, n) |  (v)))
#define HW_FMC_DATAW3SnU_CLR(x, n, v) (HW_FMC_DATAW3SnU_WR(x, n, HW_FMC_DATAW3SnU_RD(x, n) & ~(v)))
#define HW_FMC_DATAW3SnU_TOG(x, n, v) (HW_FMC_DATAW3SnU_WR(x, n, HW_FMC_DATAW3SnU_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_DATAW3SnU bitfields
 */

/*!
 * @name Register FMC_DATAW3SnU, field data[31:0] (RW)
 */
/*@{*/
#define BP_FMC_DATAW3SnU_data (0U)         /*!< Bit position for FMC_DATAW3SnU_data. */
#define BM_FMC_DATAW3SnU_data (0xFFFFFFFFU) /*!< Bit mask for FMC_DATAW3SnU_data. */
#define BS_FMC_DATAW3SnU_data (32U)        /*!< Bit field size in bits for FMC_DATAW3SnU_data. */

/*! @brief Read current value of the FMC_DATAW3SnU_data field. */
#define BR_FMC_DATAW3SnU_data(x, n) (HW_FMC_DATAW3SnU(x, n).U)

/*! @brief Format value for bitfield FMC_DATAW3SnU_data. */
#define BF_FMC_DATAW3SnU_data(v) ((uint32_t)((uint32_t)(v) << BP_FMC_DATAW3SnU_data) & BM_FMC_DATAW3SnU_data)

/*! @brief Set the data field to a new value. */
#define BW_FMC_DATAW3SnU_data(x, n, v) (HW_FMC_DATAW3SnU_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_FMC_DATAW3SnL - Cache Data Storage (lower word)
 ******************************************************************************/

/*!
 * @brief HW_FMC_DATAW3SnL - Cache Data Storage (lower word) (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of 64-bit entries is a 4-way, set-associative cache with 4 sets.
 * The ways are numbered 0-3 and the sets are numbered 0-3. In DATAWxSyU and
 * DATAWxSyL, x denotes the way, y denotes the set, and U and L represent upper and
 * lower word, respectively. This section represents data for the lower word (bits
 * [31:0]) of all sets in the indicated way.
 */
typedef union _hw_fmc_dataw3snl
{
    uint32_t U;
    struct _hw_fmc_dataw3snl_bitfields
    {
        uint32_t data : 32;            /*!< [31:0] Bits [31:0] of data entry */
    } B;
} hw_fmc_dataw3snl_t;

/*!
 * @name Constants and macros for entire FMC_DATAW3SnL register
 */
/*@{*/
#define HW_FMC_DATAW3SnL_COUNT (4U)

#define HW_FMC_DATAW3SnL_ADDR(x, n) ((uint32_t)(x) + 0x264U + (0x8U * (n)))

#define HW_FMC_DATAW3SnL(x, n)   (*(__IO hw_fmc_dataw3snl_t *) HW_FMC_DATAW3SnL_ADDR(x, n))
#define HW_FMC_DATAW3SnL_RD(x, n) (HW_FMC_DATAW3SnL(x, n).U)
#define HW_FMC_DATAW3SnL_WR(x, n, v) (HW_FMC_DATAW3SnL(x, n).U = (v))
#define HW_FMC_DATAW3SnL_SET(x, n, v) (HW_FMC_DATAW3SnL_WR(x, n, HW_FMC_DATAW3SnL_RD(x, n) |  (v)))
#define HW_FMC_DATAW3SnL_CLR(x, n, v) (HW_FMC_DATAW3SnL_WR(x, n, HW_FMC_DATAW3SnL_RD(x, n) & ~(v)))
#define HW_FMC_DATAW3SnL_TOG(x, n, v) (HW_FMC_DATAW3SnL_WR(x, n, HW_FMC_DATAW3SnL_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FMC_DATAW3SnL bitfields
 */

/*!
 * @name Register FMC_DATAW3SnL, field data[31:0] (RW)
 */
/*@{*/
#define BP_FMC_DATAW3SnL_data (0U)         /*!< Bit position for FMC_DATAW3SnL_data. */
#define BM_FMC_DATAW3SnL_data (0xFFFFFFFFU) /*!< Bit mask for FMC_DATAW3SnL_data. */
#define BS_FMC_DATAW3SnL_data (32U)        /*!< Bit field size in bits for FMC_DATAW3SnL_data. */

/*! @brief Read current value of the FMC_DATAW3SnL_data field. */
#define BR_FMC_DATAW3SnL_data(x, n) (HW_FMC_DATAW3SnL(x, n).U)

/*! @brief Format value for bitfield FMC_DATAW3SnL_data. */
#define BF_FMC_DATAW3SnL_data(v) ((uint32_t)((uint32_t)(v) << BP_FMC_DATAW3SnL_data) & BM_FMC_DATAW3SnL_data)

/*! @brief Set the data field to a new value. */
#define BW_FMC_DATAW3SnL_data(x, n, v) (HW_FMC_DATAW3SnL_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * hw_fmc_t - module struct
 ******************************************************************************/
/*!
 * @brief All FMC module registers.
 */
#pragma pack(1)
typedef struct _hw_fmc
{
    __IO hw_fmc_pfapr_t PFAPR;             /*!< [0x0] Flash Access Protection Register */
    __IO hw_fmc_pfb0cr_t PFB0CR;           /*!< [0x4] Flash Bank 0 Control Register */
    __IO hw_fmc_pfb1cr_t PFB1CR;           /*!< [0x8] Flash Bank 1 Control Register */
    uint8_t _reserved0[244];
    __IO hw_fmc_tagvdw0sn_t TAGVDW0Sn[4];  /*!< [0x100] Cache Tag Storage */
    __IO hw_fmc_tagvdw1sn_t TAGVDW1Sn[4];  /*!< [0x110] Cache Tag Storage */
    __IO hw_fmc_tagvdw2sn_t TAGVDW2Sn[4];  /*!< [0x120] Cache Tag Storage */
    __IO hw_fmc_tagvdw3sn_t TAGVDW3Sn[4];  /*!< [0x130] Cache Tag Storage */
    uint8_t _reserved1[192];
    struct {
        __IO hw_fmc_dataw0snu_t DATAW0SnU; /*!< [0x200] Cache Data Storage (upper word) */
        __IO hw_fmc_dataw0snl_t DATAW0SnL; /*!< [0x204] Cache Data Storage (lower word) */
    } DATAW0Sn[4];
    struct {
        __IO hw_fmc_dataw1snu_t DATAW1SnU; /*!< [0x220] Cache Data Storage (upper word) */
        __IO hw_fmc_dataw1snl_t DATAW1SnL; /*!< [0x224] Cache Data Storage (lower word) */
    } DATAW1Sn[4];
    struct {
        __IO hw_fmc_dataw2snu_t DATAW2SnU; /*!< [0x240] Cache Data Storage (upper word) */
        __IO hw_fmc_dataw2snl_t DATAW2SnL; /*!< [0x244] Cache Data Storage (lower word) */
    } DATAW2Sn[4];
    struct {
        __IO hw_fmc_dataw3snu_t DATAW3SnU; /*!< [0x260] Cache Data Storage (upper word) */
        __IO hw_fmc_dataw3snl_t DATAW3SnL; /*!< [0x264] Cache Data Storage (lower word) */
    } DATAW3Sn[4];
} hw_fmc_t;
#pragma pack()

/*! @brief Macro to access all FMC registers. */
/*! @param x FMC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_FMC_REGS(FMC_BASE)</code>. */
#define HW_FMC_REGS(x) (*(hw_fmc_t *)(x))

/*
 * MK64F12 FTFE
 *
 * Flash Memory Interface
 *
 * Registers defined in this header file:
 * - HW_FTFE_FSTAT - Flash Status Register
 * - HW_FTFE_FCNFG - Flash Configuration Register
 * - HW_FTFE_FSEC - Flash Security Register
 * - HW_FTFE_FOPT - Flash Option Register
 * - HW_FTFE_FCCOB3 - Flash Common Command Object Registers
 * - HW_FTFE_FCCOB2 - Flash Common Command Object Registers
 * - HW_FTFE_FCCOB1 - Flash Common Command Object Registers
 * - HW_FTFE_FCCOB0 - Flash Common Command Object Registers
 * - HW_FTFE_FCCOB7 - Flash Common Command Object Registers
 * - HW_FTFE_FCCOB6 - Flash Common Command Object Registers
 * - HW_FTFE_FCCOB5 - Flash Common Command Object Registers
 * - HW_FTFE_FCCOB4 - Flash Common Command Object Registers
 * - HW_FTFE_FCCOBB - Flash Common Command Object Registers
 * - HW_FTFE_FCCOBA - Flash Common Command Object Registers
 * - HW_FTFE_FCCOB9 - Flash Common Command Object Registers
 * - HW_FTFE_FCCOB8 - Flash Common Command Object Registers
 * - HW_FTFE_FPROT3 - Program Flash Protection Registers
 * - HW_FTFE_FPROT2 - Program Flash Protection Registers
 * - HW_FTFE_FPROT1 - Program Flash Protection Registers
 * - HW_FTFE_FPROT0 - Program Flash Protection Registers
 * - HW_FTFE_FEPROT - EEPROM Protection Register
 * - HW_FTFE_FDPROT - Data Flash Protection Register
 *
 * - hw_ftfe_t - Struct containing all module registers.
 */

#define HW_FTFE_INSTANCE_COUNT (1U) /*!< Number of instances of the FTFE module. */
#define HW_FTFE (0U) /*!< Instance number for FTFE. */

/*******************************************************************************
 * HW_FTFE_FSTAT - Flash Status Register
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FSTAT - Flash Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FSTAT register reports the operational status of the FTFE module. The
 * CCIF, RDCOLERR, ACCERR, and FPVIOL bits are readable and writable. The MGSTAT0
 * bit is read only. The unassigned bits read 0 and are not writable. When set, the
 * Access Error (ACCERR) and Flash Protection Violation (FPVIOL) bits in this
 * register prevent the launch of any more commands or writes to the FlexRAM (when
 * EEERDY is set) until the flag is cleared (by writing a one to it).
 */
typedef union _hw_ftfe_fstat
{
    uint8_t U;
    struct _hw_ftfe_fstat_bitfields
    {
        uint8_t MGSTAT0 : 1;           /*!< [0] Memory Controller Command Completion
                                        * Status Flag */
        uint8_t RESERVED0 : 3;         /*!< [3:1]  */
        uint8_t FPVIOL : 1;            /*!< [4] Flash Protection Violation Flag */
        uint8_t ACCERR : 1;            /*!< [5] Flash Access Error Flag */
        uint8_t RDCOLERR : 1;          /*!< [6] FTFE Read Collision Error Flag */
        uint8_t CCIF : 1;              /*!< [7] Command Complete Interrupt Flag */
    } B;
} hw_ftfe_fstat_t;

/*!
 * @name Constants and macros for entire FTFE_FSTAT register
 */
/*@{*/
#define HW_FTFE_FSTAT_ADDR(x)    ((uint32_t)(x) + 0x0U)

#define HW_FTFE_FSTAT(x)         (*(__IO hw_ftfe_fstat_t *) HW_FTFE_FSTAT_ADDR(x))
#define HW_FTFE_FSTAT_RD(x)      (HW_FTFE_FSTAT(x).U)
#define HW_FTFE_FSTAT_WR(x, v)   (HW_FTFE_FSTAT(x).U = (v))
#define HW_FTFE_FSTAT_SET(x, v)  (HW_FTFE_FSTAT_WR(x, HW_FTFE_FSTAT_RD(x) |  (v)))
#define HW_FTFE_FSTAT_CLR(x, v)  (HW_FTFE_FSTAT_WR(x, HW_FTFE_FSTAT_RD(x) & ~(v)))
#define HW_FTFE_FSTAT_TOG(x, v)  (HW_FTFE_FSTAT_WR(x, HW_FTFE_FSTAT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FSTAT bitfields
 */

/*!
 * @name Register FTFE_FSTAT, field MGSTAT0[0] (RO)
 *
 * The MGSTAT0 status flag is set if an error is detected during execution of an
 * FTFE command or during the flash reset sequence. As a status flag, this bit
 * cannot (and need not) be cleared by the user like the other error flags in this
 * register. The value of the MGSTAT0 bit for "command-N" is valid only at the
 * end of the "command-N" execution when CCIF=1 and before the next command has
 * been launched. At some point during the execution of "command-N+1," the previous
 * result is discarded and any previous error is cleared.
 */
/*@{*/
#define BP_FTFE_FSTAT_MGSTAT0 (0U)         /*!< Bit position for FTFE_FSTAT_MGSTAT0. */
#define BM_FTFE_FSTAT_MGSTAT0 (0x01U)      /*!< Bit mask for FTFE_FSTAT_MGSTAT0. */
#define BS_FTFE_FSTAT_MGSTAT0 (1U)         /*!< Bit field size in bits for FTFE_FSTAT_MGSTAT0. */

/*! @brief Read current value of the FTFE_FSTAT_MGSTAT0 field. */
#define BR_FTFE_FSTAT_MGSTAT0(x) (BITBAND_ACCESS8(HW_FTFE_FSTAT_ADDR(x), BP_FTFE_FSTAT_MGSTAT0))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field FPVIOL[4] (W1C)
 *
 * The FPVIOL error bit indicates an attempt was made to program or erase an
 * address in a protected area of program flash or data flash memory during a
 * command write sequence or a write was attempted to a protected area of the FlexRAM
 * while enabled for EEPROM. While FPVIOL is set, the CCIF flag cannot be cleared
 * to launch a command. The FPVIOL bit is cleared by writing a 1 to it. Writing a
 * 0 to the FPVIOL bit has no effect.
 *
 * Values:
 * - 0 - No protection violation detected
 * - 1 - Protection violation detected
 */
/*@{*/
#define BP_FTFE_FSTAT_FPVIOL (4U)          /*!< Bit position for FTFE_FSTAT_FPVIOL. */
#define BM_FTFE_FSTAT_FPVIOL (0x10U)       /*!< Bit mask for FTFE_FSTAT_FPVIOL. */
#define BS_FTFE_FSTAT_FPVIOL (1U)          /*!< Bit field size in bits for FTFE_FSTAT_FPVIOL. */

/*! @brief Read current value of the FTFE_FSTAT_FPVIOL field. */
#define BR_FTFE_FSTAT_FPVIOL(x) (BITBAND_ACCESS8(HW_FTFE_FSTAT_ADDR(x), BP_FTFE_FSTAT_FPVIOL))

/*! @brief Format value for bitfield FTFE_FSTAT_FPVIOL. */
#define BF_FTFE_FSTAT_FPVIOL(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FSTAT_FPVIOL) & BM_FTFE_FSTAT_FPVIOL)

/*! @brief Set the FPVIOL field to a new value. */
#define BW_FTFE_FSTAT_FPVIOL(x, v) (BITBAND_ACCESS8(HW_FTFE_FSTAT_ADDR(x), BP_FTFE_FSTAT_FPVIOL) = (v))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field ACCERR[5] (W1C)
 *
 * The ACCERR error bit indicates an illegal access has occurred to an FTFE
 * resource caused by a violation of the command write sequence or issuing an illegal
 * FTFE command. While ACCERR is set, the CCIF flag cannot be cleared to launch
 * a command. The ACCERR bit is cleared by writing a 1 to it. Writing a 0 to the
 * ACCERR bit has no effect.
 *
 * Values:
 * - 0 - No access error detected
 * - 1 - Access error detected
 */
/*@{*/
#define BP_FTFE_FSTAT_ACCERR (5U)          /*!< Bit position for FTFE_FSTAT_ACCERR. */
#define BM_FTFE_FSTAT_ACCERR (0x20U)       /*!< Bit mask for FTFE_FSTAT_ACCERR. */
#define BS_FTFE_FSTAT_ACCERR (1U)          /*!< Bit field size in bits for FTFE_FSTAT_ACCERR. */

/*! @brief Read current value of the FTFE_FSTAT_ACCERR field. */
#define BR_FTFE_FSTAT_ACCERR(x) (BITBAND_ACCESS8(HW_FTFE_FSTAT_ADDR(x), BP_FTFE_FSTAT_ACCERR))

/*! @brief Format value for bitfield FTFE_FSTAT_ACCERR. */
#define BF_FTFE_FSTAT_ACCERR(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FSTAT_ACCERR) & BM_FTFE_FSTAT_ACCERR)

/*! @brief Set the ACCERR field to a new value. */
#define BW_FTFE_FSTAT_ACCERR(x, v) (BITBAND_ACCESS8(HW_FTFE_FSTAT_ADDR(x), BP_FTFE_FSTAT_ACCERR) = (v))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field RDCOLERR[6] (W1C)
 *
 * The RDCOLERR error bit indicates that the MCU attempted a read from an FTFE
 * resource that was being manipulated by an FTFE command (CCIF=0). Any
 * simultaneous access is detected as a collision error by the block arbitration logic. The
 * read data in this case cannot be guaranteed. The RDCOLERR bit is cleared by
 * writing a 1 to it. Writing a 0 to RDCOLERR has no effect.
 *
 * Values:
 * - 0 - No collision error detected
 * - 1 - Collision error detected
 */
/*@{*/
#define BP_FTFE_FSTAT_RDCOLERR (6U)        /*!< Bit position for FTFE_FSTAT_RDCOLERR. */
#define BM_FTFE_FSTAT_RDCOLERR (0x40U)     /*!< Bit mask for FTFE_FSTAT_RDCOLERR. */
#define BS_FTFE_FSTAT_RDCOLERR (1U)        /*!< Bit field size in bits for FTFE_FSTAT_RDCOLERR. */

/*! @brief Read current value of the FTFE_FSTAT_RDCOLERR field. */
#define BR_FTFE_FSTAT_RDCOLERR(x) (BITBAND_ACCESS8(HW_FTFE_FSTAT_ADDR(x), BP_FTFE_FSTAT_RDCOLERR))

/*! @brief Format value for bitfield FTFE_FSTAT_RDCOLERR. */
#define BF_FTFE_FSTAT_RDCOLERR(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FSTAT_RDCOLERR) & BM_FTFE_FSTAT_RDCOLERR)

/*! @brief Set the RDCOLERR field to a new value. */
#define BW_FTFE_FSTAT_RDCOLERR(x, v) (BITBAND_ACCESS8(HW_FTFE_FSTAT_ADDR(x), BP_FTFE_FSTAT_RDCOLERR) = (v))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field CCIF[7] (W1C)
 *
 * The CCIF flag indicates that a FTFE command or EEPROM file system operation
 * has completed. The CCIF flag is cleared by writing a 1 to CCIF to launch a
 * command, and CCIF stays low until command completion or command violation. The
 * CCIF flag is also cleared by a successful write to FlexRAM while enabled for EEE,
 * and CCIF stays low until the EEPROM file system has created the associated
 * EEPROM data record. The CCIF bit is reset to 0 but is set to 1 by the memory
 * controller at the end of the reset initialization sequence. Depending on how
 * quickly the read occurs after reset release, the user may or may not see the 0
 * hardware reset value.
 *
 * Values:
 * - 0 - FTFE command or EEPROM file system operation in progress
 * - 1 - FTFE command or EEPROM file system operation has completed
 */
/*@{*/
#define BP_FTFE_FSTAT_CCIF   (7U)          /*!< Bit position for FTFE_FSTAT_CCIF. */
#define BM_FTFE_FSTAT_CCIF   (0x80U)       /*!< Bit mask for FTFE_FSTAT_CCIF. */
#define BS_FTFE_FSTAT_CCIF   (1U)          /*!< Bit field size in bits for FTFE_FSTAT_CCIF. */

/*! @brief Read current value of the FTFE_FSTAT_CCIF field. */
#define BR_FTFE_FSTAT_CCIF(x) (BITBAND_ACCESS8(HW_FTFE_FSTAT_ADDR(x), BP_FTFE_FSTAT_CCIF))

/*! @brief Format value for bitfield FTFE_FSTAT_CCIF. */
#define BF_FTFE_FSTAT_CCIF(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FSTAT_CCIF) & BM_FTFE_FSTAT_CCIF)

/*! @brief Set the CCIF field to a new value. */
#define BW_FTFE_FSTAT_CCIF(x, v) (BITBAND_ACCESS8(HW_FTFE_FSTAT_ADDR(x), BP_FTFE_FSTAT_CCIF) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCNFG - Flash Configuration Register
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCNFG - Flash Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides information on the current functional state of the
 * FTFE module. The erase control bits (ERSAREQ and ERSSUSP) have write
 * restrictions. SWAP, PFLSH, RAMRDY, and EEERDY are read-only status bits. The unassigned
 * bits read as noted and are not writable. The reset values for the SWAP, PFLSH,
 * RAMRDY, and EEERDY bits are determined during the reset sequence.
 */
typedef union _hw_ftfe_fcnfg
{
    uint8_t U;
    struct _hw_ftfe_fcnfg_bitfields
    {
        uint8_t EEERDY : 1;            /*!< [0]  */
        uint8_t RAMRDY : 1;            /*!< [1] RAM Ready */
        uint8_t PFLSH : 1;             /*!< [2] FTFE configuration */
        uint8_t SWAP : 1;              /*!< [3] Swap */
        uint8_t ERSSUSP : 1;           /*!< [4] Erase Suspend */
        uint8_t ERSAREQ : 1;           /*!< [5] Erase All Request */
        uint8_t RDCOLLIE : 1;          /*!< [6] Read Collision Error Interrupt Enable
                                        * */
        uint8_t CCIE : 1;              /*!< [7] Command Complete Interrupt Enable */
    } B;
} hw_ftfe_fcnfg_t;

/*!
 * @name Constants and macros for entire FTFE_FCNFG register
 */
/*@{*/
#define HW_FTFE_FCNFG_ADDR(x)    ((uint32_t)(x) + 0x1U)

#define HW_FTFE_FCNFG(x)         (*(__IO hw_ftfe_fcnfg_t *) HW_FTFE_FCNFG_ADDR(x))
#define HW_FTFE_FCNFG_RD(x)      (HW_FTFE_FCNFG(x).U)
#define HW_FTFE_FCNFG_WR(x, v)   (HW_FTFE_FCNFG(x).U = (v))
#define HW_FTFE_FCNFG_SET(x, v)  (HW_FTFE_FCNFG_WR(x, HW_FTFE_FCNFG_RD(x) |  (v)))
#define HW_FTFE_FCNFG_CLR(x, v)  (HW_FTFE_FCNFG_WR(x, HW_FTFE_FCNFG_RD(x) & ~(v)))
#define HW_FTFE_FCNFG_TOG(x, v)  (HW_FTFE_FCNFG_WR(x, HW_FTFE_FCNFG_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCNFG bitfields
 */

/*!
 * @name Register FTFE_FCNFG, field EEERDY[0] (RO)
 *
 * For devices with FlexNVM: This flag indicates if the EEPROM backup data has
 * been copied to the FlexRAM and is therefore available for read access. During
 * the reset sequence, the EEERDY flag remains clear while CCIF=0 and only sets if
 * the FlexNVM block is partitioned for EEPROM. For devices without FlexNVM:
 * This bit is reserved.
 *
 * Values:
 * - 0 - For devices with FlexNVM: FlexRAM is not available for EEPROM operation.
 * - 1 - For devices with FlexNVM: FlexRAM is available for EEPROM operations
 *     where: reads from the FlexRAM return data previously written to the FlexRAM
 *     in EEPROM mode and writes launch an EEPROM operation to store the written
 *     data in the FlexRAM and EEPROM backup.
 */
/*@{*/
#define BP_FTFE_FCNFG_EEERDY (0U)          /*!< Bit position for FTFE_FCNFG_EEERDY. */
#define BM_FTFE_FCNFG_EEERDY (0x01U)       /*!< Bit mask for FTFE_FCNFG_EEERDY. */
#define BS_FTFE_FCNFG_EEERDY (1U)          /*!< Bit field size in bits for FTFE_FCNFG_EEERDY. */

/*! @brief Read current value of the FTFE_FCNFG_EEERDY field. */
#define BR_FTFE_FCNFG_EEERDY(x) (BITBAND_ACCESS8(HW_FTFE_FCNFG_ADDR(x), BP_FTFE_FCNFG_EEERDY))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field RAMRDY[1] (RO)
 *
 * This flag indicates the current status of the FlexRAM/ programming
 * acceleration RAM. For devices with FlexNVM: The state of the RAMRDY flag is normally
 * controlled by the Set FlexRAM Function command. During the reset sequence, the
 * RAMRDY flag is cleared if the FlexNVM block is partitioned for EEPROM and will
 * be set if the FlexNVM block is not partitioned for EEPROM . The RAMRDY flag is
 * cleared if the Program Partition command is run to partition the FlexNVM block
 * for EEPROM. The RAMRDY flag sets after completion of the Erase All Blocks
 * command or execution of the erase-all operation triggered external to the FTFE.
 * For devices without FlexNVM: This bit should always be set.
 *
 * Values:
 * - 0 - For devices with FlexNVM: FlexRAM is not available for traditional RAM
 *     access. For devices without FlexNVM: Programming acceleration RAM is not
 *     available.
 * - 1 - For devices with FlexNVM: FlexRAM is available as traditional RAM only;
 *     writes to the FlexRAM do not trigger EEPROM operations. For devices
 *     without FlexNVM: Programming acceleration RAM is available.
 */
/*@{*/
#define BP_FTFE_FCNFG_RAMRDY (1U)          /*!< Bit position for FTFE_FCNFG_RAMRDY. */
#define BM_FTFE_FCNFG_RAMRDY (0x02U)       /*!< Bit mask for FTFE_FCNFG_RAMRDY. */
#define BS_FTFE_FCNFG_RAMRDY (1U)          /*!< Bit field size in bits for FTFE_FCNFG_RAMRDY. */

/*! @brief Read current value of the FTFE_FCNFG_RAMRDY field. */
#define BR_FTFE_FCNFG_RAMRDY(x) (BITBAND_ACCESS8(HW_FTFE_FCNFG_ADDR(x), BP_FTFE_FCNFG_RAMRDY))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field PFLSH[2] (RO)
 *
 * Values:
 * - 0 - For devices with FlexNVM: FTFE configuration supports two program flash
 *     blocks and two FlexNVM blocks For devices with program flash only:
 *     Reserved
 * - 1 - For devices with FlexNVM: Reserved For devices with program flash only:
 *     FTFE configuration supports four program flash blocks
 */
/*@{*/
#define BP_FTFE_FCNFG_PFLSH  (2U)          /*!< Bit position for FTFE_FCNFG_PFLSH. */
#define BM_FTFE_FCNFG_PFLSH  (0x04U)       /*!< Bit mask for FTFE_FCNFG_PFLSH. */
#define BS_FTFE_FCNFG_PFLSH  (1U)          /*!< Bit field size in bits for FTFE_FCNFG_PFLSH. */

/*! @brief Read current value of the FTFE_FCNFG_PFLSH field. */
#define BR_FTFE_FCNFG_PFLSH(x) (BITBAND_ACCESS8(HW_FTFE_FCNFG_ADDR(x), BP_FTFE_FCNFG_PFLSH))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field SWAP[3] (RO)
 *
 * The SWAP flag indicates which half of the program flash space is located at
 * relative address 0x0000. The state of the SWAP flag is set by the FTFE during
 * the reset sequence. See for information on swap management.
 *
 * Values:
 * - 0 - For devices with FlexNVM: Program flash 0 block is located at relative
 *     address 0x0000 For devices with program flash only: Program flash 0 block
 *     is located at relative address 0x0000
 * - 1 - For devices with FlexNVM: Reserved For devices with program flash only:
 *     Program flash 1 block is located at relative address 0x0000
 */
/*@{*/
#define BP_FTFE_FCNFG_SWAP   (3U)          /*!< Bit position for FTFE_FCNFG_SWAP. */
#define BM_FTFE_FCNFG_SWAP   (0x08U)       /*!< Bit mask for FTFE_FCNFG_SWAP. */
#define BS_FTFE_FCNFG_SWAP   (1U)          /*!< Bit field size in bits for FTFE_FCNFG_SWAP. */

/*! @brief Read current value of the FTFE_FCNFG_SWAP field. */
#define BR_FTFE_FCNFG_SWAP(x) (BITBAND_ACCESS8(HW_FTFE_FCNFG_ADDR(x), BP_FTFE_FCNFG_SWAP))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field ERSSUSP[4] (RW)
 *
 * The ERSSUSP bit allows the user to suspend (interrupt) the Erase Flash Sector
 * command while it is executing.
 *
 * Values:
 * - 0 - No suspend requested
 * - 1 - Suspend the current Erase Flash Sector command execution.
 */
/*@{*/
#define BP_FTFE_FCNFG_ERSSUSP (4U)         /*!< Bit position for FTFE_FCNFG_ERSSUSP. */
#define BM_FTFE_FCNFG_ERSSUSP (0x10U)      /*!< Bit mask for FTFE_FCNFG_ERSSUSP. */
#define BS_FTFE_FCNFG_ERSSUSP (1U)         /*!< Bit field size in bits for FTFE_FCNFG_ERSSUSP. */

/*! @brief Read current value of the FTFE_FCNFG_ERSSUSP field. */
#define BR_FTFE_FCNFG_ERSSUSP(x) (BITBAND_ACCESS8(HW_FTFE_FCNFG_ADDR(x), BP_FTFE_FCNFG_ERSSUSP))

/*! @brief Format value for bitfield FTFE_FCNFG_ERSSUSP. */
#define BF_FTFE_FCNFG_ERSSUSP(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCNFG_ERSSUSP) & BM_FTFE_FCNFG_ERSSUSP)

/*! @brief Set the ERSSUSP field to a new value. */
#define BW_FTFE_FCNFG_ERSSUSP(x, v) (BITBAND_ACCESS8(HW_FTFE_FCNFG_ADDR(x), BP_FTFE_FCNFG_ERSSUSP) = (v))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field ERSAREQ[5] (RO)
 *
 * This bit issues a request to the memory controller to execute the Erase All
 * Blocks command and release security. ERSAREQ is not directly writable but is
 * under indirect user control. Refer to the device's Chip Configuration details on
 * how to request this command. The ERSAREQ bit sets when an erase all request
 * is triggered external to the FTFE and CCIF is set (no command is currently
 * being executed). ERSAREQ is cleared by the FTFE when the operation completes.
 *
 * Values:
 * - 0 - No request or request complete
 * - 1 - Request to: run the Erase All Blocks command, verify the erased state,
 *     program the security byte in the Flash Configuration Field to the unsecure
 *     state, and release MCU security by setting the FSEC[SEC] field to the
 *     unsecure state.
 */
/*@{*/
#define BP_FTFE_FCNFG_ERSAREQ (5U)         /*!< Bit position for FTFE_FCNFG_ERSAREQ. */
#define BM_FTFE_FCNFG_ERSAREQ (0x20U)      /*!< Bit mask for FTFE_FCNFG_ERSAREQ. */
#define BS_FTFE_FCNFG_ERSAREQ (1U)         /*!< Bit field size in bits for FTFE_FCNFG_ERSAREQ. */

/*! @brief Read current value of the FTFE_FCNFG_ERSAREQ field. */
#define BR_FTFE_FCNFG_ERSAREQ(x) (BITBAND_ACCESS8(HW_FTFE_FCNFG_ADDR(x), BP_FTFE_FCNFG_ERSAREQ))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field RDCOLLIE[6] (RW)
 *
 * The RDCOLLIE bit controls interrupt generation when an FTFE read collision
 * error occurs.
 *
 * Values:
 * - 0 - Read collision error interrupt disabled
 * - 1 - Read collision error interrupt enabled. An interrupt request is
 *     generated whenever an FTFE read collision error is detected (see the description
 *     of FSTAT[RDCOLERR]).
 */
/*@{*/
#define BP_FTFE_FCNFG_RDCOLLIE (6U)        /*!< Bit position for FTFE_FCNFG_RDCOLLIE. */
#define BM_FTFE_FCNFG_RDCOLLIE (0x40U)     /*!< Bit mask for FTFE_FCNFG_RDCOLLIE. */
#define BS_FTFE_FCNFG_RDCOLLIE (1U)        /*!< Bit field size in bits for FTFE_FCNFG_RDCOLLIE. */

/*! @brief Read current value of the FTFE_FCNFG_RDCOLLIE field. */
#define BR_FTFE_FCNFG_RDCOLLIE(x) (BITBAND_ACCESS8(HW_FTFE_FCNFG_ADDR(x), BP_FTFE_FCNFG_RDCOLLIE))

/*! @brief Format value for bitfield FTFE_FCNFG_RDCOLLIE. */
#define BF_FTFE_FCNFG_RDCOLLIE(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCNFG_RDCOLLIE) & BM_FTFE_FCNFG_RDCOLLIE)

/*! @brief Set the RDCOLLIE field to a new value. */
#define BW_FTFE_FCNFG_RDCOLLIE(x, v) (BITBAND_ACCESS8(HW_FTFE_FCNFG_ADDR(x), BP_FTFE_FCNFG_RDCOLLIE) = (v))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field CCIE[7] (RW)
 *
 * The CCIE bit controls interrupt generation when an FTFE command completes.
 *
 * Values:
 * - 0 - Command complete interrupt disabled
 * - 1 - Command complete interrupt enabled. An interrupt request is generated
 *     whenever the FSTAT[CCIF] flag is set.
 */
/*@{*/
#define BP_FTFE_FCNFG_CCIE   (7U)          /*!< Bit position for FTFE_FCNFG_CCIE. */
#define BM_FTFE_FCNFG_CCIE   (0x80U)       /*!< Bit mask for FTFE_FCNFG_CCIE. */
#define BS_FTFE_FCNFG_CCIE   (1U)          /*!< Bit field size in bits for FTFE_FCNFG_CCIE. */

/*! @brief Read current value of the FTFE_FCNFG_CCIE field. */
#define BR_FTFE_FCNFG_CCIE(x) (BITBAND_ACCESS8(HW_FTFE_FCNFG_ADDR(x), BP_FTFE_FCNFG_CCIE))

/*! @brief Format value for bitfield FTFE_FCNFG_CCIE. */
#define BF_FTFE_FCNFG_CCIE(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCNFG_CCIE) & BM_FTFE_FCNFG_CCIE)

/*! @brief Set the CCIE field to a new value. */
#define BW_FTFE_FCNFG_CCIE(x, v) (BITBAND_ACCESS8(HW_FTFE_FCNFG_ADDR(x), BP_FTFE_FCNFG_CCIE) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FSEC - Flash Security Register
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FSEC - Flash Security Register (RO)
 *
 * Reset value: 0x00U
 *
 * This read-only register holds all bits associated with the security of the
 * MCU and FTFE module. During the reset sequence, the register is loaded with the
 * contents of the flash security byte in the Flash Configuration Field located
 * in program flash memory. The Flash basis for the values is signified by X in
 * the reset value.
 */
typedef union _hw_ftfe_fsec
{
    uint8_t U;
    struct _hw_ftfe_fsec_bitfields
    {
        uint8_t SEC : 2;               /*!< [1:0] Flash Security */
        uint8_t FSLACC : 2;            /*!< [3:2] Freescale Failure Analysis Access Code
                                        * */
        uint8_t MEEN : 2;              /*!< [5:4] Mass Erase Enable Bits */
        uint8_t KEYEN : 2;             /*!< [7:6] Backdoor Key Security Enable */
    } B;
} hw_ftfe_fsec_t;

/*!
 * @name Constants and macros for entire FTFE_FSEC register
 */
/*@{*/
#define HW_FTFE_FSEC_ADDR(x)     ((uint32_t)(x) + 0x2U)

#define HW_FTFE_FSEC(x)          (*(__I hw_ftfe_fsec_t *) HW_FTFE_FSEC_ADDR(x))
#define HW_FTFE_FSEC_RD(x)       (HW_FTFE_FSEC(x).U)
/*@}*/

/*
 * Constants & macros for individual FTFE_FSEC bitfields
 */

/*!
 * @name Register FTFE_FSEC, field SEC[1:0] (RO)
 *
 * These bits define the security state of the MCU. In the secure state, the MCU
 * limits access to FTFE module resources. The limitations are defined per
 * device and are detailed in the Chip Configuration details. If the FTFE module is
 * unsecured using backdoor key access, the SEC bits are forced to 10b.
 *
 * Values:
 * - 00 - MCU security status is secure
 * - 01 - MCU security status is secure
 * - 10 - MCU security status is unsecure (The standard shipping condition of
 *     the FTFE is unsecure.)
 * - 11 - MCU security status is secure
 */
/*@{*/
#define BP_FTFE_FSEC_SEC     (0U)          /*!< Bit position for FTFE_FSEC_SEC. */
#define BM_FTFE_FSEC_SEC     (0x03U)       /*!< Bit mask for FTFE_FSEC_SEC. */
#define BS_FTFE_FSEC_SEC     (2U)          /*!< Bit field size in bits for FTFE_FSEC_SEC. */

/*! @brief Read current value of the FTFE_FSEC_SEC field. */
#define BR_FTFE_FSEC_SEC(x)  (HW_FTFE_FSEC(x).B.SEC)
/*@}*/

/*!
 * @name Register FTFE_FSEC, field FSLACC[3:2] (RO)
 *
 * These bits enable or disable access to the flash memory contents during
 * returned part failure analysis at Freescale. When SEC is secure and FSLACC is
 * denied, access to the program flash contents is denied and any failure analysis
 * performed by Freescale factory test must begin with a full erase to unsecure the
 * part. When access is granted (SEC is unsecure, or SEC is secure and FSLACC is
 * granted), Freescale factory testing has visibility of the current flash
 * contents. The state of the FSLACC bits is only relevant when the SEC bits are set to
 * secure. When the SEC field is set to unsecure, the FSLACC setting does not
 * matter.
 *
 * Values:
 * - 00 - Freescale factory access granted
 * - 01 - Freescale factory access denied
 * - 10 - Freescale factory access denied
 * - 11 - Freescale factory access granted
 */
/*@{*/
#define BP_FTFE_FSEC_FSLACC  (2U)          /*!< Bit position for FTFE_FSEC_FSLACC. */
#define BM_FTFE_FSEC_FSLACC  (0x0CU)       /*!< Bit mask for FTFE_FSEC_FSLACC. */
#define BS_FTFE_FSEC_FSLACC  (2U)          /*!< Bit field size in bits for FTFE_FSEC_FSLACC. */

/*! @brief Read current value of the FTFE_FSEC_FSLACC field. */
#define BR_FTFE_FSEC_FSLACC(x) (HW_FTFE_FSEC(x).B.FSLACC)
/*@}*/

/*!
 * @name Register FTFE_FSEC, field MEEN[5:4] (RO)
 *
 * Enables and disables mass erase capability of the FTFE module. The state of
 * the MEEN bits is only relevant when the SEC bits are set to secure outside of
 * NVM Normal Mode. When the SEC field is set to unsecure, the MEEN setting does
 * not matter.
 *
 * Values:
 * - 00 - Mass erase is enabled
 * - 01 - Mass erase is enabled
 * - 10 - Mass erase is disabled
 * - 11 - Mass erase is enabled
 */
/*@{*/
#define BP_FTFE_FSEC_MEEN    (4U)          /*!< Bit position for FTFE_FSEC_MEEN. */
#define BM_FTFE_FSEC_MEEN    (0x30U)       /*!< Bit mask for FTFE_FSEC_MEEN. */
#define BS_FTFE_FSEC_MEEN    (2U)          /*!< Bit field size in bits for FTFE_FSEC_MEEN. */

/*! @brief Read current value of the FTFE_FSEC_MEEN field. */
#define BR_FTFE_FSEC_MEEN(x) (HW_FTFE_FSEC(x).B.MEEN)
/*@}*/

/*!
 * @name Register FTFE_FSEC, field KEYEN[7:6] (RO)
 *
 * These bits enable and disable backdoor key access to the FTFE module.
 *
 * Values:
 * - 00 - Backdoor key access disabled
 * - 01 - Backdoor key access disabled (preferred KEYEN state to disable
 *     backdoor key access)
 * - 10 - Backdoor key access enabled
 * - 11 - Backdoor key access disabled
 */
/*@{*/
#define BP_FTFE_FSEC_KEYEN   (6U)          /*!< Bit position for FTFE_FSEC_KEYEN. */
#define BM_FTFE_FSEC_KEYEN   (0xC0U)       /*!< Bit mask for FTFE_FSEC_KEYEN. */
#define BS_FTFE_FSEC_KEYEN   (2U)          /*!< Bit field size in bits for FTFE_FSEC_KEYEN. */

/*! @brief Read current value of the FTFE_FSEC_KEYEN field. */
#define BR_FTFE_FSEC_KEYEN(x) (HW_FTFE_FSEC(x).B.KEYEN)
/*@}*/

/*******************************************************************************
 * HW_FTFE_FOPT - Flash Option Register
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FOPT - Flash Option Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash option register allows the MCU to customize its operations by
 * examining the state of these read-only bits, which are loaded from NVM at reset.
 * The function of the bits is defined in the device's Chip Configuration details.
 * All bits in the register are read-only. During the reset sequence, the
 * register is loaded from the flash nonvolatile option byte in the Flash Configuration
 * Field located in program flash memory. The flash basis for the values is
 * signified by X in the reset value.
 */
typedef union _hw_ftfe_fopt
{
    uint8_t U;
    struct _hw_ftfe_fopt_bitfields
    {
        uint8_t OPT : 8;               /*!< [7:0] Nonvolatile Option */
    } B;
} hw_ftfe_fopt_t;

/*!
 * @name Constants and macros for entire FTFE_FOPT register
 */
/*@{*/
#define HW_FTFE_FOPT_ADDR(x)     ((uint32_t)(x) + 0x3U)

#define HW_FTFE_FOPT(x)          (*(__I hw_ftfe_fopt_t *) HW_FTFE_FOPT_ADDR(x))
#define HW_FTFE_FOPT_RD(x)       (HW_FTFE_FOPT(x).U)
/*@}*/

/*
 * Constants & macros for individual FTFE_FOPT bitfields
 */

/*!
 * @name Register FTFE_FOPT, field OPT[7:0] (RO)
 *
 * These bits are loaded from flash to this register at reset. Refer to the
 * device's Chip Configuration details for the definition and use of these bits.
 */
/*@{*/
#define BP_FTFE_FOPT_OPT     (0U)          /*!< Bit position for FTFE_FOPT_OPT. */
#define BM_FTFE_FOPT_OPT     (0xFFU)       /*!< Bit mask for FTFE_FOPT_OPT. */
#define BS_FTFE_FOPT_OPT     (8U)          /*!< Bit field size in bits for FTFE_FOPT_OPT. */

/*! @brief Read current value of the FTFE_FOPT_OPT field. */
#define BR_FTFE_FOPT_OPT(x)  (HW_FTFE_FOPT(x).U)
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOB3 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOB3 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccob3
{
    uint8_t U;
    struct _hw_ftfe_fccob3_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccob3_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOB3 register
 */
/*@{*/
#define HW_FTFE_FCCOB3_ADDR(x)   ((uint32_t)(x) + 0x4U)

#define HW_FTFE_FCCOB3(x)        (*(__IO hw_ftfe_fccob3_t *) HW_FTFE_FCCOB3_ADDR(x))
#define HW_FTFE_FCCOB3_RD(x)     (HW_FTFE_FCCOB3(x).U)
#define HW_FTFE_FCCOB3_WR(x, v)  (HW_FTFE_FCCOB3(x).U = (v))
#define HW_FTFE_FCCOB3_SET(x, v) (HW_FTFE_FCCOB3_WR(x, HW_FTFE_FCCOB3_RD(x) |  (v)))
#define HW_FTFE_FCCOB3_CLR(x, v) (HW_FTFE_FCCOB3_WR(x, HW_FTFE_FCCOB3_RD(x) & ~(v)))
#define HW_FTFE_FCCOB3_TOG(x, v) (HW_FTFE_FCCOB3_WR(x, HW_FTFE_FCCOB3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOB3 bitfields
 */

/*!
 * @name Register FTFE_FCCOB3, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOB3_CCOBn (0U)          /*!< Bit position for FTFE_FCCOB3_CCOBn. */
#define BM_FTFE_FCCOB3_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOB3_CCOBn. */
#define BS_FTFE_FCCOB3_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOB3_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOB3_CCOBn field. */
#define BR_FTFE_FCCOB3_CCOBn(x) (HW_FTFE_FCCOB3(x).U)

/*! @brief Format value for bitfield FTFE_FCCOB3_CCOBn. */
#define BF_FTFE_FCCOB3_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOB3_CCOBn) & BM_FTFE_FCCOB3_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOB3_CCOBn(x, v) (HW_FTFE_FCCOB3_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOB2 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOB2 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccob2
{
    uint8_t U;
    struct _hw_ftfe_fccob2_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccob2_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOB2 register
 */
/*@{*/
#define HW_FTFE_FCCOB2_ADDR(x)   ((uint32_t)(x) + 0x5U)

#define HW_FTFE_FCCOB2(x)        (*(__IO hw_ftfe_fccob2_t *) HW_FTFE_FCCOB2_ADDR(x))
#define HW_FTFE_FCCOB2_RD(x)     (HW_FTFE_FCCOB2(x).U)
#define HW_FTFE_FCCOB2_WR(x, v)  (HW_FTFE_FCCOB2(x).U = (v))
#define HW_FTFE_FCCOB2_SET(x, v) (HW_FTFE_FCCOB2_WR(x, HW_FTFE_FCCOB2_RD(x) |  (v)))
#define HW_FTFE_FCCOB2_CLR(x, v) (HW_FTFE_FCCOB2_WR(x, HW_FTFE_FCCOB2_RD(x) & ~(v)))
#define HW_FTFE_FCCOB2_TOG(x, v) (HW_FTFE_FCCOB2_WR(x, HW_FTFE_FCCOB2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOB2 bitfields
 */

/*!
 * @name Register FTFE_FCCOB2, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOB2_CCOBn (0U)          /*!< Bit position for FTFE_FCCOB2_CCOBn. */
#define BM_FTFE_FCCOB2_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOB2_CCOBn. */
#define BS_FTFE_FCCOB2_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOB2_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOB2_CCOBn field. */
#define BR_FTFE_FCCOB2_CCOBn(x) (HW_FTFE_FCCOB2(x).U)

/*! @brief Format value for bitfield FTFE_FCCOB2_CCOBn. */
#define BF_FTFE_FCCOB2_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOB2_CCOBn) & BM_FTFE_FCCOB2_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOB2_CCOBn(x, v) (HW_FTFE_FCCOB2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOB1 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOB1 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccob1
{
    uint8_t U;
    struct _hw_ftfe_fccob1_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccob1_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOB1 register
 */
/*@{*/
#define HW_FTFE_FCCOB1_ADDR(x)   ((uint32_t)(x) + 0x6U)

#define HW_FTFE_FCCOB1(x)        (*(__IO hw_ftfe_fccob1_t *) HW_FTFE_FCCOB1_ADDR(x))
#define HW_FTFE_FCCOB1_RD(x)     (HW_FTFE_FCCOB1(x).U)
#define HW_FTFE_FCCOB1_WR(x, v)  (HW_FTFE_FCCOB1(x).U = (v))
#define HW_FTFE_FCCOB1_SET(x, v) (HW_FTFE_FCCOB1_WR(x, HW_FTFE_FCCOB1_RD(x) |  (v)))
#define HW_FTFE_FCCOB1_CLR(x, v) (HW_FTFE_FCCOB1_WR(x, HW_FTFE_FCCOB1_RD(x) & ~(v)))
#define HW_FTFE_FCCOB1_TOG(x, v) (HW_FTFE_FCCOB1_WR(x, HW_FTFE_FCCOB1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOB1 bitfields
 */

/*!
 * @name Register FTFE_FCCOB1, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOB1_CCOBn (0U)          /*!< Bit position for FTFE_FCCOB1_CCOBn. */
#define BM_FTFE_FCCOB1_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOB1_CCOBn. */
#define BS_FTFE_FCCOB1_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOB1_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOB1_CCOBn field. */
#define BR_FTFE_FCCOB1_CCOBn(x) (HW_FTFE_FCCOB1(x).U)

/*! @brief Format value for bitfield FTFE_FCCOB1_CCOBn. */
#define BF_FTFE_FCCOB1_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOB1_CCOBn) & BM_FTFE_FCCOB1_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOB1_CCOBn(x, v) (HW_FTFE_FCCOB1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOB0 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOB0 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccob0
{
    uint8_t U;
    struct _hw_ftfe_fccob0_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccob0_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOB0 register
 */
/*@{*/
#define HW_FTFE_FCCOB0_ADDR(x)   ((uint32_t)(x) + 0x7U)

#define HW_FTFE_FCCOB0(x)        (*(__IO hw_ftfe_fccob0_t *) HW_FTFE_FCCOB0_ADDR(x))
#define HW_FTFE_FCCOB0_RD(x)     (HW_FTFE_FCCOB0(x).U)
#define HW_FTFE_FCCOB0_WR(x, v)  (HW_FTFE_FCCOB0(x).U = (v))
#define HW_FTFE_FCCOB0_SET(x, v) (HW_FTFE_FCCOB0_WR(x, HW_FTFE_FCCOB0_RD(x) |  (v)))
#define HW_FTFE_FCCOB0_CLR(x, v) (HW_FTFE_FCCOB0_WR(x, HW_FTFE_FCCOB0_RD(x) & ~(v)))
#define HW_FTFE_FCCOB0_TOG(x, v) (HW_FTFE_FCCOB0_WR(x, HW_FTFE_FCCOB0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOB0 bitfields
 */

/*!
 * @name Register FTFE_FCCOB0, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOB0_CCOBn (0U)          /*!< Bit position for FTFE_FCCOB0_CCOBn. */
#define BM_FTFE_FCCOB0_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOB0_CCOBn. */
#define BS_FTFE_FCCOB0_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOB0_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOB0_CCOBn field. */
#define BR_FTFE_FCCOB0_CCOBn(x) (HW_FTFE_FCCOB0(x).U)

/*! @brief Format value for bitfield FTFE_FCCOB0_CCOBn. */
#define BF_FTFE_FCCOB0_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOB0_CCOBn) & BM_FTFE_FCCOB0_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOB0_CCOBn(x, v) (HW_FTFE_FCCOB0_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOB7 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOB7 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccob7
{
    uint8_t U;
    struct _hw_ftfe_fccob7_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccob7_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOB7 register
 */
/*@{*/
#define HW_FTFE_FCCOB7_ADDR(x)   ((uint32_t)(x) + 0x8U)

#define HW_FTFE_FCCOB7(x)        (*(__IO hw_ftfe_fccob7_t *) HW_FTFE_FCCOB7_ADDR(x))
#define HW_FTFE_FCCOB7_RD(x)     (HW_FTFE_FCCOB7(x).U)
#define HW_FTFE_FCCOB7_WR(x, v)  (HW_FTFE_FCCOB7(x).U = (v))
#define HW_FTFE_FCCOB7_SET(x, v) (HW_FTFE_FCCOB7_WR(x, HW_FTFE_FCCOB7_RD(x) |  (v)))
#define HW_FTFE_FCCOB7_CLR(x, v) (HW_FTFE_FCCOB7_WR(x, HW_FTFE_FCCOB7_RD(x) & ~(v)))
#define HW_FTFE_FCCOB7_TOG(x, v) (HW_FTFE_FCCOB7_WR(x, HW_FTFE_FCCOB7_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOB7 bitfields
 */

/*!
 * @name Register FTFE_FCCOB7, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOB7_CCOBn (0U)          /*!< Bit position for FTFE_FCCOB7_CCOBn. */
#define BM_FTFE_FCCOB7_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOB7_CCOBn. */
#define BS_FTFE_FCCOB7_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOB7_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOB7_CCOBn field. */
#define BR_FTFE_FCCOB7_CCOBn(x) (HW_FTFE_FCCOB7(x).U)

/*! @brief Format value for bitfield FTFE_FCCOB7_CCOBn. */
#define BF_FTFE_FCCOB7_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOB7_CCOBn) & BM_FTFE_FCCOB7_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOB7_CCOBn(x, v) (HW_FTFE_FCCOB7_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOB6 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOB6 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccob6
{
    uint8_t U;
    struct _hw_ftfe_fccob6_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccob6_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOB6 register
 */
/*@{*/
#define HW_FTFE_FCCOB6_ADDR(x)   ((uint32_t)(x) + 0x9U)

#define HW_FTFE_FCCOB6(x)        (*(__IO hw_ftfe_fccob6_t *) HW_FTFE_FCCOB6_ADDR(x))
#define HW_FTFE_FCCOB6_RD(x)     (HW_FTFE_FCCOB6(x).U)
#define HW_FTFE_FCCOB6_WR(x, v)  (HW_FTFE_FCCOB6(x).U = (v))
#define HW_FTFE_FCCOB6_SET(x, v) (HW_FTFE_FCCOB6_WR(x, HW_FTFE_FCCOB6_RD(x) |  (v)))
#define HW_FTFE_FCCOB6_CLR(x, v) (HW_FTFE_FCCOB6_WR(x, HW_FTFE_FCCOB6_RD(x) & ~(v)))
#define HW_FTFE_FCCOB6_TOG(x, v) (HW_FTFE_FCCOB6_WR(x, HW_FTFE_FCCOB6_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOB6 bitfields
 */

/*!
 * @name Register FTFE_FCCOB6, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOB6_CCOBn (0U)          /*!< Bit position for FTFE_FCCOB6_CCOBn. */
#define BM_FTFE_FCCOB6_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOB6_CCOBn. */
#define BS_FTFE_FCCOB6_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOB6_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOB6_CCOBn field. */
#define BR_FTFE_FCCOB6_CCOBn(x) (HW_FTFE_FCCOB6(x).U)

/*! @brief Format value for bitfield FTFE_FCCOB6_CCOBn. */
#define BF_FTFE_FCCOB6_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOB6_CCOBn) & BM_FTFE_FCCOB6_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOB6_CCOBn(x, v) (HW_FTFE_FCCOB6_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOB5 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOB5 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccob5
{
    uint8_t U;
    struct _hw_ftfe_fccob5_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccob5_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOB5 register
 */
/*@{*/
#define HW_FTFE_FCCOB5_ADDR(x)   ((uint32_t)(x) + 0xAU)

#define HW_FTFE_FCCOB5(x)        (*(__IO hw_ftfe_fccob5_t *) HW_FTFE_FCCOB5_ADDR(x))
#define HW_FTFE_FCCOB5_RD(x)     (HW_FTFE_FCCOB5(x).U)
#define HW_FTFE_FCCOB5_WR(x, v)  (HW_FTFE_FCCOB5(x).U = (v))
#define HW_FTFE_FCCOB5_SET(x, v) (HW_FTFE_FCCOB5_WR(x, HW_FTFE_FCCOB5_RD(x) |  (v)))
#define HW_FTFE_FCCOB5_CLR(x, v) (HW_FTFE_FCCOB5_WR(x, HW_FTFE_FCCOB5_RD(x) & ~(v)))
#define HW_FTFE_FCCOB5_TOG(x, v) (HW_FTFE_FCCOB5_WR(x, HW_FTFE_FCCOB5_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOB5 bitfields
 */

/*!
 * @name Register FTFE_FCCOB5, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOB5_CCOBn (0U)          /*!< Bit position for FTFE_FCCOB5_CCOBn. */
#define BM_FTFE_FCCOB5_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOB5_CCOBn. */
#define BS_FTFE_FCCOB5_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOB5_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOB5_CCOBn field. */
#define BR_FTFE_FCCOB5_CCOBn(x) (HW_FTFE_FCCOB5(x).U)

/*! @brief Format value for bitfield FTFE_FCCOB5_CCOBn. */
#define BF_FTFE_FCCOB5_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOB5_CCOBn) & BM_FTFE_FCCOB5_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOB5_CCOBn(x, v) (HW_FTFE_FCCOB5_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOB4 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOB4 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccob4
{
    uint8_t U;
    struct _hw_ftfe_fccob4_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccob4_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOB4 register
 */
/*@{*/
#define HW_FTFE_FCCOB4_ADDR(x)   ((uint32_t)(x) + 0xBU)

#define HW_FTFE_FCCOB4(x)        (*(__IO hw_ftfe_fccob4_t *) HW_FTFE_FCCOB4_ADDR(x))
#define HW_FTFE_FCCOB4_RD(x)     (HW_FTFE_FCCOB4(x).U)
#define HW_FTFE_FCCOB4_WR(x, v)  (HW_FTFE_FCCOB4(x).U = (v))
#define HW_FTFE_FCCOB4_SET(x, v) (HW_FTFE_FCCOB4_WR(x, HW_FTFE_FCCOB4_RD(x) |  (v)))
#define HW_FTFE_FCCOB4_CLR(x, v) (HW_FTFE_FCCOB4_WR(x, HW_FTFE_FCCOB4_RD(x) & ~(v)))
#define HW_FTFE_FCCOB4_TOG(x, v) (HW_FTFE_FCCOB4_WR(x, HW_FTFE_FCCOB4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOB4 bitfields
 */

/*!
 * @name Register FTFE_FCCOB4, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOB4_CCOBn (0U)          /*!< Bit position for FTFE_FCCOB4_CCOBn. */
#define BM_FTFE_FCCOB4_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOB4_CCOBn. */
#define BS_FTFE_FCCOB4_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOB4_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOB4_CCOBn field. */
#define BR_FTFE_FCCOB4_CCOBn(x) (HW_FTFE_FCCOB4(x).U)

/*! @brief Format value for bitfield FTFE_FCCOB4_CCOBn. */
#define BF_FTFE_FCCOB4_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOB4_CCOBn) & BM_FTFE_FCCOB4_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOB4_CCOBn(x, v) (HW_FTFE_FCCOB4_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOBB - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOBB - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccobb
{
    uint8_t U;
    struct _hw_ftfe_fccobb_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccobb_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOBB register
 */
/*@{*/
#define HW_FTFE_FCCOBB_ADDR(x)   ((uint32_t)(x) + 0xCU)

#define HW_FTFE_FCCOBB(x)        (*(__IO hw_ftfe_fccobb_t *) HW_FTFE_FCCOBB_ADDR(x))
#define HW_FTFE_FCCOBB_RD(x)     (HW_FTFE_FCCOBB(x).U)
#define HW_FTFE_FCCOBB_WR(x, v)  (HW_FTFE_FCCOBB(x).U = (v))
#define HW_FTFE_FCCOBB_SET(x, v) (HW_FTFE_FCCOBB_WR(x, HW_FTFE_FCCOBB_RD(x) |  (v)))
#define HW_FTFE_FCCOBB_CLR(x, v) (HW_FTFE_FCCOBB_WR(x, HW_FTFE_FCCOBB_RD(x) & ~(v)))
#define HW_FTFE_FCCOBB_TOG(x, v) (HW_FTFE_FCCOBB_WR(x, HW_FTFE_FCCOBB_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOBB bitfields
 */

/*!
 * @name Register FTFE_FCCOBB, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOBB_CCOBn (0U)          /*!< Bit position for FTFE_FCCOBB_CCOBn. */
#define BM_FTFE_FCCOBB_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOBB_CCOBn. */
#define BS_FTFE_FCCOBB_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOBB_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOBB_CCOBn field. */
#define BR_FTFE_FCCOBB_CCOBn(x) (HW_FTFE_FCCOBB(x).U)

/*! @brief Format value for bitfield FTFE_FCCOBB_CCOBn. */
#define BF_FTFE_FCCOBB_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOBB_CCOBn) & BM_FTFE_FCCOBB_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOBB_CCOBn(x, v) (HW_FTFE_FCCOBB_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOBA - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOBA - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccoba
{
    uint8_t U;
    struct _hw_ftfe_fccoba_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccoba_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOBA register
 */
/*@{*/
#define HW_FTFE_FCCOBA_ADDR(x)   ((uint32_t)(x) + 0xDU)

#define HW_FTFE_FCCOBA(x)        (*(__IO hw_ftfe_fccoba_t *) HW_FTFE_FCCOBA_ADDR(x))
#define HW_FTFE_FCCOBA_RD(x)     (HW_FTFE_FCCOBA(x).U)
#define HW_FTFE_FCCOBA_WR(x, v)  (HW_FTFE_FCCOBA(x).U = (v))
#define HW_FTFE_FCCOBA_SET(x, v) (HW_FTFE_FCCOBA_WR(x, HW_FTFE_FCCOBA_RD(x) |  (v)))
#define HW_FTFE_FCCOBA_CLR(x, v) (HW_FTFE_FCCOBA_WR(x, HW_FTFE_FCCOBA_RD(x) & ~(v)))
#define HW_FTFE_FCCOBA_TOG(x, v) (HW_FTFE_FCCOBA_WR(x, HW_FTFE_FCCOBA_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOBA bitfields
 */

/*!
 * @name Register FTFE_FCCOBA, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOBA_CCOBn (0U)          /*!< Bit position for FTFE_FCCOBA_CCOBn. */
#define BM_FTFE_FCCOBA_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOBA_CCOBn. */
#define BS_FTFE_FCCOBA_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOBA_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOBA_CCOBn field. */
#define BR_FTFE_FCCOBA_CCOBn(x) (HW_FTFE_FCCOBA(x).U)

/*! @brief Format value for bitfield FTFE_FCCOBA_CCOBn. */
#define BF_FTFE_FCCOBA_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOBA_CCOBn) & BM_FTFE_FCCOBA_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOBA_CCOBn(x, v) (HW_FTFE_FCCOBA_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOB9 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOB9 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccob9
{
    uint8_t U;
    struct _hw_ftfe_fccob9_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccob9_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOB9 register
 */
/*@{*/
#define HW_FTFE_FCCOB9_ADDR(x)   ((uint32_t)(x) + 0xEU)

#define HW_FTFE_FCCOB9(x)        (*(__IO hw_ftfe_fccob9_t *) HW_FTFE_FCCOB9_ADDR(x))
#define HW_FTFE_FCCOB9_RD(x)     (HW_FTFE_FCCOB9(x).U)
#define HW_FTFE_FCCOB9_WR(x, v)  (HW_FTFE_FCCOB9(x).U = (v))
#define HW_FTFE_FCCOB9_SET(x, v) (HW_FTFE_FCCOB9_WR(x, HW_FTFE_FCCOB9_RD(x) |  (v)))
#define HW_FTFE_FCCOB9_CLR(x, v) (HW_FTFE_FCCOB9_WR(x, HW_FTFE_FCCOB9_RD(x) & ~(v)))
#define HW_FTFE_FCCOB9_TOG(x, v) (HW_FTFE_FCCOB9_WR(x, HW_FTFE_FCCOB9_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOB9 bitfields
 */

/*!
 * @name Register FTFE_FCCOB9, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOB9_CCOBn (0U)          /*!< Bit position for FTFE_FCCOB9_CCOBn. */
#define BM_FTFE_FCCOB9_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOB9_CCOBn. */
#define BS_FTFE_FCCOB9_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOB9_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOB9_CCOBn field. */
#define BR_FTFE_FCCOB9_CCOBn(x) (HW_FTFE_FCCOB9(x).U)

/*! @brief Format value for bitfield FTFE_FCCOB9_CCOBn. */
#define BF_FTFE_FCCOB9_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOB9_CCOBn) & BM_FTFE_FCCOB9_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOB9_CCOBn(x, v) (HW_FTFE_FCCOB9_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FCCOB8 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FCCOB8 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
typedef union _hw_ftfe_fccob8
{
    uint8_t U;
    struct _hw_ftfe_fccob8_bitfields
    {
        uint8_t CCOBn : 8;             /*!< [7:0]  */
    } B;
} hw_ftfe_fccob8_t;

/*!
 * @name Constants and macros for entire FTFE_FCCOB8 register
 */
/*@{*/
#define HW_FTFE_FCCOB8_ADDR(x)   ((uint32_t)(x) + 0xFU)

#define HW_FTFE_FCCOB8(x)        (*(__IO hw_ftfe_fccob8_t *) HW_FTFE_FCCOB8_ADDR(x))
#define HW_FTFE_FCCOB8_RD(x)     (HW_FTFE_FCCOB8(x).U)
#define HW_FTFE_FCCOB8_WR(x, v)  (HW_FTFE_FCCOB8(x).U = (v))
#define HW_FTFE_FCCOB8_SET(x, v) (HW_FTFE_FCCOB8_WR(x, HW_FTFE_FCCOB8_RD(x) |  (v)))
#define HW_FTFE_FCCOB8_CLR(x, v) (HW_FTFE_FCCOB8_WR(x, HW_FTFE_FCCOB8_RD(x) & ~(v)))
#define HW_FTFE_FCCOB8_TOG(x, v) (HW_FTFE_FCCOB8_WR(x, HW_FTFE_FCCOB8_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCCOB8 bitfields
 */

/*!
 * @name Register FTFE_FCCOB8, field CCOBn[7:0] (RW)
 *
 * The FCCOB register provides a command code and relevant parameters to the
 * memory controller. The individual registers that compose the FCCOB data set can
 * be written in any order, but you must provide all needed values, which vary
 * from command to command. First, set up all required FCCOB fields and then
 * initiate the command's execution by writing a 1 to the FSTAT[CCIF] bit. This clears
 * the CCIF bit, which locks all FCCOB parameter fields and they cannot be changed
 * by the user until the command completes (CCIF returns to 1). No command
 * buffering or queueing is provided; the next command can be loaded only after the
 * current command completes. Some commands return information to the FCCOB
 * registers. Any values returned to FCCOB are available for reading after the
 * FSTAT[CCIF] flag returns to 1 by the memory controller. The following table shows a
 * generic FTFE command format. The first FCCOB register, FCCOB0, always contains
 * the command code. This 8-bit value defines the command to be executed. The
 * command code is followed by the parameters required for this specific FTFE command,
 * typically an address and/or data values. The command parameter table is
 * written in terms of FCCOB Number (which is equivalent to the byte number). This
 * number is a reference to the FCCOB register name and is not the register address.
 * FCCOB NumberRefers to FCCOB register name, not register address Typical
 * Command Parameter Contents [7:0] 0 FCMD (a code that defines the FTFE command) 1
 * Flash address [23:16] 2 Flash address [15:8] 3 Flash address [7:0] 4 Data Byte 0
 * 5 Data Byte 1 6 Data Byte 2 7 Data Byte 3 8 Data Byte 4 9 Data Byte 5 A Data
 * Byte 6 B Data Byte 7 FCCOB Endianness and Multi-Byte Access: The FCCOB
 * register group uses a big endian addressing convention. For all command parameter
 * fields larger than 1 byte, the most significant data resides in the lowest FCCOB
 * register number. The FCCOB register group may be read and written as
 * individual bytes, aligned words (2 bytes) or aligned longwords (4 bytes).
 */
/*@{*/
#define BP_FTFE_FCCOB8_CCOBn (0U)          /*!< Bit position for FTFE_FCCOB8_CCOBn. */
#define BM_FTFE_FCCOB8_CCOBn (0xFFU)       /*!< Bit mask for FTFE_FCCOB8_CCOBn. */
#define BS_FTFE_FCCOB8_CCOBn (8U)          /*!< Bit field size in bits for FTFE_FCCOB8_CCOBn. */

/*! @brief Read current value of the FTFE_FCCOB8_CCOBn field. */
#define BR_FTFE_FCCOB8_CCOBn(x) (HW_FTFE_FCCOB8(x).U)

/*! @brief Format value for bitfield FTFE_FCCOB8_CCOBn. */
#define BF_FTFE_FCCOB8_CCOBn(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FCCOB8_CCOBn) & BM_FTFE_FCCOB8_CCOBn)

/*! @brief Set the CCOBn field to a new value. */
#define BW_FTFE_FCCOB8_CCOBn(x, v) (HW_FTFE_FCCOB8_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FPROT3 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FPROT3 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFE command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions of equal
 * memory size. Program flash protection register Program flash protection bits
 * FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During
 * the reset sequence, the FPROT registers are loaded with the contents of the
 * program flash protection bytes in the Flash Configuration Field as indicated in
 * the following table. Program flash protection register Flash Configuration Field
 * offset address FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To
 * change the program flash protection that is loaded during the reset sequence,
 * unprotect the sector of program flash memory that contains the Flash
 * Configuration Field. Then, reprogram the program flash protection byte.
 */
typedef union _hw_ftfe_fprot3
{
    uint8_t U;
    struct _hw_ftfe_fprot3_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] Program Flash Region Protect */
    } B;
} hw_ftfe_fprot3_t;

/*!
 * @name Constants and macros for entire FTFE_FPROT3 register
 */
/*@{*/
#define HW_FTFE_FPROT3_ADDR(x)   ((uint32_t)(x) + 0x10U)

#define HW_FTFE_FPROT3(x)        (*(__IO hw_ftfe_fprot3_t *) HW_FTFE_FPROT3_ADDR(x))
#define HW_FTFE_FPROT3_RD(x)     (HW_FTFE_FPROT3(x).U)
#define HW_FTFE_FPROT3_WR(x, v)  (HW_FTFE_FPROT3(x).U = (v))
#define HW_FTFE_FPROT3_SET(x, v) (HW_FTFE_FPROT3_WR(x, HW_FTFE_FPROT3_RD(x) |  (v)))
#define HW_FTFE_FPROT3_CLR(x, v) (HW_FTFE_FPROT3_WR(x, HW_FTFE_FPROT3_RD(x) & ~(v)))
#define HW_FTFE_FPROT3_TOG(x, v) (HW_FTFE_FPROT3_WR(x, HW_FTFE_FPROT3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FPROT3 bitfields
 */

/*!
 * @name Register FTFE_FPROT3, field PROT[7:0] (RW)
 *
 * Each program flash region can be protected from program and erase operations
 * by setting the associated PROT bit. In NVM Normal mode: The protection can
 * only be increased, meaning that currently unprotected memory can be protected,
 * but currently protected memory cannot be unprotected. Since unprotected regions
 * are marked with a 1 and protected regions use a 0, only writes changing 1s to
 * 0s are accepted. This 1-to-0 transition check is performed on a bit-by-bit
 * basis. Those FPROT bits with 1-to-0 transitions are accepted while all bits with
 * 0-to-1 transitions are ignored. In NVM Special mode: All bits of FPROT are
 * writable without restriction. Unprotected areas can be protected and protected
 * areas can be unprotected. The user must never write to any FPROT register while
 * a command is running (CCIF=0). Trying to alter data in any protected area in
 * the program flash memory results in a protection violation error and sets the
 * FSTAT[FPVIOL] bit. A full block erase of a program flash block is not possible
 * if it contains any protected region.
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
/*@{*/
#define BP_FTFE_FPROT3_PROT  (0U)          /*!< Bit position for FTFE_FPROT3_PROT. */
#define BM_FTFE_FPROT3_PROT  (0xFFU)       /*!< Bit mask for FTFE_FPROT3_PROT. */
#define BS_FTFE_FPROT3_PROT  (8U)          /*!< Bit field size in bits for FTFE_FPROT3_PROT. */

/*! @brief Read current value of the FTFE_FPROT3_PROT field. */
#define BR_FTFE_FPROT3_PROT(x) (HW_FTFE_FPROT3(x).U)

/*! @brief Format value for bitfield FTFE_FPROT3_PROT. */
#define BF_FTFE_FPROT3_PROT(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FPROT3_PROT) & BM_FTFE_FPROT3_PROT)

/*! @brief Set the PROT field to a new value. */
#define BW_FTFE_FPROT3_PROT(x, v) (HW_FTFE_FPROT3_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FPROT2 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FPROT2 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFE command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions of equal
 * memory size. Program flash protection register Program flash protection bits
 * FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During
 * the reset sequence, the FPROT registers are loaded with the contents of the
 * program flash protection bytes in the Flash Configuration Field as indicated in
 * the following table. Program flash protection register Flash Configuration Field
 * offset address FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To
 * change the program flash protection that is loaded during the reset sequence,
 * unprotect the sector of program flash memory that contains the Flash
 * Configuration Field. Then, reprogram the program flash protection byte.
 */
typedef union _hw_ftfe_fprot2
{
    uint8_t U;
    struct _hw_ftfe_fprot2_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] Program Flash Region Protect */
    } B;
} hw_ftfe_fprot2_t;

/*!
 * @name Constants and macros for entire FTFE_FPROT2 register
 */
/*@{*/
#define HW_FTFE_FPROT2_ADDR(x)   ((uint32_t)(x) + 0x11U)

#define HW_FTFE_FPROT2(x)        (*(__IO hw_ftfe_fprot2_t *) HW_FTFE_FPROT2_ADDR(x))
#define HW_FTFE_FPROT2_RD(x)     (HW_FTFE_FPROT2(x).U)
#define HW_FTFE_FPROT2_WR(x, v)  (HW_FTFE_FPROT2(x).U = (v))
#define HW_FTFE_FPROT2_SET(x, v) (HW_FTFE_FPROT2_WR(x, HW_FTFE_FPROT2_RD(x) |  (v)))
#define HW_FTFE_FPROT2_CLR(x, v) (HW_FTFE_FPROT2_WR(x, HW_FTFE_FPROT2_RD(x) & ~(v)))
#define HW_FTFE_FPROT2_TOG(x, v) (HW_FTFE_FPROT2_WR(x, HW_FTFE_FPROT2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FPROT2 bitfields
 */

/*!
 * @name Register FTFE_FPROT2, field PROT[7:0] (RW)
 *
 * Each program flash region can be protected from program and erase operations
 * by setting the associated PROT bit. In NVM Normal mode: The protection can
 * only be increased, meaning that currently unprotected memory can be protected,
 * but currently protected memory cannot be unprotected. Since unprotected regions
 * are marked with a 1 and protected regions use a 0, only writes changing 1s to
 * 0s are accepted. This 1-to-0 transition check is performed on a bit-by-bit
 * basis. Those FPROT bits with 1-to-0 transitions are accepted while all bits with
 * 0-to-1 transitions are ignored. In NVM Special mode: All bits of FPROT are
 * writable without restriction. Unprotected areas can be protected and protected
 * areas can be unprotected. The user must never write to any FPROT register while
 * a command is running (CCIF=0). Trying to alter data in any protected area in
 * the program flash memory results in a protection violation error and sets the
 * FSTAT[FPVIOL] bit. A full block erase of a program flash block is not possible
 * if it contains any protected region.
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
/*@{*/
#define BP_FTFE_FPROT2_PROT  (0U)          /*!< Bit position for FTFE_FPROT2_PROT. */
#define BM_FTFE_FPROT2_PROT  (0xFFU)       /*!< Bit mask for FTFE_FPROT2_PROT. */
#define BS_FTFE_FPROT2_PROT  (8U)          /*!< Bit field size in bits for FTFE_FPROT2_PROT. */

/*! @brief Read current value of the FTFE_FPROT2_PROT field. */
#define BR_FTFE_FPROT2_PROT(x) (HW_FTFE_FPROT2(x).U)

/*! @brief Format value for bitfield FTFE_FPROT2_PROT. */
#define BF_FTFE_FPROT2_PROT(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FPROT2_PROT) & BM_FTFE_FPROT2_PROT)

/*! @brief Set the PROT field to a new value. */
#define BW_FTFE_FPROT2_PROT(x, v) (HW_FTFE_FPROT2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FPROT1 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FPROT1 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFE command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions of equal
 * memory size. Program flash protection register Program flash protection bits
 * FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During
 * the reset sequence, the FPROT registers are loaded with the contents of the
 * program flash protection bytes in the Flash Configuration Field as indicated in
 * the following table. Program flash protection register Flash Configuration Field
 * offset address FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To
 * change the program flash protection that is loaded during the reset sequence,
 * unprotect the sector of program flash memory that contains the Flash
 * Configuration Field. Then, reprogram the program flash protection byte.
 */
typedef union _hw_ftfe_fprot1
{
    uint8_t U;
    struct _hw_ftfe_fprot1_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] Program Flash Region Protect */
    } B;
} hw_ftfe_fprot1_t;

/*!
 * @name Constants and macros for entire FTFE_FPROT1 register
 */
/*@{*/
#define HW_FTFE_FPROT1_ADDR(x)   ((uint32_t)(x) + 0x12U)

#define HW_FTFE_FPROT1(x)        (*(__IO hw_ftfe_fprot1_t *) HW_FTFE_FPROT1_ADDR(x))
#define HW_FTFE_FPROT1_RD(x)     (HW_FTFE_FPROT1(x).U)
#define HW_FTFE_FPROT1_WR(x, v)  (HW_FTFE_FPROT1(x).U = (v))
#define HW_FTFE_FPROT1_SET(x, v) (HW_FTFE_FPROT1_WR(x, HW_FTFE_FPROT1_RD(x) |  (v)))
#define HW_FTFE_FPROT1_CLR(x, v) (HW_FTFE_FPROT1_WR(x, HW_FTFE_FPROT1_RD(x) & ~(v)))
#define HW_FTFE_FPROT1_TOG(x, v) (HW_FTFE_FPROT1_WR(x, HW_FTFE_FPROT1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FPROT1 bitfields
 */

/*!
 * @name Register FTFE_FPROT1, field PROT[7:0] (RW)
 *
 * Each program flash region can be protected from program and erase operations
 * by setting the associated PROT bit. In NVM Normal mode: The protection can
 * only be increased, meaning that currently unprotected memory can be protected,
 * but currently protected memory cannot be unprotected. Since unprotected regions
 * are marked with a 1 and protected regions use a 0, only writes changing 1s to
 * 0s are accepted. This 1-to-0 transition check is performed on a bit-by-bit
 * basis. Those FPROT bits with 1-to-0 transitions are accepted while all bits with
 * 0-to-1 transitions are ignored. In NVM Special mode: All bits of FPROT are
 * writable without restriction. Unprotected areas can be protected and protected
 * areas can be unprotected. The user must never write to any FPROT register while
 * a command is running (CCIF=0). Trying to alter data in any protected area in
 * the program flash memory results in a protection violation error and sets the
 * FSTAT[FPVIOL] bit. A full block erase of a program flash block is not possible
 * if it contains any protected region.
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
/*@{*/
#define BP_FTFE_FPROT1_PROT  (0U)          /*!< Bit position for FTFE_FPROT1_PROT. */
#define BM_FTFE_FPROT1_PROT  (0xFFU)       /*!< Bit mask for FTFE_FPROT1_PROT. */
#define BS_FTFE_FPROT1_PROT  (8U)          /*!< Bit field size in bits for FTFE_FPROT1_PROT. */

/*! @brief Read current value of the FTFE_FPROT1_PROT field. */
#define BR_FTFE_FPROT1_PROT(x) (HW_FTFE_FPROT1(x).U)

/*! @brief Format value for bitfield FTFE_FPROT1_PROT. */
#define BF_FTFE_FPROT1_PROT(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FPROT1_PROT) & BM_FTFE_FPROT1_PROT)

/*! @brief Set the PROT field to a new value. */
#define BW_FTFE_FPROT1_PROT(x, v) (HW_FTFE_FPROT1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FPROT0 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FPROT0 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFE command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions of equal
 * memory size. Program flash protection register Program flash protection bits
 * FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During
 * the reset sequence, the FPROT registers are loaded with the contents of the
 * program flash protection bytes in the Flash Configuration Field as indicated in
 * the following table. Program flash protection register Flash Configuration Field
 * offset address FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To
 * change the program flash protection that is loaded during the reset sequence,
 * unprotect the sector of program flash memory that contains the Flash
 * Configuration Field. Then, reprogram the program flash protection byte.
 */
typedef union _hw_ftfe_fprot0
{
    uint8_t U;
    struct _hw_ftfe_fprot0_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] Program Flash Region Protect */
    } B;
} hw_ftfe_fprot0_t;

/*!
 * @name Constants and macros for entire FTFE_FPROT0 register
 */
/*@{*/
#define HW_FTFE_FPROT0_ADDR(x)   ((uint32_t)(x) + 0x13U)

#define HW_FTFE_FPROT0(x)        (*(__IO hw_ftfe_fprot0_t *) HW_FTFE_FPROT0_ADDR(x))
#define HW_FTFE_FPROT0_RD(x)     (HW_FTFE_FPROT0(x).U)
#define HW_FTFE_FPROT0_WR(x, v)  (HW_FTFE_FPROT0(x).U = (v))
#define HW_FTFE_FPROT0_SET(x, v) (HW_FTFE_FPROT0_WR(x, HW_FTFE_FPROT0_RD(x) |  (v)))
#define HW_FTFE_FPROT0_CLR(x, v) (HW_FTFE_FPROT0_WR(x, HW_FTFE_FPROT0_RD(x) & ~(v)))
#define HW_FTFE_FPROT0_TOG(x, v) (HW_FTFE_FPROT0_WR(x, HW_FTFE_FPROT0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FPROT0 bitfields
 */

/*!
 * @name Register FTFE_FPROT0, field PROT[7:0] (RW)
 *
 * Each program flash region can be protected from program and erase operations
 * by setting the associated PROT bit. In NVM Normal mode: The protection can
 * only be increased, meaning that currently unprotected memory can be protected,
 * but currently protected memory cannot be unprotected. Since unprotected regions
 * are marked with a 1 and protected regions use a 0, only writes changing 1s to
 * 0s are accepted. This 1-to-0 transition check is performed on a bit-by-bit
 * basis. Those FPROT bits with 1-to-0 transitions are accepted while all bits with
 * 0-to-1 transitions are ignored. In NVM Special mode: All bits of FPROT are
 * writable without restriction. Unprotected areas can be protected and protected
 * areas can be unprotected. The user must never write to any FPROT register while
 * a command is running (CCIF=0). Trying to alter data in any protected area in
 * the program flash memory results in a protection violation error and sets the
 * FSTAT[FPVIOL] bit. A full block erase of a program flash block is not possible
 * if it contains any protected region.
 *
 * Values:
 * - 0 - Program flash region is protected.
 * - 1 - Program flash region is not protected
 */
/*@{*/
#define BP_FTFE_FPROT0_PROT  (0U)          /*!< Bit position for FTFE_FPROT0_PROT. */
#define BM_FTFE_FPROT0_PROT  (0xFFU)       /*!< Bit mask for FTFE_FPROT0_PROT. */
#define BS_FTFE_FPROT0_PROT  (8U)          /*!< Bit field size in bits for FTFE_FPROT0_PROT. */

/*! @brief Read current value of the FTFE_FPROT0_PROT field. */
#define BR_FTFE_FPROT0_PROT(x) (HW_FTFE_FPROT0(x).U)

/*! @brief Format value for bitfield FTFE_FPROT0_PROT. */
#define BF_FTFE_FPROT0_PROT(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FPROT0_PROT) & BM_FTFE_FPROT0_PROT)

/*! @brief Set the PROT field to a new value. */
#define BW_FTFE_FPROT0_PROT(x, v) (HW_FTFE_FPROT0_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FEPROT - EEPROM Protection Register
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FEPROT - EEPROM Protection Register (RW)
 *
 * Reset value: 0x00U
 *
 * For devices with FlexNVM: The FEPROT register defines which EEPROM regions of
 * the FlexRAM are protected against program and erase operations. Protected
 * EEPROM regions cannot have their content changed by writing to it. Unprotected
 * regions can be changed by writing to the FlexRAM. For devices with program flash
 * only: This register is reserved and not used.
 */
typedef union _hw_ftfe_feprot
{
    uint8_t U;
    struct _hw_ftfe_feprot_bitfields
    {
        uint8_t EPROT : 8;             /*!< [7:0] EEPROM Region Protect */
    } B;
} hw_ftfe_feprot_t;

/*!
 * @name Constants and macros for entire FTFE_FEPROT register
 */
/*@{*/
#define HW_FTFE_FEPROT_ADDR(x)   ((uint32_t)(x) + 0x16U)

#define HW_FTFE_FEPROT(x)        (*(__IO hw_ftfe_feprot_t *) HW_FTFE_FEPROT_ADDR(x))
#define HW_FTFE_FEPROT_RD(x)     (HW_FTFE_FEPROT(x).U)
#define HW_FTFE_FEPROT_WR(x, v)  (HW_FTFE_FEPROT(x).U = (v))
#define HW_FTFE_FEPROT_SET(x, v) (HW_FTFE_FEPROT_WR(x, HW_FTFE_FEPROT_RD(x) |  (v)))
#define HW_FTFE_FEPROT_CLR(x, v) (HW_FTFE_FEPROT_WR(x, HW_FTFE_FEPROT_RD(x) & ~(v)))
#define HW_FTFE_FEPROT_TOG(x, v) (HW_FTFE_FEPROT_WR(x, HW_FTFE_FEPROT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FEPROT bitfields
 */

/*!
 * @name Register FTFE_FEPROT, field EPROT[7:0] (RW)
 *
 * For devices with program flash only: Reserved For devices with FlexNVM:
 * Individual EEPROM regions can be protected from alteration by setting the
 * associated EPROT bit. The EPROT bits are not used when the FlexNVM Partition Code is
 * set to data flash only. When the FlexNVM Partition Code is set to data flash and
 * EEPROM or EEPROM only, each EPROT bit covers one-eighth of the configured
 * EEPROM data (see the EEPROM Data Set Size parameter description). In NVM Normal
 * mode: The protection can only be increased. This means that
 * currently-unprotected memory can be protected, but currently-protected memory cannot be
 * unprotected. Since unprotected regions are marked with a 1 and protected regions use a
 * 0, only writes changing 1s to 0s are accepted. This 1-to-0 transition check is
 * performed on a bit-by-bit basis. Those FEPROT bits with 1-to-0 transitions
 * are accepted while all bits with 0-to-1 transitions are ignored. In NVM Special
 * mode: All bits of the FEPROT register are writable without restriction.
 * Unprotected areas can be protected and protected areas can be unprotected. Never
 * write to the FEPROT register while a command is running (CCIF=0). Reset: During
 * the reset sequence, the FEPROT register is loaded with the contents of the
 * FlexRAM protection byte in the Flash Configuration Field located in program flash.
 * The flash basis for the reset values is signified by X in the register
 * diagram. To change the EEPROM protection that will be loaded during the reset
 * sequence, the sector of program flash that contains the Flash Configuration Field
 * must be unprotected; then the EEPROM protection byte must be erased and
 * reprogrammed. Trying to alter data by writing to any protected area in the EEPROM
 * results in a protection violation error and sets the FSTAT[FPVIOL] bit.
 *
 * Values:
 * - 0 - For devices with program flash only: Reserved For devices with FlexNVM:
 *     EEPROM region is protected
 * - 1 - For devices with program flash only: Reserved For devices with FlexNVM:
 *     EEPROM region is not protected
 */
/*@{*/
#define BP_FTFE_FEPROT_EPROT (0U)          /*!< Bit position for FTFE_FEPROT_EPROT. */
#define BM_FTFE_FEPROT_EPROT (0xFFU)       /*!< Bit mask for FTFE_FEPROT_EPROT. */
#define BS_FTFE_FEPROT_EPROT (8U)          /*!< Bit field size in bits for FTFE_FEPROT_EPROT. */

/*! @brief Read current value of the FTFE_FEPROT_EPROT field. */
#define BR_FTFE_FEPROT_EPROT(x) (HW_FTFE_FEPROT(x).U)

/*! @brief Format value for bitfield FTFE_FEPROT_EPROT. */
#define BF_FTFE_FEPROT_EPROT(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FEPROT_EPROT) & BM_FTFE_FEPROT_EPROT)

/*! @brief Set the EPROT field to a new value. */
#define BW_FTFE_FEPROT_EPROT(x, v) (HW_FTFE_FEPROT_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_FTFE_FDPROT - Data Flash Protection Register
 ******************************************************************************/

/*!
 * @brief HW_FTFE_FDPROT - Data Flash Protection Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FDPROT register defines which data flash regions are protected against
 * program and erase operations. Protected Flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFE command. Unprotected regions can be changed by both program and erase
 * operations.
 */
typedef union _hw_ftfe_fdprot
{
    uint8_t U;
    struct _hw_ftfe_fdprot_bitfields
    {
        uint8_t DPROT : 8;             /*!< [7:0] Data Flash Region Protect */
    } B;
} hw_ftfe_fdprot_t;

/*!
 * @name Constants and macros for entire FTFE_FDPROT register
 */
/*@{*/
#define HW_FTFE_FDPROT_ADDR(x)   ((uint32_t)(x) + 0x17U)

#define HW_FTFE_FDPROT(x)        (*(__IO hw_ftfe_fdprot_t *) HW_FTFE_FDPROT_ADDR(x))
#define HW_FTFE_FDPROT_RD(x)     (HW_FTFE_FDPROT(x).U)
#define HW_FTFE_FDPROT_WR(x, v)  (HW_FTFE_FDPROT(x).U = (v))
#define HW_FTFE_FDPROT_SET(x, v) (HW_FTFE_FDPROT_WR(x, HW_FTFE_FDPROT_RD(x) |  (v)))
#define HW_FTFE_FDPROT_CLR(x, v) (HW_FTFE_FDPROT_WR(x, HW_FTFE_FDPROT_RD(x) & ~(v)))
#define HW_FTFE_FDPROT_TOG(x, v) (HW_FTFE_FDPROT_WR(x, HW_FTFE_FDPROT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FDPROT bitfields
 */

/*!
 * @name Register FTFE_FDPROT, field DPROT[7:0] (RW)
 *
 * Individual data flash regions can be protected from program and erase
 * operations by setting the associated DPROT bit. Each DPROT bit protects one-eighth of
 * the partitioned data flash memory space. The granularity of data flash
 * protection cannot be less than the data flash sector size. If an unused DPROT bit is
 * set, the Erase all Blocks command does not execute and sets the FSTAT[FPVIOL]
 * bit. In NVM Normal mode: The protection can only be increased, meaning that
 * currently unprotected memory can be protected but currently protected memory
 * cannot be unprotected. Since unprotected regions are marked with a 1 and
 * protected regions use a 0, only writes changing 1s to 0s are accepted. This 1-to-0
 * transition check is performed on a bit-by-bit basis. Those FDPROT bits with
 * 1-to-0 transitions are accepted while all bits with 0-to-1 transitions are
 * ignored. In NVM Special mode: All bits of the FDPROT register are writable without
 * restriction. Unprotected areas can be protected and protected areas can be
 * unprotected. The user must never write to the FDPROT register while a command is
 * running (CCIF=0). Reset: During the reset sequence, the FDPROT register is
 * loaded with the contents of the data flash protection byte in the Flash
 * Configuration Field located in program flash memory. The flash basis for the reset values
 * is signified by X in the register diagram. To change the data flash
 * protection that will be loaded during the reset sequence, unprotect the sector of
 * program flash that contains the Flash Configuration Field. Then, erase and
 * reprogram the data flash protection byte. Trying to alter data with the program and
 * erase commands in any protected area in the data flash memory results in a
 * protection violation error and sets the FSTAT[FPVIOL] bit. A block erase of any
 * data flash memory block (see the Erase Flash Block command description) is not
 * possible if the data flash block contains any protected region or if the FlexNVM
 * memory has been partitioned for EEPROM.
 *
 * Values:
 * - 0 - Data Flash region is protected
 * - 1 - Data Flash region is not protected
 */
/*@{*/
#define BP_FTFE_FDPROT_DPROT (0U)          /*!< Bit position for FTFE_FDPROT_DPROT. */
#define BM_FTFE_FDPROT_DPROT (0xFFU)       /*!< Bit mask for FTFE_FDPROT_DPROT. */
#define BS_FTFE_FDPROT_DPROT (8U)          /*!< Bit field size in bits for FTFE_FDPROT_DPROT. */

/*! @brief Read current value of the FTFE_FDPROT_DPROT field. */
#define BR_FTFE_FDPROT_DPROT(x) (HW_FTFE_FDPROT(x).U)

/*! @brief Format value for bitfield FTFE_FDPROT_DPROT. */
#define BF_FTFE_FDPROT_DPROT(v) ((uint8_t)((uint8_t)(v) << BP_FTFE_FDPROT_DPROT) & BM_FTFE_FDPROT_DPROT)

/*! @brief Set the DPROT field to a new value. */
#define BW_FTFE_FDPROT_DPROT(x, v) (HW_FTFE_FDPROT_WR(x, v))
/*@}*/

/*******************************************************************************
 * hw_ftfe_t - module struct
 ******************************************************************************/
/*!
 * @brief All FTFE module registers.
 */
#pragma pack(1)
typedef struct _hw_ftfe
{
    __IO hw_ftfe_fstat_t FSTAT;            /*!< [0x0] Flash Status Register */
    __IO hw_ftfe_fcnfg_t FCNFG;            /*!< [0x1] Flash Configuration Register */
    __I hw_ftfe_fsec_t FSEC;               /*!< [0x2] Flash Security Register */
    __I hw_ftfe_fopt_t FOPT;               /*!< [0x3] Flash Option Register */
    __IO hw_ftfe_fccob3_t FCCOB3;          /*!< [0x4] Flash Common Command Object Registers */
    __IO hw_ftfe_fccob2_t FCCOB2;          /*!< [0x5] Flash Common Command Object Registers */
    __IO hw_ftfe_fccob1_t FCCOB1;          /*!< [0x6] Flash Common Command Object Registers */
    __IO hw_ftfe_fccob0_t FCCOB0;          /*!< [0x7] Flash Common Command Object Registers */
    __IO hw_ftfe_fccob7_t FCCOB7;          /*!< [0x8] Flash Common Command Object Registers */
    __IO hw_ftfe_fccob6_t FCCOB6;          /*!< [0x9] Flash Common Command Object Registers */
    __IO hw_ftfe_fccob5_t FCCOB5;          /*!< [0xA] Flash Common Command Object Registers */
    __IO hw_ftfe_fccob4_t FCCOB4;          /*!< [0xB] Flash Common Command Object Registers */
    __IO hw_ftfe_fccobb_t FCCOBB;          /*!< [0xC] Flash Common Command Object Registers */
    __IO hw_ftfe_fccoba_t FCCOBA;          /*!< [0xD] Flash Common Command Object Registers */
    __IO hw_ftfe_fccob9_t FCCOB9;          /*!< [0xE] Flash Common Command Object Registers */
    __IO hw_ftfe_fccob8_t FCCOB8;          /*!< [0xF] Flash Common Command Object Registers */
    __IO hw_ftfe_fprot3_t FPROT3;          /*!< [0x10] Program Flash Protection Registers */
    __IO hw_ftfe_fprot2_t FPROT2;          /*!< [0x11] Program Flash Protection Registers */
    __IO hw_ftfe_fprot1_t FPROT1;          /*!< [0x12] Program Flash Protection Registers */
    __IO hw_ftfe_fprot0_t FPROT0;          /*!< [0x13] Program Flash Protection Registers */
    uint8_t _reserved0[2];
    __IO hw_ftfe_feprot_t FEPROT;          /*!< [0x16] EEPROM Protection Register */
    __IO hw_ftfe_fdprot_t FDPROT;          /*!< [0x17] Data Flash Protection Register */
} hw_ftfe_t;
#pragma pack()

/*! @brief Macro to access all FTFE registers. */
/*! @param x FTFE module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_FTFE_REGS(FTFE_BASE)</code>. */
#define HW_FTFE_REGS(x) (*(hw_ftfe_t *)(x))

/*
 * MK64F12 FTM
 *
 * FlexTimer Module
 *
 * Registers defined in this header file:
 * - HW_FTM_SC - Status And Control
 * - HW_FTM_CNT - Counter
 * - HW_FTM_MOD - Modulo
 * - HW_FTM_CnSC - Channel (n) Status And Control
 * - HW_FTM_CnV - Channel (n) Value
 * - HW_FTM_CNTIN - Counter Initial Value
 * - HW_FTM_STATUS - Capture And Compare Status
 * - HW_FTM_MODE - Features Mode Selection
 * - HW_FTM_SYNC - Synchronization
 * - HW_FTM_OUTINIT - Initial State For Channels Output
 * - HW_FTM_OUTMASK - Output Mask
 * - HW_FTM_COMBINE - Function For Linked Channels
 * - HW_FTM_DEADTIME - Deadtime Insertion Control
 * - HW_FTM_EXTTRIG - FTM External Trigger
 * - HW_FTM_POL - Channels Polarity
 * - HW_FTM_FMS - Fault Mode Status
 * - HW_FTM_FILTER - Input Capture Filter Control
 * - HW_FTM_FLTCTRL - Fault Control
 * - HW_FTM_QDCTRL - Quadrature Decoder Control And Status
 * - HW_FTM_CONF - Configuration
 * - HW_FTM_FLTPOL - FTM Fault Input Polarity
 * - HW_FTM_SYNCONF - Synchronization Configuration
 * - HW_FTM_INVCTRL - FTM Inverting Control
 * - HW_FTM_SWOCTRL - FTM Software Output Control
 * - HW_FTM_PWMLOAD - FTM PWM Load
 *
 * - hw_ftm_t - Struct containing all module registers.
 */

#define HW_FTM_INSTANCE_COUNT (4U) /*!< Number of instances of the FTM module. */
#define HW_FTM0 (0U) /*!< Instance number for FTM0. */
#define HW_FTM1 (1U) /*!< Instance number for FTM1. */
#define HW_FTM2 (2U) /*!< Instance number for FTM2. */
#define HW_FTM3 (3U) /*!< Instance number for FTM3. */

/*******************************************************************************
 * HW_FTM_SC - Status And Control
 ******************************************************************************/

/*!
 * @brief HW_FTM_SC - Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * SC contains the overflow status flag and control bits used to configure the
 * interrupt enable, FTM configuration, clock source, and prescaler factor. These
 * controls relate to all channels within this module.
 */
typedef union _hw_ftm_sc
{
    uint32_t U;
    struct _hw_ftm_sc_bitfields
    {
        uint32_t PS : 3;               /*!< [2:0] Prescale Factor Selection */
        uint32_t CLKS : 2;             /*!< [4:3] Clock Source Selection */
        uint32_t CPWMS : 1;            /*!< [5] Center-Aligned PWM Select */
        uint32_t TOIE : 1;             /*!< [6] Timer Overflow Interrupt Enable */
        uint32_t TOF : 1;              /*!< [7] Timer Overflow Flag */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_sc_t;

/*!
 * @name Constants and macros for entire FTM_SC register
 */
/*@{*/
#define HW_FTM_SC_ADDR(x)        ((uint32_t)(x) + 0x0U)

#define HW_FTM_SC(x)             (*(__IO hw_ftm_sc_t *) HW_FTM_SC_ADDR(x))
#define HW_FTM_SC_RD(x)          (HW_FTM_SC(x).U)
#define HW_FTM_SC_WR(x, v)       (HW_FTM_SC(x).U = (v))
#define HW_FTM_SC_SET(x, v)      (HW_FTM_SC_WR(x, HW_FTM_SC_RD(x) |  (v)))
#define HW_FTM_SC_CLR(x, v)      (HW_FTM_SC_WR(x, HW_FTM_SC_RD(x) & ~(v)))
#define HW_FTM_SC_TOG(x, v)      (HW_FTM_SC_WR(x, HW_FTM_SC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_SC bitfields
 */

/*!
 * @name Register FTM_SC, field PS[2:0] (RW)
 *
 * Selects one of 8 division factors for the clock source selected by CLKS. The
 * new prescaler factor affects the clock source on the next system clock cycle
 * after the new value is updated into the register bits. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 000 - Divide by 1
 * - 001 - Divide by 2
 * - 010 - Divide by 4
 * - 011 - Divide by 8
 * - 100 - Divide by 16
 * - 101 - Divide by 32
 * - 110 - Divide by 64
 * - 111 - Divide by 128
 */
/*@{*/
#define BP_FTM_SC_PS         (0U)          /*!< Bit position for FTM_SC_PS. */
#define BM_FTM_SC_PS         (0x00000007U) /*!< Bit mask for FTM_SC_PS. */
#define BS_FTM_SC_PS         (3U)          /*!< Bit field size in bits for FTM_SC_PS. */

/*! @brief Read current value of the FTM_SC_PS field. */
#define BR_FTM_SC_PS(x)      (HW_FTM_SC(x).B.PS)

/*! @brief Format value for bitfield FTM_SC_PS. */
#define BF_FTM_SC_PS(v)      ((uint32_t)((uint32_t)(v) << BP_FTM_SC_PS) & BM_FTM_SC_PS)

/*! @brief Set the PS field to a new value. */
#define BW_FTM_SC_PS(x, v)   (HW_FTM_SC_WR(x, (HW_FTM_SC_RD(x) & ~BM_FTM_SC_PS) | BF_FTM_SC_PS(v)))
/*@}*/

/*!
 * @name Register FTM_SC, field CLKS[4:3] (RW)
 *
 * Selects one of the three FTM counter clock sources. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 00 - No clock selected. This in effect disables the FTM counter.
 * - 01 - System clock
 * - 10 - Fixed frequency clock
 * - 11 - External clock
 */
/*@{*/
#define BP_FTM_SC_CLKS       (3U)          /*!< Bit position for FTM_SC_CLKS. */
#define BM_FTM_SC_CLKS       (0x00000018U) /*!< Bit mask for FTM_SC_CLKS. */
#define BS_FTM_SC_CLKS       (2U)          /*!< Bit field size in bits for FTM_SC_CLKS. */

/*! @brief Read current value of the FTM_SC_CLKS field. */
#define BR_FTM_SC_CLKS(x)    (HW_FTM_SC(x).B.CLKS)

/*! @brief Format value for bitfield FTM_SC_CLKS. */
#define BF_FTM_SC_CLKS(v)    ((uint32_t)((uint32_t)(v) << BP_FTM_SC_CLKS) & BM_FTM_SC_CLKS)

/*! @brief Set the CLKS field to a new value. */
#define BW_FTM_SC_CLKS(x, v) (HW_FTM_SC_WR(x, (HW_FTM_SC_RD(x) & ~BM_FTM_SC_CLKS) | BF_FTM_SC_CLKS(v)))
/*@}*/

/*!
 * @name Register FTM_SC, field CPWMS[5] (RW)
 *
 * Selects CPWM mode. This mode configures the FTM to operate in Up-Down
 * Counting mode. This field is write protected. It can be written only when MODE[WPDIS]
 * = 1.
 *
 * Values:
 * - 0 - FTM counter operates in Up Counting mode.
 * - 1 - FTM counter operates in Up-Down Counting mode.
 */
/*@{*/
#define BP_FTM_SC_CPWMS      (5U)          /*!< Bit position for FTM_SC_CPWMS. */
#define BM_FTM_SC_CPWMS      (0x00000020U) /*!< Bit mask for FTM_SC_CPWMS. */
#define BS_FTM_SC_CPWMS      (1U)          /*!< Bit field size in bits for FTM_SC_CPWMS. */

/*! @brief Read current value of the FTM_SC_CPWMS field. */
#define BR_FTM_SC_CPWMS(x)   (BITBAND_ACCESS32(HW_FTM_SC_ADDR(x), BP_FTM_SC_CPWMS))

/*! @brief Format value for bitfield FTM_SC_CPWMS. */
#define BF_FTM_SC_CPWMS(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_SC_CPWMS) & BM_FTM_SC_CPWMS)

/*! @brief Set the CPWMS field to a new value. */
#define BW_FTM_SC_CPWMS(x, v) (BITBAND_ACCESS32(HW_FTM_SC_ADDR(x), BP_FTM_SC_CPWMS) = (v))
/*@}*/

/*!
 * @name Register FTM_SC, field TOIE[6] (RW)
 *
 * Enables FTM overflow interrupts.
 *
 * Values:
 * - 0 - Disable TOF interrupts. Use software polling.
 * - 1 - Enable TOF interrupts. An interrupt is generated when TOF equals one.
 */
/*@{*/
#define BP_FTM_SC_TOIE       (6U)          /*!< Bit position for FTM_SC_TOIE. */
#define BM_FTM_SC_TOIE       (0x00000040U) /*!< Bit mask for FTM_SC_TOIE. */
#define BS_FTM_SC_TOIE       (1U)          /*!< Bit field size in bits for FTM_SC_TOIE. */

/*! @brief Read current value of the FTM_SC_TOIE field. */
#define BR_FTM_SC_TOIE(x)    (BITBAND_ACCESS32(HW_FTM_SC_ADDR(x), BP_FTM_SC_TOIE))

/*! @brief Format value for bitfield FTM_SC_TOIE. */
#define BF_FTM_SC_TOIE(v)    ((uint32_t)((uint32_t)(v) << BP_FTM_SC_TOIE) & BM_FTM_SC_TOIE)

/*! @brief Set the TOIE field to a new value. */
#define BW_FTM_SC_TOIE(x, v) (BITBAND_ACCESS32(HW_FTM_SC_ADDR(x), BP_FTM_SC_TOIE) = (v))
/*@}*/

/*!
 * @name Register FTM_SC, field TOF[7] (ROWZ)
 *
 * Set by hardware when the FTM counter passes the value in the MOD register.
 * The TOF bit is cleared by reading the SC register while TOF is set and then
 * writing a 0 to TOF bit. Writing a 1 to TOF has no effect. If another FTM overflow
 * occurs between the read and write operations, the write operation has no
 * effect; therefore, TOF remains set indicating an overflow has occurred. In this
 * case, a TOF interrupt request is not lost due to the clearing sequence for a
 * previous TOF.
 *
 * Values:
 * - 0 - FTM counter has not overflowed.
 * - 1 - FTM counter has overflowed.
 */
/*@{*/
#define BP_FTM_SC_TOF        (7U)          /*!< Bit position for FTM_SC_TOF. */
#define BM_FTM_SC_TOF        (0x00000080U) /*!< Bit mask for FTM_SC_TOF. */
#define BS_FTM_SC_TOF        (1U)          /*!< Bit field size in bits for FTM_SC_TOF. */

/*! @brief Read current value of the FTM_SC_TOF field. */
#define BR_FTM_SC_TOF(x)     (BITBAND_ACCESS32(HW_FTM_SC_ADDR(x), BP_FTM_SC_TOF))

/*! @brief Format value for bitfield FTM_SC_TOF. */
#define BF_FTM_SC_TOF(v)     ((uint32_t)((uint32_t)(v) << BP_FTM_SC_TOF) & BM_FTM_SC_TOF)

/*! @brief Set the TOF field to a new value. */
#define BW_FTM_SC_TOF(x, v)  (BITBAND_ACCESS32(HW_FTM_SC_ADDR(x), BP_FTM_SC_TOF) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_CNT - Counter
 ******************************************************************************/

/*!
 * @brief HW_FTM_CNT - Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CNT register contains the FTM counter value. Reset clears the CNT
 * register. Writing any value to COUNT updates the counter with its initial value,
 * CNTIN. When BDM is active, the FTM counter is frozen. This is the value that you
 * may read.
 */
typedef union _hw_ftm_cnt
{
    uint32_t U;
    struct _hw_ftm_cnt_bitfields
    {
        uint32_t COUNT : 16;           /*!< [15:0] Counter Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_ftm_cnt_t;

/*!
 * @name Constants and macros for entire FTM_CNT register
 */
/*@{*/
#define HW_FTM_CNT_ADDR(x)       ((uint32_t)(x) + 0x4U)

#define HW_FTM_CNT(x)            (*(__IO hw_ftm_cnt_t *) HW_FTM_CNT_ADDR(x))
#define HW_FTM_CNT_RD(x)         (HW_FTM_CNT(x).U)
#define HW_FTM_CNT_WR(x, v)      (HW_FTM_CNT(x).U = (v))
#define HW_FTM_CNT_SET(x, v)     (HW_FTM_CNT_WR(x, HW_FTM_CNT_RD(x) |  (v)))
#define HW_FTM_CNT_CLR(x, v)     (HW_FTM_CNT_WR(x, HW_FTM_CNT_RD(x) & ~(v)))
#define HW_FTM_CNT_TOG(x, v)     (HW_FTM_CNT_WR(x, HW_FTM_CNT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_CNT bitfields
 */

/*!
 * @name Register FTM_CNT, field COUNT[15:0] (RW)
 */
/*@{*/
#define BP_FTM_CNT_COUNT     (0U)          /*!< Bit position for FTM_CNT_COUNT. */
#define BM_FTM_CNT_COUNT     (0x0000FFFFU) /*!< Bit mask for FTM_CNT_COUNT. */
#define BS_FTM_CNT_COUNT     (16U)         /*!< Bit field size in bits for FTM_CNT_COUNT. */

/*! @brief Read current value of the FTM_CNT_COUNT field. */
#define BR_FTM_CNT_COUNT(x)  (HW_FTM_CNT(x).B.COUNT)

/*! @brief Format value for bitfield FTM_CNT_COUNT. */
#define BF_FTM_CNT_COUNT(v)  ((uint32_t)((uint32_t)(v) << BP_FTM_CNT_COUNT) & BM_FTM_CNT_COUNT)

/*! @brief Set the COUNT field to a new value. */
#define BW_FTM_CNT_COUNT(x, v) (HW_FTM_CNT_WR(x, (HW_FTM_CNT_RD(x) & ~BM_FTM_CNT_COUNT) | BF_FTM_CNT_COUNT(v)))
/*@}*/

/*******************************************************************************
 * HW_FTM_MOD - Modulo
 ******************************************************************************/

/*!
 * @brief HW_FTM_MOD - Modulo (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Modulo register contains the modulo value for the FTM counter. After the
 * FTM counter reaches the modulo value, the overflow flag (TOF) becomes set at
 * the next clock, and the next value of FTM counter depends on the selected
 * counting method; see Counter. Writing to the MOD register latches the value into a
 * buffer. The MOD register is updated with the value of its write buffer
 * according to Registers updated from write buffers. If FTMEN = 0, this write coherency
 * mechanism may be manually reset by writing to the SC register whether BDM is
 * active or not. Initialize the FTM counter, by writing to CNT, before writing
 * to the MOD register to avoid confusion about when the first counter overflow
 * will occur.
 */
typedef union _hw_ftm_mod
{
    uint32_t U;
    struct _hw_ftm_mod_bitfields
    {
        uint32_t MOD : 16;             /*!< [15:0]  */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_ftm_mod_t;

/*!
 * @name Constants and macros for entire FTM_MOD register
 */
/*@{*/
#define HW_FTM_MOD_ADDR(x)       ((uint32_t)(x) + 0x8U)

#define HW_FTM_MOD(x)            (*(__IO hw_ftm_mod_t *) HW_FTM_MOD_ADDR(x))
#define HW_FTM_MOD_RD(x)         (HW_FTM_MOD(x).U)
#define HW_FTM_MOD_WR(x, v)      (HW_FTM_MOD(x).U = (v))
#define HW_FTM_MOD_SET(x, v)     (HW_FTM_MOD_WR(x, HW_FTM_MOD_RD(x) |  (v)))
#define HW_FTM_MOD_CLR(x, v)     (HW_FTM_MOD_WR(x, HW_FTM_MOD_RD(x) & ~(v)))
#define HW_FTM_MOD_TOG(x, v)     (HW_FTM_MOD_WR(x, HW_FTM_MOD_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_MOD bitfields
 */

/*!
 * @name Register FTM_MOD, field MOD[15:0] (RW)
 *
 * Modulo Value
 */
/*@{*/
#define BP_FTM_MOD_MOD       (0U)          /*!< Bit position for FTM_MOD_MOD. */
#define BM_FTM_MOD_MOD       (0x0000FFFFU) /*!< Bit mask for FTM_MOD_MOD. */
#define BS_FTM_MOD_MOD       (16U)         /*!< Bit field size in bits for FTM_MOD_MOD. */

/*! @brief Read current value of the FTM_MOD_MOD field. */
#define BR_FTM_MOD_MOD(x)    (HW_FTM_MOD(x).B.MOD)

/*! @brief Format value for bitfield FTM_MOD_MOD. */
#define BF_FTM_MOD_MOD(v)    ((uint32_t)((uint32_t)(v) << BP_FTM_MOD_MOD) & BM_FTM_MOD_MOD)

/*! @brief Set the MOD field to a new value. */
#define BW_FTM_MOD_MOD(x, v) (HW_FTM_MOD_WR(x, (HW_FTM_MOD_RD(x) & ~BM_FTM_MOD_MOD) | BF_FTM_MOD_MOD(v)))
/*@}*/

/*******************************************************************************
 * HW_FTM_CnSC - Channel (n) Status And Control
 ******************************************************************************/

/*!
 * @brief HW_FTM_CnSC - Channel (n) Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. Mode,
 * edge, and level selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 0 Pin not used for FTM-revert the channel pin to general
 * purpose I/O or other peripheral control 0 0 0 0 1 Input Capture Capture on Rising
 * Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or Falling Edge
 * 1 1 Output Compare Toggle Output on match 10 Clear Output on match 11 Set
 * Output on match 1X 10 Edge-Aligned PWM High-true pulses (clear Output on match)
 * X1 Low-true pulses (set Output on match) 1 XX 10 Center-Aligned PWM High-true
 * pulses (clear Output on match-up) X1 Low-true pulses (set Output on match-up) 1
 * 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and clear on
 * channel (n+1) match) X1 Low-true pulses (clear on channel (n) match, and set
 * on channel (n+1) match) 1 0 0 X0 See the following table (#ModeSel2Table). Dual
 * Edge Capture One-Shot Capture mode X1 Continuous Capture mode Dual Edge
 * Capture mode - edge polarity selection ELSnB ELSnA Channel Port Enable Detected
 * Edges 0 0 Disabled No edge 0 1 Enabled Rising edge 1 0 Enabled Falling edge 1 1
 * Enabled Rising and falling edges
 */
typedef union _hw_ftm_cnsc
{
    uint32_t U;
    struct _hw_ftm_cnsc_bitfields
    {
        uint32_t DMA : 1;              /*!< [0] DMA Enable */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t ELSA : 1;             /*!< [2] Edge or Level Select */
        uint32_t ELSB : 1;             /*!< [3] Edge or Level Select */
        uint32_t MSA : 1;              /*!< [4] Channel Mode Select */
        uint32_t MSB : 1;              /*!< [5] Channel Mode Select */
        uint32_t CHIE : 1;             /*!< [6] Channel Interrupt Enable */
        uint32_t CHF : 1;              /*!< [7] Channel Flag */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_cnsc_t;

/*!
 * @name Constants and macros for entire FTM_CnSC register
 */
/*@{*/
#define HW_FTM_CnSC_COUNT (8U)

#define HW_FTM_CnSC_ADDR(x, n)   ((uint32_t)(x) + 0xCU + (0x8U * (n)))

#define HW_FTM_CnSC(x, n)        (*(__IO hw_ftm_cnsc_t *) HW_FTM_CnSC_ADDR(x, n))
#define HW_FTM_CnSC_RD(x, n)     (HW_FTM_CnSC(x, n).U)
#define HW_FTM_CnSC_WR(x, n, v)  (HW_FTM_CnSC(x, n).U = (v))
#define HW_FTM_CnSC_SET(x, n, v) (HW_FTM_CnSC_WR(x, n, HW_FTM_CnSC_RD(x, n) |  (v)))
#define HW_FTM_CnSC_CLR(x, n, v) (HW_FTM_CnSC_WR(x, n, HW_FTM_CnSC_RD(x, n) & ~(v)))
#define HW_FTM_CnSC_TOG(x, n, v) (HW_FTM_CnSC_WR(x, n, HW_FTM_CnSC_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_CnSC bitfields
 */

/*!
 * @name Register FTM_CnSC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0 - Disable DMA transfers.
 * - 1 - Enable DMA transfers.
 */
/*@{*/
#define BP_FTM_CnSC_DMA      (0U)          /*!< Bit position for FTM_CnSC_DMA. */
#define BM_FTM_CnSC_DMA      (0x00000001U) /*!< Bit mask for FTM_CnSC_DMA. */
#define BS_FTM_CnSC_DMA      (1U)          /*!< Bit field size in bits for FTM_CnSC_DMA. */

/*! @brief Read current value of the FTM_CnSC_DMA field. */
#define BR_FTM_CnSC_DMA(x, n) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_DMA))

/*! @brief Format value for bitfield FTM_CnSC_DMA. */
#define BF_FTM_CnSC_DMA(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_CnSC_DMA) & BM_FTM_CnSC_DMA)

/*! @brief Set the DMA field to a new value. */
#define BW_FTM_CnSC_DMA(x, n, v) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_DMA) = (v))
/*@}*/

/*!
 * @name Register FTM_CnSC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See
 * #ModeSel1Table. This field is write protected. It can be written only when MODE[WPDIS]
 * = 1.
 */
/*@{*/
#define BP_FTM_CnSC_ELSA     (2U)          /*!< Bit position for FTM_CnSC_ELSA. */
#define BM_FTM_CnSC_ELSA     (0x00000004U) /*!< Bit mask for FTM_CnSC_ELSA. */
#define BS_FTM_CnSC_ELSA     (1U)          /*!< Bit field size in bits for FTM_CnSC_ELSA. */

/*! @brief Read current value of the FTM_CnSC_ELSA field. */
#define BR_FTM_CnSC_ELSA(x, n) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_ELSA))

/*! @brief Format value for bitfield FTM_CnSC_ELSA. */
#define BF_FTM_CnSC_ELSA(v)  ((uint32_t)((uint32_t)(v) << BP_FTM_CnSC_ELSA) & BM_FTM_CnSC_ELSA)

/*! @brief Set the ELSA field to a new value. */
#define BW_FTM_CnSC_ELSA(x, n, v) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_ELSA) = (v))
/*@}*/

/*!
 * @name Register FTM_CnSC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See
 * #ModeSel1Table. This field is write protected. It can be written only when MODE[WPDIS]
 * = 1.
 */
/*@{*/
#define BP_FTM_CnSC_ELSB     (3U)          /*!< Bit position for FTM_CnSC_ELSB. */
#define BM_FTM_CnSC_ELSB     (0x00000008U) /*!< Bit mask for FTM_CnSC_ELSB. */
#define BS_FTM_CnSC_ELSB     (1U)          /*!< Bit field size in bits for FTM_CnSC_ELSB. */

/*! @brief Read current value of the FTM_CnSC_ELSB field. */
#define BR_FTM_CnSC_ELSB(x, n) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_ELSB))

/*! @brief Format value for bitfield FTM_CnSC_ELSB. */
#define BF_FTM_CnSC_ELSB(v)  ((uint32_t)((uint32_t)(v) << BP_FTM_CnSC_ELSB) & BM_FTM_CnSC_ELSB)

/*! @brief Set the ELSB field to a new value. */
#define BW_FTM_CnSC_ELSB(x, n, v) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_ELSB) = (v))
/*@}*/

/*!
 * @name Register FTM_CnSC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See #ModeSel1Table. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
#define BP_FTM_CnSC_MSA      (4U)          /*!< Bit position for FTM_CnSC_MSA. */
#define BM_FTM_CnSC_MSA      (0x00000010U) /*!< Bit mask for FTM_CnSC_MSA. */
#define BS_FTM_CnSC_MSA      (1U)          /*!< Bit field size in bits for FTM_CnSC_MSA. */

/*! @brief Read current value of the FTM_CnSC_MSA field. */
#define BR_FTM_CnSC_MSA(x, n) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_MSA))

/*! @brief Format value for bitfield FTM_CnSC_MSA. */
#define BF_FTM_CnSC_MSA(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_CnSC_MSA) & BM_FTM_CnSC_MSA)

/*! @brief Set the MSA field to a new value. */
#define BW_FTM_CnSC_MSA(x, n, v) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_MSA) = (v))
/*@}*/

/*!
 * @name Register FTM_CnSC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See #ModeSel1Table. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
#define BP_FTM_CnSC_MSB      (5U)          /*!< Bit position for FTM_CnSC_MSB. */
#define BM_FTM_CnSC_MSB      (0x00000020U) /*!< Bit mask for FTM_CnSC_MSB. */
#define BS_FTM_CnSC_MSB      (1U)          /*!< Bit field size in bits for FTM_CnSC_MSB. */

/*! @brief Read current value of the FTM_CnSC_MSB field. */
#define BR_FTM_CnSC_MSB(x, n) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_MSB))

/*! @brief Format value for bitfield FTM_CnSC_MSB. */
#define BF_FTM_CnSC_MSB(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_CnSC_MSB) & BM_FTM_CnSC_MSB)

/*! @brief Set the MSB field to a new value. */
#define BW_FTM_CnSC_MSB(x, n, v) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_MSB) = (v))
/*@}*/

/*!
 * @name Register FTM_CnSC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0 - Disable channel interrupts. Use software polling.
 * - 1 - Enable channel interrupts.
 */
/*@{*/
#define BP_FTM_CnSC_CHIE     (6U)          /*!< Bit position for FTM_CnSC_CHIE. */
#define BM_FTM_CnSC_CHIE     (0x00000040U) /*!< Bit mask for FTM_CnSC_CHIE. */
#define BS_FTM_CnSC_CHIE     (1U)          /*!< Bit field size in bits for FTM_CnSC_CHIE. */

/*! @brief Read current value of the FTM_CnSC_CHIE field. */
#define BR_FTM_CnSC_CHIE(x, n) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_CHIE))

/*! @brief Format value for bitfield FTM_CnSC_CHIE. */
#define BF_FTM_CnSC_CHIE(v)  ((uint32_t)((uint32_t)(v) << BP_FTM_CnSC_CHIE) & BM_FTM_CnSC_CHIE)

/*! @brief Set the CHIE field to a new value. */
#define BW_FTM_CnSC_CHIE(x, n, v) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_CHIE) = (v))
/*@}*/

/*!
 * @name Register FTM_CnSC, field CHF[7] (ROWZ)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * reading the CSC register while CHnF is set and then writing a 0 to the CHF bit.
 * Writing a 1 to CHF has no effect. If another event occurs between the read and
 * write operations, the write operation has no effect; therefore, CHF remains set
 * indicating an event has occurred. In this case a CHF interrupt request is not
 * lost due to the clearing sequence for a previous CHF.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_FTM_CnSC_CHF      (7U)          /*!< Bit position for FTM_CnSC_CHF. */
#define BM_FTM_CnSC_CHF      (0x00000080U) /*!< Bit mask for FTM_CnSC_CHF. */
#define BS_FTM_CnSC_CHF      (1U)          /*!< Bit field size in bits for FTM_CnSC_CHF. */

/*! @brief Read current value of the FTM_CnSC_CHF field. */
#define BR_FTM_CnSC_CHF(x, n) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_CHF))

/*! @brief Format value for bitfield FTM_CnSC_CHF. */
#define BF_FTM_CnSC_CHF(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_CnSC_CHF) & BM_FTM_CnSC_CHF)

/*! @brief Set the CHF field to a new value. */
#define BW_FTM_CnSC_CHF(x, n, v) (BITBAND_ACCESS32(HW_FTM_CnSC_ADDR(x, n), BP_FTM_CnSC_CHF) = (v))
/*@}*/
/*******************************************************************************
 * HW_FTM_CnV - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief HW_FTM_CnV - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In Input Capture, Capture Test, and
 * Dual Edge Capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers updated from
 * write buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register whether BDM mode is active or not.
 */
typedef union _hw_ftm_cnv
{
    uint32_t U;
    struct _hw_ftm_cnv_bitfields
    {
        uint32_t VAL : 16;             /*!< [15:0] Channel Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_ftm_cnv_t;

/*!
 * @name Constants and macros for entire FTM_CnV register
 */
/*@{*/
#define HW_FTM_CnV_COUNT (8U)

#define HW_FTM_CnV_ADDR(x, n)    ((uint32_t)(x) + 0x10U + (0x8U * (n)))

#define HW_FTM_CnV(x, n)         (*(__IO hw_ftm_cnv_t *) HW_FTM_CnV_ADDR(x, n))
#define HW_FTM_CnV_RD(x, n)      (HW_FTM_CnV(x, n).U)
#define HW_FTM_CnV_WR(x, n, v)   (HW_FTM_CnV(x, n).U = (v))
#define HW_FTM_CnV_SET(x, n, v)  (HW_FTM_CnV_WR(x, n, HW_FTM_CnV_RD(x, n) |  (v)))
#define HW_FTM_CnV_CLR(x, n, v)  (HW_FTM_CnV_WR(x, n, HW_FTM_CnV_RD(x, n) & ~(v)))
#define HW_FTM_CnV_TOG(x, n, v)  (HW_FTM_CnV_WR(x, n, HW_FTM_CnV_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_CnV bitfields
 */

/*!
 * @name Register FTM_CnV, field VAL[15:0] (RW)
 *
 * Captured FTM counter value of the input modes or the match value for the
 * output modes
 */
/*@{*/
#define BP_FTM_CnV_VAL       (0U)          /*!< Bit position for FTM_CnV_VAL. */
#define BM_FTM_CnV_VAL       (0x0000FFFFU) /*!< Bit mask for FTM_CnV_VAL. */
#define BS_FTM_CnV_VAL       (16U)         /*!< Bit field size in bits for FTM_CnV_VAL. */

/*! @brief Read current value of the FTM_CnV_VAL field. */
#define BR_FTM_CnV_VAL(x, n) (HW_FTM_CnV(x, n).B.VAL)

/*! @brief Format value for bitfield FTM_CnV_VAL. */
#define BF_FTM_CnV_VAL(v)    ((uint32_t)((uint32_t)(v) << BP_FTM_CnV_VAL) & BM_FTM_CnV_VAL)

/*! @brief Set the VAL field to a new value. */
#define BW_FTM_CnV_VAL(x, n, v) (HW_FTM_CnV_WR(x, n, (HW_FTM_CnV_RD(x, n) & ~BM_FTM_CnV_VAL) | BF_FTM_CnV_VAL(v)))
/*@}*/

/*******************************************************************************
 * HW_FTM_CNTIN - Counter Initial Value
 ******************************************************************************/

/*!
 * @brief HW_FTM_CNTIN - Counter Initial Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Counter Initial Value register contains the initial value for the FTM
 * counter. Writing to the CNTIN register latches the value into a buffer. The CNTIN
 * register is updated with the value of its write buffer according to Registers
 * updated from write buffers. When the FTM clock is initially selected, by
 * writing a non-zero value to the CLKS bits, the FTM counter starts with the value
 * 0x0000. To avoid this behavior, before the first write to select the FTM clock,
 * write the new value to the the CNTIN register and then initialize the FTM
 * counter by writing any value to the CNT register.
 */
typedef union _hw_ftm_cntin
{
    uint32_t U;
    struct _hw_ftm_cntin_bitfields
    {
        uint32_t INIT : 16;            /*!< [15:0]  */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_ftm_cntin_t;

/*!
 * @name Constants and macros for entire FTM_CNTIN register
 */
/*@{*/
#define HW_FTM_CNTIN_ADDR(x)     ((uint32_t)(x) + 0x4CU)

#define HW_FTM_CNTIN(x)          (*(__IO hw_ftm_cntin_t *) HW_FTM_CNTIN_ADDR(x))
#define HW_FTM_CNTIN_RD(x)       (HW_FTM_CNTIN(x).U)
#define HW_FTM_CNTIN_WR(x, v)    (HW_FTM_CNTIN(x).U = (v))
#define HW_FTM_CNTIN_SET(x, v)   (HW_FTM_CNTIN_WR(x, HW_FTM_CNTIN_RD(x) |  (v)))
#define HW_FTM_CNTIN_CLR(x, v)   (HW_FTM_CNTIN_WR(x, HW_FTM_CNTIN_RD(x) & ~(v)))
#define HW_FTM_CNTIN_TOG(x, v)   (HW_FTM_CNTIN_WR(x, HW_FTM_CNTIN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_CNTIN bitfields
 */

/*!
 * @name Register FTM_CNTIN, field INIT[15:0] (RW)
 *
 * Initial Value Of The FTM Counter
 */
/*@{*/
#define BP_FTM_CNTIN_INIT    (0U)          /*!< Bit position for FTM_CNTIN_INIT. */
#define BM_FTM_CNTIN_INIT    (0x0000FFFFU) /*!< Bit mask for FTM_CNTIN_INIT. */
#define BS_FTM_CNTIN_INIT    (16U)         /*!< Bit field size in bits for FTM_CNTIN_INIT. */

/*! @brief Read current value of the FTM_CNTIN_INIT field. */
#define BR_FTM_CNTIN_INIT(x) (HW_FTM_CNTIN(x).B.INIT)

/*! @brief Format value for bitfield FTM_CNTIN_INIT. */
#define BF_FTM_CNTIN_INIT(v) ((uint32_t)((uint32_t)(v) << BP_FTM_CNTIN_INIT) & BM_FTM_CNTIN_INIT)

/*! @brief Set the INIT field to a new value. */
#define BW_FTM_CNTIN_INIT(x, v) (HW_FTM_CNTIN_WR(x, (HW_FTM_CNTIN_RD(x) & ~BM_FTM_CNTIN_INIT) | BF_FTM_CNTIN_INIT(v)))
/*@}*/

/*******************************************************************************
 * HW_FTM_STATUS - Capture And Compare Status
 ******************************************************************************/

/*!
 * @brief HW_FTM_STATUS - Capture And Compare Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * The STATUS register contains a copy of the status flag CHnF bit in CnSC for
 * each FTM channel for software convenience. Each CHnF bit in STATUS is a mirror
 * of CHnF bit in CnSC. All CHnF bits can be checked using only one read of
 * STATUS. All CHnF bits can be cleared by reading STATUS followed by writing 0x00 to
 * STATUS. Hardware sets the individual channel flags when an event occurs on the
 * channel. CHnF is cleared by reading STATUS while CHnF is set and then writing
 * a 0 to the CHnF bit. Writing a 1 to CHnF has no effect. If another event
 * occurs between the read and write operations, the write operation has no effect;
 * therefore, CHnF remains set indicating an event has occurred. In this case, a
 * CHnF interrupt request is not lost due to the clearing sequence for a previous
 * CHnF. The STATUS register should be used only in Combine mode.
 */
typedef union _hw_ftm_status
{
    uint32_t U;
    struct _hw_ftm_status_bitfields
    {
        uint32_t CH0F : 1;             /*!< [0] Channel 0 Flag */
        uint32_t CH1F : 1;             /*!< [1] Channel 1 Flag */
        uint32_t CH2F : 1;             /*!< [2] Channel 2 Flag */
        uint32_t CH3F : 1;             /*!< [3] Channel 3 Flag */
        uint32_t CH4F : 1;             /*!< [4] Channel 4 Flag */
        uint32_t CH5F : 1;             /*!< [5] Channel 5 Flag */
        uint32_t CH6F : 1;             /*!< [6] Channel 6 Flag */
        uint32_t CH7F : 1;             /*!< [7] Channel 7 Flag */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_status_t;

/*!
 * @name Constants and macros for entire FTM_STATUS register
 */
/*@{*/
#define HW_FTM_STATUS_ADDR(x)    ((uint32_t)(x) + 0x50U)

#define HW_FTM_STATUS(x)         (*(__IO hw_ftm_status_t *) HW_FTM_STATUS_ADDR(x))
#define HW_FTM_STATUS_RD(x)      (HW_FTM_STATUS(x).U)
#define HW_FTM_STATUS_WR(x, v)   (HW_FTM_STATUS(x).U = (v))
#define HW_FTM_STATUS_SET(x, v)  (HW_FTM_STATUS_WR(x, HW_FTM_STATUS_RD(x) |  (v)))
#define HW_FTM_STATUS_CLR(x, v)  (HW_FTM_STATUS_WR(x, HW_FTM_STATUS_RD(x) & ~(v)))
#define HW_FTM_STATUS_TOG(x, v)  (HW_FTM_STATUS_WR(x, HW_FTM_STATUS_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_STATUS bitfields
 */

/*!
 * @name Register FTM_STATUS, field CH0F[0] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_FTM_STATUS_CH0F   (0U)          /*!< Bit position for FTM_STATUS_CH0F. */
#define BM_FTM_STATUS_CH0F   (0x00000001U) /*!< Bit mask for FTM_STATUS_CH0F. */
#define BS_FTM_STATUS_CH0F   (1U)          /*!< Bit field size in bits for FTM_STATUS_CH0F. */

/*! @brief Read current value of the FTM_STATUS_CH0F field. */
#define BR_FTM_STATUS_CH0F(x) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH0F))

/*! @brief Format value for bitfield FTM_STATUS_CH0F. */
#define BF_FTM_STATUS_CH0F(v) ((uint32_t)((uint32_t)(v) << BP_FTM_STATUS_CH0F) & BM_FTM_STATUS_CH0F)

/*! @brief Set the CH0F field to a new value. */
#define BW_FTM_STATUS_CH0F(x, v) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH0F) = (v))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH1F[1] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_FTM_STATUS_CH1F   (1U)          /*!< Bit position for FTM_STATUS_CH1F. */
#define BM_FTM_STATUS_CH1F   (0x00000002U) /*!< Bit mask for FTM_STATUS_CH1F. */
#define BS_FTM_STATUS_CH1F   (1U)          /*!< Bit field size in bits for FTM_STATUS_CH1F. */

/*! @brief Read current value of the FTM_STATUS_CH1F field. */
#define BR_FTM_STATUS_CH1F(x) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH1F))

/*! @brief Format value for bitfield FTM_STATUS_CH1F. */
#define BF_FTM_STATUS_CH1F(v) ((uint32_t)((uint32_t)(v) << BP_FTM_STATUS_CH1F) & BM_FTM_STATUS_CH1F)

/*! @brief Set the CH1F field to a new value. */
#define BW_FTM_STATUS_CH1F(x, v) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH1F) = (v))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH2F[2] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_FTM_STATUS_CH2F   (2U)          /*!< Bit position for FTM_STATUS_CH2F. */
#define BM_FTM_STATUS_CH2F   (0x00000004U) /*!< Bit mask for FTM_STATUS_CH2F. */
#define BS_FTM_STATUS_CH2F   (1U)          /*!< Bit field size in bits for FTM_STATUS_CH2F. */

/*! @brief Read current value of the FTM_STATUS_CH2F field. */
#define BR_FTM_STATUS_CH2F(x) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH2F))

/*! @brief Format value for bitfield FTM_STATUS_CH2F. */
#define BF_FTM_STATUS_CH2F(v) ((uint32_t)((uint32_t)(v) << BP_FTM_STATUS_CH2F) & BM_FTM_STATUS_CH2F)

/*! @brief Set the CH2F field to a new value. */
#define BW_FTM_STATUS_CH2F(x, v) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH2F) = (v))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH3F[3] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_FTM_STATUS_CH3F   (3U)          /*!< Bit position for FTM_STATUS_CH3F. */
#define BM_FTM_STATUS_CH3F   (0x00000008U) /*!< Bit mask for FTM_STATUS_CH3F. */
#define BS_FTM_STATUS_CH3F   (1U)          /*!< Bit field size in bits for FTM_STATUS_CH3F. */

/*! @brief Read current value of the FTM_STATUS_CH3F field. */
#define BR_FTM_STATUS_CH3F(x) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH3F))

/*! @brief Format value for bitfield FTM_STATUS_CH3F. */
#define BF_FTM_STATUS_CH3F(v) ((uint32_t)((uint32_t)(v) << BP_FTM_STATUS_CH3F) & BM_FTM_STATUS_CH3F)

/*! @brief Set the CH3F field to a new value. */
#define BW_FTM_STATUS_CH3F(x, v) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH3F) = (v))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH4F[4] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_FTM_STATUS_CH4F   (4U)          /*!< Bit position for FTM_STATUS_CH4F. */
#define BM_FTM_STATUS_CH4F   (0x00000010U) /*!< Bit mask for FTM_STATUS_CH4F. */
#define BS_FTM_STATUS_CH4F   (1U)          /*!< Bit field size in bits for FTM_STATUS_CH4F. */

/*! @brief Read current value of the FTM_STATUS_CH4F field. */
#define BR_FTM_STATUS_CH4F(x) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH4F))

/*! @brief Format value for bitfield FTM_STATUS_CH4F. */
#define BF_FTM_STATUS_CH4F(v) ((uint32_t)((uint32_t)(v) << BP_FTM_STATUS_CH4F) & BM_FTM_STATUS_CH4F)

/*! @brief Set the CH4F field to a new value. */
#define BW_FTM_STATUS_CH4F(x, v) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH4F) = (v))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH5F[5] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_FTM_STATUS_CH5F   (5U)          /*!< Bit position for FTM_STATUS_CH5F. */
#define BM_FTM_STATUS_CH5F   (0x00000020U) /*!< Bit mask for FTM_STATUS_CH5F. */
#define BS_FTM_STATUS_CH5F   (1U)          /*!< Bit field size in bits for FTM_STATUS_CH5F. */

/*! @brief Read current value of the FTM_STATUS_CH5F field. */
#define BR_FTM_STATUS_CH5F(x) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH5F))

/*! @brief Format value for bitfield FTM_STATUS_CH5F. */
#define BF_FTM_STATUS_CH5F(v) ((uint32_t)((uint32_t)(v) << BP_FTM_STATUS_CH5F) & BM_FTM_STATUS_CH5F)

/*! @brief Set the CH5F field to a new value. */
#define BW_FTM_STATUS_CH5F(x, v) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH5F) = (v))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH6F[6] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_FTM_STATUS_CH6F   (6U)          /*!< Bit position for FTM_STATUS_CH6F. */
#define BM_FTM_STATUS_CH6F   (0x00000040U) /*!< Bit mask for FTM_STATUS_CH6F. */
#define BS_FTM_STATUS_CH6F   (1U)          /*!< Bit field size in bits for FTM_STATUS_CH6F. */

/*! @brief Read current value of the FTM_STATUS_CH6F field. */
#define BR_FTM_STATUS_CH6F(x) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH6F))

/*! @brief Format value for bitfield FTM_STATUS_CH6F. */
#define BF_FTM_STATUS_CH6F(v) ((uint32_t)((uint32_t)(v) << BP_FTM_STATUS_CH6F) & BM_FTM_STATUS_CH6F)

/*! @brief Set the CH6F field to a new value. */
#define BW_FTM_STATUS_CH6F(x, v) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH6F) = (v))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH7F[7] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
#define BP_FTM_STATUS_CH7F   (7U)          /*!< Bit position for FTM_STATUS_CH7F. */
#define BM_FTM_STATUS_CH7F   (0x00000080U) /*!< Bit mask for FTM_STATUS_CH7F. */
#define BS_FTM_STATUS_CH7F   (1U)          /*!< Bit field size in bits for FTM_STATUS_CH7F. */

/*! @brief Read current value of the FTM_STATUS_CH7F field. */
#define BR_FTM_STATUS_CH7F(x) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH7F))

/*! @brief Format value for bitfield FTM_STATUS_CH7F. */
#define BF_FTM_STATUS_CH7F(v) ((uint32_t)((uint32_t)(v) << BP_FTM_STATUS_CH7F) & BM_FTM_STATUS_CH7F)

/*! @brief Set the CH7F field to a new value. */
#define BW_FTM_STATUS_CH7F(x, v) (BITBAND_ACCESS32(HW_FTM_STATUS_ADDR(x), BP_FTM_STATUS_CH7F) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_MODE - Features Mode Selection
 ******************************************************************************/

/*!
 * @brief HW_FTM_MODE - Features Mode Selection (RW)
 *
 * Reset value: 0x00000004U
 *
 * This register contains the global enable bit for FTM-specific features and
 * the control bits used to configure: Fault control mode and interrupt Capture
 * Test mode PWM synchronization Write protection Channel output initialization
 * These controls relate to all channels within this module.
 */
typedef union _hw_ftm_mode
{
    uint32_t U;
    struct _hw_ftm_mode_bitfields
    {
        uint32_t FTMEN : 1;            /*!< [0] FTM Enable */
        uint32_t INIT : 1;             /*!< [1] Initialize The Channels Output */
        uint32_t WPDIS : 1;            /*!< [2] Write Protection Disable */
        uint32_t PWMSYNC : 1;          /*!< [3] PWM Synchronization Mode */
        uint32_t CAPTEST : 1;          /*!< [4] Capture Test Mode Enable */
        uint32_t FAULTM : 2;           /*!< [6:5] Fault Control Mode */
        uint32_t FAULTIE : 1;          /*!< [7] Fault Interrupt Enable */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_mode_t;

/*!
 * @name Constants and macros for entire FTM_MODE register
 */
/*@{*/
#define HW_FTM_MODE_ADDR(x)      ((uint32_t)(x) + 0x54U)

#define HW_FTM_MODE(x)           (*(__IO hw_ftm_mode_t *) HW_FTM_MODE_ADDR(x))
#define HW_FTM_MODE_RD(x)        (HW_FTM_MODE(x).U)
#define HW_FTM_MODE_WR(x, v)     (HW_FTM_MODE(x).U = (v))
#define HW_FTM_MODE_SET(x, v)    (HW_FTM_MODE_WR(x, HW_FTM_MODE_RD(x) |  (v)))
#define HW_FTM_MODE_CLR(x, v)    (HW_FTM_MODE_WR(x, HW_FTM_MODE_RD(x) & ~(v)))
#define HW_FTM_MODE_TOG(x, v)    (HW_FTM_MODE_WR(x, HW_FTM_MODE_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_MODE bitfields
 */

/*!
 * @name Register FTM_MODE, field FTMEN[0] (RW)
 *
 * This field is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Only the TPM-compatible registers (first set of registers) can be used
 *     without any restriction. Do not use the FTM-specific registers.
 * - 1 - All registers including the FTM-specific registers (second set of
 *     registers) are available for use with no restrictions.
 */
/*@{*/
#define BP_FTM_MODE_FTMEN    (0U)          /*!< Bit position for FTM_MODE_FTMEN. */
#define BM_FTM_MODE_FTMEN    (0x00000001U) /*!< Bit mask for FTM_MODE_FTMEN. */
#define BS_FTM_MODE_FTMEN    (1U)          /*!< Bit field size in bits for FTM_MODE_FTMEN. */

/*! @brief Read current value of the FTM_MODE_FTMEN field. */
#define BR_FTM_MODE_FTMEN(x) (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_FTMEN))

/*! @brief Format value for bitfield FTM_MODE_FTMEN. */
#define BF_FTM_MODE_FTMEN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_MODE_FTMEN) & BM_FTM_MODE_FTMEN)

/*! @brief Set the FTMEN field to a new value. */
#define BW_FTM_MODE_FTMEN(x, v) (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_FTMEN) = (v))
/*@}*/

/*!
 * @name Register FTM_MODE, field INIT[1] (RW)
 *
 * When a 1 is written to INIT bit the channels output is initialized according
 * to the state of their corresponding bit in the OUTINIT register. Writing a 0
 * to INIT bit has no effect. The INIT bit is always read as 0.
 */
/*@{*/
#define BP_FTM_MODE_INIT     (1U)          /*!< Bit position for FTM_MODE_INIT. */
#define BM_FTM_MODE_INIT     (0x00000002U) /*!< Bit mask for FTM_MODE_INIT. */
#define BS_FTM_MODE_INIT     (1U)          /*!< Bit field size in bits for FTM_MODE_INIT. */

/*! @brief Read current value of the FTM_MODE_INIT field. */
#define BR_FTM_MODE_INIT(x)  (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_INIT))

/*! @brief Format value for bitfield FTM_MODE_INIT. */
#define BF_FTM_MODE_INIT(v)  ((uint32_t)((uint32_t)(v) << BP_FTM_MODE_INIT) & BM_FTM_MODE_INIT)

/*! @brief Set the INIT field to a new value. */
#define BW_FTM_MODE_INIT(x, v) (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_INIT) = (v))
/*@}*/

/*!
 * @name Register FTM_MODE, field WPDIS[2] (RW)
 *
 * When write protection is enabled (WPDIS = 0), write protected bits cannot be
 * written. When write protection is disabled (WPDIS = 1), write protected bits
 * can be written. The WPDIS bit is the negation of the WPEN bit. WPDIS is cleared
 * when 1 is written to WPEN. WPDIS is set when WPEN bit is read as a 1 and then
 * 1 is written to WPDIS. Writing 0 to WPDIS has no effect.
 *
 * Values:
 * - 0 - Write protection is enabled.
 * - 1 - Write protection is disabled.
 */
/*@{*/
#define BP_FTM_MODE_WPDIS    (2U)          /*!< Bit position for FTM_MODE_WPDIS. */
#define BM_FTM_MODE_WPDIS    (0x00000004U) /*!< Bit mask for FTM_MODE_WPDIS. */
#define BS_FTM_MODE_WPDIS    (1U)          /*!< Bit field size in bits for FTM_MODE_WPDIS. */

/*! @brief Read current value of the FTM_MODE_WPDIS field. */
#define BR_FTM_MODE_WPDIS(x) (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_WPDIS))

/*! @brief Format value for bitfield FTM_MODE_WPDIS. */
#define BF_FTM_MODE_WPDIS(v) ((uint32_t)((uint32_t)(v) << BP_FTM_MODE_WPDIS) & BM_FTM_MODE_WPDIS)

/*! @brief Set the WPDIS field to a new value. */
#define BW_FTM_MODE_WPDIS(x, v) (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_WPDIS) = (v))
/*@}*/

/*!
 * @name Register FTM_MODE, field PWMSYNC[3] (RW)
 *
 * Selects which triggers can be used by MOD, CnV, OUTMASK, and FTM counter
 * synchronization. See PWM synchronization. The PWMSYNC bit configures the
 * synchronization when SYNCMODE is 0.
 *
 * Values:
 * - 0 - No restrictions. Software and hardware triggers can be used by MOD,
 *     CnV, OUTMASK, and FTM counter synchronization.
 * - 1 - Software trigger can only be used by MOD and CnV synchronization, and
 *     hardware triggers can only be used by OUTMASK and FTM counter
 *     synchronization.
 */
/*@{*/
#define BP_FTM_MODE_PWMSYNC  (3U)          /*!< Bit position for FTM_MODE_PWMSYNC. */
#define BM_FTM_MODE_PWMSYNC  (0x00000008U) /*!< Bit mask for FTM_MODE_PWMSYNC. */
#define BS_FTM_MODE_PWMSYNC  (1U)          /*!< Bit field size in bits for FTM_MODE_PWMSYNC. */

/*! @brief Read current value of the FTM_MODE_PWMSYNC field. */
#define BR_FTM_MODE_PWMSYNC(x) (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_PWMSYNC))

/*! @brief Format value for bitfield FTM_MODE_PWMSYNC. */
#define BF_FTM_MODE_PWMSYNC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_MODE_PWMSYNC) & BM_FTM_MODE_PWMSYNC)

/*! @brief Set the PWMSYNC field to a new value. */
#define BW_FTM_MODE_PWMSYNC(x, v) (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_PWMSYNC) = (v))
/*@}*/

/*!
 * @name Register FTM_MODE, field CAPTEST[4] (RW)
 *
 * Enables the capture test mode. This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Capture test mode is disabled.
 * - 1 - Capture test mode is enabled.
 */
/*@{*/
#define BP_FTM_MODE_CAPTEST  (4U)          /*!< Bit position for FTM_MODE_CAPTEST. */
#define BM_FTM_MODE_CAPTEST  (0x00000010U) /*!< Bit mask for FTM_MODE_CAPTEST. */
#define BS_FTM_MODE_CAPTEST  (1U)          /*!< Bit field size in bits for FTM_MODE_CAPTEST. */

/*! @brief Read current value of the FTM_MODE_CAPTEST field. */
#define BR_FTM_MODE_CAPTEST(x) (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_CAPTEST))

/*! @brief Format value for bitfield FTM_MODE_CAPTEST. */
#define BF_FTM_MODE_CAPTEST(v) ((uint32_t)((uint32_t)(v) << BP_FTM_MODE_CAPTEST) & BM_FTM_MODE_CAPTEST)

/*! @brief Set the CAPTEST field to a new value. */
#define BW_FTM_MODE_CAPTEST(x, v) (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_CAPTEST) = (v))
/*@}*/

/*!
 * @name Register FTM_MODE, field FAULTM[6:5] (RW)
 *
 * Defines the FTM fault control mode. This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 00 - Fault control is disabled for all channels.
 * - 01 - Fault control is enabled for even channels only (channels 0, 2, 4, and
 *     6), and the selected mode is the manual fault clearing.
 * - 10 - Fault control is enabled for all channels, and the selected mode is
 *     the manual fault clearing.
 * - 11 - Fault control is enabled for all channels, and the selected mode is
 *     the automatic fault clearing.
 */
/*@{*/
#define BP_FTM_MODE_FAULTM   (5U)          /*!< Bit position for FTM_MODE_FAULTM. */
#define BM_FTM_MODE_FAULTM   (0x00000060U) /*!< Bit mask for FTM_MODE_FAULTM. */
#define BS_FTM_MODE_FAULTM   (2U)          /*!< Bit field size in bits for FTM_MODE_FAULTM. */

/*! @brief Read current value of the FTM_MODE_FAULTM field. */
#define BR_FTM_MODE_FAULTM(x) (HW_FTM_MODE(x).B.FAULTM)

/*! @brief Format value for bitfield FTM_MODE_FAULTM. */
#define BF_FTM_MODE_FAULTM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_MODE_FAULTM) & BM_FTM_MODE_FAULTM)

/*! @brief Set the FAULTM field to a new value. */
#define BW_FTM_MODE_FAULTM(x, v) (HW_FTM_MODE_WR(x, (HW_FTM_MODE_RD(x) & ~BM_FTM_MODE_FAULTM) | BF_FTM_MODE_FAULTM(v)))
/*@}*/

/*!
 * @name Register FTM_MODE, field FAULTIE[7] (RW)
 *
 * Enables the generation of an interrupt when a fault is detected by FTM and
 * the FTM fault control is enabled.
 *
 * Values:
 * - 0 - Fault control interrupt is disabled.
 * - 1 - Fault control interrupt is enabled.
 */
/*@{*/
#define BP_FTM_MODE_FAULTIE  (7U)          /*!< Bit position for FTM_MODE_FAULTIE. */
#define BM_FTM_MODE_FAULTIE  (0x00000080U) /*!< Bit mask for FTM_MODE_FAULTIE. */
#define BS_FTM_MODE_FAULTIE  (1U)          /*!< Bit field size in bits for FTM_MODE_FAULTIE. */

/*! @brief Read current value of the FTM_MODE_FAULTIE field. */
#define BR_FTM_MODE_FAULTIE(x) (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_FAULTIE))

/*! @brief Format value for bitfield FTM_MODE_FAULTIE. */
#define BF_FTM_MODE_FAULTIE(v) ((uint32_t)((uint32_t)(v) << BP_FTM_MODE_FAULTIE) & BM_FTM_MODE_FAULTIE)

/*! @brief Set the FAULTIE field to a new value. */
#define BW_FTM_MODE_FAULTIE(x, v) (BITBAND_ACCESS32(HW_FTM_MODE_ADDR(x), BP_FTM_MODE_FAULTIE) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_SYNC - Synchronization
 ******************************************************************************/

/*!
 * @brief HW_FTM_SYNC - Synchronization (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the PWM synchronization. A synchronization event can
 * perform the synchronized update of MOD, CV, and OUTMASK registers with the
 * value of their write buffer and the FTM counter initialization. The software
 * trigger, SWSYNC bit, and hardware triggers TRIG0, TRIG1, and TRIG2 bits have a
 * potential conflict if used together when SYNCMODE = 0. Use only hardware or
 * software triggers but not both at the same time, otherwise unpredictable behavior
 * is likely to happen. The selection of the loading point, CNTMAX and CNTMIN
 * bits, is intended to provide the update of MOD, CNTIN, and CnV registers across
 * all enabled channels simultaneously. The use of the loading point selection
 * together with SYNCMODE = 0 and hardware trigger selection, TRIG0, TRIG1, or TRIG2
 * bits, is likely to result in unpredictable behavior. The synchronization
 * event selection also depends on the PWMSYNC (MODE register) and SYNCMODE (SYNCONF
 * register) bits. See PWM synchronization.
 */
typedef union _hw_ftm_sync
{
    uint32_t U;
    struct _hw_ftm_sync_bitfields
    {
        uint32_t CNTMIN : 1;           /*!< [0] Minimum Loading Point Enable */
        uint32_t CNTMAX : 1;           /*!< [1] Maximum Loading Point Enable */
        uint32_t REINIT : 1;           /*!< [2] FTM Counter Reinitialization By
                                        * Synchronization (FTM counter synchronization) */
        uint32_t SYNCHOM : 1;          /*!< [3] Output Mask Synchronization */
        uint32_t TRIG0 : 1;            /*!< [4] PWM Synchronization Hardware Trigger 0 */
        uint32_t TRIG1 : 1;            /*!< [5] PWM Synchronization Hardware Trigger 1 */
        uint32_t TRIG2 : 1;            /*!< [6] PWM Synchronization Hardware Trigger 2 */
        uint32_t SWSYNC : 1;           /*!< [7] PWM Synchronization Software Trigger */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_sync_t;

/*!
 * @name Constants and macros for entire FTM_SYNC register
 */
/*@{*/
#define HW_FTM_SYNC_ADDR(x)      ((uint32_t)(x) + 0x58U)

#define HW_FTM_SYNC(x)           (*(__IO hw_ftm_sync_t *) HW_FTM_SYNC_ADDR(x))
#define HW_FTM_SYNC_RD(x)        (HW_FTM_SYNC(x).U)
#define HW_FTM_SYNC_WR(x, v)     (HW_FTM_SYNC(x).U = (v))
#define HW_FTM_SYNC_SET(x, v)    (HW_FTM_SYNC_WR(x, HW_FTM_SYNC_RD(x) |  (v)))
#define HW_FTM_SYNC_CLR(x, v)    (HW_FTM_SYNC_WR(x, HW_FTM_SYNC_RD(x) & ~(v)))
#define HW_FTM_SYNC_TOG(x, v)    (HW_FTM_SYNC_WR(x, HW_FTM_SYNC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_SYNC bitfields
 */

/*!
 * @name Register FTM_SYNC, field CNTMIN[0] (RW)
 *
 * Selects the minimum loading point to PWM synchronization. See Boundary cycle
 * and loading points. If CNTMIN is one, the selected loading point is when the
 * FTM counter reaches its minimum value (CNTIN register).
 *
 * Values:
 * - 0 - The minimum loading point is disabled.
 * - 1 - The minimum loading point is enabled.
 */
/*@{*/
#define BP_FTM_SYNC_CNTMIN   (0U)          /*!< Bit position for FTM_SYNC_CNTMIN. */
#define BM_FTM_SYNC_CNTMIN   (0x00000001U) /*!< Bit mask for FTM_SYNC_CNTMIN. */
#define BS_FTM_SYNC_CNTMIN   (1U)          /*!< Bit field size in bits for FTM_SYNC_CNTMIN. */

/*! @brief Read current value of the FTM_SYNC_CNTMIN field. */
#define BR_FTM_SYNC_CNTMIN(x) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_CNTMIN))

/*! @brief Format value for bitfield FTM_SYNC_CNTMIN. */
#define BF_FTM_SYNC_CNTMIN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNC_CNTMIN) & BM_FTM_SYNC_CNTMIN)

/*! @brief Set the CNTMIN field to a new value. */
#define BW_FTM_SYNC_CNTMIN(x, v) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_CNTMIN) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNC, field CNTMAX[1] (RW)
 *
 * Selects the maximum loading point to PWM synchronization. See Boundary cycle
 * and loading points. If CNTMAX is 1, the selected loading point is when the FTM
 * counter reaches its maximum value (MOD register).
 *
 * Values:
 * - 0 - The maximum loading point is disabled.
 * - 1 - The maximum loading point is enabled.
 */
/*@{*/
#define BP_FTM_SYNC_CNTMAX   (1U)          /*!< Bit position for FTM_SYNC_CNTMAX. */
#define BM_FTM_SYNC_CNTMAX   (0x00000002U) /*!< Bit mask for FTM_SYNC_CNTMAX. */
#define BS_FTM_SYNC_CNTMAX   (1U)          /*!< Bit field size in bits for FTM_SYNC_CNTMAX. */

/*! @brief Read current value of the FTM_SYNC_CNTMAX field. */
#define BR_FTM_SYNC_CNTMAX(x) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_CNTMAX))

/*! @brief Format value for bitfield FTM_SYNC_CNTMAX. */
#define BF_FTM_SYNC_CNTMAX(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNC_CNTMAX) & BM_FTM_SYNC_CNTMAX)

/*! @brief Set the CNTMAX field to a new value. */
#define BW_FTM_SYNC_CNTMAX(x, v) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_CNTMAX) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNC, field REINIT[2] (RW)
 *
 * Determines if the FTM counter is reinitialized when the selected trigger for
 * the synchronization is detected. The REINIT bit configures the synchronization
 * when SYNCMODE is zero.
 *
 * Values:
 * - 0 - FTM counter continues to count normally.
 * - 1 - FTM counter is updated with its initial value when the selected trigger
 *     is detected.
 */
/*@{*/
#define BP_FTM_SYNC_REINIT   (2U)          /*!< Bit position for FTM_SYNC_REINIT. */
#define BM_FTM_SYNC_REINIT   (0x00000004U) /*!< Bit mask for FTM_SYNC_REINIT. */
#define BS_FTM_SYNC_REINIT   (1U)          /*!< Bit field size in bits for FTM_SYNC_REINIT. */

/*! @brief Read current value of the FTM_SYNC_REINIT field. */
#define BR_FTM_SYNC_REINIT(x) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_REINIT))

/*! @brief Format value for bitfield FTM_SYNC_REINIT. */
#define BF_FTM_SYNC_REINIT(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNC_REINIT) & BM_FTM_SYNC_REINIT)

/*! @brief Set the REINIT field to a new value. */
#define BW_FTM_SYNC_REINIT(x, v) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_REINIT) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNC, field SYNCHOM[3] (RW)
 *
 * Selects when the OUTMASK register is updated with the value of its buffer.
 *
 * Values:
 * - 0 - OUTMASK register is updated with the value of its buffer in all rising
 *     edges of the system clock.
 * - 1 - OUTMASK register is updated with the value of its buffer only by the
 *     PWM synchronization.
 */
/*@{*/
#define BP_FTM_SYNC_SYNCHOM  (3U)          /*!< Bit position for FTM_SYNC_SYNCHOM. */
#define BM_FTM_SYNC_SYNCHOM  (0x00000008U) /*!< Bit mask for FTM_SYNC_SYNCHOM. */
#define BS_FTM_SYNC_SYNCHOM  (1U)          /*!< Bit field size in bits for FTM_SYNC_SYNCHOM. */

/*! @brief Read current value of the FTM_SYNC_SYNCHOM field. */
#define BR_FTM_SYNC_SYNCHOM(x) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_SYNCHOM))

/*! @brief Format value for bitfield FTM_SYNC_SYNCHOM. */
#define BF_FTM_SYNC_SYNCHOM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNC_SYNCHOM) & BM_FTM_SYNC_SYNCHOM)

/*! @brief Set the SYNCHOM field to a new value. */
#define BW_FTM_SYNC_SYNCHOM(x, v) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_SYNCHOM) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG0[4] (RW)
 *
 * Enables hardware trigger 0 to the PWM synchronization. Hardware trigger 0
 * occurs when a rising edge is detected at the trigger 0 input signal.
 *
 * Values:
 * - 0 - Trigger is disabled.
 * - 1 - Trigger is enabled.
 */
/*@{*/
#define BP_FTM_SYNC_TRIG0    (4U)          /*!< Bit position for FTM_SYNC_TRIG0. */
#define BM_FTM_SYNC_TRIG0    (0x00000010U) /*!< Bit mask for FTM_SYNC_TRIG0. */
#define BS_FTM_SYNC_TRIG0    (1U)          /*!< Bit field size in bits for FTM_SYNC_TRIG0. */

/*! @brief Read current value of the FTM_SYNC_TRIG0 field. */
#define BR_FTM_SYNC_TRIG0(x) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_TRIG0))

/*! @brief Format value for bitfield FTM_SYNC_TRIG0. */
#define BF_FTM_SYNC_TRIG0(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNC_TRIG0) & BM_FTM_SYNC_TRIG0)

/*! @brief Set the TRIG0 field to a new value. */
#define BW_FTM_SYNC_TRIG0(x, v) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_TRIG0) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG1[5] (RW)
 *
 * Enables hardware trigger 1 to the PWM synchronization. Hardware trigger 1
 * happens when a rising edge is detected at the trigger 1 input signal.
 *
 * Values:
 * - 0 - Trigger is disabled.
 * - 1 - Trigger is enabled.
 */
/*@{*/
#define BP_FTM_SYNC_TRIG1    (5U)          /*!< Bit position for FTM_SYNC_TRIG1. */
#define BM_FTM_SYNC_TRIG1    (0x00000020U) /*!< Bit mask for FTM_SYNC_TRIG1. */
#define BS_FTM_SYNC_TRIG1    (1U)          /*!< Bit field size in bits for FTM_SYNC_TRIG1. */

/*! @brief Read current value of the FTM_SYNC_TRIG1 field. */
#define BR_FTM_SYNC_TRIG1(x) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_TRIG1))

/*! @brief Format value for bitfield FTM_SYNC_TRIG1. */
#define BF_FTM_SYNC_TRIG1(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNC_TRIG1) & BM_FTM_SYNC_TRIG1)

/*! @brief Set the TRIG1 field to a new value. */
#define BW_FTM_SYNC_TRIG1(x, v) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_TRIG1) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG2[6] (RW)
 *
 * Enables hardware trigger 2 to the PWM synchronization. Hardware trigger 2
 * happens when a rising edge is detected at the trigger 2 input signal.
 *
 * Values:
 * - 0 - Trigger is disabled.
 * - 1 - Trigger is enabled.
 */
/*@{*/
#define BP_FTM_SYNC_TRIG2    (6U)          /*!< Bit position for FTM_SYNC_TRIG2. */
#define BM_FTM_SYNC_TRIG2    (0x00000040U) /*!< Bit mask for FTM_SYNC_TRIG2. */
#define BS_FTM_SYNC_TRIG2    (1U)          /*!< Bit field size in bits for FTM_SYNC_TRIG2. */

/*! @brief Read current value of the FTM_SYNC_TRIG2 field. */
#define BR_FTM_SYNC_TRIG2(x) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_TRIG2))

/*! @brief Format value for bitfield FTM_SYNC_TRIG2. */
#define BF_FTM_SYNC_TRIG2(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNC_TRIG2) & BM_FTM_SYNC_TRIG2)

/*! @brief Set the TRIG2 field to a new value. */
#define BW_FTM_SYNC_TRIG2(x, v) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_TRIG2) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNC, field SWSYNC[7] (RW)
 *
 * Selects the software trigger as the PWM synchronization trigger. The software
 * trigger happens when a 1 is written to SWSYNC bit.
 *
 * Values:
 * - 0 - Software trigger is not selected.
 * - 1 - Software trigger is selected.
 */
/*@{*/
#define BP_FTM_SYNC_SWSYNC   (7U)          /*!< Bit position for FTM_SYNC_SWSYNC. */
#define BM_FTM_SYNC_SWSYNC   (0x00000080U) /*!< Bit mask for FTM_SYNC_SWSYNC. */
#define BS_FTM_SYNC_SWSYNC   (1U)          /*!< Bit field size in bits for FTM_SYNC_SWSYNC. */

/*! @brief Read current value of the FTM_SYNC_SWSYNC field. */
#define BR_FTM_SYNC_SWSYNC(x) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_SWSYNC))

/*! @brief Format value for bitfield FTM_SYNC_SWSYNC. */
#define BF_FTM_SYNC_SWSYNC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNC_SWSYNC) & BM_FTM_SYNC_SWSYNC)

/*! @brief Set the SWSYNC field to a new value. */
#define BW_FTM_SYNC_SWSYNC(x, v) (BITBAND_ACCESS32(HW_FTM_SYNC_ADDR(x), BP_FTM_SYNC_SWSYNC) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_OUTINIT - Initial State For Channels Output
 ******************************************************************************/

/*!
 * @brief HW_FTM_OUTINIT - Initial State For Channels Output (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_ftm_outinit
{
    uint32_t U;
    struct _hw_ftm_outinit_bitfields
    {
        uint32_t CH0OI : 1;            /*!< [0] Channel 0 Output Initialization Value */
        uint32_t CH1OI : 1;            /*!< [1] Channel 1 Output Initialization Value */
        uint32_t CH2OI : 1;            /*!< [2] Channel 2 Output Initialization Value */
        uint32_t CH3OI : 1;            /*!< [3] Channel 3 Output Initialization Value */
        uint32_t CH4OI : 1;            /*!< [4] Channel 4 Output Initialization Value */
        uint32_t CH5OI : 1;            /*!< [5] Channel 5 Output Initialization Value */
        uint32_t CH6OI : 1;            /*!< [6] Channel 6 Output Initialization Value */
        uint32_t CH7OI : 1;            /*!< [7] Channel 7 Output Initialization Value */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_outinit_t;

/*!
 * @name Constants and macros for entire FTM_OUTINIT register
 */
/*@{*/
#define HW_FTM_OUTINIT_ADDR(x)   ((uint32_t)(x) + 0x5CU)

#define HW_FTM_OUTINIT(x)        (*(__IO hw_ftm_outinit_t *) HW_FTM_OUTINIT_ADDR(x))
#define HW_FTM_OUTINIT_RD(x)     (HW_FTM_OUTINIT(x).U)
#define HW_FTM_OUTINIT_WR(x, v)  (HW_FTM_OUTINIT(x).U = (v))
#define HW_FTM_OUTINIT_SET(x, v) (HW_FTM_OUTINIT_WR(x, HW_FTM_OUTINIT_RD(x) |  (v)))
#define HW_FTM_OUTINIT_CLR(x, v) (HW_FTM_OUTINIT_WR(x, HW_FTM_OUTINIT_RD(x) & ~(v)))
#define HW_FTM_OUTINIT_TOG(x, v) (HW_FTM_OUTINIT_WR(x, HW_FTM_OUTINIT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_OUTINIT bitfields
 */

/*!
 * @name Register FTM_OUTINIT, field CH0OI[0] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
#define BP_FTM_OUTINIT_CH0OI (0U)          /*!< Bit position for FTM_OUTINIT_CH0OI. */
#define BM_FTM_OUTINIT_CH0OI (0x00000001U) /*!< Bit mask for FTM_OUTINIT_CH0OI. */
#define BS_FTM_OUTINIT_CH0OI (1U)          /*!< Bit field size in bits for FTM_OUTINIT_CH0OI. */

/*! @brief Read current value of the FTM_OUTINIT_CH0OI field. */
#define BR_FTM_OUTINIT_CH0OI(x) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH0OI))

/*! @brief Format value for bitfield FTM_OUTINIT_CH0OI. */
#define BF_FTM_OUTINIT_CH0OI(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTINIT_CH0OI) & BM_FTM_OUTINIT_CH0OI)

/*! @brief Set the CH0OI field to a new value. */
#define BW_FTM_OUTINIT_CH0OI(x, v) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH0OI) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH1OI[1] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
#define BP_FTM_OUTINIT_CH1OI (1U)          /*!< Bit position for FTM_OUTINIT_CH1OI. */
#define BM_FTM_OUTINIT_CH1OI (0x00000002U) /*!< Bit mask for FTM_OUTINIT_CH1OI. */
#define BS_FTM_OUTINIT_CH1OI (1U)          /*!< Bit field size in bits for FTM_OUTINIT_CH1OI. */

/*! @brief Read current value of the FTM_OUTINIT_CH1OI field. */
#define BR_FTM_OUTINIT_CH1OI(x) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH1OI))

/*! @brief Format value for bitfield FTM_OUTINIT_CH1OI. */
#define BF_FTM_OUTINIT_CH1OI(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTINIT_CH1OI) & BM_FTM_OUTINIT_CH1OI)

/*! @brief Set the CH1OI field to a new value. */
#define BW_FTM_OUTINIT_CH1OI(x, v) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH1OI) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH2OI[2] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
#define BP_FTM_OUTINIT_CH2OI (2U)          /*!< Bit position for FTM_OUTINIT_CH2OI. */
#define BM_FTM_OUTINIT_CH2OI (0x00000004U) /*!< Bit mask for FTM_OUTINIT_CH2OI. */
#define BS_FTM_OUTINIT_CH2OI (1U)          /*!< Bit field size in bits for FTM_OUTINIT_CH2OI. */

/*! @brief Read current value of the FTM_OUTINIT_CH2OI field. */
#define BR_FTM_OUTINIT_CH2OI(x) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH2OI))

/*! @brief Format value for bitfield FTM_OUTINIT_CH2OI. */
#define BF_FTM_OUTINIT_CH2OI(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTINIT_CH2OI) & BM_FTM_OUTINIT_CH2OI)

/*! @brief Set the CH2OI field to a new value. */
#define BW_FTM_OUTINIT_CH2OI(x, v) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH2OI) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH3OI[3] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
#define BP_FTM_OUTINIT_CH3OI (3U)          /*!< Bit position for FTM_OUTINIT_CH3OI. */
#define BM_FTM_OUTINIT_CH3OI (0x00000008U) /*!< Bit mask for FTM_OUTINIT_CH3OI. */
#define BS_FTM_OUTINIT_CH3OI (1U)          /*!< Bit field size in bits for FTM_OUTINIT_CH3OI. */

/*! @brief Read current value of the FTM_OUTINIT_CH3OI field. */
#define BR_FTM_OUTINIT_CH3OI(x) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH3OI))

/*! @brief Format value for bitfield FTM_OUTINIT_CH3OI. */
#define BF_FTM_OUTINIT_CH3OI(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTINIT_CH3OI) & BM_FTM_OUTINIT_CH3OI)

/*! @brief Set the CH3OI field to a new value. */
#define BW_FTM_OUTINIT_CH3OI(x, v) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH3OI) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH4OI[4] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
#define BP_FTM_OUTINIT_CH4OI (4U)          /*!< Bit position for FTM_OUTINIT_CH4OI. */
#define BM_FTM_OUTINIT_CH4OI (0x00000010U) /*!< Bit mask for FTM_OUTINIT_CH4OI. */
#define BS_FTM_OUTINIT_CH4OI (1U)          /*!< Bit field size in bits for FTM_OUTINIT_CH4OI. */

/*! @brief Read current value of the FTM_OUTINIT_CH4OI field. */
#define BR_FTM_OUTINIT_CH4OI(x) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH4OI))

/*! @brief Format value for bitfield FTM_OUTINIT_CH4OI. */
#define BF_FTM_OUTINIT_CH4OI(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTINIT_CH4OI) & BM_FTM_OUTINIT_CH4OI)

/*! @brief Set the CH4OI field to a new value. */
#define BW_FTM_OUTINIT_CH4OI(x, v) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH4OI) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH5OI[5] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
#define BP_FTM_OUTINIT_CH5OI (5U)          /*!< Bit position for FTM_OUTINIT_CH5OI. */
#define BM_FTM_OUTINIT_CH5OI (0x00000020U) /*!< Bit mask for FTM_OUTINIT_CH5OI. */
#define BS_FTM_OUTINIT_CH5OI (1U)          /*!< Bit field size in bits for FTM_OUTINIT_CH5OI. */

/*! @brief Read current value of the FTM_OUTINIT_CH5OI field. */
#define BR_FTM_OUTINIT_CH5OI(x) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH5OI))

/*! @brief Format value for bitfield FTM_OUTINIT_CH5OI. */
#define BF_FTM_OUTINIT_CH5OI(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTINIT_CH5OI) & BM_FTM_OUTINIT_CH5OI)

/*! @brief Set the CH5OI field to a new value. */
#define BW_FTM_OUTINIT_CH5OI(x, v) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH5OI) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH6OI[6] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
#define BP_FTM_OUTINIT_CH6OI (6U)          /*!< Bit position for FTM_OUTINIT_CH6OI. */
#define BM_FTM_OUTINIT_CH6OI (0x00000040U) /*!< Bit mask for FTM_OUTINIT_CH6OI. */
#define BS_FTM_OUTINIT_CH6OI (1U)          /*!< Bit field size in bits for FTM_OUTINIT_CH6OI. */

/*! @brief Read current value of the FTM_OUTINIT_CH6OI field. */
#define BR_FTM_OUTINIT_CH6OI(x) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH6OI))

/*! @brief Format value for bitfield FTM_OUTINIT_CH6OI. */
#define BF_FTM_OUTINIT_CH6OI(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTINIT_CH6OI) & BM_FTM_OUTINIT_CH6OI)

/*! @brief Set the CH6OI field to a new value. */
#define BW_FTM_OUTINIT_CH6OI(x, v) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH6OI) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH7OI[7] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0 - The initialization value is 0.
 * - 1 - The initialization value is 1.
 */
/*@{*/
#define BP_FTM_OUTINIT_CH7OI (7U)          /*!< Bit position for FTM_OUTINIT_CH7OI. */
#define BM_FTM_OUTINIT_CH7OI (0x00000080U) /*!< Bit mask for FTM_OUTINIT_CH7OI. */
#define BS_FTM_OUTINIT_CH7OI (1U)          /*!< Bit field size in bits for FTM_OUTINIT_CH7OI. */

/*! @brief Read current value of the FTM_OUTINIT_CH7OI field. */
#define BR_FTM_OUTINIT_CH7OI(x) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH7OI))

/*! @brief Format value for bitfield FTM_OUTINIT_CH7OI. */
#define BF_FTM_OUTINIT_CH7OI(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTINIT_CH7OI) & BM_FTM_OUTINIT_CH7OI)

/*! @brief Set the CH7OI field to a new value. */
#define BW_FTM_OUTINIT_CH7OI(x, v) (BITBAND_ACCESS32(HW_FTM_OUTINIT_ADDR(x), BP_FTM_OUTINIT_CH7OI) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_OUTMASK - Output Mask
 ******************************************************************************/

/*!
 * @brief HW_FTM_OUTMASK - Output Mask (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register provides a mask for each FTM channel. The mask of a channel
 * determines if its output responds, that is, it is masked or not, when a match
 * occurs. This feature is used for BLDC control where the PWM signal is presented
 * to an electric motor at specific times to provide electronic commutation. Any
 * write to the OUTMASK register, stores the value in its write buffer. The
 * register is updated with the value of its write buffer according to PWM
 * synchronization.
 */
typedef union _hw_ftm_outmask
{
    uint32_t U;
    struct _hw_ftm_outmask_bitfields
    {
        uint32_t CH0OM : 1;            /*!< [0] Channel 0 Output Mask */
        uint32_t CH1OM : 1;            /*!< [1] Channel 1 Output Mask */
        uint32_t CH2OM : 1;            /*!< [2] Channel 2 Output Mask */
        uint32_t CH3OM : 1;            /*!< [3] Channel 3 Output Mask */
        uint32_t CH4OM : 1;            /*!< [4] Channel 4 Output Mask */
        uint32_t CH5OM : 1;            /*!< [5] Channel 5 Output Mask */
        uint32_t CH6OM : 1;            /*!< [6] Channel 6 Output Mask */
        uint32_t CH7OM : 1;            /*!< [7] Channel 7 Output Mask */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_outmask_t;

/*!
 * @name Constants and macros for entire FTM_OUTMASK register
 */
/*@{*/
#define HW_FTM_OUTMASK_ADDR(x)   ((uint32_t)(x) + 0x60U)

#define HW_FTM_OUTMASK(x)        (*(__IO hw_ftm_outmask_t *) HW_FTM_OUTMASK_ADDR(x))
#define HW_FTM_OUTMASK_RD(x)     (HW_FTM_OUTMASK(x).U)
#define HW_FTM_OUTMASK_WR(x, v)  (HW_FTM_OUTMASK(x).U = (v))
#define HW_FTM_OUTMASK_SET(x, v) (HW_FTM_OUTMASK_WR(x, HW_FTM_OUTMASK_RD(x) |  (v)))
#define HW_FTM_OUTMASK_CLR(x, v) (HW_FTM_OUTMASK_WR(x, HW_FTM_OUTMASK_RD(x) & ~(v)))
#define HW_FTM_OUTMASK_TOG(x, v) (HW_FTM_OUTMASK_WR(x, HW_FTM_OUTMASK_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_OUTMASK bitfields
 */

/*!
 * @name Register FTM_OUTMASK, field CH0OM[0] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
#define BP_FTM_OUTMASK_CH0OM (0U)          /*!< Bit position for FTM_OUTMASK_CH0OM. */
#define BM_FTM_OUTMASK_CH0OM (0x00000001U) /*!< Bit mask for FTM_OUTMASK_CH0OM. */
#define BS_FTM_OUTMASK_CH0OM (1U)          /*!< Bit field size in bits for FTM_OUTMASK_CH0OM. */

/*! @brief Read current value of the FTM_OUTMASK_CH0OM field. */
#define BR_FTM_OUTMASK_CH0OM(x) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH0OM))

/*! @brief Format value for bitfield FTM_OUTMASK_CH0OM. */
#define BF_FTM_OUTMASK_CH0OM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTMASK_CH0OM) & BM_FTM_OUTMASK_CH0OM)

/*! @brief Set the CH0OM field to a new value. */
#define BW_FTM_OUTMASK_CH0OM(x, v) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH0OM) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH1OM[1] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
#define BP_FTM_OUTMASK_CH1OM (1U)          /*!< Bit position for FTM_OUTMASK_CH1OM. */
#define BM_FTM_OUTMASK_CH1OM (0x00000002U) /*!< Bit mask for FTM_OUTMASK_CH1OM. */
#define BS_FTM_OUTMASK_CH1OM (1U)          /*!< Bit field size in bits for FTM_OUTMASK_CH1OM. */

/*! @brief Read current value of the FTM_OUTMASK_CH1OM field. */
#define BR_FTM_OUTMASK_CH1OM(x) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH1OM))

/*! @brief Format value for bitfield FTM_OUTMASK_CH1OM. */
#define BF_FTM_OUTMASK_CH1OM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTMASK_CH1OM) & BM_FTM_OUTMASK_CH1OM)

/*! @brief Set the CH1OM field to a new value. */
#define BW_FTM_OUTMASK_CH1OM(x, v) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH1OM) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH2OM[2] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
#define BP_FTM_OUTMASK_CH2OM (2U)          /*!< Bit position for FTM_OUTMASK_CH2OM. */
#define BM_FTM_OUTMASK_CH2OM (0x00000004U) /*!< Bit mask for FTM_OUTMASK_CH2OM. */
#define BS_FTM_OUTMASK_CH2OM (1U)          /*!< Bit field size in bits for FTM_OUTMASK_CH2OM. */

/*! @brief Read current value of the FTM_OUTMASK_CH2OM field. */
#define BR_FTM_OUTMASK_CH2OM(x) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH2OM))

/*! @brief Format value for bitfield FTM_OUTMASK_CH2OM. */
#define BF_FTM_OUTMASK_CH2OM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTMASK_CH2OM) & BM_FTM_OUTMASK_CH2OM)

/*! @brief Set the CH2OM field to a new value. */
#define BW_FTM_OUTMASK_CH2OM(x, v) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH2OM) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH3OM[3] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
#define BP_FTM_OUTMASK_CH3OM (3U)          /*!< Bit position for FTM_OUTMASK_CH3OM. */
#define BM_FTM_OUTMASK_CH3OM (0x00000008U) /*!< Bit mask for FTM_OUTMASK_CH3OM. */
#define BS_FTM_OUTMASK_CH3OM (1U)          /*!< Bit field size in bits for FTM_OUTMASK_CH3OM. */

/*! @brief Read current value of the FTM_OUTMASK_CH3OM field. */
#define BR_FTM_OUTMASK_CH3OM(x) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH3OM))

/*! @brief Format value for bitfield FTM_OUTMASK_CH3OM. */
#define BF_FTM_OUTMASK_CH3OM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTMASK_CH3OM) & BM_FTM_OUTMASK_CH3OM)

/*! @brief Set the CH3OM field to a new value. */
#define BW_FTM_OUTMASK_CH3OM(x, v) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH3OM) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH4OM[4] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
#define BP_FTM_OUTMASK_CH4OM (4U)          /*!< Bit position for FTM_OUTMASK_CH4OM. */
#define BM_FTM_OUTMASK_CH4OM (0x00000010U) /*!< Bit mask for FTM_OUTMASK_CH4OM. */
#define BS_FTM_OUTMASK_CH4OM (1U)          /*!< Bit field size in bits for FTM_OUTMASK_CH4OM. */

/*! @brief Read current value of the FTM_OUTMASK_CH4OM field. */
#define BR_FTM_OUTMASK_CH4OM(x) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH4OM))

/*! @brief Format value for bitfield FTM_OUTMASK_CH4OM. */
#define BF_FTM_OUTMASK_CH4OM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTMASK_CH4OM) & BM_FTM_OUTMASK_CH4OM)

/*! @brief Set the CH4OM field to a new value. */
#define BW_FTM_OUTMASK_CH4OM(x, v) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH4OM) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH5OM[5] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
#define BP_FTM_OUTMASK_CH5OM (5U)          /*!< Bit position for FTM_OUTMASK_CH5OM. */
#define BM_FTM_OUTMASK_CH5OM (0x00000020U) /*!< Bit mask for FTM_OUTMASK_CH5OM. */
#define BS_FTM_OUTMASK_CH5OM (1U)          /*!< Bit field size in bits for FTM_OUTMASK_CH5OM. */

/*! @brief Read current value of the FTM_OUTMASK_CH5OM field. */
#define BR_FTM_OUTMASK_CH5OM(x) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH5OM))

/*! @brief Format value for bitfield FTM_OUTMASK_CH5OM. */
#define BF_FTM_OUTMASK_CH5OM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTMASK_CH5OM) & BM_FTM_OUTMASK_CH5OM)

/*! @brief Set the CH5OM field to a new value. */
#define BW_FTM_OUTMASK_CH5OM(x, v) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH5OM) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH6OM[6] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
#define BP_FTM_OUTMASK_CH6OM (6U)          /*!< Bit position for FTM_OUTMASK_CH6OM. */
#define BM_FTM_OUTMASK_CH6OM (0x00000040U) /*!< Bit mask for FTM_OUTMASK_CH6OM. */
#define BS_FTM_OUTMASK_CH6OM (1U)          /*!< Bit field size in bits for FTM_OUTMASK_CH6OM. */

/*! @brief Read current value of the FTM_OUTMASK_CH6OM field. */
#define BR_FTM_OUTMASK_CH6OM(x) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH6OM))

/*! @brief Format value for bitfield FTM_OUTMASK_CH6OM. */
#define BF_FTM_OUTMASK_CH6OM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTMASK_CH6OM) & BM_FTM_OUTMASK_CH6OM)

/*! @brief Set the CH6OM field to a new value. */
#define BW_FTM_OUTMASK_CH6OM(x, v) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH6OM) = (v))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH7OM[7] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0 - Channel output is not masked. It continues to operate normally.
 * - 1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
#define BP_FTM_OUTMASK_CH7OM (7U)          /*!< Bit position for FTM_OUTMASK_CH7OM. */
#define BM_FTM_OUTMASK_CH7OM (0x00000080U) /*!< Bit mask for FTM_OUTMASK_CH7OM. */
#define BS_FTM_OUTMASK_CH7OM (1U)          /*!< Bit field size in bits for FTM_OUTMASK_CH7OM. */

/*! @brief Read current value of the FTM_OUTMASK_CH7OM field. */
#define BR_FTM_OUTMASK_CH7OM(x) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH7OM))

/*! @brief Format value for bitfield FTM_OUTMASK_CH7OM. */
#define BF_FTM_OUTMASK_CH7OM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_OUTMASK_CH7OM) & BM_FTM_OUTMASK_CH7OM)

/*! @brief Set the CH7OM field to a new value. */
#define BW_FTM_OUTMASK_CH7OM(x, v) (BITBAND_ACCESS32(HW_FTM_OUTMASK_ADDR(x), BP_FTM_OUTMASK_CH7OM) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_COMBINE - Function For Linked Channels
 ******************************************************************************/

/*!
 * @brief HW_FTM_COMBINE - Function For Linked Channels (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the control bits used to configure the fault control,
 * synchronization, deadtime insertion, Dual Edge Capture mode, Complementary,
 * and Combine mode for each pair of channels (n) and (n+1), where n equals 0, 2,
 * 4, and 6.
 */
typedef union _hw_ftm_combine
{
    uint32_t U;
    struct _hw_ftm_combine_bitfields
    {
        uint32_t COMBINE0 : 1;         /*!< [0] Combine Channels For n = 0 */
        uint32_t COMP0 : 1;            /*!< [1] Complement Of Channel (n) For n = 0 */
        uint32_t DECAPEN0 : 1;         /*!< [2] Dual Edge Capture Mode Enable For n =
                                        * 0 */
        uint32_t DECAP0 : 1;           /*!< [3] Dual Edge Capture Mode Captures For n =
                                        * 0 */
        uint32_t DTEN0 : 1;            /*!< [4] Deadtime Enable For n = 0 */
        uint32_t SYNCEN0 : 1;          /*!< [5] Synchronization Enable For n = 0 */
        uint32_t FAULTEN0 : 1;         /*!< [6] Fault Control Enable For n = 0 */
        uint32_t RESERVED0 : 1;        /*!< [7]  */
        uint32_t COMBINE1 : 1;         /*!< [8] Combine Channels For n = 2 */
        uint32_t COMP1 : 1;            /*!< [9] Complement Of Channel (n) For n = 2 */
        uint32_t DECAPEN1 : 1;         /*!< [10] Dual Edge Capture Mode Enable For n
                                        * = 2 */
        uint32_t DECAP1 : 1;           /*!< [11] Dual Edge Capture Mode Captures For n
                                        * = 2 */
        uint32_t DTEN1 : 1;            /*!< [12] Deadtime Enable For n = 2 */
        uint32_t SYNCEN1 : 1;          /*!< [13] Synchronization Enable For n = 2 */
        uint32_t FAULTEN1 : 1;         /*!< [14] Fault Control Enable For n = 2 */
        uint32_t RESERVED1 : 1;        /*!< [15]  */
        uint32_t COMBINE2 : 1;         /*!< [16] Combine Channels For n = 4 */
        uint32_t COMP2 : 1;            /*!< [17] Complement Of Channel (n) For n = 4 */
        uint32_t DECAPEN2 : 1;         /*!< [18] Dual Edge Capture Mode Enable For n
                                        * = 4 */
        uint32_t DECAP2 : 1;           /*!< [19] Dual Edge Capture Mode Captures For n
                                        * = 4 */
        uint32_t DTEN2 : 1;            /*!< [20] Deadtime Enable For n = 4 */
        uint32_t SYNCEN2 : 1;          /*!< [21] Synchronization Enable For n = 4 */
        uint32_t FAULTEN2 : 1;         /*!< [22] Fault Control Enable For n = 4 */
        uint32_t RESERVED2 : 1;        /*!< [23]  */
        uint32_t COMBINE3 : 1;         /*!< [24] Combine Channels For n = 6 */
        uint32_t COMP3 : 1;            /*!< [25] Complement Of Channel (n) for n = 6 */
        uint32_t DECAPEN3 : 1;         /*!< [26] Dual Edge Capture Mode Enable For n
                                        * = 6 */
        uint32_t DECAP3 : 1;           /*!< [27] Dual Edge Capture Mode Captures For n
                                        * = 6 */
        uint32_t DTEN3 : 1;            /*!< [28] Deadtime Enable For n = 6 */
        uint32_t SYNCEN3 : 1;          /*!< [29] Synchronization Enable For n = 6 */
        uint32_t FAULTEN3 : 1;         /*!< [30] Fault Control Enable For n = 6 */
        uint32_t RESERVED3 : 1;        /*!< [31]  */
    } B;
} hw_ftm_combine_t;

/*!
 * @name Constants and macros for entire FTM_COMBINE register
 */
/*@{*/
#define HW_FTM_COMBINE_ADDR(x)   ((uint32_t)(x) + 0x64U)

#define HW_FTM_COMBINE(x)        (*(__IO hw_ftm_combine_t *) HW_FTM_COMBINE_ADDR(x))
#define HW_FTM_COMBINE_RD(x)     (HW_FTM_COMBINE(x).U)
#define HW_FTM_COMBINE_WR(x, v)  (HW_FTM_COMBINE(x).U = (v))
#define HW_FTM_COMBINE_SET(x, v) (HW_FTM_COMBINE_WR(x, HW_FTM_COMBINE_RD(x) |  (v)))
#define HW_FTM_COMBINE_CLR(x, v) (HW_FTM_COMBINE_WR(x, HW_FTM_COMBINE_RD(x) & ~(v)))
#define HW_FTM_COMBINE_TOG(x, v) (HW_FTM_COMBINE_WR(x, HW_FTM_COMBINE_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_COMBINE bitfields
 */

/*!
 * @name Register FTM_COMBINE, field COMBINE0[0] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
#define BP_FTM_COMBINE_COMBINE0 (0U)       /*!< Bit position for FTM_COMBINE_COMBINE0. */
#define BM_FTM_COMBINE_COMBINE0 (0x00000001U) /*!< Bit mask for FTM_COMBINE_COMBINE0. */
#define BS_FTM_COMBINE_COMBINE0 (1U)       /*!< Bit field size in bits for FTM_COMBINE_COMBINE0. */

/*! @brief Read current value of the FTM_COMBINE_COMBINE0 field. */
#define BR_FTM_COMBINE_COMBINE0(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMBINE0))

/*! @brief Format value for bitfield FTM_COMBINE_COMBINE0. */
#define BF_FTM_COMBINE_COMBINE0(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_COMBINE0) & BM_FTM_COMBINE_COMBINE0)

/*! @brief Set the COMBINE0 field to a new value. */
#define BW_FTM_COMBINE_COMBINE0(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMBINE0) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP0[1] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
#define BP_FTM_COMBINE_COMP0 (1U)          /*!< Bit position for FTM_COMBINE_COMP0. */
#define BM_FTM_COMBINE_COMP0 (0x00000002U) /*!< Bit mask for FTM_COMBINE_COMP0. */
#define BS_FTM_COMBINE_COMP0 (1U)          /*!< Bit field size in bits for FTM_COMBINE_COMP0. */

/*! @brief Read current value of the FTM_COMBINE_COMP0 field. */
#define BR_FTM_COMBINE_COMP0(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMP0))

/*! @brief Format value for bitfield FTM_COMBINE_COMP0. */
#define BF_FTM_COMBINE_COMP0(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_COMP0) & BM_FTM_COMBINE_COMP0)

/*! @brief Set the COMP0 field to a new value. */
#define BW_FTM_COMBINE_COMP0(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMP0) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN0[2] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to #ModeSel1Table. This field applies only
 * when FTMEN = 1. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_DECAPEN0 (2U)       /*!< Bit position for FTM_COMBINE_DECAPEN0. */
#define BM_FTM_COMBINE_DECAPEN0 (0x00000004U) /*!< Bit mask for FTM_COMBINE_DECAPEN0. */
#define BS_FTM_COMBINE_DECAPEN0 (1U)       /*!< Bit field size in bits for FTM_COMBINE_DECAPEN0. */

/*! @brief Read current value of the FTM_COMBINE_DECAPEN0 field. */
#define BR_FTM_COMBINE_DECAPEN0(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAPEN0))

/*! @brief Format value for bitfield FTM_COMBINE_DECAPEN0. */
#define BF_FTM_COMBINE_DECAPEN0(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DECAPEN0) & BM_FTM_COMBINE_DECAPEN0)

/*! @brief Set the DECAPEN0 field to a new value. */
#define BW_FTM_COMBINE_DECAPEN0(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAPEN0) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP0[3] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when FTMEN = 1 and DECAPEN = 1. DECAP bit is cleared automatically by
 * hardware if dual edge capture - one-shot mode is selected and when the capture
 * of channel (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
#define BP_FTM_COMBINE_DECAP0 (3U)         /*!< Bit position for FTM_COMBINE_DECAP0. */
#define BM_FTM_COMBINE_DECAP0 (0x00000008U) /*!< Bit mask for FTM_COMBINE_DECAP0. */
#define BS_FTM_COMBINE_DECAP0 (1U)         /*!< Bit field size in bits for FTM_COMBINE_DECAP0. */

/*! @brief Read current value of the FTM_COMBINE_DECAP0 field. */
#define BR_FTM_COMBINE_DECAP0(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAP0))

/*! @brief Format value for bitfield FTM_COMBINE_DECAP0. */
#define BF_FTM_COMBINE_DECAP0(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DECAP0) & BM_FTM_COMBINE_DECAP0)

/*! @brief Set the DECAP0 field to a new value. */
#define BW_FTM_COMBINE_DECAP0(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAP0) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN0[4] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_DTEN0 (4U)          /*!< Bit position for FTM_COMBINE_DTEN0. */
#define BM_FTM_COMBINE_DTEN0 (0x00000010U) /*!< Bit mask for FTM_COMBINE_DTEN0. */
#define BS_FTM_COMBINE_DTEN0 (1U)          /*!< Bit field size in bits for FTM_COMBINE_DTEN0. */

/*! @brief Read current value of the FTM_COMBINE_DTEN0 field. */
#define BR_FTM_COMBINE_DTEN0(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DTEN0))

/*! @brief Format value for bitfield FTM_COMBINE_DTEN0. */
#define BF_FTM_COMBINE_DTEN0(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DTEN0) & BM_FTM_COMBINE_DTEN0)

/*! @brief Set the DTEN0 field to a new value. */
#define BW_FTM_COMBINE_DTEN0(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DTEN0) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN0[5] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_SYNCEN0 (5U)        /*!< Bit position for FTM_COMBINE_SYNCEN0. */
#define BM_FTM_COMBINE_SYNCEN0 (0x00000020U) /*!< Bit mask for FTM_COMBINE_SYNCEN0. */
#define BS_FTM_COMBINE_SYNCEN0 (1U)        /*!< Bit field size in bits for FTM_COMBINE_SYNCEN0. */

/*! @brief Read current value of the FTM_COMBINE_SYNCEN0 field. */
#define BR_FTM_COMBINE_SYNCEN0(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_SYNCEN0))

/*! @brief Format value for bitfield FTM_COMBINE_SYNCEN0. */
#define BF_FTM_COMBINE_SYNCEN0(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_SYNCEN0) & BM_FTM_COMBINE_SYNCEN0)

/*! @brief Set the SYNCEN0 field to a new value. */
#define BW_FTM_COMBINE_SYNCEN0(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_SYNCEN0) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN0[6] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_FAULTEN0 (6U)       /*!< Bit position for FTM_COMBINE_FAULTEN0. */
#define BM_FTM_COMBINE_FAULTEN0 (0x00000040U) /*!< Bit mask for FTM_COMBINE_FAULTEN0. */
#define BS_FTM_COMBINE_FAULTEN0 (1U)       /*!< Bit field size in bits for FTM_COMBINE_FAULTEN0. */

/*! @brief Read current value of the FTM_COMBINE_FAULTEN0 field. */
#define BR_FTM_COMBINE_FAULTEN0(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_FAULTEN0))

/*! @brief Format value for bitfield FTM_COMBINE_FAULTEN0. */
#define BF_FTM_COMBINE_FAULTEN0(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_FAULTEN0) & BM_FTM_COMBINE_FAULTEN0)

/*! @brief Set the FAULTEN0 field to a new value. */
#define BW_FTM_COMBINE_FAULTEN0(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_FAULTEN0) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE1[8] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
#define BP_FTM_COMBINE_COMBINE1 (8U)       /*!< Bit position for FTM_COMBINE_COMBINE1. */
#define BM_FTM_COMBINE_COMBINE1 (0x00000100U) /*!< Bit mask for FTM_COMBINE_COMBINE1. */
#define BS_FTM_COMBINE_COMBINE1 (1U)       /*!< Bit field size in bits for FTM_COMBINE_COMBINE1. */

/*! @brief Read current value of the FTM_COMBINE_COMBINE1 field. */
#define BR_FTM_COMBINE_COMBINE1(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMBINE1))

/*! @brief Format value for bitfield FTM_COMBINE_COMBINE1. */
#define BF_FTM_COMBINE_COMBINE1(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_COMBINE1) & BM_FTM_COMBINE_COMBINE1)

/*! @brief Set the COMBINE1 field to a new value. */
#define BW_FTM_COMBINE_COMBINE1(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMBINE1) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP1[9] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
#define BP_FTM_COMBINE_COMP1 (9U)          /*!< Bit position for FTM_COMBINE_COMP1. */
#define BM_FTM_COMBINE_COMP1 (0x00000200U) /*!< Bit mask for FTM_COMBINE_COMP1. */
#define BS_FTM_COMBINE_COMP1 (1U)          /*!< Bit field size in bits for FTM_COMBINE_COMP1. */

/*! @brief Read current value of the FTM_COMBINE_COMP1 field. */
#define BR_FTM_COMBINE_COMP1(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMP1))

/*! @brief Format value for bitfield FTM_COMBINE_COMP1. */
#define BF_FTM_COMBINE_COMP1(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_COMP1) & BM_FTM_COMBINE_COMP1)

/*! @brief Set the COMP1 field to a new value. */
#define BW_FTM_COMBINE_COMP1(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMP1) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN1[10] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to #ModeSel1Table. This field applies only
 * when FTMEN = 1. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_DECAPEN1 (10U)      /*!< Bit position for FTM_COMBINE_DECAPEN1. */
#define BM_FTM_COMBINE_DECAPEN1 (0x00000400U) /*!< Bit mask for FTM_COMBINE_DECAPEN1. */
#define BS_FTM_COMBINE_DECAPEN1 (1U)       /*!< Bit field size in bits for FTM_COMBINE_DECAPEN1. */

/*! @brief Read current value of the FTM_COMBINE_DECAPEN1 field. */
#define BR_FTM_COMBINE_DECAPEN1(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAPEN1))

/*! @brief Format value for bitfield FTM_COMBINE_DECAPEN1. */
#define BF_FTM_COMBINE_DECAPEN1(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DECAPEN1) & BM_FTM_COMBINE_DECAPEN1)

/*! @brief Set the DECAPEN1 field to a new value. */
#define BW_FTM_COMBINE_DECAPEN1(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAPEN1) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP1[11] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when FTMEN = 1 and DECAPEN = 1. DECAP bit is cleared automatically by
 * hardware if Dual Edge Capture - One-Shot mode is selected and when the capture
 * of channel (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
#define BP_FTM_COMBINE_DECAP1 (11U)        /*!< Bit position for FTM_COMBINE_DECAP1. */
#define BM_FTM_COMBINE_DECAP1 (0x00000800U) /*!< Bit mask for FTM_COMBINE_DECAP1. */
#define BS_FTM_COMBINE_DECAP1 (1U)         /*!< Bit field size in bits for FTM_COMBINE_DECAP1. */

/*! @brief Read current value of the FTM_COMBINE_DECAP1 field. */
#define BR_FTM_COMBINE_DECAP1(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAP1))

/*! @brief Format value for bitfield FTM_COMBINE_DECAP1. */
#define BF_FTM_COMBINE_DECAP1(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DECAP1) & BM_FTM_COMBINE_DECAP1)

/*! @brief Set the DECAP1 field to a new value. */
#define BW_FTM_COMBINE_DECAP1(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAP1) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN1[12] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_DTEN1 (12U)         /*!< Bit position for FTM_COMBINE_DTEN1. */
#define BM_FTM_COMBINE_DTEN1 (0x00001000U) /*!< Bit mask for FTM_COMBINE_DTEN1. */
#define BS_FTM_COMBINE_DTEN1 (1U)          /*!< Bit field size in bits for FTM_COMBINE_DTEN1. */

/*! @brief Read current value of the FTM_COMBINE_DTEN1 field. */
#define BR_FTM_COMBINE_DTEN1(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DTEN1))

/*! @brief Format value for bitfield FTM_COMBINE_DTEN1. */
#define BF_FTM_COMBINE_DTEN1(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DTEN1) & BM_FTM_COMBINE_DTEN1)

/*! @brief Set the DTEN1 field to a new value. */
#define BW_FTM_COMBINE_DTEN1(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DTEN1) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN1[13] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_SYNCEN1 (13U)       /*!< Bit position for FTM_COMBINE_SYNCEN1. */
#define BM_FTM_COMBINE_SYNCEN1 (0x00002000U) /*!< Bit mask for FTM_COMBINE_SYNCEN1. */
#define BS_FTM_COMBINE_SYNCEN1 (1U)        /*!< Bit field size in bits for FTM_COMBINE_SYNCEN1. */

/*! @brief Read current value of the FTM_COMBINE_SYNCEN1 field. */
#define BR_FTM_COMBINE_SYNCEN1(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_SYNCEN1))

/*! @brief Format value for bitfield FTM_COMBINE_SYNCEN1. */
#define BF_FTM_COMBINE_SYNCEN1(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_SYNCEN1) & BM_FTM_COMBINE_SYNCEN1)

/*! @brief Set the SYNCEN1 field to a new value. */
#define BW_FTM_COMBINE_SYNCEN1(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_SYNCEN1) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN1[14] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_FAULTEN1 (14U)      /*!< Bit position for FTM_COMBINE_FAULTEN1. */
#define BM_FTM_COMBINE_FAULTEN1 (0x00004000U) /*!< Bit mask for FTM_COMBINE_FAULTEN1. */
#define BS_FTM_COMBINE_FAULTEN1 (1U)       /*!< Bit field size in bits for FTM_COMBINE_FAULTEN1. */

/*! @brief Read current value of the FTM_COMBINE_FAULTEN1 field. */
#define BR_FTM_COMBINE_FAULTEN1(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_FAULTEN1))

/*! @brief Format value for bitfield FTM_COMBINE_FAULTEN1. */
#define BF_FTM_COMBINE_FAULTEN1(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_FAULTEN1) & BM_FTM_COMBINE_FAULTEN1)

/*! @brief Set the FAULTEN1 field to a new value. */
#define BW_FTM_COMBINE_FAULTEN1(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_FAULTEN1) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE2[16] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
#define BP_FTM_COMBINE_COMBINE2 (16U)      /*!< Bit position for FTM_COMBINE_COMBINE2. */
#define BM_FTM_COMBINE_COMBINE2 (0x00010000U) /*!< Bit mask for FTM_COMBINE_COMBINE2. */
#define BS_FTM_COMBINE_COMBINE2 (1U)       /*!< Bit field size in bits for FTM_COMBINE_COMBINE2. */

/*! @brief Read current value of the FTM_COMBINE_COMBINE2 field. */
#define BR_FTM_COMBINE_COMBINE2(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMBINE2))

/*! @brief Format value for bitfield FTM_COMBINE_COMBINE2. */
#define BF_FTM_COMBINE_COMBINE2(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_COMBINE2) & BM_FTM_COMBINE_COMBINE2)

/*! @brief Set the COMBINE2 field to a new value. */
#define BW_FTM_COMBINE_COMBINE2(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMBINE2) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP2[17] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
#define BP_FTM_COMBINE_COMP2 (17U)         /*!< Bit position for FTM_COMBINE_COMP2. */
#define BM_FTM_COMBINE_COMP2 (0x00020000U) /*!< Bit mask for FTM_COMBINE_COMP2. */
#define BS_FTM_COMBINE_COMP2 (1U)          /*!< Bit field size in bits for FTM_COMBINE_COMP2. */

/*! @brief Read current value of the FTM_COMBINE_COMP2 field. */
#define BR_FTM_COMBINE_COMP2(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMP2))

/*! @brief Format value for bitfield FTM_COMBINE_COMP2. */
#define BF_FTM_COMBINE_COMP2(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_COMP2) & BM_FTM_COMBINE_COMP2)

/*! @brief Set the COMP2 field to a new value. */
#define BW_FTM_COMBINE_COMP2(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMP2) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN2[18] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to #ModeSel1Table. This field applies only
 * when FTMEN = 1. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_DECAPEN2 (18U)      /*!< Bit position for FTM_COMBINE_DECAPEN2. */
#define BM_FTM_COMBINE_DECAPEN2 (0x00040000U) /*!< Bit mask for FTM_COMBINE_DECAPEN2. */
#define BS_FTM_COMBINE_DECAPEN2 (1U)       /*!< Bit field size in bits for FTM_COMBINE_DECAPEN2. */

/*! @brief Read current value of the FTM_COMBINE_DECAPEN2 field. */
#define BR_FTM_COMBINE_DECAPEN2(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAPEN2))

/*! @brief Format value for bitfield FTM_COMBINE_DECAPEN2. */
#define BF_FTM_COMBINE_DECAPEN2(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DECAPEN2) & BM_FTM_COMBINE_DECAPEN2)

/*! @brief Set the DECAPEN2 field to a new value. */
#define BW_FTM_COMBINE_DECAPEN2(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAPEN2) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP2[19] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when FTMEN = 1 and DECAPEN = 1. DECAP bit is cleared automatically by
 * hardware if dual edge capture - one-shot mode is selected and when the capture
 * of channel (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
#define BP_FTM_COMBINE_DECAP2 (19U)        /*!< Bit position for FTM_COMBINE_DECAP2. */
#define BM_FTM_COMBINE_DECAP2 (0x00080000U) /*!< Bit mask for FTM_COMBINE_DECAP2. */
#define BS_FTM_COMBINE_DECAP2 (1U)         /*!< Bit field size in bits for FTM_COMBINE_DECAP2. */

/*! @brief Read current value of the FTM_COMBINE_DECAP2 field. */
#define BR_FTM_COMBINE_DECAP2(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAP2))

/*! @brief Format value for bitfield FTM_COMBINE_DECAP2. */
#define BF_FTM_COMBINE_DECAP2(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DECAP2) & BM_FTM_COMBINE_DECAP2)

/*! @brief Set the DECAP2 field to a new value. */
#define BW_FTM_COMBINE_DECAP2(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAP2) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN2[20] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_DTEN2 (20U)         /*!< Bit position for FTM_COMBINE_DTEN2. */
#define BM_FTM_COMBINE_DTEN2 (0x00100000U) /*!< Bit mask for FTM_COMBINE_DTEN2. */
#define BS_FTM_COMBINE_DTEN2 (1U)          /*!< Bit field size in bits for FTM_COMBINE_DTEN2. */

/*! @brief Read current value of the FTM_COMBINE_DTEN2 field. */
#define BR_FTM_COMBINE_DTEN2(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DTEN2))

/*! @brief Format value for bitfield FTM_COMBINE_DTEN2. */
#define BF_FTM_COMBINE_DTEN2(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DTEN2) & BM_FTM_COMBINE_DTEN2)

/*! @brief Set the DTEN2 field to a new value. */
#define BW_FTM_COMBINE_DTEN2(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DTEN2) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN2[21] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_SYNCEN2 (21U)       /*!< Bit position for FTM_COMBINE_SYNCEN2. */
#define BM_FTM_COMBINE_SYNCEN2 (0x00200000U) /*!< Bit mask for FTM_COMBINE_SYNCEN2. */
#define BS_FTM_COMBINE_SYNCEN2 (1U)        /*!< Bit field size in bits for FTM_COMBINE_SYNCEN2. */

/*! @brief Read current value of the FTM_COMBINE_SYNCEN2 field. */
#define BR_FTM_COMBINE_SYNCEN2(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_SYNCEN2))

/*! @brief Format value for bitfield FTM_COMBINE_SYNCEN2. */
#define BF_FTM_COMBINE_SYNCEN2(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_SYNCEN2) & BM_FTM_COMBINE_SYNCEN2)

/*! @brief Set the SYNCEN2 field to a new value. */
#define BW_FTM_COMBINE_SYNCEN2(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_SYNCEN2) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN2[22] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_FAULTEN2 (22U)      /*!< Bit position for FTM_COMBINE_FAULTEN2. */
#define BM_FTM_COMBINE_FAULTEN2 (0x00400000U) /*!< Bit mask for FTM_COMBINE_FAULTEN2. */
#define BS_FTM_COMBINE_FAULTEN2 (1U)       /*!< Bit field size in bits for FTM_COMBINE_FAULTEN2. */

/*! @brief Read current value of the FTM_COMBINE_FAULTEN2 field. */
#define BR_FTM_COMBINE_FAULTEN2(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_FAULTEN2))

/*! @brief Format value for bitfield FTM_COMBINE_FAULTEN2. */
#define BF_FTM_COMBINE_FAULTEN2(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_FAULTEN2) & BM_FTM_COMBINE_FAULTEN2)

/*! @brief Set the FAULTEN2 field to a new value. */
#define BW_FTM_COMBINE_FAULTEN2(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_FAULTEN2) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE3[24] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Channels (n) and (n+1) are independent.
 * - 1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
#define BP_FTM_COMBINE_COMBINE3 (24U)      /*!< Bit position for FTM_COMBINE_COMBINE3. */
#define BM_FTM_COMBINE_COMBINE3 (0x01000000U) /*!< Bit mask for FTM_COMBINE_COMBINE3. */
#define BS_FTM_COMBINE_COMBINE3 (1U)       /*!< Bit field size in bits for FTM_COMBINE_COMBINE3. */

/*! @brief Read current value of the FTM_COMBINE_COMBINE3 field. */
#define BR_FTM_COMBINE_COMBINE3(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMBINE3))

/*! @brief Format value for bitfield FTM_COMBINE_COMBINE3. */
#define BF_FTM_COMBINE_COMBINE3(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_COMBINE3) & BM_FTM_COMBINE_COMBINE3)

/*! @brief Set the COMBINE3 field to a new value. */
#define BW_FTM_COMBINE_COMBINE3(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMBINE3) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP3[25] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel (n+1) output is the same as the channel (n) output.
 * - 1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
#define BP_FTM_COMBINE_COMP3 (25U)         /*!< Bit position for FTM_COMBINE_COMP3. */
#define BM_FTM_COMBINE_COMP3 (0x02000000U) /*!< Bit mask for FTM_COMBINE_COMP3. */
#define BS_FTM_COMBINE_COMP3 (1U)          /*!< Bit field size in bits for FTM_COMBINE_COMP3. */

/*! @brief Read current value of the FTM_COMBINE_COMP3 field. */
#define BR_FTM_COMBINE_COMP3(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMP3))

/*! @brief Format value for bitfield FTM_COMBINE_COMP3. */
#define BF_FTM_COMBINE_COMP3(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_COMP3) & BM_FTM_COMBINE_COMP3)

/*! @brief Set the COMP3 field to a new value. */
#define BW_FTM_COMBINE_COMP3(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_COMP3) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN3[26] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to #ModeSel1Table. This field applies only
 * when FTMEN = 1. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_DECAPEN3 (26U)      /*!< Bit position for FTM_COMBINE_DECAPEN3. */
#define BM_FTM_COMBINE_DECAPEN3 (0x04000000U) /*!< Bit mask for FTM_COMBINE_DECAPEN3. */
#define BS_FTM_COMBINE_DECAPEN3 (1U)       /*!< Bit field size in bits for FTM_COMBINE_DECAPEN3. */

/*! @brief Read current value of the FTM_COMBINE_DECAPEN3 field. */
#define BR_FTM_COMBINE_DECAPEN3(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAPEN3))

/*! @brief Format value for bitfield FTM_COMBINE_DECAPEN3. */
#define BF_FTM_COMBINE_DECAPEN3(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DECAPEN3) & BM_FTM_COMBINE_DECAPEN3)

/*! @brief Set the DECAPEN3 field to a new value. */
#define BW_FTM_COMBINE_DECAPEN3(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAPEN3) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP3[27] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when FTMEN = 1 and DECAPEN = 1. DECAP bit is cleared automatically by
 * hardware if dual edge capture - one-shot mode is selected and when the capture
 * of channel (n+1) event is made.
 *
 * Values:
 * - 0 - The dual edge captures are inactive.
 * - 1 - The dual edge captures are active.
 */
/*@{*/
#define BP_FTM_COMBINE_DECAP3 (27U)        /*!< Bit position for FTM_COMBINE_DECAP3. */
#define BM_FTM_COMBINE_DECAP3 (0x08000000U) /*!< Bit mask for FTM_COMBINE_DECAP3. */
#define BS_FTM_COMBINE_DECAP3 (1U)         /*!< Bit field size in bits for FTM_COMBINE_DECAP3. */

/*! @brief Read current value of the FTM_COMBINE_DECAP3 field. */
#define BR_FTM_COMBINE_DECAP3(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAP3))

/*! @brief Format value for bitfield FTM_COMBINE_DECAP3. */
#define BF_FTM_COMBINE_DECAP3(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DECAP3) & BM_FTM_COMBINE_DECAP3)

/*! @brief Set the DECAP3 field to a new value. */
#define BW_FTM_COMBINE_DECAP3(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DECAP3) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN3[28] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The deadtime insertion in this pair of channels is disabled.
 * - 1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_DTEN3 (28U)         /*!< Bit position for FTM_COMBINE_DTEN3. */
#define BM_FTM_COMBINE_DTEN3 (0x10000000U) /*!< Bit mask for FTM_COMBINE_DTEN3. */
#define BS_FTM_COMBINE_DTEN3 (1U)          /*!< Bit field size in bits for FTM_COMBINE_DTEN3. */

/*! @brief Read current value of the FTM_COMBINE_DTEN3 field. */
#define BR_FTM_COMBINE_DTEN3(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DTEN3))

/*! @brief Format value for bitfield FTM_COMBINE_DTEN3. */
#define BF_FTM_COMBINE_DTEN3(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_DTEN3) & BM_FTM_COMBINE_DTEN3)

/*! @brief Set the DTEN3 field to a new value. */
#define BW_FTM_COMBINE_DTEN3(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_DTEN3) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN3[29] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0 - The PWM synchronization in this pair of channels is disabled.
 * - 1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_SYNCEN3 (29U)       /*!< Bit position for FTM_COMBINE_SYNCEN3. */
#define BM_FTM_COMBINE_SYNCEN3 (0x20000000U) /*!< Bit mask for FTM_COMBINE_SYNCEN3. */
#define BS_FTM_COMBINE_SYNCEN3 (1U)        /*!< Bit field size in bits for FTM_COMBINE_SYNCEN3. */

/*! @brief Read current value of the FTM_COMBINE_SYNCEN3 field. */
#define BR_FTM_COMBINE_SYNCEN3(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_SYNCEN3))

/*! @brief Format value for bitfield FTM_COMBINE_SYNCEN3. */
#define BF_FTM_COMBINE_SYNCEN3(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_SYNCEN3) & BM_FTM_COMBINE_SYNCEN3)

/*! @brief Set the SYNCEN3 field to a new value. */
#define BW_FTM_COMBINE_SYNCEN3(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_SYNCEN3) = (v))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN3[30] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault control in this pair of channels is disabled.
 * - 1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
#define BP_FTM_COMBINE_FAULTEN3 (30U)      /*!< Bit position for FTM_COMBINE_FAULTEN3. */
#define BM_FTM_COMBINE_FAULTEN3 (0x40000000U) /*!< Bit mask for FTM_COMBINE_FAULTEN3. */
#define BS_FTM_COMBINE_FAULTEN3 (1U)       /*!< Bit field size in bits for FTM_COMBINE_FAULTEN3. */

/*! @brief Read current value of the FTM_COMBINE_FAULTEN3 field. */
#define BR_FTM_COMBINE_FAULTEN3(x) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_FAULTEN3))

/*! @brief Format value for bitfield FTM_COMBINE_FAULTEN3. */
#define BF_FTM_COMBINE_FAULTEN3(v) ((uint32_t)((uint32_t)(v) << BP_FTM_COMBINE_FAULTEN3) & BM_FTM_COMBINE_FAULTEN3)

/*! @brief Set the FAULTEN3 field to a new value. */
#define BW_FTM_COMBINE_FAULTEN3(x, v) (BITBAND_ACCESS32(HW_FTM_COMBINE_ADDR(x), BP_FTM_COMBINE_FAULTEN3) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_DEADTIME - Deadtime Insertion Control
 ******************************************************************************/

/*!
 * @brief HW_FTM_DEADTIME - Deadtime Insertion Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the deadtime prescaler factor and deadtime value. All
 * FTM channels use this clock prescaler and this deadtime value for the deadtime
 * insertion.
 */
typedef union _hw_ftm_deadtime
{
    uint32_t U;
    struct _hw_ftm_deadtime_bitfields
    {
        uint32_t DTVAL : 6;            /*!< [5:0] Deadtime Value */
        uint32_t DTPS : 2;             /*!< [7:6] Deadtime Prescaler Value */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_deadtime_t;

/*!
 * @name Constants and macros for entire FTM_DEADTIME register
 */
/*@{*/
#define HW_FTM_DEADTIME_ADDR(x)  ((uint32_t)(x) + 0x68U)

#define HW_FTM_DEADTIME(x)       (*(__IO hw_ftm_deadtime_t *) HW_FTM_DEADTIME_ADDR(x))
#define HW_FTM_DEADTIME_RD(x)    (HW_FTM_DEADTIME(x).U)
#define HW_FTM_DEADTIME_WR(x, v) (HW_FTM_DEADTIME(x).U = (v))
#define HW_FTM_DEADTIME_SET(x, v) (HW_FTM_DEADTIME_WR(x, HW_FTM_DEADTIME_RD(x) |  (v)))
#define HW_FTM_DEADTIME_CLR(x, v) (HW_FTM_DEADTIME_WR(x, HW_FTM_DEADTIME_RD(x) & ~(v)))
#define HW_FTM_DEADTIME_TOG(x, v) (HW_FTM_DEADTIME_WR(x, HW_FTM_DEADTIME_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_DEADTIME bitfields
 */

/*!
 * @name Register FTM_DEADTIME, field DTVAL[5:0] (RW)
 *
 * Selects the deadtime insertion value for the deadtime counter. The deadtime
 * counter is clocked by a scaled version of the system clock. See the description
 * of DTPS. Deadtime insert value = (DTPS * DTVAL). DTVAL selects the number of
 * deadtime counts inserted as follows: When DTVAL is 0, no counts are inserted.
 * When DTVAL is 1, 1 count is inserted. When DTVAL is 2, 2 counts are inserted.
 * This pattern continues up to a possible 63 counts. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
#define BP_FTM_DEADTIME_DTVAL (0U)         /*!< Bit position for FTM_DEADTIME_DTVAL. */
#define BM_FTM_DEADTIME_DTVAL (0x0000003FU) /*!< Bit mask for FTM_DEADTIME_DTVAL. */
#define BS_FTM_DEADTIME_DTVAL (6U)         /*!< Bit field size in bits for FTM_DEADTIME_DTVAL. */

/*! @brief Read current value of the FTM_DEADTIME_DTVAL field. */
#define BR_FTM_DEADTIME_DTVAL(x) (HW_FTM_DEADTIME(x).B.DTVAL)

/*! @brief Format value for bitfield FTM_DEADTIME_DTVAL. */
#define BF_FTM_DEADTIME_DTVAL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_DEADTIME_DTVAL) & BM_FTM_DEADTIME_DTVAL)

/*! @brief Set the DTVAL field to a new value. */
#define BW_FTM_DEADTIME_DTVAL(x, v) (HW_FTM_DEADTIME_WR(x, (HW_FTM_DEADTIME_RD(x) & ~BM_FTM_DEADTIME_DTVAL) | BF_FTM_DEADTIME_DTVAL(v)))
/*@}*/

/*!
 * @name Register FTM_DEADTIME, field DTPS[7:6] (RW)
 *
 * Selects the division factor of the system clock. This prescaled clock is used
 * by the deadtime counter. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0x - Divide the system clock by 1.
 * - 10 - Divide the system clock by 4.
 * - 11 - Divide the system clock by 16.
 */
/*@{*/
#define BP_FTM_DEADTIME_DTPS (6U)          /*!< Bit position for FTM_DEADTIME_DTPS. */
#define BM_FTM_DEADTIME_DTPS (0x000000C0U) /*!< Bit mask for FTM_DEADTIME_DTPS. */
#define BS_FTM_DEADTIME_DTPS (2U)          /*!< Bit field size in bits for FTM_DEADTIME_DTPS. */

/*! @brief Read current value of the FTM_DEADTIME_DTPS field. */
#define BR_FTM_DEADTIME_DTPS(x) (HW_FTM_DEADTIME(x).B.DTPS)

/*! @brief Format value for bitfield FTM_DEADTIME_DTPS. */
#define BF_FTM_DEADTIME_DTPS(v) ((uint32_t)((uint32_t)(v) << BP_FTM_DEADTIME_DTPS) & BM_FTM_DEADTIME_DTPS)

/*! @brief Set the DTPS field to a new value. */
#define BW_FTM_DEADTIME_DTPS(x, v) (HW_FTM_DEADTIME_WR(x, (HW_FTM_DEADTIME_RD(x) & ~BM_FTM_DEADTIME_DTPS) | BF_FTM_DEADTIME_DTPS(v)))
/*@}*/

/*******************************************************************************
 * HW_FTM_EXTTRIG - FTM External Trigger
 ******************************************************************************/

/*!
 * @brief HW_FTM_EXTTRIG - FTM External Trigger (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register: Indicates when a channel trigger was generated Enables the
 * generation of a trigger when the FTM counter is equal to its initial value
 * Selects which channels are used in the generation of the channel triggers Several
 * channels can be selected to generate multiple triggers in one PWM period.
 * Channels 6 and 7 are not used to generate channel triggers.
 */
typedef union _hw_ftm_exttrig
{
    uint32_t U;
    struct _hw_ftm_exttrig_bitfields
    {
        uint32_t CH2TRIG : 1;          /*!< [0] Channel 2 Trigger Enable */
        uint32_t CH3TRIG : 1;          /*!< [1] Channel 3 Trigger Enable */
        uint32_t CH4TRIG : 1;          /*!< [2] Channel 4 Trigger Enable */
        uint32_t CH5TRIG : 1;          /*!< [3] Channel 5 Trigger Enable */
        uint32_t CH0TRIG : 1;          /*!< [4] Channel 0 Trigger Enable */
        uint32_t CH1TRIG : 1;          /*!< [5] Channel 1 Trigger Enable */
        uint32_t INITTRIGEN : 1;       /*!< [6] Initialization Trigger Enable */
        uint32_t TRIGF : 1;            /*!< [7] Channel Trigger Flag */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_exttrig_t;

/*!
 * @name Constants and macros for entire FTM_EXTTRIG register
 */
/*@{*/
#define HW_FTM_EXTTRIG_ADDR(x)   ((uint32_t)(x) + 0x6CU)

#define HW_FTM_EXTTRIG(x)        (*(__IO hw_ftm_exttrig_t *) HW_FTM_EXTTRIG_ADDR(x))
#define HW_FTM_EXTTRIG_RD(x)     (HW_FTM_EXTTRIG(x).U)
#define HW_FTM_EXTTRIG_WR(x, v)  (HW_FTM_EXTTRIG(x).U = (v))
#define HW_FTM_EXTTRIG_SET(x, v) (HW_FTM_EXTTRIG_WR(x, HW_FTM_EXTTRIG_RD(x) |  (v)))
#define HW_FTM_EXTTRIG_CLR(x, v) (HW_FTM_EXTTRIG_WR(x, HW_FTM_EXTTRIG_RD(x) & ~(v)))
#define HW_FTM_EXTTRIG_TOG(x, v) (HW_FTM_EXTTRIG_WR(x, HW_FTM_EXTTRIG_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_EXTTRIG bitfields
 */

/*!
 * @name Register FTM_EXTTRIG, field CH2TRIG[0] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
#define BP_FTM_EXTTRIG_CH2TRIG (0U)        /*!< Bit position for FTM_EXTTRIG_CH2TRIG. */
#define BM_FTM_EXTTRIG_CH2TRIG (0x00000001U) /*!< Bit mask for FTM_EXTTRIG_CH2TRIG. */
#define BS_FTM_EXTTRIG_CH2TRIG (1U)        /*!< Bit field size in bits for FTM_EXTTRIG_CH2TRIG. */

/*! @brief Read current value of the FTM_EXTTRIG_CH2TRIG field. */
#define BR_FTM_EXTTRIG_CH2TRIG(x) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH2TRIG))

/*! @brief Format value for bitfield FTM_EXTTRIG_CH2TRIG. */
#define BF_FTM_EXTTRIG_CH2TRIG(v) ((uint32_t)((uint32_t)(v) << BP_FTM_EXTTRIG_CH2TRIG) & BM_FTM_EXTTRIG_CH2TRIG)

/*! @brief Set the CH2TRIG field to a new value. */
#define BW_FTM_EXTTRIG_CH2TRIG(x, v) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH2TRIG) = (v))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH3TRIG[1] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
#define BP_FTM_EXTTRIG_CH3TRIG (1U)        /*!< Bit position for FTM_EXTTRIG_CH3TRIG. */
#define BM_FTM_EXTTRIG_CH3TRIG (0x00000002U) /*!< Bit mask for FTM_EXTTRIG_CH3TRIG. */
#define BS_FTM_EXTTRIG_CH3TRIG (1U)        /*!< Bit field size in bits for FTM_EXTTRIG_CH3TRIG. */

/*! @brief Read current value of the FTM_EXTTRIG_CH3TRIG field. */
#define BR_FTM_EXTTRIG_CH3TRIG(x) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH3TRIG))

/*! @brief Format value for bitfield FTM_EXTTRIG_CH3TRIG. */
#define BF_FTM_EXTTRIG_CH3TRIG(v) ((uint32_t)((uint32_t)(v) << BP_FTM_EXTTRIG_CH3TRIG) & BM_FTM_EXTTRIG_CH3TRIG)

/*! @brief Set the CH3TRIG field to a new value. */
#define BW_FTM_EXTTRIG_CH3TRIG(x, v) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH3TRIG) = (v))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH4TRIG[2] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
#define BP_FTM_EXTTRIG_CH4TRIG (2U)        /*!< Bit position for FTM_EXTTRIG_CH4TRIG. */
#define BM_FTM_EXTTRIG_CH4TRIG (0x00000004U) /*!< Bit mask for FTM_EXTTRIG_CH4TRIG. */
#define BS_FTM_EXTTRIG_CH4TRIG (1U)        /*!< Bit field size in bits for FTM_EXTTRIG_CH4TRIG. */

/*! @brief Read current value of the FTM_EXTTRIG_CH4TRIG field. */
#define BR_FTM_EXTTRIG_CH4TRIG(x) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH4TRIG))

/*! @brief Format value for bitfield FTM_EXTTRIG_CH4TRIG. */
#define BF_FTM_EXTTRIG_CH4TRIG(v) ((uint32_t)((uint32_t)(v) << BP_FTM_EXTTRIG_CH4TRIG) & BM_FTM_EXTTRIG_CH4TRIG)

/*! @brief Set the CH4TRIG field to a new value. */
#define BW_FTM_EXTTRIG_CH4TRIG(x, v) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH4TRIG) = (v))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH5TRIG[3] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
#define BP_FTM_EXTTRIG_CH5TRIG (3U)        /*!< Bit position for FTM_EXTTRIG_CH5TRIG. */
#define BM_FTM_EXTTRIG_CH5TRIG (0x00000008U) /*!< Bit mask for FTM_EXTTRIG_CH5TRIG. */
#define BS_FTM_EXTTRIG_CH5TRIG (1U)        /*!< Bit field size in bits for FTM_EXTTRIG_CH5TRIG. */

/*! @brief Read current value of the FTM_EXTTRIG_CH5TRIG field. */
#define BR_FTM_EXTTRIG_CH5TRIG(x) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH5TRIG))

/*! @brief Format value for bitfield FTM_EXTTRIG_CH5TRIG. */
#define BF_FTM_EXTTRIG_CH5TRIG(v) ((uint32_t)((uint32_t)(v) << BP_FTM_EXTTRIG_CH5TRIG) & BM_FTM_EXTTRIG_CH5TRIG)

/*! @brief Set the CH5TRIG field to a new value. */
#define BW_FTM_EXTTRIG_CH5TRIG(x, v) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH5TRIG) = (v))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH0TRIG[4] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
#define BP_FTM_EXTTRIG_CH0TRIG (4U)        /*!< Bit position for FTM_EXTTRIG_CH0TRIG. */
#define BM_FTM_EXTTRIG_CH0TRIG (0x00000010U) /*!< Bit mask for FTM_EXTTRIG_CH0TRIG. */
#define BS_FTM_EXTTRIG_CH0TRIG (1U)        /*!< Bit field size in bits for FTM_EXTTRIG_CH0TRIG. */

/*! @brief Read current value of the FTM_EXTTRIG_CH0TRIG field. */
#define BR_FTM_EXTTRIG_CH0TRIG(x) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH0TRIG))

/*! @brief Format value for bitfield FTM_EXTTRIG_CH0TRIG. */
#define BF_FTM_EXTTRIG_CH0TRIG(v) ((uint32_t)((uint32_t)(v) << BP_FTM_EXTTRIG_CH0TRIG) & BM_FTM_EXTTRIG_CH0TRIG)

/*! @brief Set the CH0TRIG field to a new value. */
#define BW_FTM_EXTTRIG_CH0TRIG(x, v) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH0TRIG) = (v))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH1TRIG[5] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0 - The generation of the channel trigger is disabled.
 * - 1 - The generation of the channel trigger is enabled.
 */
/*@{*/
#define BP_FTM_EXTTRIG_CH1TRIG (5U)        /*!< Bit position for FTM_EXTTRIG_CH1TRIG. */
#define BM_FTM_EXTTRIG_CH1TRIG (0x00000020U) /*!< Bit mask for FTM_EXTTRIG_CH1TRIG. */
#define BS_FTM_EXTTRIG_CH1TRIG (1U)        /*!< Bit field size in bits for FTM_EXTTRIG_CH1TRIG. */

/*! @brief Read current value of the FTM_EXTTRIG_CH1TRIG field. */
#define BR_FTM_EXTTRIG_CH1TRIG(x) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH1TRIG))

/*! @brief Format value for bitfield FTM_EXTTRIG_CH1TRIG. */
#define BF_FTM_EXTTRIG_CH1TRIG(v) ((uint32_t)((uint32_t)(v) << BP_FTM_EXTTRIG_CH1TRIG) & BM_FTM_EXTTRIG_CH1TRIG)

/*! @brief Set the CH1TRIG field to a new value. */
#define BW_FTM_EXTTRIG_CH1TRIG(x, v) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_CH1TRIG) = (v))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field INITTRIGEN[6] (RW)
 *
 * Enables the generation of the trigger when the FTM counter is equal to the
 * CNTIN register.
 *
 * Values:
 * - 0 - The generation of initialization trigger is disabled.
 * - 1 - The generation of initialization trigger is enabled.
 */
/*@{*/
#define BP_FTM_EXTTRIG_INITTRIGEN (6U)     /*!< Bit position for FTM_EXTTRIG_INITTRIGEN. */
#define BM_FTM_EXTTRIG_INITTRIGEN (0x00000040U) /*!< Bit mask for FTM_EXTTRIG_INITTRIGEN. */
#define BS_FTM_EXTTRIG_INITTRIGEN (1U)     /*!< Bit field size in bits for FTM_EXTTRIG_INITTRIGEN. */

/*! @brief Read current value of the FTM_EXTTRIG_INITTRIGEN field. */
#define BR_FTM_EXTTRIG_INITTRIGEN(x) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_INITTRIGEN))

/*! @brief Format value for bitfield FTM_EXTTRIG_INITTRIGEN. */
#define BF_FTM_EXTTRIG_INITTRIGEN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_EXTTRIG_INITTRIGEN) & BM_FTM_EXTTRIG_INITTRIGEN)

/*! @brief Set the INITTRIGEN field to a new value. */
#define BW_FTM_EXTTRIG_INITTRIGEN(x, v) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_INITTRIGEN) = (v))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field TRIGF[7] (ROWZ)
 *
 * Set by hardware when a channel trigger is generated. Clear TRIGF by reading
 * EXTTRIG while TRIGF is set and then writing a 0 to TRIGF. Writing a 1 to TRIGF
 * has no effect. If another channel trigger is generated before the clearing
 * sequence is completed, the sequence is reset so TRIGF remains set after the clear
 * sequence is completed for the earlier TRIGF.
 *
 * Values:
 * - 0 - No channel trigger was generated.
 * - 1 - A channel trigger was generated.
 */
/*@{*/
#define BP_FTM_EXTTRIG_TRIGF (7U)          /*!< Bit position for FTM_EXTTRIG_TRIGF. */
#define BM_FTM_EXTTRIG_TRIGF (0x00000080U) /*!< Bit mask for FTM_EXTTRIG_TRIGF. */
#define BS_FTM_EXTTRIG_TRIGF (1U)          /*!< Bit field size in bits for FTM_EXTTRIG_TRIGF. */

/*! @brief Read current value of the FTM_EXTTRIG_TRIGF field. */
#define BR_FTM_EXTTRIG_TRIGF(x) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_TRIGF))

/*! @brief Format value for bitfield FTM_EXTTRIG_TRIGF. */
#define BF_FTM_EXTTRIG_TRIGF(v) ((uint32_t)((uint32_t)(v) << BP_FTM_EXTTRIG_TRIGF) & BM_FTM_EXTTRIG_TRIGF)

/*! @brief Set the TRIGF field to a new value. */
#define BW_FTM_EXTTRIG_TRIGF(x, v) (BITBAND_ACCESS32(HW_FTM_EXTTRIG_ADDR(x), BP_FTM_EXTTRIG_TRIGF) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_POL - Channels Polarity
 ******************************************************************************/

/*!
 * @brief HW_FTM_POL - Channels Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the output polarity of the FTM channels. The safe value
 * that is driven in a channel output when the fault control is enabled and a
 * fault condition is detected is the inactive state of the channel. That is, the
 * safe value of a channel is the value of its POL bit.
 */
typedef union _hw_ftm_pol
{
    uint32_t U;
    struct _hw_ftm_pol_bitfields
    {
        uint32_t POL0 : 1;             /*!< [0] Channel 0 Polarity */
        uint32_t POL1 : 1;             /*!< [1] Channel 1 Polarity */
        uint32_t POL2 : 1;             /*!< [2] Channel 2 Polarity */
        uint32_t POL3 : 1;             /*!< [3] Channel 3 Polarity */
        uint32_t POL4 : 1;             /*!< [4] Channel 4 Polarity */
        uint32_t POL5 : 1;             /*!< [5] Channel 5 Polarity */
        uint32_t POL6 : 1;             /*!< [6] Channel 6 Polarity */
        uint32_t POL7 : 1;             /*!< [7] Channel 7 Polarity */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_pol_t;

/*!
 * @name Constants and macros for entire FTM_POL register
 */
/*@{*/
#define HW_FTM_POL_ADDR(x)       ((uint32_t)(x) + 0x70U)

#define HW_FTM_POL(x)            (*(__IO hw_ftm_pol_t *) HW_FTM_POL_ADDR(x))
#define HW_FTM_POL_RD(x)         (HW_FTM_POL(x).U)
#define HW_FTM_POL_WR(x, v)      (HW_FTM_POL(x).U = (v))
#define HW_FTM_POL_SET(x, v)     (HW_FTM_POL_WR(x, HW_FTM_POL_RD(x) |  (v)))
#define HW_FTM_POL_CLR(x, v)     (HW_FTM_POL_WR(x, HW_FTM_POL_RD(x) & ~(v)))
#define HW_FTM_POL_TOG(x, v)     (HW_FTM_POL_WR(x, HW_FTM_POL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_POL bitfields
 */

/*!
 * @name Register FTM_POL, field POL0[0] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_FTM_POL_POL0      (0U)          /*!< Bit position for FTM_POL_POL0. */
#define BM_FTM_POL_POL0      (0x00000001U) /*!< Bit mask for FTM_POL_POL0. */
#define BS_FTM_POL_POL0      (1U)          /*!< Bit field size in bits for FTM_POL_POL0. */

/*! @brief Read current value of the FTM_POL_POL0 field. */
#define BR_FTM_POL_POL0(x)   (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL0))

/*! @brief Format value for bitfield FTM_POL_POL0. */
#define BF_FTM_POL_POL0(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_POL_POL0) & BM_FTM_POL_POL0)

/*! @brief Set the POL0 field to a new value. */
#define BW_FTM_POL_POL0(x, v) (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL0) = (v))
/*@}*/

/*!
 * @name Register FTM_POL, field POL1[1] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_FTM_POL_POL1      (1U)          /*!< Bit position for FTM_POL_POL1. */
#define BM_FTM_POL_POL1      (0x00000002U) /*!< Bit mask for FTM_POL_POL1. */
#define BS_FTM_POL_POL1      (1U)          /*!< Bit field size in bits for FTM_POL_POL1. */

/*! @brief Read current value of the FTM_POL_POL1 field. */
#define BR_FTM_POL_POL1(x)   (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL1))

/*! @brief Format value for bitfield FTM_POL_POL1. */
#define BF_FTM_POL_POL1(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_POL_POL1) & BM_FTM_POL_POL1)

/*! @brief Set the POL1 field to a new value. */
#define BW_FTM_POL_POL1(x, v) (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL1) = (v))
/*@}*/

/*!
 * @name Register FTM_POL, field POL2[2] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_FTM_POL_POL2      (2U)          /*!< Bit position for FTM_POL_POL2. */
#define BM_FTM_POL_POL2      (0x00000004U) /*!< Bit mask for FTM_POL_POL2. */
#define BS_FTM_POL_POL2      (1U)          /*!< Bit field size in bits for FTM_POL_POL2. */

/*! @brief Read current value of the FTM_POL_POL2 field. */
#define BR_FTM_POL_POL2(x)   (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL2))

/*! @brief Format value for bitfield FTM_POL_POL2. */
#define BF_FTM_POL_POL2(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_POL_POL2) & BM_FTM_POL_POL2)

/*! @brief Set the POL2 field to a new value. */
#define BW_FTM_POL_POL2(x, v) (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL2) = (v))
/*@}*/

/*!
 * @name Register FTM_POL, field POL3[3] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_FTM_POL_POL3      (3U)          /*!< Bit position for FTM_POL_POL3. */
#define BM_FTM_POL_POL3      (0x00000008U) /*!< Bit mask for FTM_POL_POL3. */
#define BS_FTM_POL_POL3      (1U)          /*!< Bit field size in bits for FTM_POL_POL3. */

/*! @brief Read current value of the FTM_POL_POL3 field. */
#define BR_FTM_POL_POL3(x)   (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL3))

/*! @brief Format value for bitfield FTM_POL_POL3. */
#define BF_FTM_POL_POL3(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_POL_POL3) & BM_FTM_POL_POL3)

/*! @brief Set the POL3 field to a new value. */
#define BW_FTM_POL_POL3(x, v) (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL3) = (v))
/*@}*/

/*!
 * @name Register FTM_POL, field POL4[4] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_FTM_POL_POL4      (4U)          /*!< Bit position for FTM_POL_POL4. */
#define BM_FTM_POL_POL4      (0x00000010U) /*!< Bit mask for FTM_POL_POL4. */
#define BS_FTM_POL_POL4      (1U)          /*!< Bit field size in bits for FTM_POL_POL4. */

/*! @brief Read current value of the FTM_POL_POL4 field. */
#define BR_FTM_POL_POL4(x)   (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL4))

/*! @brief Format value for bitfield FTM_POL_POL4. */
#define BF_FTM_POL_POL4(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_POL_POL4) & BM_FTM_POL_POL4)

/*! @brief Set the POL4 field to a new value. */
#define BW_FTM_POL_POL4(x, v) (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL4) = (v))
/*@}*/

/*!
 * @name Register FTM_POL, field POL5[5] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_FTM_POL_POL5      (5U)          /*!< Bit position for FTM_POL_POL5. */
#define BM_FTM_POL_POL5      (0x00000020U) /*!< Bit mask for FTM_POL_POL5. */
#define BS_FTM_POL_POL5      (1U)          /*!< Bit field size in bits for FTM_POL_POL5. */

/*! @brief Read current value of the FTM_POL_POL5 field. */
#define BR_FTM_POL_POL5(x)   (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL5))

/*! @brief Format value for bitfield FTM_POL_POL5. */
#define BF_FTM_POL_POL5(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_POL_POL5) & BM_FTM_POL_POL5)

/*! @brief Set the POL5 field to a new value. */
#define BW_FTM_POL_POL5(x, v) (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL5) = (v))
/*@}*/

/*!
 * @name Register FTM_POL, field POL6[6] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_FTM_POL_POL6      (6U)          /*!< Bit position for FTM_POL_POL6. */
#define BM_FTM_POL_POL6      (0x00000040U) /*!< Bit mask for FTM_POL_POL6. */
#define BS_FTM_POL_POL6      (1U)          /*!< Bit field size in bits for FTM_POL_POL6. */

/*! @brief Read current value of the FTM_POL_POL6 field. */
#define BR_FTM_POL_POL6(x)   (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL6))

/*! @brief Format value for bitfield FTM_POL_POL6. */
#define BF_FTM_POL_POL6(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_POL_POL6) & BM_FTM_POL_POL6)

/*! @brief Set the POL6 field to a new value. */
#define BW_FTM_POL_POL6(x, v) (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL6) = (v))
/*@}*/

/*!
 * @name Register FTM_POL, field POL7[7] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
#define BP_FTM_POL_POL7      (7U)          /*!< Bit position for FTM_POL_POL7. */
#define BM_FTM_POL_POL7      (0x00000080U) /*!< Bit mask for FTM_POL_POL7. */
#define BS_FTM_POL_POL7      (1U)          /*!< Bit field size in bits for FTM_POL_POL7. */

/*! @brief Read current value of the FTM_POL_POL7 field. */
#define BR_FTM_POL_POL7(x)   (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL7))

/*! @brief Format value for bitfield FTM_POL_POL7. */
#define BF_FTM_POL_POL7(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_POL_POL7) & BM_FTM_POL_POL7)

/*! @brief Set the POL7 field to a new value. */
#define BW_FTM_POL_POL7(x, v) (BITBAND_ACCESS32(HW_FTM_POL_ADDR(x), BP_FTM_POL_POL7) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_FMS - Fault Mode Status
 ******************************************************************************/

/*!
 * @brief HW_FTM_FMS - Fault Mode Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the fault detection flags, write protection enable
 * bit, and the logic OR of the enabled fault inputs.
 */
typedef union _hw_ftm_fms
{
    uint32_t U;
    struct _hw_ftm_fms_bitfields
    {
        uint32_t FAULTF0 : 1;          /*!< [0] Fault Detection Flag 0 */
        uint32_t FAULTF1 : 1;          /*!< [1] Fault Detection Flag 1 */
        uint32_t FAULTF2 : 1;          /*!< [2] Fault Detection Flag 2 */
        uint32_t FAULTF3 : 1;          /*!< [3] Fault Detection Flag 3 */
        uint32_t RESERVED0 : 1;        /*!< [4]  */
        uint32_t FAULTIN : 1;          /*!< [5] Fault Inputs */
        uint32_t WPEN : 1;             /*!< [6] Write Protection Enable */
        uint32_t FAULTF : 1;           /*!< [7] Fault Detection Flag */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_fms_t;

/*!
 * @name Constants and macros for entire FTM_FMS register
 */
/*@{*/
#define HW_FTM_FMS_ADDR(x)       ((uint32_t)(x) + 0x74U)

#define HW_FTM_FMS(x)            (*(__IO hw_ftm_fms_t *) HW_FTM_FMS_ADDR(x))
#define HW_FTM_FMS_RD(x)         (HW_FTM_FMS(x).U)
#define HW_FTM_FMS_WR(x, v)      (HW_FTM_FMS(x).U = (v))
#define HW_FTM_FMS_SET(x, v)     (HW_FTM_FMS_WR(x, HW_FTM_FMS_RD(x) |  (v)))
#define HW_FTM_FMS_CLR(x, v)     (HW_FTM_FMS_WR(x, HW_FTM_FMS_RD(x) & ~(v)))
#define HW_FTM_FMS_TOG(x, v)     (HW_FTM_FMS_WR(x, HW_FTM_FMS_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_FMS bitfields
 */

/*!
 * @name Register FTM_FMS, field FAULTF0[0] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF0
 * by reading the FMS register while FAULTF0 is set and then writing a 0 to
 * FAULTF0 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF0 has no effect. FAULTF0 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF0 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
#define BP_FTM_FMS_FAULTF0   (0U)          /*!< Bit position for FTM_FMS_FAULTF0. */
#define BM_FTM_FMS_FAULTF0   (0x00000001U) /*!< Bit mask for FTM_FMS_FAULTF0. */
#define BS_FTM_FMS_FAULTF0   (1U)          /*!< Bit field size in bits for FTM_FMS_FAULTF0. */

/*! @brief Read current value of the FTM_FMS_FAULTF0 field. */
#define BR_FTM_FMS_FAULTF0(x) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_FAULTF0))

/*! @brief Format value for bitfield FTM_FMS_FAULTF0. */
#define BF_FTM_FMS_FAULTF0(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FMS_FAULTF0) & BM_FTM_FMS_FAULTF0)

/*! @brief Set the FAULTF0 field to a new value. */
#define BW_FTM_FMS_FAULTF0(x, v) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_FAULTF0) = (v))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF1[1] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF1
 * by reading the FMS register while FAULTF1 is set and then writing a 0 to
 * FAULTF1 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF1 has no effect. FAULTF1 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF1 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
#define BP_FTM_FMS_FAULTF1   (1U)          /*!< Bit position for FTM_FMS_FAULTF1. */
#define BM_FTM_FMS_FAULTF1   (0x00000002U) /*!< Bit mask for FTM_FMS_FAULTF1. */
#define BS_FTM_FMS_FAULTF1   (1U)          /*!< Bit field size in bits for FTM_FMS_FAULTF1. */

/*! @brief Read current value of the FTM_FMS_FAULTF1 field. */
#define BR_FTM_FMS_FAULTF1(x) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_FAULTF1))

/*! @brief Format value for bitfield FTM_FMS_FAULTF1. */
#define BF_FTM_FMS_FAULTF1(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FMS_FAULTF1) & BM_FTM_FMS_FAULTF1)

/*! @brief Set the FAULTF1 field to a new value. */
#define BW_FTM_FMS_FAULTF1(x, v) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_FAULTF1) = (v))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF2[2] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF2
 * by reading the FMS register while FAULTF2 is set and then writing a 0 to
 * FAULTF2 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF2 has no effect. FAULTF2 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF2 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
#define BP_FTM_FMS_FAULTF2   (2U)          /*!< Bit position for FTM_FMS_FAULTF2. */
#define BM_FTM_FMS_FAULTF2   (0x00000004U) /*!< Bit mask for FTM_FMS_FAULTF2. */
#define BS_FTM_FMS_FAULTF2   (1U)          /*!< Bit field size in bits for FTM_FMS_FAULTF2. */

/*! @brief Read current value of the FTM_FMS_FAULTF2 field. */
#define BR_FTM_FMS_FAULTF2(x) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_FAULTF2))

/*! @brief Format value for bitfield FTM_FMS_FAULTF2. */
#define BF_FTM_FMS_FAULTF2(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FMS_FAULTF2) & BM_FTM_FMS_FAULTF2)

/*! @brief Set the FAULTF2 field to a new value. */
#define BW_FTM_FMS_FAULTF2(x, v) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_FAULTF2) = (v))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF3[3] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF3
 * by reading the FMS register while FAULTF3 is set and then writing a 0 to
 * FAULTF3 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF3 has no effect. FAULTF3 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF3 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0 - No fault condition was detected at the fault input.
 * - 1 - A fault condition was detected at the fault input.
 */
/*@{*/
#define BP_FTM_FMS_FAULTF3   (3U)          /*!< Bit position for FTM_FMS_FAULTF3. */
#define BM_FTM_FMS_FAULTF3   (0x00000008U) /*!< Bit mask for FTM_FMS_FAULTF3. */
#define BS_FTM_FMS_FAULTF3   (1U)          /*!< Bit field size in bits for FTM_FMS_FAULTF3. */

/*! @brief Read current value of the FTM_FMS_FAULTF3 field. */
#define BR_FTM_FMS_FAULTF3(x) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_FAULTF3))

/*! @brief Format value for bitfield FTM_FMS_FAULTF3. */
#define BF_FTM_FMS_FAULTF3(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FMS_FAULTF3) & BM_FTM_FMS_FAULTF3)

/*! @brief Set the FAULTF3 field to a new value. */
#define BW_FTM_FMS_FAULTF3(x, v) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_FAULTF3) = (v))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTIN[5] (RO)
 *
 * Represents the logic OR of the enabled fault inputs after their filter (if
 * their filter is enabled) when fault control is enabled.
 *
 * Values:
 * - 0 - The logic OR of the enabled fault inputs is 0.
 * - 1 - The logic OR of the enabled fault inputs is 1.
 */
/*@{*/
#define BP_FTM_FMS_FAULTIN   (5U)          /*!< Bit position for FTM_FMS_FAULTIN. */
#define BM_FTM_FMS_FAULTIN   (0x00000020U) /*!< Bit mask for FTM_FMS_FAULTIN. */
#define BS_FTM_FMS_FAULTIN   (1U)          /*!< Bit field size in bits for FTM_FMS_FAULTIN. */

/*! @brief Read current value of the FTM_FMS_FAULTIN field. */
#define BR_FTM_FMS_FAULTIN(x) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_FAULTIN))
/*@}*/

/*!
 * @name Register FTM_FMS, field WPEN[6] (RW)
 *
 * The WPEN bit is the negation of the WPDIS bit. WPEN is set when 1 is written
 * to it. WPEN is cleared when WPEN bit is read as a 1 and then 1 is written to
 * WPDIS. Writing 0 to WPEN has no effect.
 *
 * Values:
 * - 0 - Write protection is disabled. Write protected bits can be written.
 * - 1 - Write protection is enabled. Write protected bits cannot be written.
 */
/*@{*/
#define BP_FTM_FMS_WPEN      (6U)          /*!< Bit position for FTM_FMS_WPEN. */
#define BM_FTM_FMS_WPEN      (0x00000040U) /*!< Bit mask for FTM_FMS_WPEN. */
#define BS_FTM_FMS_WPEN      (1U)          /*!< Bit field size in bits for FTM_FMS_WPEN. */

/*! @brief Read current value of the FTM_FMS_WPEN field. */
#define BR_FTM_FMS_WPEN(x)   (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_WPEN))

/*! @brief Format value for bitfield FTM_FMS_WPEN. */
#define BF_FTM_FMS_WPEN(v)   ((uint32_t)((uint32_t)(v) << BP_FTM_FMS_WPEN) & BM_FTM_FMS_WPEN)

/*! @brief Set the WPEN field to a new value. */
#define BW_FTM_FMS_WPEN(x, v) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_WPEN) = (v))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF[7] (ROWZ)
 *
 * Represents the logic OR of the individual FAULTFj bits where j = 3, 2, 1, 0.
 * Clear FAULTF by reading the FMS register while FAULTF is set and then writing
 * a 0 to FAULTF while there is no existing fault condition at the enabled fault
 * inputs. Writing a 1 to FAULTF has no effect. If another fault condition is
 * detected in an enabled fault input before the clearing sequence is completed, the
 * sequence is reset so FAULTF remains set after the clearing sequence is
 * completed for the earlier fault condition. FAULTF is also cleared when FAULTFj bits
 * are cleared individually.
 *
 * Values:
 * - 0 - No fault condition was detected.
 * - 1 - A fault condition was detected.
 */
/*@{*/
#define BP_FTM_FMS_FAULTF    (7U)          /*!< Bit position for FTM_FMS_FAULTF. */
#define BM_FTM_FMS_FAULTF    (0x00000080U) /*!< Bit mask for FTM_FMS_FAULTF. */
#define BS_FTM_FMS_FAULTF    (1U)          /*!< Bit field size in bits for FTM_FMS_FAULTF. */

/*! @brief Read current value of the FTM_FMS_FAULTF field. */
#define BR_FTM_FMS_FAULTF(x) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_FAULTF))

/*! @brief Format value for bitfield FTM_FMS_FAULTF. */
#define BF_FTM_FMS_FAULTF(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FMS_FAULTF) & BM_FTM_FMS_FAULTF)

/*! @brief Set the FAULTF field to a new value. */
#define BW_FTM_FMS_FAULTF(x, v) (BITBAND_ACCESS32(HW_FTM_FMS_ADDR(x), BP_FTM_FMS_FAULTF) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_FILTER - Input Capture Filter Control
 ******************************************************************************/

/*!
 * @brief HW_FTM_FILTER - Input Capture Filter Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value for the inputs of channels. Channels
 * 4, 5, 6 and 7 do not have an input filter. Writing to the FILTER register has
 * immediate effect and must be done only when the channels 0, 1, 2, and 3 are not
 * in input modes. Failure to do this could result in a missing valid signal.
 */
typedef union _hw_ftm_filter
{
    uint32_t U;
    struct _hw_ftm_filter_bitfields
    {
        uint32_t CH0FVAL : 4;          /*!< [3:0] Channel 0 Input Filter */
        uint32_t CH1FVAL : 4;          /*!< [7:4] Channel 1 Input Filter */
        uint32_t CH2FVAL : 4;          /*!< [11:8] Channel 2 Input Filter */
        uint32_t CH3FVAL : 4;          /*!< [15:12] Channel 3 Input Filter */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_ftm_filter_t;

/*!
 * @name Constants and macros for entire FTM_FILTER register
 */
/*@{*/
#define HW_FTM_FILTER_ADDR(x)    ((uint32_t)(x) + 0x78U)

#define HW_FTM_FILTER(x)         (*(__IO hw_ftm_filter_t *) HW_FTM_FILTER_ADDR(x))
#define HW_FTM_FILTER_RD(x)      (HW_FTM_FILTER(x).U)
#define HW_FTM_FILTER_WR(x, v)   (HW_FTM_FILTER(x).U = (v))
#define HW_FTM_FILTER_SET(x, v)  (HW_FTM_FILTER_WR(x, HW_FTM_FILTER_RD(x) |  (v)))
#define HW_FTM_FILTER_CLR(x, v)  (HW_FTM_FILTER_WR(x, HW_FTM_FILTER_RD(x) & ~(v)))
#define HW_FTM_FILTER_TOG(x, v)  (HW_FTM_FILTER_WR(x, HW_FTM_FILTER_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_FILTER bitfields
 */

/*!
 * @name Register FTM_FILTER, field CH0FVAL[3:0] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
#define BP_FTM_FILTER_CH0FVAL (0U)         /*!< Bit position for FTM_FILTER_CH0FVAL. */
#define BM_FTM_FILTER_CH0FVAL (0x0000000FU) /*!< Bit mask for FTM_FILTER_CH0FVAL. */
#define BS_FTM_FILTER_CH0FVAL (4U)         /*!< Bit field size in bits for FTM_FILTER_CH0FVAL. */

/*! @brief Read current value of the FTM_FILTER_CH0FVAL field. */
#define BR_FTM_FILTER_CH0FVAL(x) (HW_FTM_FILTER(x).B.CH0FVAL)

/*! @brief Format value for bitfield FTM_FILTER_CH0FVAL. */
#define BF_FTM_FILTER_CH0FVAL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FILTER_CH0FVAL) & BM_FTM_FILTER_CH0FVAL)

/*! @brief Set the CH0FVAL field to a new value. */
#define BW_FTM_FILTER_CH0FVAL(x, v) (HW_FTM_FILTER_WR(x, (HW_FTM_FILTER_RD(x) & ~BM_FTM_FILTER_CH0FVAL) | BF_FTM_FILTER_CH0FVAL(v)))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH1FVAL[7:4] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
#define BP_FTM_FILTER_CH1FVAL (4U)         /*!< Bit position for FTM_FILTER_CH1FVAL. */
#define BM_FTM_FILTER_CH1FVAL (0x000000F0U) /*!< Bit mask for FTM_FILTER_CH1FVAL. */
#define BS_FTM_FILTER_CH1FVAL (4U)         /*!< Bit field size in bits for FTM_FILTER_CH1FVAL. */

/*! @brief Read current value of the FTM_FILTER_CH1FVAL field. */
#define BR_FTM_FILTER_CH1FVAL(x) (HW_FTM_FILTER(x).B.CH1FVAL)

/*! @brief Format value for bitfield FTM_FILTER_CH1FVAL. */
#define BF_FTM_FILTER_CH1FVAL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FILTER_CH1FVAL) & BM_FTM_FILTER_CH1FVAL)

/*! @brief Set the CH1FVAL field to a new value. */
#define BW_FTM_FILTER_CH1FVAL(x, v) (HW_FTM_FILTER_WR(x, (HW_FTM_FILTER_RD(x) & ~BM_FTM_FILTER_CH1FVAL) | BF_FTM_FILTER_CH1FVAL(v)))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH2FVAL[11:8] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
#define BP_FTM_FILTER_CH2FVAL (8U)         /*!< Bit position for FTM_FILTER_CH2FVAL. */
#define BM_FTM_FILTER_CH2FVAL (0x00000F00U) /*!< Bit mask for FTM_FILTER_CH2FVAL. */
#define BS_FTM_FILTER_CH2FVAL (4U)         /*!< Bit field size in bits for FTM_FILTER_CH2FVAL. */

/*! @brief Read current value of the FTM_FILTER_CH2FVAL field. */
#define BR_FTM_FILTER_CH2FVAL(x) (HW_FTM_FILTER(x).B.CH2FVAL)

/*! @brief Format value for bitfield FTM_FILTER_CH2FVAL. */
#define BF_FTM_FILTER_CH2FVAL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FILTER_CH2FVAL) & BM_FTM_FILTER_CH2FVAL)

/*! @brief Set the CH2FVAL field to a new value. */
#define BW_FTM_FILTER_CH2FVAL(x, v) (HW_FTM_FILTER_WR(x, (HW_FTM_FILTER_RD(x) & ~BM_FTM_FILTER_CH2FVAL) | BF_FTM_FILTER_CH2FVAL(v)))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH3FVAL[15:12] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
#define BP_FTM_FILTER_CH3FVAL (12U)        /*!< Bit position for FTM_FILTER_CH3FVAL. */
#define BM_FTM_FILTER_CH3FVAL (0x0000F000U) /*!< Bit mask for FTM_FILTER_CH3FVAL. */
#define BS_FTM_FILTER_CH3FVAL (4U)         /*!< Bit field size in bits for FTM_FILTER_CH3FVAL. */

/*! @brief Read current value of the FTM_FILTER_CH3FVAL field. */
#define BR_FTM_FILTER_CH3FVAL(x) (HW_FTM_FILTER(x).B.CH3FVAL)

/*! @brief Format value for bitfield FTM_FILTER_CH3FVAL. */
#define BF_FTM_FILTER_CH3FVAL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FILTER_CH3FVAL) & BM_FTM_FILTER_CH3FVAL)

/*! @brief Set the CH3FVAL field to a new value. */
#define BW_FTM_FILTER_CH3FVAL(x, v) (HW_FTM_FILTER_WR(x, (HW_FTM_FILTER_RD(x) & ~BM_FTM_FILTER_CH3FVAL) | BF_FTM_FILTER_CH3FVAL(v)))
/*@}*/

/*******************************************************************************
 * HW_FTM_FLTCTRL - Fault Control
 ******************************************************************************/

/*!
 * @brief HW_FTM_FLTCTRL - Fault Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value for the fault inputs, enables the
 * fault inputs and the fault inputs filter.
 */
typedef union _hw_ftm_fltctrl
{
    uint32_t U;
    struct _hw_ftm_fltctrl_bitfields
    {
        uint32_t FAULT0EN : 1;         /*!< [0] Fault Input 0 Enable */
        uint32_t FAULT1EN : 1;         /*!< [1] Fault Input 1 Enable */
        uint32_t FAULT2EN : 1;         /*!< [2] Fault Input 2 Enable */
        uint32_t FAULT3EN : 1;         /*!< [3] Fault Input 3 Enable */
        uint32_t FFLTR0EN : 1;         /*!< [4] Fault Input 0 Filter Enable */
        uint32_t FFLTR1EN : 1;         /*!< [5] Fault Input 1 Filter Enable */
        uint32_t FFLTR2EN : 1;         /*!< [6] Fault Input 2 Filter Enable */
        uint32_t FFLTR3EN : 1;         /*!< [7] Fault Input 3 Filter Enable */
        uint32_t FFVAL : 4;            /*!< [11:8] Fault Input Filter */
        uint32_t RESERVED0 : 20;       /*!< [31:12]  */
    } B;
} hw_ftm_fltctrl_t;

/*!
 * @name Constants and macros for entire FTM_FLTCTRL register
 */
/*@{*/
#define HW_FTM_FLTCTRL_ADDR(x)   ((uint32_t)(x) + 0x7CU)

#define HW_FTM_FLTCTRL(x)        (*(__IO hw_ftm_fltctrl_t *) HW_FTM_FLTCTRL_ADDR(x))
#define HW_FTM_FLTCTRL_RD(x)     (HW_FTM_FLTCTRL(x).U)
#define HW_FTM_FLTCTRL_WR(x, v)  (HW_FTM_FLTCTRL(x).U = (v))
#define HW_FTM_FLTCTRL_SET(x, v) (HW_FTM_FLTCTRL_WR(x, HW_FTM_FLTCTRL_RD(x) |  (v)))
#define HW_FTM_FLTCTRL_CLR(x, v) (HW_FTM_FLTCTRL_WR(x, HW_FTM_FLTCTRL_RD(x) & ~(v)))
#define HW_FTM_FLTCTRL_TOG(x, v) (HW_FTM_FLTCTRL_WR(x, HW_FTM_FLTCTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_FLTCTRL bitfields
 */

/*!
 * @name Register FTM_FLTCTRL, field FAULT0EN[0] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
#define BP_FTM_FLTCTRL_FAULT0EN (0U)       /*!< Bit position for FTM_FLTCTRL_FAULT0EN. */
#define BM_FTM_FLTCTRL_FAULT0EN (0x00000001U) /*!< Bit mask for FTM_FLTCTRL_FAULT0EN. */
#define BS_FTM_FLTCTRL_FAULT0EN (1U)       /*!< Bit field size in bits for FTM_FLTCTRL_FAULT0EN. */

/*! @brief Read current value of the FTM_FLTCTRL_FAULT0EN field. */
#define BR_FTM_FLTCTRL_FAULT0EN(x) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FAULT0EN))

/*! @brief Format value for bitfield FTM_FLTCTRL_FAULT0EN. */
#define BF_FTM_FLTCTRL_FAULT0EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTCTRL_FAULT0EN) & BM_FTM_FLTCTRL_FAULT0EN)

/*! @brief Set the FAULT0EN field to a new value. */
#define BW_FTM_FLTCTRL_FAULT0EN(x, v) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FAULT0EN) = (v))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT1EN[1] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
#define BP_FTM_FLTCTRL_FAULT1EN (1U)       /*!< Bit position for FTM_FLTCTRL_FAULT1EN. */
#define BM_FTM_FLTCTRL_FAULT1EN (0x00000002U) /*!< Bit mask for FTM_FLTCTRL_FAULT1EN. */
#define BS_FTM_FLTCTRL_FAULT1EN (1U)       /*!< Bit field size in bits for FTM_FLTCTRL_FAULT1EN. */

/*! @brief Read current value of the FTM_FLTCTRL_FAULT1EN field. */
#define BR_FTM_FLTCTRL_FAULT1EN(x) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FAULT1EN))

/*! @brief Format value for bitfield FTM_FLTCTRL_FAULT1EN. */
#define BF_FTM_FLTCTRL_FAULT1EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTCTRL_FAULT1EN) & BM_FTM_FLTCTRL_FAULT1EN)

/*! @brief Set the FAULT1EN field to a new value. */
#define BW_FTM_FLTCTRL_FAULT1EN(x, v) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FAULT1EN) = (v))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT2EN[2] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
#define BP_FTM_FLTCTRL_FAULT2EN (2U)       /*!< Bit position for FTM_FLTCTRL_FAULT2EN. */
#define BM_FTM_FLTCTRL_FAULT2EN (0x00000004U) /*!< Bit mask for FTM_FLTCTRL_FAULT2EN. */
#define BS_FTM_FLTCTRL_FAULT2EN (1U)       /*!< Bit field size in bits for FTM_FLTCTRL_FAULT2EN. */

/*! @brief Read current value of the FTM_FLTCTRL_FAULT2EN field. */
#define BR_FTM_FLTCTRL_FAULT2EN(x) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FAULT2EN))

/*! @brief Format value for bitfield FTM_FLTCTRL_FAULT2EN. */
#define BF_FTM_FLTCTRL_FAULT2EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTCTRL_FAULT2EN) & BM_FTM_FLTCTRL_FAULT2EN)

/*! @brief Set the FAULT2EN field to a new value. */
#define BW_FTM_FLTCTRL_FAULT2EN(x, v) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FAULT2EN) = (v))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT3EN[3] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input is disabled.
 * - 1 - Fault input is enabled.
 */
/*@{*/
#define BP_FTM_FLTCTRL_FAULT3EN (3U)       /*!< Bit position for FTM_FLTCTRL_FAULT3EN. */
#define BM_FTM_FLTCTRL_FAULT3EN (0x00000008U) /*!< Bit mask for FTM_FLTCTRL_FAULT3EN. */
#define BS_FTM_FLTCTRL_FAULT3EN (1U)       /*!< Bit field size in bits for FTM_FLTCTRL_FAULT3EN. */

/*! @brief Read current value of the FTM_FLTCTRL_FAULT3EN field. */
#define BR_FTM_FLTCTRL_FAULT3EN(x) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FAULT3EN))

/*! @brief Format value for bitfield FTM_FLTCTRL_FAULT3EN. */
#define BF_FTM_FLTCTRL_FAULT3EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTCTRL_FAULT3EN) & BM_FTM_FLTCTRL_FAULT3EN)

/*! @brief Set the FAULT3EN field to a new value. */
#define BW_FTM_FLTCTRL_FAULT3EN(x, v) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FAULT3EN) = (v))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR0EN[4] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
#define BP_FTM_FLTCTRL_FFLTR0EN (4U)       /*!< Bit position for FTM_FLTCTRL_FFLTR0EN. */
#define BM_FTM_FLTCTRL_FFLTR0EN (0x00000010U) /*!< Bit mask for FTM_FLTCTRL_FFLTR0EN. */
#define BS_FTM_FLTCTRL_FFLTR0EN (1U)       /*!< Bit field size in bits for FTM_FLTCTRL_FFLTR0EN. */

/*! @brief Read current value of the FTM_FLTCTRL_FFLTR0EN field. */
#define BR_FTM_FLTCTRL_FFLTR0EN(x) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FFLTR0EN))

/*! @brief Format value for bitfield FTM_FLTCTRL_FFLTR0EN. */
#define BF_FTM_FLTCTRL_FFLTR0EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTCTRL_FFLTR0EN) & BM_FTM_FLTCTRL_FFLTR0EN)

/*! @brief Set the FFLTR0EN field to a new value. */
#define BW_FTM_FLTCTRL_FFLTR0EN(x, v) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FFLTR0EN) = (v))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR1EN[5] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
#define BP_FTM_FLTCTRL_FFLTR1EN (5U)       /*!< Bit position for FTM_FLTCTRL_FFLTR1EN. */
#define BM_FTM_FLTCTRL_FFLTR1EN (0x00000020U) /*!< Bit mask for FTM_FLTCTRL_FFLTR1EN. */
#define BS_FTM_FLTCTRL_FFLTR1EN (1U)       /*!< Bit field size in bits for FTM_FLTCTRL_FFLTR1EN. */

/*! @brief Read current value of the FTM_FLTCTRL_FFLTR1EN field. */
#define BR_FTM_FLTCTRL_FFLTR1EN(x) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FFLTR1EN))

/*! @brief Format value for bitfield FTM_FLTCTRL_FFLTR1EN. */
#define BF_FTM_FLTCTRL_FFLTR1EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTCTRL_FFLTR1EN) & BM_FTM_FLTCTRL_FFLTR1EN)

/*! @brief Set the FFLTR1EN field to a new value. */
#define BW_FTM_FLTCTRL_FFLTR1EN(x, v) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FFLTR1EN) = (v))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR2EN[6] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
#define BP_FTM_FLTCTRL_FFLTR2EN (6U)       /*!< Bit position for FTM_FLTCTRL_FFLTR2EN. */
#define BM_FTM_FLTCTRL_FFLTR2EN (0x00000040U) /*!< Bit mask for FTM_FLTCTRL_FFLTR2EN. */
#define BS_FTM_FLTCTRL_FFLTR2EN (1U)       /*!< Bit field size in bits for FTM_FLTCTRL_FFLTR2EN. */

/*! @brief Read current value of the FTM_FLTCTRL_FFLTR2EN field. */
#define BR_FTM_FLTCTRL_FFLTR2EN(x) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FFLTR2EN))

/*! @brief Format value for bitfield FTM_FLTCTRL_FFLTR2EN. */
#define BF_FTM_FLTCTRL_FFLTR2EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTCTRL_FFLTR2EN) & BM_FTM_FLTCTRL_FFLTR2EN)

/*! @brief Set the FFLTR2EN field to a new value. */
#define BW_FTM_FLTCTRL_FFLTR2EN(x, v) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FFLTR2EN) = (v))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR3EN[7] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Fault input filter is disabled.
 * - 1 - Fault input filter is enabled.
 */
/*@{*/
#define BP_FTM_FLTCTRL_FFLTR3EN (7U)       /*!< Bit position for FTM_FLTCTRL_FFLTR3EN. */
#define BM_FTM_FLTCTRL_FFLTR3EN (0x00000080U) /*!< Bit mask for FTM_FLTCTRL_FFLTR3EN. */
#define BS_FTM_FLTCTRL_FFLTR3EN (1U)       /*!< Bit field size in bits for FTM_FLTCTRL_FFLTR3EN. */

/*! @brief Read current value of the FTM_FLTCTRL_FFLTR3EN field. */
#define BR_FTM_FLTCTRL_FFLTR3EN(x) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FFLTR3EN))

/*! @brief Format value for bitfield FTM_FLTCTRL_FFLTR3EN. */
#define BF_FTM_FLTCTRL_FFLTR3EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTCTRL_FFLTR3EN) & BM_FTM_FLTCTRL_FFLTR3EN)

/*! @brief Set the FFLTR3EN field to a new value. */
#define BW_FTM_FLTCTRL_FFLTR3EN(x, v) (BITBAND_ACCESS32(HW_FTM_FLTCTRL_ADDR(x), BP_FTM_FLTCTRL_FFLTR3EN) = (v))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFVAL[11:8] (RW)
 *
 * Selects the filter value for the fault inputs. The fault filter is disabled
 * when the value is zero. Writing to this field has immediate effect and must be
 * done only when the fault control or all fault inputs are disabled. Failure to
 * do this could result in a missing fault detection.
 */
/*@{*/
#define BP_FTM_FLTCTRL_FFVAL (8U)          /*!< Bit position for FTM_FLTCTRL_FFVAL. */
#define BM_FTM_FLTCTRL_FFVAL (0x00000F00U) /*!< Bit mask for FTM_FLTCTRL_FFVAL. */
#define BS_FTM_FLTCTRL_FFVAL (4U)          /*!< Bit field size in bits for FTM_FLTCTRL_FFVAL. */

/*! @brief Read current value of the FTM_FLTCTRL_FFVAL field. */
#define BR_FTM_FLTCTRL_FFVAL(x) (HW_FTM_FLTCTRL(x).B.FFVAL)

/*! @brief Format value for bitfield FTM_FLTCTRL_FFVAL. */
#define BF_FTM_FLTCTRL_FFVAL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTCTRL_FFVAL) & BM_FTM_FLTCTRL_FFVAL)

/*! @brief Set the FFVAL field to a new value. */
#define BW_FTM_FLTCTRL_FFVAL(x, v) (HW_FTM_FLTCTRL_WR(x, (HW_FTM_FLTCTRL_RD(x) & ~BM_FTM_FLTCTRL_FFVAL) | BF_FTM_FLTCTRL_FFVAL(v)))
/*@}*/

/*******************************************************************************
 * HW_FTM_QDCTRL - Quadrature Decoder Control And Status
 ******************************************************************************/

/*!
 * @brief HW_FTM_QDCTRL - Quadrature Decoder Control And Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has the control and status bits for the Quadrature Decoder mode.
 */
typedef union _hw_ftm_qdctrl
{
    uint32_t U;
    struct _hw_ftm_qdctrl_bitfields
    {
        uint32_t QUADEN : 1;           /*!< [0] Quadrature Decoder Mode Enable */
        uint32_t TOFDIR : 1;           /*!< [1] Timer Overflow Direction In Quadrature
                                        * Decoder Mode */
        uint32_t QUADIR : 1;           /*!< [2] FTM Counter Direction In Quadrature
                                        * Decoder Mode */
        uint32_t QUADMODE : 1;         /*!< [3] Quadrature Decoder Mode */
        uint32_t PHBPOL : 1;           /*!< [4] Phase B Input Polarity */
        uint32_t PHAPOL : 1;           /*!< [5] Phase A Input Polarity */
        uint32_t PHBFLTREN : 1;        /*!< [6] Phase B Input Filter Enable */
        uint32_t PHAFLTREN : 1;        /*!< [7] Phase A Input Filter Enable */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_ftm_qdctrl_t;

/*!
 * @name Constants and macros for entire FTM_QDCTRL register
 */
/*@{*/
#define HW_FTM_QDCTRL_ADDR(x)    ((uint32_t)(x) + 0x80U)

#define HW_FTM_QDCTRL(x)         (*(__IO hw_ftm_qdctrl_t *) HW_FTM_QDCTRL_ADDR(x))
#define HW_FTM_QDCTRL_RD(x)      (HW_FTM_QDCTRL(x).U)
#define HW_FTM_QDCTRL_WR(x, v)   (HW_FTM_QDCTRL(x).U = (v))
#define HW_FTM_QDCTRL_SET(x, v)  (HW_FTM_QDCTRL_WR(x, HW_FTM_QDCTRL_RD(x) |  (v)))
#define HW_FTM_QDCTRL_CLR(x, v)  (HW_FTM_QDCTRL_WR(x, HW_FTM_QDCTRL_RD(x) & ~(v)))
#define HW_FTM_QDCTRL_TOG(x, v)  (HW_FTM_QDCTRL_WR(x, HW_FTM_QDCTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_QDCTRL bitfields
 */

/*!
 * @name Register FTM_QDCTRL, field QUADEN[0] (RW)
 *
 * Enables the Quadrature Decoder mode. In this mode, the phase A and B input
 * signals control the FTM counter direction. The Quadrature Decoder mode has
 * precedence over the other modes. See #ModeSel1Table. This field is write protected.
 * It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - Quadrature Decoder mode is disabled.
 * - 1 - Quadrature Decoder mode is enabled.
 */
/*@{*/
#define BP_FTM_QDCTRL_QUADEN (0U)          /*!< Bit position for FTM_QDCTRL_QUADEN. */
#define BM_FTM_QDCTRL_QUADEN (0x00000001U) /*!< Bit mask for FTM_QDCTRL_QUADEN. */
#define BS_FTM_QDCTRL_QUADEN (1U)          /*!< Bit field size in bits for FTM_QDCTRL_QUADEN. */

/*! @brief Read current value of the FTM_QDCTRL_QUADEN field. */
#define BR_FTM_QDCTRL_QUADEN(x) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_QUADEN))

/*! @brief Format value for bitfield FTM_QDCTRL_QUADEN. */
#define BF_FTM_QDCTRL_QUADEN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_QDCTRL_QUADEN) & BM_FTM_QDCTRL_QUADEN)

/*! @brief Set the QUADEN field to a new value. */
#define BW_FTM_QDCTRL_QUADEN(x, v) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_QUADEN) = (v))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field TOFDIR[1] (RO)
 *
 * Indicates if the TOF bit was set on the top or the bottom of counting.
 *
 * Values:
 * - 0 - TOF bit was set on the bottom of counting. There was an FTM counter
 *     decrement and FTM counter changes from its minimum value (CNTIN register) to
 *     its maximum value (MOD register).
 * - 1 - TOF bit was set on the top of counting. There was an FTM counter
 *     increment and FTM counter changes from its maximum value (MOD register) to its
 *     minimum value (CNTIN register).
 */
/*@{*/
#define BP_FTM_QDCTRL_TOFDIR (1U)          /*!< Bit position for FTM_QDCTRL_TOFDIR. */
#define BM_FTM_QDCTRL_TOFDIR (0x00000002U) /*!< Bit mask for FTM_QDCTRL_TOFDIR. */
#define BS_FTM_QDCTRL_TOFDIR (1U)          /*!< Bit field size in bits for FTM_QDCTRL_TOFDIR. */

/*! @brief Read current value of the FTM_QDCTRL_TOFDIR field. */
#define BR_FTM_QDCTRL_TOFDIR(x) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_TOFDIR))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field QUADIR[2] (RO)
 *
 * Indicates the counting direction.
 *
 * Values:
 * - 0 - Counting direction is decreasing (FTM counter decrement).
 * - 1 - Counting direction is increasing (FTM counter increment).
 */
/*@{*/
#define BP_FTM_QDCTRL_QUADIR (2U)          /*!< Bit position for FTM_QDCTRL_QUADIR. */
#define BM_FTM_QDCTRL_QUADIR (0x00000004U) /*!< Bit mask for FTM_QDCTRL_QUADIR. */
#define BS_FTM_QDCTRL_QUADIR (1U)          /*!< Bit field size in bits for FTM_QDCTRL_QUADIR. */

/*! @brief Read current value of the FTM_QDCTRL_QUADIR field. */
#define BR_FTM_QDCTRL_QUADIR(x) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_QUADIR))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field QUADMODE[3] (RW)
 *
 * Selects the encoding mode used in the Quadrature Decoder mode.
 *
 * Values:
 * - 0 - Phase A and phase B encoding mode.
 * - 1 - Count and direction encoding mode.
 */
/*@{*/
#define BP_FTM_QDCTRL_QUADMODE (3U)        /*!< Bit position for FTM_QDCTRL_QUADMODE. */
#define BM_FTM_QDCTRL_QUADMODE (0x00000008U) /*!< Bit mask for FTM_QDCTRL_QUADMODE. */
#define BS_FTM_QDCTRL_QUADMODE (1U)        /*!< Bit field size in bits for FTM_QDCTRL_QUADMODE. */

/*! @brief Read current value of the FTM_QDCTRL_QUADMODE field. */
#define BR_FTM_QDCTRL_QUADMODE(x) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_QUADMODE))

/*! @brief Format value for bitfield FTM_QDCTRL_QUADMODE. */
#define BF_FTM_QDCTRL_QUADMODE(v) ((uint32_t)((uint32_t)(v) << BP_FTM_QDCTRL_QUADMODE) & BM_FTM_QDCTRL_QUADMODE)

/*! @brief Set the QUADMODE field to a new value. */
#define BW_FTM_QDCTRL_QUADMODE(x, v) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_QUADMODE) = (v))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHBPOL[4] (RW)
 *
 * Selects the polarity for the quadrature decoder phase B input.
 *
 * Values:
 * - 0 - Normal polarity. Phase B input signal is not inverted before
 *     identifying the rising and falling edges of this signal.
 * - 1 - Inverted polarity. Phase B input signal is inverted before identifying
 *     the rising and falling edges of this signal.
 */
/*@{*/
#define BP_FTM_QDCTRL_PHBPOL (4U)          /*!< Bit position for FTM_QDCTRL_PHBPOL. */
#define BM_FTM_QDCTRL_PHBPOL (0x00000010U) /*!< Bit mask for FTM_QDCTRL_PHBPOL. */
#define BS_FTM_QDCTRL_PHBPOL (1U)          /*!< Bit field size in bits for FTM_QDCTRL_PHBPOL. */

/*! @brief Read current value of the FTM_QDCTRL_PHBPOL field. */
#define BR_FTM_QDCTRL_PHBPOL(x) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_PHBPOL))

/*! @brief Format value for bitfield FTM_QDCTRL_PHBPOL. */
#define BF_FTM_QDCTRL_PHBPOL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_QDCTRL_PHBPOL) & BM_FTM_QDCTRL_PHBPOL)

/*! @brief Set the PHBPOL field to a new value. */
#define BW_FTM_QDCTRL_PHBPOL(x, v) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_PHBPOL) = (v))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHAPOL[5] (RW)
 *
 * Selects the polarity for the quadrature decoder phase A input.
 *
 * Values:
 * - 0 - Normal polarity. Phase A input signal is not inverted before
 *     identifying the rising and falling edges of this signal.
 * - 1 - Inverted polarity. Phase A input signal is inverted before identifying
 *     the rising and falling edges of this signal.
 */
/*@{*/
#define BP_FTM_QDCTRL_PHAPOL (5U)          /*!< Bit position for FTM_QDCTRL_PHAPOL. */
#define BM_FTM_QDCTRL_PHAPOL (0x00000020U) /*!< Bit mask for FTM_QDCTRL_PHAPOL. */
#define BS_FTM_QDCTRL_PHAPOL (1U)          /*!< Bit field size in bits for FTM_QDCTRL_PHAPOL. */

/*! @brief Read current value of the FTM_QDCTRL_PHAPOL field. */
#define BR_FTM_QDCTRL_PHAPOL(x) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_PHAPOL))

/*! @brief Format value for bitfield FTM_QDCTRL_PHAPOL. */
#define BF_FTM_QDCTRL_PHAPOL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_QDCTRL_PHAPOL) & BM_FTM_QDCTRL_PHAPOL)

/*! @brief Set the PHAPOL field to a new value. */
#define BW_FTM_QDCTRL_PHAPOL(x, v) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_PHAPOL) = (v))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHBFLTREN[6] (RW)
 *
 * Enables the filter for the quadrature decoder phase B input. The filter value
 * for the phase B input is defined by the CH1FVAL field of FILTER. The phase B
 * filter is also disabled when CH1FVAL is zero.
 *
 * Values:
 * - 0 - Phase B input filter is disabled.
 * - 1 - Phase B input filter is enabled.
 */
/*@{*/
#define BP_FTM_QDCTRL_PHBFLTREN (6U)       /*!< Bit position for FTM_QDCTRL_PHBFLTREN. */
#define BM_FTM_QDCTRL_PHBFLTREN (0x00000040U) /*!< Bit mask for FTM_QDCTRL_PHBFLTREN. */
#define BS_FTM_QDCTRL_PHBFLTREN (1U)       /*!< Bit field size in bits for FTM_QDCTRL_PHBFLTREN. */

/*! @brief Read current value of the FTM_QDCTRL_PHBFLTREN field. */
#define BR_FTM_QDCTRL_PHBFLTREN(x) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_PHBFLTREN))

/*! @brief Format value for bitfield FTM_QDCTRL_PHBFLTREN. */
#define BF_FTM_QDCTRL_PHBFLTREN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_QDCTRL_PHBFLTREN) & BM_FTM_QDCTRL_PHBFLTREN)

/*! @brief Set the PHBFLTREN field to a new value. */
#define BW_FTM_QDCTRL_PHBFLTREN(x, v) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_PHBFLTREN) = (v))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHAFLTREN[7] (RW)
 *
 * Enables the filter for the quadrature decoder phase A input. The filter value
 * for the phase A input is defined by the CH0FVAL field of FILTER. The phase A
 * filter is also disabled when CH0FVAL is zero.
 *
 * Values:
 * - 0 - Phase A input filter is disabled.
 * - 1 - Phase A input filter is enabled.
 */
/*@{*/
#define BP_FTM_QDCTRL_PHAFLTREN (7U)       /*!< Bit position for FTM_QDCTRL_PHAFLTREN. */
#define BM_FTM_QDCTRL_PHAFLTREN (0x00000080U) /*!< Bit mask for FTM_QDCTRL_PHAFLTREN. */
#define BS_FTM_QDCTRL_PHAFLTREN (1U)       /*!< Bit field size in bits for FTM_QDCTRL_PHAFLTREN. */

/*! @brief Read current value of the FTM_QDCTRL_PHAFLTREN field. */
#define BR_FTM_QDCTRL_PHAFLTREN(x) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_PHAFLTREN))

/*! @brief Format value for bitfield FTM_QDCTRL_PHAFLTREN. */
#define BF_FTM_QDCTRL_PHAFLTREN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_QDCTRL_PHAFLTREN) & BM_FTM_QDCTRL_PHAFLTREN)

/*! @brief Set the PHAFLTREN field to a new value. */
#define BW_FTM_QDCTRL_PHAFLTREN(x, v) (BITBAND_ACCESS32(HW_FTM_QDCTRL_ADDR(x), BP_FTM_QDCTRL_PHAFLTREN) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_CONF - Configuration
 ******************************************************************************/

/*!
 * @brief HW_FTM_CONF - Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the number of times that the FTM counter overflow
 * should occur before the TOF bit to be set, the FTM behavior in BDM modes, the use
 * of an external global time base, and the global time base signal generation.
 */
typedef union _hw_ftm_conf
{
    uint32_t U;
    struct _hw_ftm_conf_bitfields
    {
        uint32_t NUMTOF : 5;           /*!< [4:0] TOF Frequency */
        uint32_t RESERVED0 : 1;        /*!< [5]  */
        uint32_t BDMMODE : 2;          /*!< [7:6] BDM Mode */
        uint32_t RESERVED1 : 1;        /*!< [8]  */
        uint32_t GTBEEN : 1;           /*!< [9] Global Time Base Enable */
        uint32_t GTBEOUT : 1;          /*!< [10] Global Time Base Output */
        uint32_t RESERVED2 : 21;       /*!< [31:11]  */
    } B;
} hw_ftm_conf_t;

/*!
 * @name Constants and macros for entire FTM_CONF register
 */
/*@{*/
#define HW_FTM_CONF_ADDR(x)      ((uint32_t)(x) + 0x84U)

#define HW_FTM_CONF(x)           (*(__IO hw_ftm_conf_t *) HW_FTM_CONF_ADDR(x))
#define HW_FTM_CONF_RD(x)        (HW_FTM_CONF(x).U)
#define HW_FTM_CONF_WR(x, v)     (HW_FTM_CONF(x).U = (v))
#define HW_FTM_CONF_SET(x, v)    (HW_FTM_CONF_WR(x, HW_FTM_CONF_RD(x) |  (v)))
#define HW_FTM_CONF_CLR(x, v)    (HW_FTM_CONF_WR(x, HW_FTM_CONF_RD(x) & ~(v)))
#define HW_FTM_CONF_TOG(x, v)    (HW_FTM_CONF_WR(x, HW_FTM_CONF_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_CONF bitfields
 */

/*!
 * @name Register FTM_CONF, field NUMTOF[4:0] (RW)
 *
 * Selects the ratio between the number of counter overflows to the number of
 * times the TOF bit is set. NUMTOF = 0: The TOF bit is set for each counter
 * overflow. NUMTOF = 1: The TOF bit is set for the first counter overflow but not for
 * the next overflow. NUMTOF = 2: The TOF bit is set for the first counter
 * overflow but not for the next 2 overflows. NUMTOF = 3: The TOF bit is set for the
 * first counter overflow but not for the next 3 overflows. This pattern continues
 * up to a maximum of 31.
 */
/*@{*/
#define BP_FTM_CONF_NUMTOF   (0U)          /*!< Bit position for FTM_CONF_NUMTOF. */
#define BM_FTM_CONF_NUMTOF   (0x0000001FU) /*!< Bit mask for FTM_CONF_NUMTOF. */
#define BS_FTM_CONF_NUMTOF   (5U)          /*!< Bit field size in bits for FTM_CONF_NUMTOF. */

/*! @brief Read current value of the FTM_CONF_NUMTOF field. */
#define BR_FTM_CONF_NUMTOF(x) (HW_FTM_CONF(x).B.NUMTOF)

/*! @brief Format value for bitfield FTM_CONF_NUMTOF. */
#define BF_FTM_CONF_NUMTOF(v) ((uint32_t)((uint32_t)(v) << BP_FTM_CONF_NUMTOF) & BM_FTM_CONF_NUMTOF)

/*! @brief Set the NUMTOF field to a new value. */
#define BW_FTM_CONF_NUMTOF(x, v) (HW_FTM_CONF_WR(x, (HW_FTM_CONF_RD(x) & ~BM_FTM_CONF_NUMTOF) | BF_FTM_CONF_NUMTOF(v)))
/*@}*/

/*!
 * @name Register FTM_CONF, field BDMMODE[7:6] (RW)
 *
 * Selects the FTM behavior in BDM mode. See BDM mode.
 */
/*@{*/
#define BP_FTM_CONF_BDMMODE  (6U)          /*!< Bit position for FTM_CONF_BDMMODE. */
#define BM_FTM_CONF_BDMMODE  (0x000000C0U) /*!< Bit mask for FTM_CONF_BDMMODE. */
#define BS_FTM_CONF_BDMMODE  (2U)          /*!< Bit field size in bits for FTM_CONF_BDMMODE. */

/*! @brief Read current value of the FTM_CONF_BDMMODE field. */
#define BR_FTM_CONF_BDMMODE(x) (HW_FTM_CONF(x).B.BDMMODE)

/*! @brief Format value for bitfield FTM_CONF_BDMMODE. */
#define BF_FTM_CONF_BDMMODE(v) ((uint32_t)((uint32_t)(v) << BP_FTM_CONF_BDMMODE) & BM_FTM_CONF_BDMMODE)

/*! @brief Set the BDMMODE field to a new value. */
#define BW_FTM_CONF_BDMMODE(x, v) (HW_FTM_CONF_WR(x, (HW_FTM_CONF_RD(x) & ~BM_FTM_CONF_BDMMODE) | BF_FTM_CONF_BDMMODE(v)))
/*@}*/

/*!
 * @name Register FTM_CONF, field GTBEEN[9] (RW)
 *
 * Configures the FTM to use an external global time base signal that is
 * generated by another FTM.
 *
 * Values:
 * - 0 - Use of an external global time base is disabled.
 * - 1 - Use of an external global time base is enabled.
 */
/*@{*/
#define BP_FTM_CONF_GTBEEN   (9U)          /*!< Bit position for FTM_CONF_GTBEEN. */
#define BM_FTM_CONF_GTBEEN   (0x00000200U) /*!< Bit mask for FTM_CONF_GTBEEN. */
#define BS_FTM_CONF_GTBEEN   (1U)          /*!< Bit field size in bits for FTM_CONF_GTBEEN. */

/*! @brief Read current value of the FTM_CONF_GTBEEN field. */
#define BR_FTM_CONF_GTBEEN(x) (BITBAND_ACCESS32(HW_FTM_CONF_ADDR(x), BP_FTM_CONF_GTBEEN))

/*! @brief Format value for bitfield FTM_CONF_GTBEEN. */
#define BF_FTM_CONF_GTBEEN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_CONF_GTBEEN) & BM_FTM_CONF_GTBEEN)

/*! @brief Set the GTBEEN field to a new value. */
#define BW_FTM_CONF_GTBEEN(x, v) (BITBAND_ACCESS32(HW_FTM_CONF_ADDR(x), BP_FTM_CONF_GTBEEN) = (v))
/*@}*/

/*!
 * @name Register FTM_CONF, field GTBEOUT[10] (RW)
 *
 * Enables the global time base signal generation to other FTMs.
 *
 * Values:
 * - 0 - A global time base signal generation is disabled.
 * - 1 - A global time base signal generation is enabled.
 */
/*@{*/
#define BP_FTM_CONF_GTBEOUT  (10U)         /*!< Bit position for FTM_CONF_GTBEOUT. */
#define BM_FTM_CONF_GTBEOUT  (0x00000400U) /*!< Bit mask for FTM_CONF_GTBEOUT. */
#define BS_FTM_CONF_GTBEOUT  (1U)          /*!< Bit field size in bits for FTM_CONF_GTBEOUT. */

/*! @brief Read current value of the FTM_CONF_GTBEOUT field. */
#define BR_FTM_CONF_GTBEOUT(x) (BITBAND_ACCESS32(HW_FTM_CONF_ADDR(x), BP_FTM_CONF_GTBEOUT))

/*! @brief Format value for bitfield FTM_CONF_GTBEOUT. */
#define BF_FTM_CONF_GTBEOUT(v) ((uint32_t)((uint32_t)(v) << BP_FTM_CONF_GTBEOUT) & BM_FTM_CONF_GTBEOUT)

/*! @brief Set the GTBEOUT field to a new value. */
#define BW_FTM_CONF_GTBEOUT(x, v) (BITBAND_ACCESS32(HW_FTM_CONF_ADDR(x), BP_FTM_CONF_GTBEOUT) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_FLTPOL - FTM Fault Input Polarity
 ******************************************************************************/

/*!
 * @brief HW_FTM_FLTPOL - FTM Fault Input Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the fault inputs polarity.
 */
typedef union _hw_ftm_fltpol
{
    uint32_t U;
    struct _hw_ftm_fltpol_bitfields
    {
        uint32_t FLT0POL : 1;          /*!< [0] Fault Input 0 Polarity */
        uint32_t FLT1POL : 1;          /*!< [1] Fault Input 1 Polarity */
        uint32_t FLT2POL : 1;          /*!< [2] Fault Input 2 Polarity */
        uint32_t FLT3POL : 1;          /*!< [3] Fault Input 3 Polarity */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_ftm_fltpol_t;

/*!
 * @name Constants and macros for entire FTM_FLTPOL register
 */
/*@{*/
#define HW_FTM_FLTPOL_ADDR(x)    ((uint32_t)(x) + 0x88U)

#define HW_FTM_FLTPOL(x)         (*(__IO hw_ftm_fltpol_t *) HW_FTM_FLTPOL_ADDR(x))
#define HW_FTM_FLTPOL_RD(x)      (HW_FTM_FLTPOL(x).U)
#define HW_FTM_FLTPOL_WR(x, v)   (HW_FTM_FLTPOL(x).U = (v))
#define HW_FTM_FLTPOL_SET(x, v)  (HW_FTM_FLTPOL_WR(x, HW_FTM_FLTPOL_RD(x) |  (v)))
#define HW_FTM_FLTPOL_CLR(x, v)  (HW_FTM_FLTPOL_WR(x, HW_FTM_FLTPOL_RD(x) & ~(v)))
#define HW_FTM_FLTPOL_TOG(x, v)  (HW_FTM_FLTPOL_WR(x, HW_FTM_FLTPOL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_FLTPOL bitfields
 */

/*!
 * @name Register FTM_FLTPOL, field FLT0POL[0] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
#define BP_FTM_FLTPOL_FLT0POL (0U)         /*!< Bit position for FTM_FLTPOL_FLT0POL. */
#define BM_FTM_FLTPOL_FLT0POL (0x00000001U) /*!< Bit mask for FTM_FLTPOL_FLT0POL. */
#define BS_FTM_FLTPOL_FLT0POL (1U)         /*!< Bit field size in bits for FTM_FLTPOL_FLT0POL. */

/*! @brief Read current value of the FTM_FLTPOL_FLT0POL field. */
#define BR_FTM_FLTPOL_FLT0POL(x) (BITBAND_ACCESS32(HW_FTM_FLTPOL_ADDR(x), BP_FTM_FLTPOL_FLT0POL))

/*! @brief Format value for bitfield FTM_FLTPOL_FLT0POL. */
#define BF_FTM_FLTPOL_FLT0POL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTPOL_FLT0POL) & BM_FTM_FLTPOL_FLT0POL)

/*! @brief Set the FLT0POL field to a new value. */
#define BW_FTM_FLTPOL_FLT0POL(x, v) (BITBAND_ACCESS32(HW_FTM_FLTPOL_ADDR(x), BP_FTM_FLTPOL_FLT0POL) = (v))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT1POL[1] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
#define BP_FTM_FLTPOL_FLT1POL (1U)         /*!< Bit position for FTM_FLTPOL_FLT1POL. */
#define BM_FTM_FLTPOL_FLT1POL (0x00000002U) /*!< Bit mask for FTM_FLTPOL_FLT1POL. */
#define BS_FTM_FLTPOL_FLT1POL (1U)         /*!< Bit field size in bits for FTM_FLTPOL_FLT1POL. */

/*! @brief Read current value of the FTM_FLTPOL_FLT1POL field. */
#define BR_FTM_FLTPOL_FLT1POL(x) (BITBAND_ACCESS32(HW_FTM_FLTPOL_ADDR(x), BP_FTM_FLTPOL_FLT1POL))

/*! @brief Format value for bitfield FTM_FLTPOL_FLT1POL. */
#define BF_FTM_FLTPOL_FLT1POL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTPOL_FLT1POL) & BM_FTM_FLTPOL_FLT1POL)

/*! @brief Set the FLT1POL field to a new value. */
#define BW_FTM_FLTPOL_FLT1POL(x, v) (BITBAND_ACCESS32(HW_FTM_FLTPOL_ADDR(x), BP_FTM_FLTPOL_FLT1POL) = (v))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT2POL[2] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
#define BP_FTM_FLTPOL_FLT2POL (2U)         /*!< Bit position for FTM_FLTPOL_FLT2POL. */
#define BM_FTM_FLTPOL_FLT2POL (0x00000004U) /*!< Bit mask for FTM_FLTPOL_FLT2POL. */
#define BS_FTM_FLTPOL_FLT2POL (1U)         /*!< Bit field size in bits for FTM_FLTPOL_FLT2POL. */

/*! @brief Read current value of the FTM_FLTPOL_FLT2POL field. */
#define BR_FTM_FLTPOL_FLT2POL(x) (BITBAND_ACCESS32(HW_FTM_FLTPOL_ADDR(x), BP_FTM_FLTPOL_FLT2POL))

/*! @brief Format value for bitfield FTM_FLTPOL_FLT2POL. */
#define BF_FTM_FLTPOL_FLT2POL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTPOL_FLT2POL) & BM_FTM_FLTPOL_FLT2POL)

/*! @brief Set the FLT2POL field to a new value. */
#define BW_FTM_FLTPOL_FLT2POL(x, v) (BITBAND_ACCESS32(HW_FTM_FLTPOL_ADDR(x), BP_FTM_FLTPOL_FLT2POL) = (v))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT3POL[3] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
#define BP_FTM_FLTPOL_FLT3POL (3U)         /*!< Bit position for FTM_FLTPOL_FLT3POL. */
#define BM_FTM_FLTPOL_FLT3POL (0x00000008U) /*!< Bit mask for FTM_FLTPOL_FLT3POL. */
#define BS_FTM_FLTPOL_FLT3POL (1U)         /*!< Bit field size in bits for FTM_FLTPOL_FLT3POL. */

/*! @brief Read current value of the FTM_FLTPOL_FLT3POL field. */
#define BR_FTM_FLTPOL_FLT3POL(x) (BITBAND_ACCESS32(HW_FTM_FLTPOL_ADDR(x), BP_FTM_FLTPOL_FLT3POL))

/*! @brief Format value for bitfield FTM_FLTPOL_FLT3POL. */
#define BF_FTM_FLTPOL_FLT3POL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_FLTPOL_FLT3POL) & BM_FTM_FLTPOL_FLT3POL)

/*! @brief Set the FLT3POL field to a new value. */
#define BW_FTM_FLTPOL_FLT3POL(x, v) (BITBAND_ACCESS32(HW_FTM_FLTPOL_ADDR(x), BP_FTM_FLTPOL_FLT3POL) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_SYNCONF - Synchronization Configuration
 ******************************************************************************/

/*!
 * @brief HW_FTM_SYNCONF - Synchronization Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the PWM synchronization configuration, SWOCTRL, INVCTRL
 * and CNTIN registers synchronization, if FTM clears the TRIGj bit, where j =
 * 0, 1, 2, when the hardware trigger j is detected.
 */
typedef union _hw_ftm_synconf
{
    uint32_t U;
    struct _hw_ftm_synconf_bitfields
    {
        uint32_t HWTRIGMODE : 1;       /*!< [0] Hardware Trigger Mode */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t CNTINC : 1;           /*!< [2] CNTIN Register Synchronization */
        uint32_t RESERVED1 : 1;        /*!< [3]  */
        uint32_t INVC : 1;             /*!< [4] INVCTRL Register Synchronization */
        uint32_t SWOC : 1;             /*!< [5] SWOCTRL Register Synchronization */
        uint32_t RESERVED2 : 1;        /*!< [6]  */
        uint32_t SYNCMODE : 1;         /*!< [7] Synchronization Mode */
        uint32_t SWRSTCNT : 1;         /*!< [8]  */
        uint32_t SWWRBUF : 1;          /*!< [9]  */
        uint32_t SWOM : 1;             /*!< [10]  */
        uint32_t SWINVC : 1;           /*!< [11]  */
        uint32_t SWSOC : 1;            /*!< [12]  */
        uint32_t RESERVED3 : 3;        /*!< [15:13]  */
        uint32_t HWRSTCNT : 1;         /*!< [16]  */
        uint32_t HWWRBUF : 1;          /*!< [17]  */
        uint32_t HWOM : 1;             /*!< [18]  */
        uint32_t HWINVC : 1;           /*!< [19]  */
        uint32_t HWSOC : 1;            /*!< [20]  */
        uint32_t RESERVED4 : 11;       /*!< [31:21]  */
    } B;
} hw_ftm_synconf_t;

/*!
 * @name Constants and macros for entire FTM_SYNCONF register
 */
/*@{*/
#define HW_FTM_SYNCONF_ADDR(x)   ((uint32_t)(x) + 0x8CU)

#define HW_FTM_SYNCONF(x)        (*(__IO hw_ftm_synconf_t *) HW_FTM_SYNCONF_ADDR(x))
#define HW_FTM_SYNCONF_RD(x)     (HW_FTM_SYNCONF(x).U)
#define HW_FTM_SYNCONF_WR(x, v)  (HW_FTM_SYNCONF(x).U = (v))
#define HW_FTM_SYNCONF_SET(x, v) (HW_FTM_SYNCONF_WR(x, HW_FTM_SYNCONF_RD(x) |  (v)))
#define HW_FTM_SYNCONF_CLR(x, v) (HW_FTM_SYNCONF_WR(x, HW_FTM_SYNCONF_RD(x) & ~(v)))
#define HW_FTM_SYNCONF_TOG(x, v) (HW_FTM_SYNCONF_WR(x, HW_FTM_SYNCONF_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_SYNCONF bitfields
 */

/*!
 * @name Register FTM_SYNCONF, field HWTRIGMODE[0] (RW)
 *
 * Values:
 * - 0 - FTM clears the TRIGj bit when the hardware trigger j is detected, where
 *     j = 0, 1,2.
 * - 1 - FTM does not clear the TRIGj bit when the hardware trigger j is
 *     detected, where j = 0, 1,2.
 */
/*@{*/
#define BP_FTM_SYNCONF_HWTRIGMODE (0U)     /*!< Bit position for FTM_SYNCONF_HWTRIGMODE. */
#define BM_FTM_SYNCONF_HWTRIGMODE (0x00000001U) /*!< Bit mask for FTM_SYNCONF_HWTRIGMODE. */
#define BS_FTM_SYNCONF_HWTRIGMODE (1U)     /*!< Bit field size in bits for FTM_SYNCONF_HWTRIGMODE. */

/*! @brief Read current value of the FTM_SYNCONF_HWTRIGMODE field. */
#define BR_FTM_SYNCONF_HWTRIGMODE(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWTRIGMODE))

/*! @brief Format value for bitfield FTM_SYNCONF_HWTRIGMODE. */
#define BF_FTM_SYNCONF_HWTRIGMODE(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_HWTRIGMODE) & BM_FTM_SYNCONF_HWTRIGMODE)

/*! @brief Set the HWTRIGMODE field to a new value. */
#define BW_FTM_SYNCONF_HWTRIGMODE(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWTRIGMODE) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field CNTINC[2] (RW)
 *
 * Values:
 * - 0 - CNTIN register is updated with its buffer value at all rising edges of
 *     system clock.
 * - 1 - CNTIN register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_CNTINC (2U)         /*!< Bit position for FTM_SYNCONF_CNTINC. */
#define BM_FTM_SYNCONF_CNTINC (0x00000004U) /*!< Bit mask for FTM_SYNCONF_CNTINC. */
#define BS_FTM_SYNCONF_CNTINC (1U)         /*!< Bit field size in bits for FTM_SYNCONF_CNTINC. */

/*! @brief Read current value of the FTM_SYNCONF_CNTINC field. */
#define BR_FTM_SYNCONF_CNTINC(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_CNTINC))

/*! @brief Format value for bitfield FTM_SYNCONF_CNTINC. */
#define BF_FTM_SYNCONF_CNTINC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_CNTINC) & BM_FTM_SYNCONF_CNTINC)

/*! @brief Set the CNTINC field to a new value. */
#define BW_FTM_SYNCONF_CNTINC(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_CNTINC) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field INVC[4] (RW)
 *
 * Values:
 * - 0 - INVCTRL register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 1 - INVCTRL register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_INVC  (4U)          /*!< Bit position for FTM_SYNCONF_INVC. */
#define BM_FTM_SYNCONF_INVC  (0x00000010U) /*!< Bit mask for FTM_SYNCONF_INVC. */
#define BS_FTM_SYNCONF_INVC  (1U)          /*!< Bit field size in bits for FTM_SYNCONF_INVC. */

/*! @brief Read current value of the FTM_SYNCONF_INVC field. */
#define BR_FTM_SYNCONF_INVC(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_INVC))

/*! @brief Format value for bitfield FTM_SYNCONF_INVC. */
#define BF_FTM_SYNCONF_INVC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_INVC) & BM_FTM_SYNCONF_INVC)

/*! @brief Set the INVC field to a new value. */
#define BW_FTM_SYNCONF_INVC(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_INVC) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWOC[5] (RW)
 *
 * Values:
 * - 0 - SWOCTRL register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 1 - SWOCTRL register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_SWOC  (5U)          /*!< Bit position for FTM_SYNCONF_SWOC. */
#define BM_FTM_SYNCONF_SWOC  (0x00000020U) /*!< Bit mask for FTM_SYNCONF_SWOC. */
#define BS_FTM_SYNCONF_SWOC  (1U)          /*!< Bit field size in bits for FTM_SYNCONF_SWOC. */

/*! @brief Read current value of the FTM_SYNCONF_SWOC field. */
#define BR_FTM_SYNCONF_SWOC(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWOC))

/*! @brief Format value for bitfield FTM_SYNCONF_SWOC. */
#define BF_FTM_SYNCONF_SWOC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_SWOC) & BM_FTM_SYNCONF_SWOC)

/*! @brief Set the SWOC field to a new value. */
#define BW_FTM_SYNCONF_SWOC(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWOC) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SYNCMODE[7] (RW)
 *
 * Selects the PWM Synchronization mode.
 *
 * Values:
 * - 0 - Legacy PWM synchronization is selected.
 * - 1 - Enhanced PWM synchronization is selected.
 */
/*@{*/
#define BP_FTM_SYNCONF_SYNCMODE (7U)       /*!< Bit position for FTM_SYNCONF_SYNCMODE. */
#define BM_FTM_SYNCONF_SYNCMODE (0x00000080U) /*!< Bit mask for FTM_SYNCONF_SYNCMODE. */
#define BS_FTM_SYNCONF_SYNCMODE (1U)       /*!< Bit field size in bits for FTM_SYNCONF_SYNCMODE. */

/*! @brief Read current value of the FTM_SYNCONF_SYNCMODE field. */
#define BR_FTM_SYNCONF_SYNCMODE(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SYNCMODE))

/*! @brief Format value for bitfield FTM_SYNCONF_SYNCMODE. */
#define BF_FTM_SYNCONF_SYNCMODE(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_SYNCMODE) & BM_FTM_SYNCONF_SYNCMODE)

/*! @brief Set the SYNCMODE field to a new value. */
#define BW_FTM_SYNCONF_SYNCMODE(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SYNCMODE) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWRSTCNT[8] (RW)
 *
 * FTM counter synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the FTM counter synchronization.
 * - 1 - The software trigger activates the FTM counter synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_SWRSTCNT (8U)       /*!< Bit position for FTM_SYNCONF_SWRSTCNT. */
#define BM_FTM_SYNCONF_SWRSTCNT (0x00000100U) /*!< Bit mask for FTM_SYNCONF_SWRSTCNT. */
#define BS_FTM_SYNCONF_SWRSTCNT (1U)       /*!< Bit field size in bits for FTM_SYNCONF_SWRSTCNT. */

/*! @brief Read current value of the FTM_SYNCONF_SWRSTCNT field. */
#define BR_FTM_SYNCONF_SWRSTCNT(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWRSTCNT))

/*! @brief Format value for bitfield FTM_SYNCONF_SWRSTCNT. */
#define BF_FTM_SYNCONF_SWRSTCNT(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_SWRSTCNT) & BM_FTM_SYNCONF_SWRSTCNT)

/*! @brief Set the SWRSTCNT field to a new value. */
#define BW_FTM_SYNCONF_SWRSTCNT(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWRSTCNT) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWWRBUF[9] (RW)
 *
 * MOD, CNTIN, and CV registers synchronization is activated by the software
 * trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate MOD, CNTIN, and CV registers
 *     synchronization.
 * - 1 - The software trigger activates MOD, CNTIN, and CV registers
 *     synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_SWWRBUF (9U)        /*!< Bit position for FTM_SYNCONF_SWWRBUF. */
#define BM_FTM_SYNCONF_SWWRBUF (0x00000200U) /*!< Bit mask for FTM_SYNCONF_SWWRBUF. */
#define BS_FTM_SYNCONF_SWWRBUF (1U)        /*!< Bit field size in bits for FTM_SYNCONF_SWWRBUF. */

/*! @brief Read current value of the FTM_SYNCONF_SWWRBUF field. */
#define BR_FTM_SYNCONF_SWWRBUF(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWWRBUF))

/*! @brief Format value for bitfield FTM_SYNCONF_SWWRBUF. */
#define BF_FTM_SYNCONF_SWWRBUF(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_SWWRBUF) & BM_FTM_SYNCONF_SWWRBUF)

/*! @brief Set the SWWRBUF field to a new value. */
#define BW_FTM_SYNCONF_SWWRBUF(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWWRBUF) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWOM[10] (RW)
 *
 * Output mask synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the OUTMASK register
 *     synchronization.
 * - 1 - The software trigger activates the OUTMASK register synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_SWOM  (10U)         /*!< Bit position for FTM_SYNCONF_SWOM. */
#define BM_FTM_SYNCONF_SWOM  (0x00000400U) /*!< Bit mask for FTM_SYNCONF_SWOM. */
#define BS_FTM_SYNCONF_SWOM  (1U)          /*!< Bit field size in bits for FTM_SYNCONF_SWOM. */

/*! @brief Read current value of the FTM_SYNCONF_SWOM field. */
#define BR_FTM_SYNCONF_SWOM(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWOM))

/*! @brief Format value for bitfield FTM_SYNCONF_SWOM. */
#define BF_FTM_SYNCONF_SWOM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_SWOM) & BM_FTM_SYNCONF_SWOM)

/*! @brief Set the SWOM field to a new value. */
#define BW_FTM_SYNCONF_SWOM(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWOM) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWINVC[11] (RW)
 *
 * Inverting control synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the INVCTRL register
 *     synchronization.
 * - 1 - The software trigger activates the INVCTRL register synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_SWINVC (11U)        /*!< Bit position for FTM_SYNCONF_SWINVC. */
#define BM_FTM_SYNCONF_SWINVC (0x00000800U) /*!< Bit mask for FTM_SYNCONF_SWINVC. */
#define BS_FTM_SYNCONF_SWINVC (1U)         /*!< Bit field size in bits for FTM_SYNCONF_SWINVC. */

/*! @brief Read current value of the FTM_SYNCONF_SWINVC field. */
#define BR_FTM_SYNCONF_SWINVC(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWINVC))

/*! @brief Format value for bitfield FTM_SYNCONF_SWINVC. */
#define BF_FTM_SYNCONF_SWINVC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_SWINVC) & BM_FTM_SYNCONF_SWINVC)

/*! @brief Set the SWINVC field to a new value. */
#define BW_FTM_SYNCONF_SWINVC(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWINVC) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWSOC[12] (RW)
 *
 * Software output control synchronization is activated by the software trigger.
 *
 * Values:
 * - 0 - The software trigger does not activate the SWOCTRL register
 *     synchronization.
 * - 1 - The software trigger activates the SWOCTRL register synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_SWSOC (12U)         /*!< Bit position for FTM_SYNCONF_SWSOC. */
#define BM_FTM_SYNCONF_SWSOC (0x00001000U) /*!< Bit mask for FTM_SYNCONF_SWSOC. */
#define BS_FTM_SYNCONF_SWSOC (1U)          /*!< Bit field size in bits for FTM_SYNCONF_SWSOC. */

/*! @brief Read current value of the FTM_SYNCONF_SWSOC field. */
#define BR_FTM_SYNCONF_SWSOC(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWSOC))

/*! @brief Format value for bitfield FTM_SYNCONF_SWSOC. */
#define BF_FTM_SYNCONF_SWSOC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_SWSOC) & BM_FTM_SYNCONF_SWSOC)

/*! @brief Set the SWSOC field to a new value. */
#define BW_FTM_SYNCONF_SWSOC(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_SWSOC) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWRSTCNT[16] (RW)
 *
 * FTM counter synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the FTM counter synchronization.
 * - 1 - A hardware trigger activates the FTM counter synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_HWRSTCNT (16U)      /*!< Bit position for FTM_SYNCONF_HWRSTCNT. */
#define BM_FTM_SYNCONF_HWRSTCNT (0x00010000U) /*!< Bit mask for FTM_SYNCONF_HWRSTCNT. */
#define BS_FTM_SYNCONF_HWRSTCNT (1U)       /*!< Bit field size in bits for FTM_SYNCONF_HWRSTCNT. */

/*! @brief Read current value of the FTM_SYNCONF_HWRSTCNT field. */
#define BR_FTM_SYNCONF_HWRSTCNT(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWRSTCNT))

/*! @brief Format value for bitfield FTM_SYNCONF_HWRSTCNT. */
#define BF_FTM_SYNCONF_HWRSTCNT(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_HWRSTCNT) & BM_FTM_SYNCONF_HWRSTCNT)

/*! @brief Set the HWRSTCNT field to a new value. */
#define BW_FTM_SYNCONF_HWRSTCNT(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWRSTCNT) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWWRBUF[17] (RW)
 *
 * MOD, CNTIN, and CV registers synchronization is activated by a hardware
 * trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate MOD, CNTIN, and CV registers
 *     synchronization.
 * - 1 - A hardware trigger activates MOD, CNTIN, and CV registers
 *     synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_HWWRBUF (17U)       /*!< Bit position for FTM_SYNCONF_HWWRBUF. */
#define BM_FTM_SYNCONF_HWWRBUF (0x00020000U) /*!< Bit mask for FTM_SYNCONF_HWWRBUF. */
#define BS_FTM_SYNCONF_HWWRBUF (1U)        /*!< Bit field size in bits for FTM_SYNCONF_HWWRBUF. */

/*! @brief Read current value of the FTM_SYNCONF_HWWRBUF field. */
#define BR_FTM_SYNCONF_HWWRBUF(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWWRBUF))

/*! @brief Format value for bitfield FTM_SYNCONF_HWWRBUF. */
#define BF_FTM_SYNCONF_HWWRBUF(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_HWWRBUF) & BM_FTM_SYNCONF_HWWRBUF)

/*! @brief Set the HWWRBUF field to a new value. */
#define BW_FTM_SYNCONF_HWWRBUF(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWWRBUF) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWOM[18] (RW)
 *
 * Output mask synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the OUTMASK register
 *     synchronization.
 * - 1 - A hardware trigger activates the OUTMASK register synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_HWOM  (18U)         /*!< Bit position for FTM_SYNCONF_HWOM. */
#define BM_FTM_SYNCONF_HWOM  (0x00040000U) /*!< Bit mask for FTM_SYNCONF_HWOM. */
#define BS_FTM_SYNCONF_HWOM  (1U)          /*!< Bit field size in bits for FTM_SYNCONF_HWOM. */

/*! @brief Read current value of the FTM_SYNCONF_HWOM field. */
#define BR_FTM_SYNCONF_HWOM(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWOM))

/*! @brief Format value for bitfield FTM_SYNCONF_HWOM. */
#define BF_FTM_SYNCONF_HWOM(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_HWOM) & BM_FTM_SYNCONF_HWOM)

/*! @brief Set the HWOM field to a new value. */
#define BW_FTM_SYNCONF_HWOM(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWOM) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWINVC[19] (RW)
 *
 * Inverting control synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the INVCTRL register
 *     synchronization.
 * - 1 - A hardware trigger activates the INVCTRL register synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_HWINVC (19U)        /*!< Bit position for FTM_SYNCONF_HWINVC. */
#define BM_FTM_SYNCONF_HWINVC (0x00080000U) /*!< Bit mask for FTM_SYNCONF_HWINVC. */
#define BS_FTM_SYNCONF_HWINVC (1U)         /*!< Bit field size in bits for FTM_SYNCONF_HWINVC. */

/*! @brief Read current value of the FTM_SYNCONF_HWINVC field. */
#define BR_FTM_SYNCONF_HWINVC(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWINVC))

/*! @brief Format value for bitfield FTM_SYNCONF_HWINVC. */
#define BF_FTM_SYNCONF_HWINVC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_HWINVC) & BM_FTM_SYNCONF_HWINVC)

/*! @brief Set the HWINVC field to a new value. */
#define BW_FTM_SYNCONF_HWINVC(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWINVC) = (v))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWSOC[20] (RW)
 *
 * Software output control synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0 - A hardware trigger does not activate the SWOCTRL register
 *     synchronization.
 * - 1 - A hardware trigger activates the SWOCTRL register synchronization.
 */
/*@{*/
#define BP_FTM_SYNCONF_HWSOC (20U)         /*!< Bit position for FTM_SYNCONF_HWSOC. */
#define BM_FTM_SYNCONF_HWSOC (0x00100000U) /*!< Bit mask for FTM_SYNCONF_HWSOC. */
#define BS_FTM_SYNCONF_HWSOC (1U)          /*!< Bit field size in bits for FTM_SYNCONF_HWSOC. */

/*! @brief Read current value of the FTM_SYNCONF_HWSOC field. */
#define BR_FTM_SYNCONF_HWSOC(x) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWSOC))

/*! @brief Format value for bitfield FTM_SYNCONF_HWSOC. */
#define BF_FTM_SYNCONF_HWSOC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SYNCONF_HWSOC) & BM_FTM_SYNCONF_HWSOC)

/*! @brief Set the HWSOC field to a new value. */
#define BW_FTM_SYNCONF_HWSOC(x, v) (BITBAND_ACCESS32(HW_FTM_SYNCONF_ADDR(x), BP_FTM_SYNCONF_HWSOC) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_INVCTRL - FTM Inverting Control
 ******************************************************************************/

/*!
 * @brief HW_FTM_INVCTRL - FTM Inverting Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls when the channel (n) output becomes the channel (n+1)
 * output, and channel (n+1) output becomes the channel (n) output. Each INVmEN
 * bit enables the inverting operation for the corresponding pair channels m. This
 * register has a write buffer. The INVmEN bit is updated by the INVCTRL
 * register synchronization.
 */
typedef union _hw_ftm_invctrl
{
    uint32_t U;
    struct _hw_ftm_invctrl_bitfields
    {
        uint32_t INV0EN : 1;           /*!< [0] Pair Channels 0 Inverting Enable */
        uint32_t INV1EN : 1;           /*!< [1] Pair Channels 1 Inverting Enable */
        uint32_t INV2EN : 1;           /*!< [2] Pair Channels 2 Inverting Enable */
        uint32_t INV3EN : 1;           /*!< [3] Pair Channels 3 Inverting Enable */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_ftm_invctrl_t;

/*!
 * @name Constants and macros for entire FTM_INVCTRL register
 */
/*@{*/
#define HW_FTM_INVCTRL_ADDR(x)   ((uint32_t)(x) + 0x90U)

#define HW_FTM_INVCTRL(x)        (*(__IO hw_ftm_invctrl_t *) HW_FTM_INVCTRL_ADDR(x))
#define HW_FTM_INVCTRL_RD(x)     (HW_FTM_INVCTRL(x).U)
#define HW_FTM_INVCTRL_WR(x, v)  (HW_FTM_INVCTRL(x).U = (v))
#define HW_FTM_INVCTRL_SET(x, v) (HW_FTM_INVCTRL_WR(x, HW_FTM_INVCTRL_RD(x) |  (v)))
#define HW_FTM_INVCTRL_CLR(x, v) (HW_FTM_INVCTRL_WR(x, HW_FTM_INVCTRL_RD(x) & ~(v)))
#define HW_FTM_INVCTRL_TOG(x, v) (HW_FTM_INVCTRL_WR(x, HW_FTM_INVCTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_INVCTRL bitfields
 */

/*!
 * @name Register FTM_INVCTRL, field INV0EN[0] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
#define BP_FTM_INVCTRL_INV0EN (0U)         /*!< Bit position for FTM_INVCTRL_INV0EN. */
#define BM_FTM_INVCTRL_INV0EN (0x00000001U) /*!< Bit mask for FTM_INVCTRL_INV0EN. */
#define BS_FTM_INVCTRL_INV0EN (1U)         /*!< Bit field size in bits for FTM_INVCTRL_INV0EN. */

/*! @brief Read current value of the FTM_INVCTRL_INV0EN field. */
#define BR_FTM_INVCTRL_INV0EN(x) (BITBAND_ACCESS32(HW_FTM_INVCTRL_ADDR(x), BP_FTM_INVCTRL_INV0EN))

/*! @brief Format value for bitfield FTM_INVCTRL_INV0EN. */
#define BF_FTM_INVCTRL_INV0EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_INVCTRL_INV0EN) & BM_FTM_INVCTRL_INV0EN)

/*! @brief Set the INV0EN field to a new value. */
#define BW_FTM_INVCTRL_INV0EN(x, v) (BITBAND_ACCESS32(HW_FTM_INVCTRL_ADDR(x), BP_FTM_INVCTRL_INV0EN) = (v))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV1EN[1] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
#define BP_FTM_INVCTRL_INV1EN (1U)         /*!< Bit position for FTM_INVCTRL_INV1EN. */
#define BM_FTM_INVCTRL_INV1EN (0x00000002U) /*!< Bit mask for FTM_INVCTRL_INV1EN. */
#define BS_FTM_INVCTRL_INV1EN (1U)         /*!< Bit field size in bits for FTM_INVCTRL_INV1EN. */

/*! @brief Read current value of the FTM_INVCTRL_INV1EN field. */
#define BR_FTM_INVCTRL_INV1EN(x) (BITBAND_ACCESS32(HW_FTM_INVCTRL_ADDR(x), BP_FTM_INVCTRL_INV1EN))

/*! @brief Format value for bitfield FTM_INVCTRL_INV1EN. */
#define BF_FTM_INVCTRL_INV1EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_INVCTRL_INV1EN) & BM_FTM_INVCTRL_INV1EN)

/*! @brief Set the INV1EN field to a new value. */
#define BW_FTM_INVCTRL_INV1EN(x, v) (BITBAND_ACCESS32(HW_FTM_INVCTRL_ADDR(x), BP_FTM_INVCTRL_INV1EN) = (v))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV2EN[2] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
#define BP_FTM_INVCTRL_INV2EN (2U)         /*!< Bit position for FTM_INVCTRL_INV2EN. */
#define BM_FTM_INVCTRL_INV2EN (0x00000004U) /*!< Bit mask for FTM_INVCTRL_INV2EN. */
#define BS_FTM_INVCTRL_INV2EN (1U)         /*!< Bit field size in bits for FTM_INVCTRL_INV2EN. */

/*! @brief Read current value of the FTM_INVCTRL_INV2EN field. */
#define BR_FTM_INVCTRL_INV2EN(x) (BITBAND_ACCESS32(HW_FTM_INVCTRL_ADDR(x), BP_FTM_INVCTRL_INV2EN))

/*! @brief Format value for bitfield FTM_INVCTRL_INV2EN. */
#define BF_FTM_INVCTRL_INV2EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_INVCTRL_INV2EN) & BM_FTM_INVCTRL_INV2EN)

/*! @brief Set the INV2EN field to a new value. */
#define BW_FTM_INVCTRL_INV2EN(x, v) (BITBAND_ACCESS32(HW_FTM_INVCTRL_ADDR(x), BP_FTM_INVCTRL_INV2EN) = (v))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV3EN[3] (RW)
 *
 * Values:
 * - 0 - Inverting is disabled.
 * - 1 - Inverting is enabled.
 */
/*@{*/
#define BP_FTM_INVCTRL_INV3EN (3U)         /*!< Bit position for FTM_INVCTRL_INV3EN. */
#define BM_FTM_INVCTRL_INV3EN (0x00000008U) /*!< Bit mask for FTM_INVCTRL_INV3EN. */
#define BS_FTM_INVCTRL_INV3EN (1U)         /*!< Bit field size in bits for FTM_INVCTRL_INV3EN. */

/*! @brief Read current value of the FTM_INVCTRL_INV3EN field. */
#define BR_FTM_INVCTRL_INV3EN(x) (BITBAND_ACCESS32(HW_FTM_INVCTRL_ADDR(x), BP_FTM_INVCTRL_INV3EN))

/*! @brief Format value for bitfield FTM_INVCTRL_INV3EN. */
#define BF_FTM_INVCTRL_INV3EN(v) ((uint32_t)((uint32_t)(v) << BP_FTM_INVCTRL_INV3EN) & BM_FTM_INVCTRL_INV3EN)

/*! @brief Set the INV3EN field to a new value. */
#define BW_FTM_INVCTRL_INV3EN(x, v) (BITBAND_ACCESS32(HW_FTM_INVCTRL_ADDR(x), BP_FTM_INVCTRL_INV3EN) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_SWOCTRL - FTM Software Output Control
 ******************************************************************************/

/*!
 * @brief HW_FTM_SWOCTRL - FTM Software Output Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register enables software control of channel (n) output and defines the
 * value forced to the channel (n) output: The CHnOC bits enable the control of
 * the corresponding channel (n) output by software. The CHnOCV bits select the
 * value that is forced at the corresponding channel (n) output. This register has
 * a write buffer. The fields are updated by the SWOCTRL register synchronization.
 */
typedef union _hw_ftm_swoctrl
{
    uint32_t U;
    struct _hw_ftm_swoctrl_bitfields
    {
        uint32_t CH0OC : 1;            /*!< [0] Channel 0 Software Output Control Enable
                                        * */
        uint32_t CH1OC : 1;            /*!< [1] Channel 1 Software Output Control Enable
                                        * */
        uint32_t CH2OC : 1;            /*!< [2] Channel 2 Software Output Control Enable
                                        * */
        uint32_t CH3OC : 1;            /*!< [3] Channel 3 Software Output Control Enable
                                        * */
        uint32_t CH4OC : 1;            /*!< [4] Channel 4 Software Output Control Enable
                                        * */
        uint32_t CH5OC : 1;            /*!< [5] Channel 5 Software Output Control Enable
                                        * */
        uint32_t CH6OC : 1;            /*!< [6] Channel 6 Software Output Control Enable
                                        * */
        uint32_t CH7OC : 1;            /*!< [7] Channel 7 Software Output Control Enable
                                        * */
        uint32_t CH0OCV : 1;           /*!< [8] Channel 0 Software Output Control Value
                                        * */
        uint32_t CH1OCV : 1;           /*!< [9] Channel 1 Software Output Control Value
                                        * */
        uint32_t CH2OCV : 1;           /*!< [10] Channel 2 Software Output Control
                                        * Value */
        uint32_t CH3OCV : 1;           /*!< [11] Channel 3 Software Output Control
                                        * Value */
        uint32_t CH4OCV : 1;           /*!< [12] Channel 4 Software Output Control
                                        * Value */
        uint32_t CH5OCV : 1;           /*!< [13] Channel 5 Software Output Control
                                        * Value */
        uint32_t CH6OCV : 1;           /*!< [14] Channel 6 Software Output Control
                                        * Value */
        uint32_t CH7OCV : 1;           /*!< [15] Channel 7 Software Output Control
                                        * Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_ftm_swoctrl_t;

/*!
 * @name Constants and macros for entire FTM_SWOCTRL register
 */
/*@{*/
#define HW_FTM_SWOCTRL_ADDR(x)   ((uint32_t)(x) + 0x94U)

#define HW_FTM_SWOCTRL(x)        (*(__IO hw_ftm_swoctrl_t *) HW_FTM_SWOCTRL_ADDR(x))
#define HW_FTM_SWOCTRL_RD(x)     (HW_FTM_SWOCTRL(x).U)
#define HW_FTM_SWOCTRL_WR(x, v)  (HW_FTM_SWOCTRL(x).U = (v))
#define HW_FTM_SWOCTRL_SET(x, v) (HW_FTM_SWOCTRL_WR(x, HW_FTM_SWOCTRL_RD(x) |  (v)))
#define HW_FTM_SWOCTRL_CLR(x, v) (HW_FTM_SWOCTRL_WR(x, HW_FTM_SWOCTRL_RD(x) & ~(v)))
#define HW_FTM_SWOCTRL_TOG(x, v) (HW_FTM_SWOCTRL_WR(x, HW_FTM_SWOCTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_SWOCTRL bitfields
 */

/*!
 * @name Register FTM_SWOCTRL, field CH0OC[0] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH0OC (0U)          /*!< Bit position for FTM_SWOCTRL_CH0OC. */
#define BM_FTM_SWOCTRL_CH0OC (0x00000001U) /*!< Bit mask for FTM_SWOCTRL_CH0OC. */
#define BS_FTM_SWOCTRL_CH0OC (1U)          /*!< Bit field size in bits for FTM_SWOCTRL_CH0OC. */

/*! @brief Read current value of the FTM_SWOCTRL_CH0OC field. */
#define BR_FTM_SWOCTRL_CH0OC(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH0OC))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH0OC. */
#define BF_FTM_SWOCTRL_CH0OC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH0OC) & BM_FTM_SWOCTRL_CH0OC)

/*! @brief Set the CH0OC field to a new value. */
#define BW_FTM_SWOCTRL_CH0OC(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH0OC) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH1OC[1] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH1OC (1U)          /*!< Bit position for FTM_SWOCTRL_CH1OC. */
#define BM_FTM_SWOCTRL_CH1OC (0x00000002U) /*!< Bit mask for FTM_SWOCTRL_CH1OC. */
#define BS_FTM_SWOCTRL_CH1OC (1U)          /*!< Bit field size in bits for FTM_SWOCTRL_CH1OC. */

/*! @brief Read current value of the FTM_SWOCTRL_CH1OC field. */
#define BR_FTM_SWOCTRL_CH1OC(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH1OC))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH1OC. */
#define BF_FTM_SWOCTRL_CH1OC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH1OC) & BM_FTM_SWOCTRL_CH1OC)

/*! @brief Set the CH1OC field to a new value. */
#define BW_FTM_SWOCTRL_CH1OC(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH1OC) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH2OC[2] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH2OC (2U)          /*!< Bit position for FTM_SWOCTRL_CH2OC. */
#define BM_FTM_SWOCTRL_CH2OC (0x00000004U) /*!< Bit mask for FTM_SWOCTRL_CH2OC. */
#define BS_FTM_SWOCTRL_CH2OC (1U)          /*!< Bit field size in bits for FTM_SWOCTRL_CH2OC. */

/*! @brief Read current value of the FTM_SWOCTRL_CH2OC field. */
#define BR_FTM_SWOCTRL_CH2OC(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH2OC))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH2OC. */
#define BF_FTM_SWOCTRL_CH2OC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH2OC) & BM_FTM_SWOCTRL_CH2OC)

/*! @brief Set the CH2OC field to a new value. */
#define BW_FTM_SWOCTRL_CH2OC(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH2OC) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH3OC[3] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH3OC (3U)          /*!< Bit position for FTM_SWOCTRL_CH3OC. */
#define BM_FTM_SWOCTRL_CH3OC (0x00000008U) /*!< Bit mask for FTM_SWOCTRL_CH3OC. */
#define BS_FTM_SWOCTRL_CH3OC (1U)          /*!< Bit field size in bits for FTM_SWOCTRL_CH3OC. */

/*! @brief Read current value of the FTM_SWOCTRL_CH3OC field. */
#define BR_FTM_SWOCTRL_CH3OC(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH3OC))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH3OC. */
#define BF_FTM_SWOCTRL_CH3OC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH3OC) & BM_FTM_SWOCTRL_CH3OC)

/*! @brief Set the CH3OC field to a new value. */
#define BW_FTM_SWOCTRL_CH3OC(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH3OC) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH4OC[4] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH4OC (4U)          /*!< Bit position for FTM_SWOCTRL_CH4OC. */
#define BM_FTM_SWOCTRL_CH4OC (0x00000010U) /*!< Bit mask for FTM_SWOCTRL_CH4OC. */
#define BS_FTM_SWOCTRL_CH4OC (1U)          /*!< Bit field size in bits for FTM_SWOCTRL_CH4OC. */

/*! @brief Read current value of the FTM_SWOCTRL_CH4OC field. */
#define BR_FTM_SWOCTRL_CH4OC(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH4OC))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH4OC. */
#define BF_FTM_SWOCTRL_CH4OC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH4OC) & BM_FTM_SWOCTRL_CH4OC)

/*! @brief Set the CH4OC field to a new value. */
#define BW_FTM_SWOCTRL_CH4OC(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH4OC) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH5OC[5] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH5OC (5U)          /*!< Bit position for FTM_SWOCTRL_CH5OC. */
#define BM_FTM_SWOCTRL_CH5OC (0x00000020U) /*!< Bit mask for FTM_SWOCTRL_CH5OC. */
#define BS_FTM_SWOCTRL_CH5OC (1U)          /*!< Bit field size in bits for FTM_SWOCTRL_CH5OC. */

/*! @brief Read current value of the FTM_SWOCTRL_CH5OC field. */
#define BR_FTM_SWOCTRL_CH5OC(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH5OC))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH5OC. */
#define BF_FTM_SWOCTRL_CH5OC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH5OC) & BM_FTM_SWOCTRL_CH5OC)

/*! @brief Set the CH5OC field to a new value. */
#define BW_FTM_SWOCTRL_CH5OC(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH5OC) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH6OC[6] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH6OC (6U)          /*!< Bit position for FTM_SWOCTRL_CH6OC. */
#define BM_FTM_SWOCTRL_CH6OC (0x00000040U) /*!< Bit mask for FTM_SWOCTRL_CH6OC. */
#define BS_FTM_SWOCTRL_CH6OC (1U)          /*!< Bit field size in bits for FTM_SWOCTRL_CH6OC. */

/*! @brief Read current value of the FTM_SWOCTRL_CH6OC field. */
#define BR_FTM_SWOCTRL_CH6OC(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH6OC))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH6OC. */
#define BF_FTM_SWOCTRL_CH6OC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH6OC) & BM_FTM_SWOCTRL_CH6OC)

/*! @brief Set the CH6OC field to a new value. */
#define BW_FTM_SWOCTRL_CH6OC(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH6OC) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH7OC[7] (RW)
 *
 * Values:
 * - 0 - The channel output is not affected by software output control.
 * - 1 - The channel output is affected by software output control.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH7OC (7U)          /*!< Bit position for FTM_SWOCTRL_CH7OC. */
#define BM_FTM_SWOCTRL_CH7OC (0x00000080U) /*!< Bit mask for FTM_SWOCTRL_CH7OC. */
#define BS_FTM_SWOCTRL_CH7OC (1U)          /*!< Bit field size in bits for FTM_SWOCTRL_CH7OC. */

/*! @brief Read current value of the FTM_SWOCTRL_CH7OC field. */
#define BR_FTM_SWOCTRL_CH7OC(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH7OC))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH7OC. */
#define BF_FTM_SWOCTRL_CH7OC(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH7OC) & BM_FTM_SWOCTRL_CH7OC)

/*! @brief Set the CH7OC field to a new value. */
#define BW_FTM_SWOCTRL_CH7OC(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH7OC) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH0OCV[8] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH0OCV (8U)         /*!< Bit position for FTM_SWOCTRL_CH0OCV. */
#define BM_FTM_SWOCTRL_CH0OCV (0x00000100U) /*!< Bit mask for FTM_SWOCTRL_CH0OCV. */
#define BS_FTM_SWOCTRL_CH0OCV (1U)         /*!< Bit field size in bits for FTM_SWOCTRL_CH0OCV. */

/*! @brief Read current value of the FTM_SWOCTRL_CH0OCV field. */
#define BR_FTM_SWOCTRL_CH0OCV(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH0OCV))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH0OCV. */
#define BF_FTM_SWOCTRL_CH0OCV(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH0OCV) & BM_FTM_SWOCTRL_CH0OCV)

/*! @brief Set the CH0OCV field to a new value. */
#define BW_FTM_SWOCTRL_CH0OCV(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH0OCV) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH1OCV[9] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH1OCV (9U)         /*!< Bit position for FTM_SWOCTRL_CH1OCV. */
#define BM_FTM_SWOCTRL_CH1OCV (0x00000200U) /*!< Bit mask for FTM_SWOCTRL_CH1OCV. */
#define BS_FTM_SWOCTRL_CH1OCV (1U)         /*!< Bit field size in bits for FTM_SWOCTRL_CH1OCV. */

/*! @brief Read current value of the FTM_SWOCTRL_CH1OCV field. */
#define BR_FTM_SWOCTRL_CH1OCV(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH1OCV))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH1OCV. */
#define BF_FTM_SWOCTRL_CH1OCV(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH1OCV) & BM_FTM_SWOCTRL_CH1OCV)

/*! @brief Set the CH1OCV field to a new value. */
#define BW_FTM_SWOCTRL_CH1OCV(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH1OCV) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH2OCV[10] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH2OCV (10U)        /*!< Bit position for FTM_SWOCTRL_CH2OCV. */
#define BM_FTM_SWOCTRL_CH2OCV (0x00000400U) /*!< Bit mask for FTM_SWOCTRL_CH2OCV. */
#define BS_FTM_SWOCTRL_CH2OCV (1U)         /*!< Bit field size in bits for FTM_SWOCTRL_CH2OCV. */

/*! @brief Read current value of the FTM_SWOCTRL_CH2OCV field. */
#define BR_FTM_SWOCTRL_CH2OCV(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH2OCV))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH2OCV. */
#define BF_FTM_SWOCTRL_CH2OCV(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH2OCV) & BM_FTM_SWOCTRL_CH2OCV)

/*! @brief Set the CH2OCV field to a new value. */
#define BW_FTM_SWOCTRL_CH2OCV(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH2OCV) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH3OCV[11] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH3OCV (11U)        /*!< Bit position for FTM_SWOCTRL_CH3OCV. */
#define BM_FTM_SWOCTRL_CH3OCV (0x00000800U) /*!< Bit mask for FTM_SWOCTRL_CH3OCV. */
#define BS_FTM_SWOCTRL_CH3OCV (1U)         /*!< Bit field size in bits for FTM_SWOCTRL_CH3OCV. */

/*! @brief Read current value of the FTM_SWOCTRL_CH3OCV field. */
#define BR_FTM_SWOCTRL_CH3OCV(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH3OCV))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH3OCV. */
#define BF_FTM_SWOCTRL_CH3OCV(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH3OCV) & BM_FTM_SWOCTRL_CH3OCV)

/*! @brief Set the CH3OCV field to a new value. */
#define BW_FTM_SWOCTRL_CH3OCV(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH3OCV) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH4OCV[12] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH4OCV (12U)        /*!< Bit position for FTM_SWOCTRL_CH4OCV. */
#define BM_FTM_SWOCTRL_CH4OCV (0x00001000U) /*!< Bit mask for FTM_SWOCTRL_CH4OCV. */
#define BS_FTM_SWOCTRL_CH4OCV (1U)         /*!< Bit field size in bits for FTM_SWOCTRL_CH4OCV. */

/*! @brief Read current value of the FTM_SWOCTRL_CH4OCV field. */
#define BR_FTM_SWOCTRL_CH4OCV(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH4OCV))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH4OCV. */
#define BF_FTM_SWOCTRL_CH4OCV(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH4OCV) & BM_FTM_SWOCTRL_CH4OCV)

/*! @brief Set the CH4OCV field to a new value. */
#define BW_FTM_SWOCTRL_CH4OCV(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH4OCV) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH5OCV[13] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH5OCV (13U)        /*!< Bit position for FTM_SWOCTRL_CH5OCV. */
#define BM_FTM_SWOCTRL_CH5OCV (0x00002000U) /*!< Bit mask for FTM_SWOCTRL_CH5OCV. */
#define BS_FTM_SWOCTRL_CH5OCV (1U)         /*!< Bit field size in bits for FTM_SWOCTRL_CH5OCV. */

/*! @brief Read current value of the FTM_SWOCTRL_CH5OCV field. */
#define BR_FTM_SWOCTRL_CH5OCV(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH5OCV))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH5OCV. */
#define BF_FTM_SWOCTRL_CH5OCV(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH5OCV) & BM_FTM_SWOCTRL_CH5OCV)

/*! @brief Set the CH5OCV field to a new value. */
#define BW_FTM_SWOCTRL_CH5OCV(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH5OCV) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH6OCV[14] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH6OCV (14U)        /*!< Bit position for FTM_SWOCTRL_CH6OCV. */
#define BM_FTM_SWOCTRL_CH6OCV (0x00004000U) /*!< Bit mask for FTM_SWOCTRL_CH6OCV. */
#define BS_FTM_SWOCTRL_CH6OCV (1U)         /*!< Bit field size in bits for FTM_SWOCTRL_CH6OCV. */

/*! @brief Read current value of the FTM_SWOCTRL_CH6OCV field. */
#define BR_FTM_SWOCTRL_CH6OCV(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH6OCV))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH6OCV. */
#define BF_FTM_SWOCTRL_CH6OCV(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH6OCV) & BM_FTM_SWOCTRL_CH6OCV)

/*! @brief Set the CH6OCV field to a new value. */
#define BW_FTM_SWOCTRL_CH6OCV(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH6OCV) = (v))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH7OCV[15] (RW)
 *
 * Values:
 * - 0 - The software output control forces 0 to the channel output.
 * - 1 - The software output control forces 1 to the channel output.
 */
/*@{*/
#define BP_FTM_SWOCTRL_CH7OCV (15U)        /*!< Bit position for FTM_SWOCTRL_CH7OCV. */
#define BM_FTM_SWOCTRL_CH7OCV (0x00008000U) /*!< Bit mask for FTM_SWOCTRL_CH7OCV. */
#define BS_FTM_SWOCTRL_CH7OCV (1U)         /*!< Bit field size in bits for FTM_SWOCTRL_CH7OCV. */

/*! @brief Read current value of the FTM_SWOCTRL_CH7OCV field. */
#define BR_FTM_SWOCTRL_CH7OCV(x) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH7OCV))

/*! @brief Format value for bitfield FTM_SWOCTRL_CH7OCV. */
#define BF_FTM_SWOCTRL_CH7OCV(v) ((uint32_t)((uint32_t)(v) << BP_FTM_SWOCTRL_CH7OCV) & BM_FTM_SWOCTRL_CH7OCV)

/*! @brief Set the CH7OCV field to a new value. */
#define BW_FTM_SWOCTRL_CH7OCV(x, v) (BITBAND_ACCESS32(HW_FTM_SWOCTRL_ADDR(x), BP_FTM_SWOCTRL_CH7OCV) = (v))
/*@}*/

/*******************************************************************************
 * HW_FTM_PWMLOAD - FTM PWM Load
 ******************************************************************************/

/*!
 * @brief HW_FTM_PWMLOAD - FTM PWM Load (RW)
 *
 * Reset value: 0x00000000U
 *
 * Enables the loading of the MOD, CNTIN, C(n)V, and C(n+1)V registers with the
 * values of their write buffers when the FTM counter changes from the MOD
 * register value to its next value or when a channel (j) match occurs. A match occurs
 * for the channel (j) when FTM counter = C(j)V.
 */
typedef union _hw_ftm_pwmload
{
    uint32_t U;
    struct _hw_ftm_pwmload_bitfields
    {
        uint32_t CH0SEL : 1;           /*!< [0] Channel 0 Select */
        uint32_t CH1SEL : 1;           /*!< [1] Channel 1 Select */
        uint32_t CH2SEL : 1;           /*!< [2] Channel 2 Select */
        uint32_t CH3SEL : 1;           /*!< [3] Channel 3 Select */
        uint32_t CH4SEL : 1;           /*!< [4] Channel 4 Select */
        uint32_t CH5SEL : 1;           /*!< [5] Channel 5 Select */
        uint32_t CH6SEL : 1;           /*!< [6] Channel 6 Select */
        uint32_t CH7SEL : 1;           /*!< [7] Channel 7 Select */
        uint32_t RESERVED0 : 1;        /*!< [8]  */
        uint32_t LDOK : 1;             /*!< [9] Load Enable */
        uint32_t RESERVED1 : 22;       /*!< [31:10]  */
    } B;
} hw_ftm_pwmload_t;

/*!
 * @name Constants and macros for entire FTM_PWMLOAD register
 */
/*@{*/
#define HW_FTM_PWMLOAD_ADDR(x)   ((uint32_t)(x) + 0x98U)

#define HW_FTM_PWMLOAD(x)        (*(__IO hw_ftm_pwmload_t *) HW_FTM_PWMLOAD_ADDR(x))
#define HW_FTM_PWMLOAD_RD(x)     (HW_FTM_PWMLOAD(x).U)
#define HW_FTM_PWMLOAD_WR(x, v)  (HW_FTM_PWMLOAD(x).U = (v))
#define HW_FTM_PWMLOAD_SET(x, v) (HW_FTM_PWMLOAD_WR(x, HW_FTM_PWMLOAD_RD(x) |  (v)))
#define HW_FTM_PWMLOAD_CLR(x, v) (HW_FTM_PWMLOAD_WR(x, HW_FTM_PWMLOAD_RD(x) & ~(v)))
#define HW_FTM_PWMLOAD_TOG(x, v) (HW_FTM_PWMLOAD_WR(x, HW_FTM_PWMLOAD_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual FTM_PWMLOAD bitfields
 */

/*!
 * @name Register FTM_PWMLOAD, field CH0SEL[0] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
#define BP_FTM_PWMLOAD_CH0SEL (0U)         /*!< Bit position for FTM_PWMLOAD_CH0SEL. */
#define BM_FTM_PWMLOAD_CH0SEL (0x00000001U) /*!< Bit mask for FTM_PWMLOAD_CH0SEL. */
#define BS_FTM_PWMLOAD_CH0SEL (1U)         /*!< Bit field size in bits for FTM_PWMLOAD_CH0SEL. */

/*! @brief Read current value of the FTM_PWMLOAD_CH0SEL field. */
#define BR_FTM_PWMLOAD_CH0SEL(x) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH0SEL))

/*! @brief Format value for bitfield FTM_PWMLOAD_CH0SEL. */
#define BF_FTM_PWMLOAD_CH0SEL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_PWMLOAD_CH0SEL) & BM_FTM_PWMLOAD_CH0SEL)

/*! @brief Set the CH0SEL field to a new value. */
#define BW_FTM_PWMLOAD_CH0SEL(x, v) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH0SEL) = (v))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH1SEL[1] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
#define BP_FTM_PWMLOAD_CH1SEL (1U)         /*!< Bit position for FTM_PWMLOAD_CH1SEL. */
#define BM_FTM_PWMLOAD_CH1SEL (0x00000002U) /*!< Bit mask for FTM_PWMLOAD_CH1SEL. */
#define BS_FTM_PWMLOAD_CH1SEL (1U)         /*!< Bit field size in bits for FTM_PWMLOAD_CH1SEL. */

/*! @brief Read current value of the FTM_PWMLOAD_CH1SEL field. */
#define BR_FTM_PWMLOAD_CH1SEL(x) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH1SEL))

/*! @brief Format value for bitfield FTM_PWMLOAD_CH1SEL. */
#define BF_FTM_PWMLOAD_CH1SEL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_PWMLOAD_CH1SEL) & BM_FTM_PWMLOAD_CH1SEL)

/*! @brief Set the CH1SEL field to a new value. */
#define BW_FTM_PWMLOAD_CH1SEL(x, v) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH1SEL) = (v))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH2SEL[2] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
#define BP_FTM_PWMLOAD_CH2SEL (2U)         /*!< Bit position for FTM_PWMLOAD_CH2SEL. */
#define BM_FTM_PWMLOAD_CH2SEL (0x00000004U) /*!< Bit mask for FTM_PWMLOAD_CH2SEL. */
#define BS_FTM_PWMLOAD_CH2SEL (1U)         /*!< Bit field size in bits for FTM_PWMLOAD_CH2SEL. */

/*! @brief Read current value of the FTM_PWMLOAD_CH2SEL field. */
#define BR_FTM_PWMLOAD_CH2SEL(x) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH2SEL))

/*! @brief Format value for bitfield FTM_PWMLOAD_CH2SEL. */
#define BF_FTM_PWMLOAD_CH2SEL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_PWMLOAD_CH2SEL) & BM_FTM_PWMLOAD_CH2SEL)

/*! @brief Set the CH2SEL field to a new value. */
#define BW_FTM_PWMLOAD_CH2SEL(x, v) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH2SEL) = (v))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH3SEL[3] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
#define BP_FTM_PWMLOAD_CH3SEL (3U)         /*!< Bit position for FTM_PWMLOAD_CH3SEL. */
#define BM_FTM_PWMLOAD_CH3SEL (0x00000008U) /*!< Bit mask for FTM_PWMLOAD_CH3SEL. */
#define BS_FTM_PWMLOAD_CH3SEL (1U)         /*!< Bit field size in bits for FTM_PWMLOAD_CH3SEL. */

/*! @brief Read current value of the FTM_PWMLOAD_CH3SEL field. */
#define BR_FTM_PWMLOAD_CH3SEL(x) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH3SEL))

/*! @brief Format value for bitfield FTM_PWMLOAD_CH3SEL. */
#define BF_FTM_PWMLOAD_CH3SEL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_PWMLOAD_CH3SEL) & BM_FTM_PWMLOAD_CH3SEL)

/*! @brief Set the CH3SEL field to a new value. */
#define BW_FTM_PWMLOAD_CH3SEL(x, v) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH3SEL) = (v))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH4SEL[4] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
#define BP_FTM_PWMLOAD_CH4SEL (4U)         /*!< Bit position for FTM_PWMLOAD_CH4SEL. */
#define BM_FTM_PWMLOAD_CH4SEL (0x00000010U) /*!< Bit mask for FTM_PWMLOAD_CH4SEL. */
#define BS_FTM_PWMLOAD_CH4SEL (1U)         /*!< Bit field size in bits for FTM_PWMLOAD_CH4SEL. */

/*! @brief Read current value of the FTM_PWMLOAD_CH4SEL field. */
#define BR_FTM_PWMLOAD_CH4SEL(x) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH4SEL))

/*! @brief Format value for bitfield FTM_PWMLOAD_CH4SEL. */
#define BF_FTM_PWMLOAD_CH4SEL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_PWMLOAD_CH4SEL) & BM_FTM_PWMLOAD_CH4SEL)

/*! @brief Set the CH4SEL field to a new value. */
#define BW_FTM_PWMLOAD_CH4SEL(x, v) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH4SEL) = (v))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH5SEL[5] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
#define BP_FTM_PWMLOAD_CH5SEL (5U)         /*!< Bit position for FTM_PWMLOAD_CH5SEL. */
#define BM_FTM_PWMLOAD_CH5SEL (0x00000020U) /*!< Bit mask for FTM_PWMLOAD_CH5SEL. */
#define BS_FTM_PWMLOAD_CH5SEL (1U)         /*!< Bit field size in bits for FTM_PWMLOAD_CH5SEL. */

/*! @brief Read current value of the FTM_PWMLOAD_CH5SEL field. */
#define BR_FTM_PWMLOAD_CH5SEL(x) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH5SEL))

/*! @brief Format value for bitfield FTM_PWMLOAD_CH5SEL. */
#define BF_FTM_PWMLOAD_CH5SEL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_PWMLOAD_CH5SEL) & BM_FTM_PWMLOAD_CH5SEL)

/*! @brief Set the CH5SEL field to a new value. */
#define BW_FTM_PWMLOAD_CH5SEL(x, v) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH5SEL) = (v))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH6SEL[6] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
#define BP_FTM_PWMLOAD_CH6SEL (6U)         /*!< Bit position for FTM_PWMLOAD_CH6SEL. */
#define BM_FTM_PWMLOAD_CH6SEL (0x00000040U) /*!< Bit mask for FTM_PWMLOAD_CH6SEL. */
#define BS_FTM_PWMLOAD_CH6SEL (1U)         /*!< Bit field size in bits for FTM_PWMLOAD_CH6SEL. */

/*! @brief Read current value of the FTM_PWMLOAD_CH6SEL field. */
#define BR_FTM_PWMLOAD_CH6SEL(x) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH6SEL))

/*! @brief Format value for bitfield FTM_PWMLOAD_CH6SEL. */
#define BF_FTM_PWMLOAD_CH6SEL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_PWMLOAD_CH6SEL) & BM_FTM_PWMLOAD_CH6SEL)

/*! @brief Set the CH6SEL field to a new value. */
#define BW_FTM_PWMLOAD_CH6SEL(x, v) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH6SEL) = (v))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH7SEL[7] (RW)
 *
 * Values:
 * - 0 - Do not include the channel in the matching process.
 * - 1 - Include the channel in the matching process.
 */
/*@{*/
#define BP_FTM_PWMLOAD_CH7SEL (7U)         /*!< Bit position for FTM_PWMLOAD_CH7SEL. */
#define BM_FTM_PWMLOAD_CH7SEL (0x00000080U) /*!< Bit mask for FTM_PWMLOAD_CH7SEL. */
#define BS_FTM_PWMLOAD_CH7SEL (1U)         /*!< Bit field size in bits for FTM_PWMLOAD_CH7SEL. */

/*! @brief Read current value of the FTM_PWMLOAD_CH7SEL field. */
#define BR_FTM_PWMLOAD_CH7SEL(x) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH7SEL))

/*! @brief Format value for bitfield FTM_PWMLOAD_CH7SEL. */
#define BF_FTM_PWMLOAD_CH7SEL(v) ((uint32_t)((uint32_t)(v) << BP_FTM_PWMLOAD_CH7SEL) & BM_FTM_PWMLOAD_CH7SEL)

/*! @brief Set the CH7SEL field to a new value. */
#define BW_FTM_PWMLOAD_CH7SEL(x, v) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_CH7SEL) = (v))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field LDOK[9] (RW)
 *
 * Enables the loading of the MOD, CNTIN, and CV registers with the values of
 * their write buffers.
 *
 * Values:
 * - 0 - Loading updated values is disabled.
 * - 1 - Loading updated values is enabled.
 */
/*@{*/
#define BP_FTM_PWMLOAD_LDOK  (9U)          /*!< Bit position for FTM_PWMLOAD_LDOK. */
#define BM_FTM_PWMLOAD_LDOK  (0x00000200U) /*!< Bit mask for FTM_PWMLOAD_LDOK. */
#define BS_FTM_PWMLOAD_LDOK  (1U)          /*!< Bit field size in bits for FTM_PWMLOAD_LDOK. */

/*! @brief Read current value of the FTM_PWMLOAD_LDOK field. */
#define BR_FTM_PWMLOAD_LDOK(x) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_LDOK))

/*! @brief Format value for bitfield FTM_PWMLOAD_LDOK. */
#define BF_FTM_PWMLOAD_LDOK(v) ((uint32_t)((uint32_t)(v) << BP_FTM_PWMLOAD_LDOK) & BM_FTM_PWMLOAD_LDOK)

/*! @brief Set the LDOK field to a new value. */
#define BW_FTM_PWMLOAD_LDOK(x, v) (BITBAND_ACCESS32(HW_FTM_PWMLOAD_ADDR(x), BP_FTM_PWMLOAD_LDOK) = (v))
/*@}*/

/*******************************************************************************
 * hw_ftm_t - module struct
 ******************************************************************************/
/*!
 * @brief All FTM module registers.
 */
#pragma pack(1)
typedef struct _hw_ftm
{
    __IO hw_ftm_sc_t SC;                   /*!< [0x0] Status And Control */
    __IO hw_ftm_cnt_t CNT;                 /*!< [0x4] Counter */
    __IO hw_ftm_mod_t MOD;                 /*!< [0x8] Modulo */
    struct {
        __IO hw_ftm_cnsc_t CnSC;           /*!< [0xC] Channel (n) Status And Control */
        __IO hw_ftm_cnv_t CnV;             /*!< [0x10] Channel (n) Value */
    } CONTROLS[8];
    __IO hw_ftm_cntin_t CNTIN;             /*!< [0x4C] Counter Initial Value */
    __IO hw_ftm_status_t STATUS;           /*!< [0x50] Capture And Compare Status */
    __IO hw_ftm_mode_t MODE;               /*!< [0x54] Features Mode Selection */
    __IO hw_ftm_sync_t SYNC;               /*!< [0x58] Synchronization */
    __IO hw_ftm_outinit_t OUTINIT;         /*!< [0x5C] Initial State For Channels Output */
    __IO hw_ftm_outmask_t OUTMASK;         /*!< [0x60] Output Mask */
    __IO hw_ftm_combine_t COMBINE;         /*!< [0x64] Function For Linked Channels */
    __IO hw_ftm_deadtime_t DEADTIME;       /*!< [0x68] Deadtime Insertion Control */
    __IO hw_ftm_exttrig_t EXTTRIG;         /*!< [0x6C] FTM External Trigger */
    __IO hw_ftm_pol_t POL;                 /*!< [0x70] Channels Polarity */
    __IO hw_ftm_fms_t FMS;                 /*!< [0x74] Fault Mode Status */
    __IO hw_ftm_filter_t FILTER;           /*!< [0x78] Input Capture Filter Control */
    __IO hw_ftm_fltctrl_t FLTCTRL;         /*!< [0x7C] Fault Control */
    __IO hw_ftm_qdctrl_t QDCTRL;           /*!< [0x80] Quadrature Decoder Control And Status */
    __IO hw_ftm_conf_t CONF;               /*!< [0x84] Configuration */
    __IO hw_ftm_fltpol_t FLTPOL;           /*!< [0x88] FTM Fault Input Polarity */
    __IO hw_ftm_synconf_t SYNCONF;         /*!< [0x8C] Synchronization Configuration */
    __IO hw_ftm_invctrl_t INVCTRL;         /*!< [0x90] FTM Inverting Control */
    __IO hw_ftm_swoctrl_t SWOCTRL;         /*!< [0x94] FTM Software Output Control */
    __IO hw_ftm_pwmload_t PWMLOAD;         /*!< [0x98] FTM PWM Load */
} hw_ftm_t;
#pragma pack()

/*! @brief Macro to access all FTM registers. */
/*! @param x FTM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_FTM_REGS(FTM0_BASE)</code>. */
#define HW_FTM_REGS(x) (*(hw_ftm_t *)(x))

/*
 * MK64F12 GPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - HW_GPIO_PDOR - Port Data Output Register
 * - HW_GPIO_PSOR - Port Set Output Register
 * - HW_GPIO_PCOR - Port Clear Output Register
 * - HW_GPIO_PTOR - Port Toggle Output Register
 * - HW_GPIO_PDIR - Port Data Input Register
 * - HW_GPIO_PDDR - Port Data Direction Register
 *
 * - hw_gpio_t - Struct containing all module registers.
 */

#define HW_GPIO_INSTANCE_COUNT (5U) /*!< Number of instances of the GPIO module. */
#define HW_GPIOA (0U) /*!< Instance number for GPIOA. */
#define HW_GPIOB (1U) /*!< Instance number for GPIOB. */
#define HW_GPIOC (2U) /*!< Instance number for GPIOC. */
#define HW_GPIOD (3U) /*!< Instance number for GPIOD. */
#define HW_GPIOE (4U) /*!< Instance number for GPIOE. */

/*******************************************************************************
 * HW_GPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins. Do not modify pin configuration registers associated with
 * pins not available in your selected package. All unbonded pins not available in
 * your package will default to DISABLE state for lowest power consumption.
 */
typedef union _hw_gpio_pdor
{
    uint32_t U;
    struct _hw_gpio_pdor_bitfields
    {
        uint32_t PDO : 32;             /*!< [31:0] Port Data Output */
    } B;
} hw_gpio_pdor_t;

/*!
 * @name Constants and macros for entire GPIO_PDOR register
 */
/*@{*/
#define HW_GPIO_PDOR_ADDR(x)     ((uint32_t)(x) + 0x0U)

#define HW_GPIO_PDOR(x)          (*(__IO hw_gpio_pdor_t *) HW_GPIO_PDOR_ADDR(x))
#define HW_GPIO_PDOR_RD(x)       (HW_GPIO_PDOR(x).U)
#define HW_GPIO_PDOR_WR(x, v)    (HW_GPIO_PDOR(x).U = (v))
#define HW_GPIO_PDOR_SET(x, v)   (HW_GPIO_PDOR_WR(x, HW_GPIO_PDOR_RD(x) |  (v)))
#define HW_GPIO_PDOR_CLR(x, v)   (HW_GPIO_PDOR_WR(x, HW_GPIO_PDOR_RD(x) & ~(v)))
#define HW_GPIO_PDOR_TOG(x, v)   (HW_GPIO_PDOR_WR(x, HW_GPIO_PDOR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual GPIO_PDOR bitfields
 */

/*!
 * @name Register GPIO_PDOR, field PDO[31:0] (RW)
 *
 * Register bits for unbonded pins return a undefined value when read.
 *
 * Values:
 * - 0 - Logic level 0 is driven on pin, provided pin is configured for
 *     general-purpose output.
 * - 1 - Logic level 1 is driven on pin, provided pin is configured for
 *     general-purpose output.
 */
/*@{*/
#define BP_GPIO_PDOR_PDO     (0U)          /*!< Bit position for GPIO_PDOR_PDO. */
#define BM_GPIO_PDOR_PDO     (0xFFFFFFFFU) /*!< Bit mask for GPIO_PDOR_PDO. */
#define BS_GPIO_PDOR_PDO     (32U)         /*!< Bit field size in bits for GPIO_PDOR_PDO. */

/*! @brief Read current value of the GPIO_PDOR_PDO field. */
#define BR_GPIO_PDOR_PDO(x)  (HW_GPIO_PDOR(x).U)

/*! @brief Format value for bitfield GPIO_PDOR_PDO. */
#define BF_GPIO_PDOR_PDO(v)  ((uint32_t)((uint32_t)(v) << BP_GPIO_PDOR_PDO) & BM_GPIO_PDOR_PDO)

/*! @brief Set the PDO field to a new value. */
#define BW_GPIO_PDOR_PDO(x, v) (HW_GPIO_PDOR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_GPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to set the fields of the PDOR.
 */
typedef union _hw_gpio_psor
{
    uint32_t U;
    struct _hw_gpio_psor_bitfields
    {
        uint32_t PTSO : 32;            /*!< [31:0] Port Set Output */
    } B;
} hw_gpio_psor_t;

/*!
 * @name Constants and macros for entire GPIO_PSOR register
 */
/*@{*/
#define HW_GPIO_PSOR_ADDR(x)     ((uint32_t)(x) + 0x4U)

#define HW_GPIO_PSOR(x)          (*(__O hw_gpio_psor_t *) HW_GPIO_PSOR_ADDR(x))
#define HW_GPIO_PSOR_RD(x)       (HW_GPIO_PSOR(x).U)
#define HW_GPIO_PSOR_WR(x, v)    (HW_GPIO_PSOR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual GPIO_PSOR bitfields
 */

/*!
 * @name Register GPIO_PSOR, field PTSO[31:0] (WORZ)
 *
 * Writing to this register will update the contents of the corresponding bit in
 * the PDOR as follows:
 *
 * Values:
 * - 0 - Corresponding bit in PDORn does not change.
 * - 1 - Corresponding bit in PDORn is set to logic 1.
 */
/*@{*/
#define BP_GPIO_PSOR_PTSO    (0U)          /*!< Bit position for GPIO_PSOR_PTSO. */
#define BM_GPIO_PSOR_PTSO    (0xFFFFFFFFU) /*!< Bit mask for GPIO_PSOR_PTSO. */
#define BS_GPIO_PSOR_PTSO    (32U)         /*!< Bit field size in bits for GPIO_PSOR_PTSO. */

/*! @brief Format value for bitfield GPIO_PSOR_PTSO. */
#define BF_GPIO_PSOR_PTSO(v) ((uint32_t)((uint32_t)(v) << BP_GPIO_PSOR_PTSO) & BM_GPIO_PSOR_PTSO)

/*! @brief Set the PTSO field to a new value. */
#define BW_GPIO_PSOR_PTSO(x, v) (HW_GPIO_PSOR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_GPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to clear the fields of PDOR.
 */
typedef union _hw_gpio_pcor
{
    uint32_t U;
    struct _hw_gpio_pcor_bitfields
    {
        uint32_t PTCO : 32;            /*!< [31:0] Port Clear Output */
    } B;
} hw_gpio_pcor_t;

/*!
 * @name Constants and macros for entire GPIO_PCOR register
 */
/*@{*/
#define HW_GPIO_PCOR_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_GPIO_PCOR(x)          (*(__O hw_gpio_pcor_t *) HW_GPIO_PCOR_ADDR(x))
#define HW_GPIO_PCOR_RD(x)       (HW_GPIO_PCOR(x).U)
#define HW_GPIO_PCOR_WR(x, v)    (HW_GPIO_PCOR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual GPIO_PCOR bitfields
 */

/*!
 * @name Register GPIO_PCOR, field PTCO[31:0] (WORZ)
 *
 * Writing to this register will update the contents of the corresponding bit in
 * the Port Data Output Register (PDOR) as follows:
 *
 * Values:
 * - 0 - Corresponding bit in PDORn does not change.
 * - 1 - Corresponding bit in PDORn is cleared to logic 0.
 */
/*@{*/
#define BP_GPIO_PCOR_PTCO    (0U)          /*!< Bit position for GPIO_PCOR_PTCO. */
#define BM_GPIO_PCOR_PTCO    (0xFFFFFFFFU) /*!< Bit mask for GPIO_PCOR_PTCO. */
#define BS_GPIO_PCOR_PTCO    (32U)         /*!< Bit field size in bits for GPIO_PCOR_PTCO. */

/*! @brief Format value for bitfield GPIO_PCOR_PTCO. */
#define BF_GPIO_PCOR_PTCO(v) ((uint32_t)((uint32_t)(v) << BP_GPIO_PCOR_PTCO) & BM_GPIO_PCOR_PTCO)

/*! @brief Set the PTCO field to a new value. */
#define BW_GPIO_PCOR_PTCO(x, v) (HW_GPIO_PCOR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_GPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_gpio_ptor
{
    uint32_t U;
    struct _hw_gpio_ptor_bitfields
    {
        uint32_t PTTO : 32;            /*!< [31:0] Port Toggle Output */
    } B;
} hw_gpio_ptor_t;

/*!
 * @name Constants and macros for entire GPIO_PTOR register
 */
/*@{*/
#define HW_GPIO_PTOR_ADDR(x)     ((uint32_t)(x) + 0xCU)

#define HW_GPIO_PTOR(x)          (*(__O hw_gpio_ptor_t *) HW_GPIO_PTOR_ADDR(x))
#define HW_GPIO_PTOR_RD(x)       (HW_GPIO_PTOR(x).U)
#define HW_GPIO_PTOR_WR(x, v)    (HW_GPIO_PTOR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual GPIO_PTOR bitfields
 */

/*!
 * @name Register GPIO_PTOR, field PTTO[31:0] (WORZ)
 *
 * Writing to this register will update the contents of the corresponding bit in
 * the PDOR as follows:
 *
 * Values:
 * - 0 - Corresponding bit in PDORn does not change.
 * - 1 - Corresponding bit in PDORn is set to the inverse of its existing logic
 *     state.
 */
/*@{*/
#define BP_GPIO_PTOR_PTTO    (0U)          /*!< Bit position for GPIO_PTOR_PTTO. */
#define BM_GPIO_PTOR_PTTO    (0xFFFFFFFFU) /*!< Bit mask for GPIO_PTOR_PTTO. */
#define BS_GPIO_PTOR_PTTO    (32U)         /*!< Bit field size in bits for GPIO_PTOR_PTTO. */

/*! @brief Format value for bitfield GPIO_PTOR_PTTO. */
#define BF_GPIO_PTOR_PTTO(v) ((uint32_t)((uint32_t)(v) << BP_GPIO_PTOR_PTTO) & BM_GPIO_PTOR_PTTO)

/*! @brief Set the PTTO field to a new value. */
#define BW_GPIO_PTOR_PTTO(x, v) (HW_GPIO_PTOR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_GPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Do not modify pin configuration registers associated with pins not available
 * in your selected package. All unbonded pins not available in your package will
 * default to DISABLE state for lowest power consumption.
 */
typedef union _hw_gpio_pdir
{
    uint32_t U;
    struct _hw_gpio_pdir_bitfields
    {
        uint32_t PDI : 32;             /*!< [31:0] Port Data Input */
    } B;
} hw_gpio_pdir_t;

/*!
 * @name Constants and macros for entire GPIO_PDIR register
 */
/*@{*/
#define HW_GPIO_PDIR_ADDR(x)     ((uint32_t)(x) + 0x10U)

#define HW_GPIO_PDIR(x)          (*(__I hw_gpio_pdir_t *) HW_GPIO_PDIR_ADDR(x))
#define HW_GPIO_PDIR_RD(x)       (HW_GPIO_PDIR(x).U)
/*@}*/

/*
 * Constants & macros for individual GPIO_PDIR bitfields
 */

/*!
 * @name Register GPIO_PDIR, field PDI[31:0] (RO)
 *
 * Reads 0 at the unimplemented pins for a particular device. Pins that are not
 * configured for a digital function read 0. If the Port Control and Interrupt
 * module is disabled, then the corresponding bit in PDIR does not update.
 *
 * Values:
 * - 0 - Pin logic level is logic 0, or is not configured for use by digital
 *     function.
 * - 1 - Pin logic level is logic 1.
 */
/*@{*/
#define BP_GPIO_PDIR_PDI     (0U)          /*!< Bit position for GPIO_PDIR_PDI. */
#define BM_GPIO_PDIR_PDI     (0xFFFFFFFFU) /*!< Bit mask for GPIO_PDIR_PDI. */
#define BS_GPIO_PDIR_PDI     (32U)         /*!< Bit field size in bits for GPIO_PDIR_PDI. */

/*! @brief Read current value of the GPIO_PDIR_PDI field. */
#define BR_GPIO_PDIR_PDI(x)  (HW_GPIO_PDIR(x).U)
/*@}*/

/*******************************************************************************
 * HW_GPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief HW_GPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
typedef union _hw_gpio_pddr
{
    uint32_t U;
    struct _hw_gpio_pddr_bitfields
    {
        uint32_t PDD : 32;             /*!< [31:0] Port Data Direction */
    } B;
} hw_gpio_pddr_t;

/*!
 * @name Constants and macros for entire GPIO_PDDR register
 */
/*@{*/
#define HW_GPIO_PDDR_ADDR(x)     ((uint32_t)(x) + 0x14U)

#define HW_GPIO_PDDR(x)          (*(__IO hw_gpio_pddr_t *) HW_GPIO_PDDR_ADDR(x))
#define HW_GPIO_PDDR_RD(x)       (HW_GPIO_PDDR(x).U)
#define HW_GPIO_PDDR_WR(x, v)    (HW_GPIO_PDDR(x).U = (v))
#define HW_GPIO_PDDR_SET(x, v)   (HW_GPIO_PDDR_WR(x, HW_GPIO_PDDR_RD(x) |  (v)))
#define HW_GPIO_PDDR_CLR(x, v)   (HW_GPIO_PDDR_WR(x, HW_GPIO_PDDR_RD(x) & ~(v)))
#define HW_GPIO_PDDR_TOG(x, v)   (HW_GPIO_PDDR_WR(x, HW_GPIO_PDDR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual GPIO_PDDR bitfields
 */

/*!
 * @name Register GPIO_PDDR, field PDD[31:0] (RW)
 *
 * Configures individual port pins for input or output.
 *
 * Values:
 * - 0 - Pin is configured as general-purpose input, for the GPIO function.
 * - 1 - Pin is configured as general-purpose output, for the GPIO function.
 */
/*@{*/
#define BP_GPIO_PDDR_PDD     (0U)          /*!< Bit position for GPIO_PDDR_PDD. */
#define BM_GPIO_PDDR_PDD     (0xFFFFFFFFU) /*!< Bit mask for GPIO_PDDR_PDD. */
#define BS_GPIO_PDDR_PDD     (32U)         /*!< Bit field size in bits for GPIO_PDDR_PDD. */

/*! @brief Read current value of the GPIO_PDDR_PDD field. */
#define BR_GPIO_PDDR_PDD(x)  (HW_GPIO_PDDR(x).U)

/*! @brief Format value for bitfield GPIO_PDDR_PDD. */
#define BF_GPIO_PDDR_PDD(v)  ((uint32_t)((uint32_t)(v) << BP_GPIO_PDDR_PDD) & BM_GPIO_PDDR_PDD)

/*! @brief Set the PDD field to a new value. */
#define BW_GPIO_PDDR_PDD(x, v) (HW_GPIO_PDDR_WR(x, v))
/*@}*/

/*******************************************************************************
 * hw_gpio_t - module struct
 ******************************************************************************/
/*!
 * @brief All GPIO module registers.
 */
#pragma pack(1)
typedef struct _hw_gpio
{
    __IO hw_gpio_pdor_t PDOR;              /*!< [0x0] Port Data Output Register */
    __O hw_gpio_psor_t PSOR;               /*!< [0x4] Port Set Output Register */
    __O hw_gpio_pcor_t PCOR;               /*!< [0x8] Port Clear Output Register */
    __O hw_gpio_ptor_t PTOR;               /*!< [0xC] Port Toggle Output Register */
    __I hw_gpio_pdir_t PDIR;               /*!< [0x10] Port Data Input Register */
    __IO hw_gpio_pddr_t PDDR;              /*!< [0x14] Port Data Direction Register */
} hw_gpio_t;
#pragma pack()

/*! @brief Macro to access all GPIO registers. */
/*! @param x GPIO module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_GPIO_REGS(PTA_BASE)</code>. */
#define HW_GPIO_REGS(x) (*(hw_gpio_t *)(x))

/*
 * MK64F12 I2C
 *
 * Inter-Integrated Circuit
 *
 * Registers defined in this header file:
 * - HW_I2C_A1 - I2C Address Register 1
 * - HW_I2C_F - I2C Frequency Divider register
 * - HW_I2C_C1 - I2C Control Register 1
 * - HW_I2C_S - I2C Status register
 * - HW_I2C_D - I2C Data I/O register
 * - HW_I2C_C2 - I2C Control Register 2
 * - HW_I2C_FLT - I2C Programmable Input Glitch Filter register
 * - HW_I2C_RA - I2C Range Address register
 * - HW_I2C_SMB - I2C SMBus Control and Status register
 * - HW_I2C_A2 - I2C Address Register 2
 * - HW_I2C_SLTH - I2C SCL Low Timeout Register High
 * - HW_I2C_SLTL - I2C SCL Low Timeout Register Low
 *
 * - hw_i2c_t - Struct containing all module registers.
 */

#define HW_I2C_INSTANCE_COUNT (3U) /*!< Number of instances of the I2C module. */
#define HW_I2C0 (0U) /*!< Instance number for I2C0. */
#define HW_I2C1 (1U) /*!< Instance number for I2C1. */
#define HW_I2C2 (2U) /*!< Instance number for I2C2. */

/*******************************************************************************
 * HW_I2C_A1 - I2C Address Register 1
 ******************************************************************************/

/*!
 * @brief HW_I2C_A1 - I2C Address Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the slave address to be used by the I2C module.
 */
typedef union _hw_i2c_a1
{
    uint8_t U;
    struct _hw_i2c_a1_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t AD : 7;                /*!< [7:1] Address */
    } B;
} hw_i2c_a1_t;

/*!
 * @name Constants and macros for entire I2C_A1 register
 */
/*@{*/
#define HW_I2C_A1_ADDR(x)        ((uint32_t)(x) + 0x0U)

#define HW_I2C_A1(x)             (*(__IO hw_i2c_a1_t *) HW_I2C_A1_ADDR(x))
#define HW_I2C_A1_RD(x)          (HW_I2C_A1(x).U)
#define HW_I2C_A1_WR(x, v)       (HW_I2C_A1(x).U = (v))
#define HW_I2C_A1_SET(x, v)      (HW_I2C_A1_WR(x, HW_I2C_A1_RD(x) |  (v)))
#define HW_I2C_A1_CLR(x, v)      (HW_I2C_A1_WR(x, HW_I2C_A1_RD(x) & ~(v)))
#define HW_I2C_A1_TOG(x, v)      (HW_I2C_A1_WR(x, HW_I2C_A1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_A1 bitfields
 */

/*!
 * @name Register I2C_A1, field AD[7:1] (RW)
 *
 * Contains the primary slave address used by the I2C module when it is
 * addressed as a slave. This field is used in the 7-bit address scheme and the lower
 * seven bits in the 10-bit address scheme.
 */
/*@{*/
#define BP_I2C_A1_AD         (1U)          /*!< Bit position for I2C_A1_AD. */
#define BM_I2C_A1_AD         (0xFEU)       /*!< Bit mask for I2C_A1_AD. */
#define BS_I2C_A1_AD         (7U)          /*!< Bit field size in bits for I2C_A1_AD. */

/*! @brief Read current value of the I2C_A1_AD field. */
#define BR_I2C_A1_AD(x)      (HW_I2C_A1(x).B.AD)

/*! @brief Format value for bitfield I2C_A1_AD. */
#define BF_I2C_A1_AD(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_A1_AD) & BM_I2C_A1_AD)

/*! @brief Set the AD field to a new value. */
#define BW_I2C_A1_AD(x, v)   (HW_I2C_A1_WR(x, (HW_I2C_A1_RD(x) & ~BM_I2C_A1_AD) | BF_I2C_A1_AD(v)))
/*@}*/

/*******************************************************************************
 * HW_I2C_F - I2C Frequency Divider register
 ******************************************************************************/

/*!
 * @brief HW_I2C_F - I2C Frequency Divider register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_f
{
    uint8_t U;
    struct _hw_i2c_f_bitfields
    {
        uint8_t ICR : 6;               /*!< [5:0] ClockRate */
        uint8_t MULT : 2;              /*!< [7:6] Multiplier Factor */
    } B;
} hw_i2c_f_t;

/*!
 * @name Constants and macros for entire I2C_F register
 */
/*@{*/
#define HW_I2C_F_ADDR(x)         ((uint32_t)(x) + 0x1U)

#define HW_I2C_F(x)              (*(__IO hw_i2c_f_t *) HW_I2C_F_ADDR(x))
#define HW_I2C_F_RD(x)           (HW_I2C_F(x).U)
#define HW_I2C_F_WR(x, v)        (HW_I2C_F(x).U = (v))
#define HW_I2C_F_SET(x, v)       (HW_I2C_F_WR(x, HW_I2C_F_RD(x) |  (v)))
#define HW_I2C_F_CLR(x, v)       (HW_I2C_F_WR(x, HW_I2C_F_RD(x) & ~(v)))
#define HW_I2C_F_TOG(x, v)       (HW_I2C_F_WR(x, HW_I2C_F_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_F bitfields
 */

/*!
 * @name Register I2C_F, field ICR[5:0] (RW)
 *
 * Prescales the I2C module clock for bit rate selection. This field and the
 * MULT field determine the I2C baud rate, the SDA hold time, the SCL start hold
 * time, and the SCL stop hold time. For a list of values corresponding to each ICR
 * setting, see I2C divider and hold values. The SCL divider multiplied by
 * multiplier factor (mul) determines the I2C baud rate. I2C baud rate = I2C module
 * clock speed (Hz)/(mul * SCL divider) The SDA hold time is the delay from the
 * falling edge of SCL (I2C clock) to the changing of SDA (I2C data). SDA hold time =
 * I2C module clock period (s) * mul * SDA hold value The SCL start hold time is
 * the delay from the falling edge of SDA (I2C data) while SCL is high (start
 * condition) to the falling edge of SCL (I2C clock). SCL start hold time = I2C
 * module clock period (s) * mul * SCL start hold value The SCL stop hold time is
 * the delay from the rising edge of SCL (I2C clock) to the rising edge of SDA (I2C
 * data) while SCL is high (stop condition). SCL stop hold time = I2C module
 * clock period (s) * mul * SCL stop hold value For example, if the I2C module clock
 * speed is 8 MHz, the following table shows the possible hold time values with
 * different ICR and MULT selections to achieve an I2C baud rate of 100 kbit/s.
 * MULT ICR Hold times (us) SDA SCL Start SCL Stop 2h 00h 3.500 3.000 5.500 1h 07h
 * 2.500 4.000 5.250 1h 0Bh 2.250 4.000 5.250 0h 14h 2.125 4.250 5.125 0h 18h
 * 1.125 4.750 5.125
 */
/*@{*/
#define BP_I2C_F_ICR         (0U)          /*!< Bit position for I2C_F_ICR. */
#define BM_I2C_F_ICR         (0x3FU)       /*!< Bit mask for I2C_F_ICR. */
#define BS_I2C_F_ICR         (6U)          /*!< Bit field size in bits for I2C_F_ICR. */

/*! @brief Read current value of the I2C_F_ICR field. */
#define BR_I2C_F_ICR(x)      (HW_I2C_F(x).B.ICR)

/*! @brief Format value for bitfield I2C_F_ICR. */
#define BF_I2C_F_ICR(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_F_ICR) & BM_I2C_F_ICR)

/*! @brief Set the ICR field to a new value. */
#define BW_I2C_F_ICR(x, v)   (HW_I2C_F_WR(x, (HW_I2C_F_RD(x) & ~BM_I2C_F_ICR) | BF_I2C_F_ICR(v)))
/*@}*/

/*!
 * @name Register I2C_F, field MULT[7:6] (RW)
 *
 * Defines the multiplier factor (mul). This factor is used along with the SCL
 * divider to generate the I2C baud rate.
 *
 * Values:
 * - 00 - mul = 1
 * - 01 - mul = 2
 * - 10 - mul = 4
 * - 11 - Reserved
 */
/*@{*/
#define BP_I2C_F_MULT        (6U)          /*!< Bit position for I2C_F_MULT. */
#define BM_I2C_F_MULT        (0xC0U)       /*!< Bit mask for I2C_F_MULT. */
#define BS_I2C_F_MULT        (2U)          /*!< Bit field size in bits for I2C_F_MULT. */

/*! @brief Read current value of the I2C_F_MULT field. */
#define BR_I2C_F_MULT(x)     (HW_I2C_F(x).B.MULT)

/*! @brief Format value for bitfield I2C_F_MULT. */
#define BF_I2C_F_MULT(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_F_MULT) & BM_I2C_F_MULT)

/*! @brief Set the MULT field to a new value. */
#define BW_I2C_F_MULT(x, v)  (HW_I2C_F_WR(x, (HW_I2C_F_RD(x) & ~BM_I2C_F_MULT) | BF_I2C_F_MULT(v)))
/*@}*/

/*******************************************************************************
 * HW_I2C_C1 - I2C Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_I2C_C1 - I2C Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_c1
{
    uint8_t U;
    struct _hw_i2c_c1_bitfields
    {
        uint8_t DMAEN : 1;             /*!< [0] DMA Enable */
        uint8_t WUEN : 1;              /*!< [1] Wakeup Enable */
        uint8_t RSTA : 1;              /*!< [2] Repeat START */
        uint8_t TXAK : 1;              /*!< [3] Transmit Acknowledge Enable */
        uint8_t TX : 1;                /*!< [4] Transmit Mode Select */
        uint8_t MST : 1;               /*!< [5] Master Mode Select */
        uint8_t IICIE : 1;             /*!< [6] I2C Interrupt Enable */
        uint8_t IICEN : 1;             /*!< [7] I2C Enable */
    } B;
} hw_i2c_c1_t;

/*!
 * @name Constants and macros for entire I2C_C1 register
 */
/*@{*/
#define HW_I2C_C1_ADDR(x)        ((uint32_t)(x) + 0x2U)

#define HW_I2C_C1(x)             (*(__IO hw_i2c_c1_t *) HW_I2C_C1_ADDR(x))
#define HW_I2C_C1_RD(x)          (HW_I2C_C1(x).U)
#define HW_I2C_C1_WR(x, v)       (HW_I2C_C1(x).U = (v))
#define HW_I2C_C1_SET(x, v)      (HW_I2C_C1_WR(x, HW_I2C_C1_RD(x) |  (v)))
#define HW_I2C_C1_CLR(x, v)      (HW_I2C_C1_WR(x, HW_I2C_C1_RD(x) & ~(v)))
#define HW_I2C_C1_TOG(x, v)      (HW_I2C_C1_WR(x, HW_I2C_C1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_C1 bitfields
 */

/*!
 * @name Register I2C_C1, field DMAEN[0] (RW)
 *
 * Enables or disables the DMA function.
 *
 * Values:
 * - 0 - All DMA signalling disabled.
 * - 1 - DMA transfer is enabled. While SMB[FACK] = 0, the following conditions
 *     trigger the DMA request: a data byte is received, and either address or
 *     data is transmitted. (ACK/NACK is automatic) the first byte received matches
 *     the A1 register or is a general call address. If any address matching
 *     occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known
 *     from master to slave, then it is not required to check S[SRW]. With this
 *     assumption, DMA can also be used in this case. In other cases, if the master
 *     reads data from the slave, then it is required to rewrite the C1 register
 *     operation. With this assumption, DMA cannot be used. When FACK = 1, an
 *     address or a data byte is transmitted.
 */
/*@{*/
#define BP_I2C_C1_DMAEN      (0U)          /*!< Bit position for I2C_C1_DMAEN. */
#define BM_I2C_C1_DMAEN      (0x01U)       /*!< Bit mask for I2C_C1_DMAEN. */
#define BS_I2C_C1_DMAEN      (1U)          /*!< Bit field size in bits for I2C_C1_DMAEN. */

/*! @brief Read current value of the I2C_C1_DMAEN field. */
#define BR_I2C_C1_DMAEN(x)   (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_DMAEN))

/*! @brief Format value for bitfield I2C_C1_DMAEN. */
#define BF_I2C_C1_DMAEN(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C1_DMAEN) & BM_I2C_C1_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_I2C_C1_DMAEN(x, v) (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_DMAEN) = (v))
/*@}*/

/*!
 * @name Register I2C_C1, field WUEN[1] (RW)
 *
 * The I2C module can wake the MCU from low power mode with no peripheral bus
 * running when slave address matching occurs.
 *
 * Values:
 * - 0 - Normal operation. No interrupt generated when address matching in low
 *     power mode.
 * - 1 - Enables the wakeup function in low power mode.
 */
/*@{*/
#define BP_I2C_C1_WUEN       (1U)          /*!< Bit position for I2C_C1_WUEN. */
#define BM_I2C_C1_WUEN       (0x02U)       /*!< Bit mask for I2C_C1_WUEN. */
#define BS_I2C_C1_WUEN       (1U)          /*!< Bit field size in bits for I2C_C1_WUEN. */

/*! @brief Read current value of the I2C_C1_WUEN field. */
#define BR_I2C_C1_WUEN(x)    (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_WUEN))

/*! @brief Format value for bitfield I2C_C1_WUEN. */
#define BF_I2C_C1_WUEN(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C1_WUEN) & BM_I2C_C1_WUEN)

/*! @brief Set the WUEN field to a new value. */
#define BW_I2C_C1_WUEN(x, v) (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_WUEN) = (v))
/*@}*/

/*!
 * @name Register I2C_C1, field RSTA[2] (WORZ)
 *
 * Writing 1 to this bit generates a repeated START condition provided it is the
 * current master. This bit will always be read as 0. Attempting a repeat at the
 * wrong time results in loss of arbitration.
 */
/*@{*/
#define BP_I2C_C1_RSTA       (2U)          /*!< Bit position for I2C_C1_RSTA. */
#define BM_I2C_C1_RSTA       (0x04U)       /*!< Bit mask for I2C_C1_RSTA. */
#define BS_I2C_C1_RSTA       (1U)          /*!< Bit field size in bits for I2C_C1_RSTA. */

/*! @brief Format value for bitfield I2C_C1_RSTA. */
#define BF_I2C_C1_RSTA(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C1_RSTA) & BM_I2C_C1_RSTA)

/*! @brief Set the RSTA field to a new value. */
#define BW_I2C_C1_RSTA(x, v) (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_RSTA) = (v))
/*@}*/

/*!
 * @name Register I2C_C1, field TXAK[3] (RW)
 *
 * Specifies the value driven onto the SDA during data acknowledge cycles for
 * both master and slave receivers. The value of SMB[FACK] affects NACK/ACK
 * generation. SCL is held low until TXAK is written.
 *
 * Values:
 * - 0 - An acknowledge signal is sent to the bus on the following receiving
 *     byte (if FACK is cleared) or the current receiving byte (if FACK is set).
 * - 1 - No acknowledge signal is sent to the bus on the following receiving
 *     data byte (if FACK is cleared) or the current receiving data byte (if FACK is
 *     set).
 */
/*@{*/
#define BP_I2C_C1_TXAK       (3U)          /*!< Bit position for I2C_C1_TXAK. */
#define BM_I2C_C1_TXAK       (0x08U)       /*!< Bit mask for I2C_C1_TXAK. */
#define BS_I2C_C1_TXAK       (1U)          /*!< Bit field size in bits for I2C_C1_TXAK. */

/*! @brief Read current value of the I2C_C1_TXAK field. */
#define BR_I2C_C1_TXAK(x)    (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_TXAK))

/*! @brief Format value for bitfield I2C_C1_TXAK. */
#define BF_I2C_C1_TXAK(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C1_TXAK) & BM_I2C_C1_TXAK)

/*! @brief Set the TXAK field to a new value. */
#define BW_I2C_C1_TXAK(x, v) (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_TXAK) = (v))
/*@}*/

/*!
 * @name Register I2C_C1, field TX[4] (RW)
 *
 * Selects the direction of master and slave transfers. In master mode this bit
 * must be set according to the type of transfer required. Therefore, for address
 * cycles, this bit is always set. When addressed as a slave this bit must be
 * set by software according to the SRW bit in the status register.
 *
 * Values:
 * - 0 - Receive
 * - 1 - Transmit
 */
/*@{*/
#define BP_I2C_C1_TX         (4U)          /*!< Bit position for I2C_C1_TX. */
#define BM_I2C_C1_TX         (0x10U)       /*!< Bit mask for I2C_C1_TX. */
#define BS_I2C_C1_TX         (1U)          /*!< Bit field size in bits for I2C_C1_TX. */

/*! @brief Read current value of the I2C_C1_TX field. */
#define BR_I2C_C1_TX(x)      (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_TX))

/*! @brief Format value for bitfield I2C_C1_TX. */
#define BF_I2C_C1_TX(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_C1_TX) & BM_I2C_C1_TX)

/*! @brief Set the TX field to a new value. */
#define BW_I2C_C1_TX(x, v)   (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_TX) = (v))
/*@}*/

/*!
 * @name Register I2C_C1, field MST[5] (RW)
 *
 * When MST is changed from 0 to 1, a START signal is generated on the bus and
 * master mode is selected. When this bit changes from 1 to 0, a STOP signal is
 * generated and the mode of operation changes from master to slave.
 *
 * Values:
 * - 0 - Slave mode
 * - 1 - Master mode
 */
/*@{*/
#define BP_I2C_C1_MST        (5U)          /*!< Bit position for I2C_C1_MST. */
#define BM_I2C_C1_MST        (0x20U)       /*!< Bit mask for I2C_C1_MST. */
#define BS_I2C_C1_MST        (1U)          /*!< Bit field size in bits for I2C_C1_MST. */

/*! @brief Read current value of the I2C_C1_MST field. */
#define BR_I2C_C1_MST(x)     (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_MST))

/*! @brief Format value for bitfield I2C_C1_MST. */
#define BF_I2C_C1_MST(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_C1_MST) & BM_I2C_C1_MST)

/*! @brief Set the MST field to a new value. */
#define BW_I2C_C1_MST(x, v)  (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_MST) = (v))
/*@}*/

/*!
 * @name Register I2C_C1, field IICIE[6] (RW)
 *
 * Enables I2C interrupt requests.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_I2C_C1_IICIE      (6U)          /*!< Bit position for I2C_C1_IICIE. */
#define BM_I2C_C1_IICIE      (0x40U)       /*!< Bit mask for I2C_C1_IICIE. */
#define BS_I2C_C1_IICIE      (1U)          /*!< Bit field size in bits for I2C_C1_IICIE. */

/*! @brief Read current value of the I2C_C1_IICIE field. */
#define BR_I2C_C1_IICIE(x)   (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_IICIE))

/*! @brief Format value for bitfield I2C_C1_IICIE. */
#define BF_I2C_C1_IICIE(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C1_IICIE) & BM_I2C_C1_IICIE)

/*! @brief Set the IICIE field to a new value. */
#define BW_I2C_C1_IICIE(x, v) (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_IICIE) = (v))
/*@}*/

/*!
 * @name Register I2C_C1, field IICEN[7] (RW)
 *
 * Enables I2C module operation.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_I2C_C1_IICEN      (7U)          /*!< Bit position for I2C_C1_IICEN. */
#define BM_I2C_C1_IICEN      (0x80U)       /*!< Bit mask for I2C_C1_IICEN. */
#define BS_I2C_C1_IICEN      (1U)          /*!< Bit field size in bits for I2C_C1_IICEN. */

/*! @brief Read current value of the I2C_C1_IICEN field. */
#define BR_I2C_C1_IICEN(x)   (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_IICEN))

/*! @brief Format value for bitfield I2C_C1_IICEN. */
#define BF_I2C_C1_IICEN(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C1_IICEN) & BM_I2C_C1_IICEN)

/*! @brief Set the IICEN field to a new value. */
#define BW_I2C_C1_IICEN(x, v) (BITBAND_ACCESS8(HW_I2C_C1_ADDR(x), BP_I2C_C1_IICEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_I2C_S - I2C Status register
 ******************************************************************************/

/*!
 * @brief HW_I2C_S - I2C Status register (RW)
 *
 * Reset value: 0x80U
 */
typedef union _hw_i2c_s
{
    uint8_t U;
    struct _hw_i2c_s_bitfields
    {
        uint8_t RXAK : 1;              /*!< [0] Receive Acknowledge */
        uint8_t IICIF : 1;             /*!< [1] Interrupt Flag */
        uint8_t SRW : 1;               /*!< [2] Slave Read/Write */
        uint8_t RAM : 1;               /*!< [3] Range Address Match */
        uint8_t ARBL : 1;              /*!< [4] Arbitration Lost */
        uint8_t BUSY : 1;              /*!< [5] Bus Busy */
        uint8_t IAAS : 1;              /*!< [6] Addressed As A Slave */
        uint8_t TCF : 1;               /*!< [7] Transfer Complete Flag */
    } B;
} hw_i2c_s_t;

/*!
 * @name Constants and macros for entire I2C_S register
 */
/*@{*/
#define HW_I2C_S_ADDR(x)         ((uint32_t)(x) + 0x3U)

#define HW_I2C_S(x)              (*(__IO hw_i2c_s_t *) HW_I2C_S_ADDR(x))
#define HW_I2C_S_RD(x)           (HW_I2C_S(x).U)
#define HW_I2C_S_WR(x, v)        (HW_I2C_S(x).U = (v))
#define HW_I2C_S_SET(x, v)       (HW_I2C_S_WR(x, HW_I2C_S_RD(x) |  (v)))
#define HW_I2C_S_CLR(x, v)       (HW_I2C_S_WR(x, HW_I2C_S_RD(x) & ~(v)))
#define HW_I2C_S_TOG(x, v)       (HW_I2C_S_WR(x, HW_I2C_S_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_S bitfields
 */

/*!
 * @name Register I2C_S, field RXAK[0] (RO)
 *
 * Values:
 * - 0 - Acknowledge signal was received after the completion of one byte of
 *     data transmission on the bus
 * - 1 - No acknowledge signal detected
 */
/*@{*/
#define BP_I2C_S_RXAK        (0U)          /*!< Bit position for I2C_S_RXAK. */
#define BM_I2C_S_RXAK        (0x01U)       /*!< Bit mask for I2C_S_RXAK. */
#define BS_I2C_S_RXAK        (1U)          /*!< Bit field size in bits for I2C_S_RXAK. */

/*! @brief Read current value of the I2C_S_RXAK field. */
#define BR_I2C_S_RXAK(x)     (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_RXAK))
/*@}*/

/*!
 * @name Register I2C_S, field IICIF[1] (W1C)
 *
 * This bit sets when an interrupt is pending. This bit must be cleared by
 * software by writing 1 to it, such as in the interrupt routine. One of the following
 * events can set this bit: One byte transfer, including ACK/NACK bit, completes
 * if FACK is 0. An ACK or NACK is sent on the bus by writing 0 or 1 to TXAK
 * after this bit is set in receive mode. One byte transfer, excluding ACK/NACK bit,
 * completes if FACK is 1. Match of slave address to calling address including
 * primary slave address, range slave address , alert response address, second
 * slave address, or general call address. Arbitration lost In SMBus mode, any
 * timeouts except SCL and SDA high timeouts I2C bus stop or start detection if the
 * SSIE bit in the Input Glitch Filter register is 1 To clear the I2C bus stop or
 * start detection interrupt: In the interrupt service routine, first clear the
 * STOPF or STARTF bit in the Input Glitch Filter register by writing 1 to it, and
 * then clear the IICIF bit. If this sequence is reversed, the IICIF bit is
 * asserted again.
 *
 * Values:
 * - 0 - No interrupt pending
 * - 1 - Interrupt pending
 */
/*@{*/
#define BP_I2C_S_IICIF       (1U)          /*!< Bit position for I2C_S_IICIF. */
#define BM_I2C_S_IICIF       (0x02U)       /*!< Bit mask for I2C_S_IICIF. */
#define BS_I2C_S_IICIF       (1U)          /*!< Bit field size in bits for I2C_S_IICIF. */

/*! @brief Read current value of the I2C_S_IICIF field. */
#define BR_I2C_S_IICIF(x)    (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_IICIF))

/*! @brief Format value for bitfield I2C_S_IICIF. */
#define BF_I2C_S_IICIF(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_S_IICIF) & BM_I2C_S_IICIF)

/*! @brief Set the IICIF field to a new value. */
#define BW_I2C_S_IICIF(x, v) (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_IICIF) = (v))
/*@}*/

/*!
 * @name Register I2C_S, field SRW[2] (RO)
 *
 * When addressed as a slave, SRW indicates the value of the R/W command bit of
 * the calling address sent to the master.
 *
 * Values:
 * - 0 - Slave receive, master writing to slave
 * - 1 - Slave transmit, master reading from slave
 */
/*@{*/
#define BP_I2C_S_SRW         (2U)          /*!< Bit position for I2C_S_SRW. */
#define BM_I2C_S_SRW         (0x04U)       /*!< Bit mask for I2C_S_SRW. */
#define BS_I2C_S_SRW         (1U)          /*!< Bit field size in bits for I2C_S_SRW. */

/*! @brief Read current value of the I2C_S_SRW field. */
#define BR_I2C_S_SRW(x)      (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_SRW))
/*@}*/

/*!
 * @name Register I2C_S, field RAM[3] (RW)
 *
 * This bit is set to 1 by any of the following conditions, if I2C_C2[RMEN] = 1:
 * Any nonzero calling address is received that matches the address in the RA
 * register. The calling address is within the range of values of the A1 and RA
 * registers. For the RAM bit to be set to 1 correctly, C1[IICIE] must be set to 1.
 * Writing the C1 register with any value clears this bit to 0.
 *
 * Values:
 * - 0 - Not addressed
 * - 1 - Addressed as a slave
 */
/*@{*/
#define BP_I2C_S_RAM         (3U)          /*!< Bit position for I2C_S_RAM. */
#define BM_I2C_S_RAM         (0x08U)       /*!< Bit mask for I2C_S_RAM. */
#define BS_I2C_S_RAM         (1U)          /*!< Bit field size in bits for I2C_S_RAM. */

/*! @brief Read current value of the I2C_S_RAM field. */
#define BR_I2C_S_RAM(x)      (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_RAM))

/*! @brief Format value for bitfield I2C_S_RAM. */
#define BF_I2C_S_RAM(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_S_RAM) & BM_I2C_S_RAM)

/*! @brief Set the RAM field to a new value. */
#define BW_I2C_S_RAM(x, v)   (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_RAM) = (v))
/*@}*/

/*!
 * @name Register I2C_S, field ARBL[4] (W1C)
 *
 * This bit is set by hardware when the arbitration procedure is lost. The ARBL
 * bit must be cleared by software, by writing 1 to it.
 *
 * Values:
 * - 0 - Standard bus operation.
 * - 1 - Loss of arbitration.
 */
/*@{*/
#define BP_I2C_S_ARBL        (4U)          /*!< Bit position for I2C_S_ARBL. */
#define BM_I2C_S_ARBL        (0x10U)       /*!< Bit mask for I2C_S_ARBL. */
#define BS_I2C_S_ARBL        (1U)          /*!< Bit field size in bits for I2C_S_ARBL. */

/*! @brief Read current value of the I2C_S_ARBL field. */
#define BR_I2C_S_ARBL(x)     (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_ARBL))

/*! @brief Format value for bitfield I2C_S_ARBL. */
#define BF_I2C_S_ARBL(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_S_ARBL) & BM_I2C_S_ARBL)

/*! @brief Set the ARBL field to a new value. */
#define BW_I2C_S_ARBL(x, v)  (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_ARBL) = (v))
/*@}*/

/*!
 * @name Register I2C_S, field BUSY[5] (RO)
 *
 * Indicates the status of the bus regardless of slave or master mode. This bit
 * is set when a START signal is detected and cleared when a STOP signal is
 * detected.
 *
 * Values:
 * - 0 - Bus is idle
 * - 1 - Bus is busy
 */
/*@{*/
#define BP_I2C_S_BUSY        (5U)          /*!< Bit position for I2C_S_BUSY. */
#define BM_I2C_S_BUSY        (0x20U)       /*!< Bit mask for I2C_S_BUSY. */
#define BS_I2C_S_BUSY        (1U)          /*!< Bit field size in bits for I2C_S_BUSY. */

/*! @brief Read current value of the I2C_S_BUSY field. */
#define BR_I2C_S_BUSY(x)     (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_BUSY))
/*@}*/

/*!
 * @name Register I2C_S, field IAAS[6] (RW)
 *
 * This bit is set by one of the following conditions: The calling address
 * matches the programmed primary slave address in the A1 register, or matches the
 * range address in the RA register (which must be set to a nonzero value and under
 * the condition I2C_C2[RMEN] = 1). C2[GCAEN] is set and a general call is
 * received. SMB[SIICAEN] is set and the calling address matches the second programmed
 * slave address. ALERTEN is set and an SMBus alert response address is received
 * RMEN is set and an address is received that is within the range between the
 * values of the A1 and RA registers. IAAS sets before the ACK bit. The CPU must
 * check the SRW bit and set TX/RX accordingly. Writing the C1 register with any
 * value clears this bit.
 *
 * Values:
 * - 0 - Not addressed
 * - 1 - Addressed as a slave
 */
/*@{*/
#define BP_I2C_S_IAAS        (6U)          /*!< Bit position for I2C_S_IAAS. */
#define BM_I2C_S_IAAS        (0x40U)       /*!< Bit mask for I2C_S_IAAS. */
#define BS_I2C_S_IAAS        (1U)          /*!< Bit field size in bits for I2C_S_IAAS. */

/*! @brief Read current value of the I2C_S_IAAS field. */
#define BR_I2C_S_IAAS(x)     (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_IAAS))

/*! @brief Format value for bitfield I2C_S_IAAS. */
#define BF_I2C_S_IAAS(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_S_IAAS) & BM_I2C_S_IAAS)

/*! @brief Set the IAAS field to a new value. */
#define BW_I2C_S_IAAS(x, v)  (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_IAAS) = (v))
/*@}*/

/*!
 * @name Register I2C_S, field TCF[7] (RO)
 *
 * Acknowledges a byte transfer; TCF sets on the completion of a byte transfer.
 * This bit is valid only during or immediately following a transfer to or from
 * the I2C module. TCF is cleared by reading the I2C data register in receive mode
 * or by writing to the I2C data register in transmit mode.
 *
 * Values:
 * - 0 - Transfer in progress
 * - 1 - Transfer complete
 */
/*@{*/
#define BP_I2C_S_TCF         (7U)          /*!< Bit position for I2C_S_TCF. */
#define BM_I2C_S_TCF         (0x80U)       /*!< Bit mask for I2C_S_TCF. */
#define BS_I2C_S_TCF         (1U)          /*!< Bit field size in bits for I2C_S_TCF. */

/*! @brief Read current value of the I2C_S_TCF field. */
#define BR_I2C_S_TCF(x)      (BITBAND_ACCESS8(HW_I2C_S_ADDR(x), BP_I2C_S_TCF))
/*@}*/

/*******************************************************************************
 * HW_I2C_D - I2C Data I/O register
 ******************************************************************************/

/*!
 * @brief HW_I2C_D - I2C Data I/O register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_d
{
    uint8_t U;
    struct _hw_i2c_d_bitfields
    {
        uint8_t DATA : 8;              /*!< [7:0] Data */
    } B;
} hw_i2c_d_t;

/*!
 * @name Constants and macros for entire I2C_D register
 */
/*@{*/
#define HW_I2C_D_ADDR(x)         ((uint32_t)(x) + 0x4U)

#define HW_I2C_D(x)              (*(__IO hw_i2c_d_t *) HW_I2C_D_ADDR(x))
#define HW_I2C_D_RD(x)           (HW_I2C_D(x).U)
#define HW_I2C_D_WR(x, v)        (HW_I2C_D(x).U = (v))
#define HW_I2C_D_SET(x, v)       (HW_I2C_D_WR(x, HW_I2C_D_RD(x) |  (v)))
#define HW_I2C_D_CLR(x, v)       (HW_I2C_D_WR(x, HW_I2C_D_RD(x) & ~(v)))
#define HW_I2C_D_TOG(x, v)       (HW_I2C_D_WR(x, HW_I2C_D_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_D bitfields
 */

/*!
 * @name Register I2C_D, field DATA[7:0] (RW)
 *
 * In master transmit mode, when data is written to this register, a data
 * transfer is initiated. The most significant bit is sent first. In master receive
 * mode, reading this register initiates receiving of the next byte of data. When
 * making the transition out of master receive mode, switch the I2C mode before
 * reading the Data register to prevent an inadvertent initiation of a master
 * receive data transfer. In slave mode, the same functions are available after an
 * address match occurs. The C1[TX] bit must correctly reflect the desired direction
 * of transfer in master and slave modes for the transmission to begin. For
 * example, if the I2C module is configured for master transmit but a master receive
 * is desired, reading the Data register does not initiate the receive. Reading
 * the Data register returns the last byte received while the I2C module is
 * configured in master receive or slave receive mode. The Data register does not
 * reflect every byte that is transmitted on the I2C bus, and neither can software
 * verify that a byte has been written to the Data register correctly by reading it
 * back. In master transmit mode, the first byte of data written to the Data
 * register following assertion of MST (start bit) or assertion of RSTA (repeated
 * start bit) is used for the address transfer and must consist of the calling
 * address (in bits 7-1) concatenated with the required R/W bit (in position bit 0).
 */
/*@{*/
#define BP_I2C_D_DATA        (0U)          /*!< Bit position for I2C_D_DATA. */
#define BM_I2C_D_DATA        (0xFFU)       /*!< Bit mask for I2C_D_DATA. */
#define BS_I2C_D_DATA        (8U)          /*!< Bit field size in bits for I2C_D_DATA. */

/*! @brief Read current value of the I2C_D_DATA field. */
#define BR_I2C_D_DATA(x)     (HW_I2C_D(x).U)

/*! @brief Format value for bitfield I2C_D_DATA. */
#define BF_I2C_D_DATA(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_D_DATA) & BM_I2C_D_DATA)

/*! @brief Set the DATA field to a new value. */
#define BW_I2C_D_DATA(x, v)  (HW_I2C_D_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_I2C_C2 - I2C Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_I2C_C2 - I2C Control Register 2 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_c2
{
    uint8_t U;
    struct _hw_i2c_c2_bitfields
    {
        uint8_t AD : 3;                /*!< [2:0] Slave Address */
        uint8_t RMEN : 1;              /*!< [3] Range Address Matching Enable */
        uint8_t SBRC : 1;              /*!< [4] Slave Baud Rate Control */
        uint8_t HDRS : 1;              /*!< [5] High Drive Select */
        uint8_t ADEXT : 1;             /*!< [6] Address Extension */
        uint8_t GCAEN : 1;             /*!< [7] General Call Address Enable */
    } B;
} hw_i2c_c2_t;

/*!
 * @name Constants and macros for entire I2C_C2 register
 */
/*@{*/
#define HW_I2C_C2_ADDR(x)        ((uint32_t)(x) + 0x5U)

#define HW_I2C_C2(x)             (*(__IO hw_i2c_c2_t *) HW_I2C_C2_ADDR(x))
#define HW_I2C_C2_RD(x)          (HW_I2C_C2(x).U)
#define HW_I2C_C2_WR(x, v)       (HW_I2C_C2(x).U = (v))
#define HW_I2C_C2_SET(x, v)      (HW_I2C_C2_WR(x, HW_I2C_C2_RD(x) |  (v)))
#define HW_I2C_C2_CLR(x, v)      (HW_I2C_C2_WR(x, HW_I2C_C2_RD(x) & ~(v)))
#define HW_I2C_C2_TOG(x, v)      (HW_I2C_C2_WR(x, HW_I2C_C2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_C2 bitfields
 */

/*!
 * @name Register I2C_C2, field AD[2:0] (RW)
 *
 * Contains the upper three bits of the slave address in the 10-bit address
 * scheme. This field is valid only while the ADEXT bit is set.
 */
/*@{*/
#define BP_I2C_C2_AD         (0U)          /*!< Bit position for I2C_C2_AD. */
#define BM_I2C_C2_AD         (0x07U)       /*!< Bit mask for I2C_C2_AD. */
#define BS_I2C_C2_AD         (3U)          /*!< Bit field size in bits for I2C_C2_AD. */

/*! @brief Read current value of the I2C_C2_AD field. */
#define BR_I2C_C2_AD(x)      (HW_I2C_C2(x).B.AD)

/*! @brief Format value for bitfield I2C_C2_AD. */
#define BF_I2C_C2_AD(v)      ((uint8_t)((uint8_t)(v) << BP_I2C_C2_AD) & BM_I2C_C2_AD)

/*! @brief Set the AD field to a new value. */
#define BW_I2C_C2_AD(x, v)   (HW_I2C_C2_WR(x, (HW_I2C_C2_RD(x) & ~BM_I2C_C2_AD) | BF_I2C_C2_AD(v)))
/*@}*/

/*!
 * @name Register I2C_C2, field RMEN[3] (RW)
 *
 * This bit controls the slave address matching for addresses between the values
 * of the A1 and RA registers. When this bit is set, a slave address matching
 * occurs for any address greater than the value of the A1 register and less than
 * or equal to the value of the RA register.
 *
 * Values:
 * - 0 - Range mode disabled. No address matching occurs for an address within
 *     the range of values of the A1 and RA registers.
 * - 1 - Range mode enabled. Address matching occurs when a slave receives an
 *     address within the range of values of the A1 and RA registers.
 */
/*@{*/
#define BP_I2C_C2_RMEN       (3U)          /*!< Bit position for I2C_C2_RMEN. */
#define BM_I2C_C2_RMEN       (0x08U)       /*!< Bit mask for I2C_C2_RMEN. */
#define BS_I2C_C2_RMEN       (1U)          /*!< Bit field size in bits for I2C_C2_RMEN. */

/*! @brief Read current value of the I2C_C2_RMEN field. */
#define BR_I2C_C2_RMEN(x)    (BITBAND_ACCESS8(HW_I2C_C2_ADDR(x), BP_I2C_C2_RMEN))

/*! @brief Format value for bitfield I2C_C2_RMEN. */
#define BF_I2C_C2_RMEN(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C2_RMEN) & BM_I2C_C2_RMEN)

/*! @brief Set the RMEN field to a new value. */
#define BW_I2C_C2_RMEN(x, v) (BITBAND_ACCESS8(HW_I2C_C2_ADDR(x), BP_I2C_C2_RMEN) = (v))
/*@}*/

/*!
 * @name Register I2C_C2, field SBRC[4] (RW)
 *
 * Enables independent slave mode baud rate at maximum frequency, which forces
 * clock stretching on SCL in very fast I2C modes. To a slave, an example of a
 * "very fast" mode is when the master transfers at 40 kbit/s but the slave can
 * capture the master's data at only 10 kbit/s.
 *
 * Values:
 * - 0 - The slave baud rate follows the master baud rate and clock stretching
 *     may occur
 * - 1 - Slave baud rate is independent of the master baud rate
 */
/*@{*/
#define BP_I2C_C2_SBRC       (4U)          /*!< Bit position for I2C_C2_SBRC. */
#define BM_I2C_C2_SBRC       (0x10U)       /*!< Bit mask for I2C_C2_SBRC. */
#define BS_I2C_C2_SBRC       (1U)          /*!< Bit field size in bits for I2C_C2_SBRC. */

/*! @brief Read current value of the I2C_C2_SBRC field. */
#define BR_I2C_C2_SBRC(x)    (BITBAND_ACCESS8(HW_I2C_C2_ADDR(x), BP_I2C_C2_SBRC))

/*! @brief Format value for bitfield I2C_C2_SBRC. */
#define BF_I2C_C2_SBRC(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C2_SBRC) & BM_I2C_C2_SBRC)

/*! @brief Set the SBRC field to a new value. */
#define BW_I2C_C2_SBRC(x, v) (BITBAND_ACCESS8(HW_I2C_C2_ADDR(x), BP_I2C_C2_SBRC) = (v))
/*@}*/

/*!
 * @name Register I2C_C2, field HDRS[5] (RW)
 *
 * Controls the drive capability of the I2C pads.
 *
 * Values:
 * - 0 - Normal drive mode
 * - 1 - High drive mode
 */
/*@{*/
#define BP_I2C_C2_HDRS       (5U)          /*!< Bit position for I2C_C2_HDRS. */
#define BM_I2C_C2_HDRS       (0x20U)       /*!< Bit mask for I2C_C2_HDRS. */
#define BS_I2C_C2_HDRS       (1U)          /*!< Bit field size in bits for I2C_C2_HDRS. */

/*! @brief Read current value of the I2C_C2_HDRS field. */
#define BR_I2C_C2_HDRS(x)    (BITBAND_ACCESS8(HW_I2C_C2_ADDR(x), BP_I2C_C2_HDRS))

/*! @brief Format value for bitfield I2C_C2_HDRS. */
#define BF_I2C_C2_HDRS(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_C2_HDRS) & BM_I2C_C2_HDRS)

/*! @brief Set the HDRS field to a new value. */
#define BW_I2C_C2_HDRS(x, v) (BITBAND_ACCESS8(HW_I2C_C2_ADDR(x), BP_I2C_C2_HDRS) = (v))
/*@}*/

/*!
 * @name Register I2C_C2, field ADEXT[6] (RW)
 *
 * Controls the number of bits used for the slave address.
 *
 * Values:
 * - 0 - 7-bit address scheme
 * - 1 - 10-bit address scheme
 */
/*@{*/
#define BP_I2C_C2_ADEXT      (6U)          /*!< Bit position for I2C_C2_ADEXT. */
#define BM_I2C_C2_ADEXT      (0x40U)       /*!< Bit mask for I2C_C2_ADEXT. */
#define BS_I2C_C2_ADEXT      (1U)          /*!< Bit field size in bits for I2C_C2_ADEXT. */

/*! @brief Read current value of the I2C_C2_ADEXT field. */
#define BR_I2C_C2_ADEXT(x)   (BITBAND_ACCESS8(HW_I2C_C2_ADDR(x), BP_I2C_C2_ADEXT))

/*! @brief Format value for bitfield I2C_C2_ADEXT. */
#define BF_I2C_C2_ADEXT(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C2_ADEXT) & BM_I2C_C2_ADEXT)

/*! @brief Set the ADEXT field to a new value. */
#define BW_I2C_C2_ADEXT(x, v) (BITBAND_ACCESS8(HW_I2C_C2_ADDR(x), BP_I2C_C2_ADEXT) = (v))
/*@}*/

/*!
 * @name Register I2C_C2, field GCAEN[7] (RW)
 *
 * Enables general call address.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_I2C_C2_GCAEN      (7U)          /*!< Bit position for I2C_C2_GCAEN. */
#define BM_I2C_C2_GCAEN      (0x80U)       /*!< Bit mask for I2C_C2_GCAEN. */
#define BS_I2C_C2_GCAEN      (1U)          /*!< Bit field size in bits for I2C_C2_GCAEN. */

/*! @brief Read current value of the I2C_C2_GCAEN field. */
#define BR_I2C_C2_GCAEN(x)   (BITBAND_ACCESS8(HW_I2C_C2_ADDR(x), BP_I2C_C2_GCAEN))

/*! @brief Format value for bitfield I2C_C2_GCAEN. */
#define BF_I2C_C2_GCAEN(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_C2_GCAEN) & BM_I2C_C2_GCAEN)

/*! @brief Set the GCAEN field to a new value. */
#define BW_I2C_C2_GCAEN(x, v) (BITBAND_ACCESS8(HW_I2C_C2_ADDR(x), BP_I2C_C2_GCAEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_I2C_FLT - I2C Programmable Input Glitch Filter register
 ******************************************************************************/

/*!
 * @brief HW_I2C_FLT - I2C Programmable Input Glitch Filter register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_flt
{
    uint8_t U;
    struct _hw_i2c_flt_bitfields
    {
        uint8_t FLT : 4;               /*!< [3:0] I2C Programmable Filter Factor */
        uint8_t STARTF : 1;            /*!< [4] I2C Bus Start Detect Flag */
        uint8_t SSIE : 1;              /*!< [5] I2C Bus Stop or Start Interrupt Enable */
        uint8_t STOPF : 1;             /*!< [6] I2C Bus Stop Detect Flag */
        uint8_t SHEN : 1;              /*!< [7] Stop Hold Enable */
    } B;
} hw_i2c_flt_t;

/*!
 * @name Constants and macros for entire I2C_FLT register
 */
/*@{*/
#define HW_I2C_FLT_ADDR(x)       ((uint32_t)(x) + 0x6U)

#define HW_I2C_FLT(x)            (*(__IO hw_i2c_flt_t *) HW_I2C_FLT_ADDR(x))
#define HW_I2C_FLT_RD(x)         (HW_I2C_FLT(x).U)
#define HW_I2C_FLT_WR(x, v)      (HW_I2C_FLT(x).U = (v))
#define HW_I2C_FLT_SET(x, v)     (HW_I2C_FLT_WR(x, HW_I2C_FLT_RD(x) |  (v)))
#define HW_I2C_FLT_CLR(x, v)     (HW_I2C_FLT_WR(x, HW_I2C_FLT_RD(x) & ~(v)))
#define HW_I2C_FLT_TOG(x, v)     (HW_I2C_FLT_WR(x, HW_I2C_FLT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_FLT bitfields
 */

/*!
 * @name Register I2C_FLT, field FLT[3:0] (RW)
 *
 * Controls the width of the glitch, in terms of I2C module clock cycles, that
 * the filter must absorb. For any glitch whose size is less than or equal to this
 * width setting, the filter does not allow the glitch to pass.
 *
 * Values:
 * - 0 - No filter/bypass
 */
/*@{*/
#define BP_I2C_FLT_FLT       (0U)          /*!< Bit position for I2C_FLT_FLT. */
#define BM_I2C_FLT_FLT       (0x0FU)       /*!< Bit mask for I2C_FLT_FLT. */
#define BS_I2C_FLT_FLT       (4U)          /*!< Bit field size in bits for I2C_FLT_FLT. */

/*! @brief Read current value of the I2C_FLT_FLT field. */
#define BR_I2C_FLT_FLT(x)    (HW_I2C_FLT(x).B.FLT)

/*! @brief Format value for bitfield I2C_FLT_FLT. */
#define BF_I2C_FLT_FLT(v)    ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_FLT) & BM_I2C_FLT_FLT)

/*! @brief Set the FLT field to a new value. */
#define BW_I2C_FLT_FLT(x, v) (HW_I2C_FLT_WR(x, (HW_I2C_FLT_RD(x) & ~BM_I2C_FLT_FLT) | BF_I2C_FLT_FLT(v)))
/*@}*/

/*!
 * @name Register I2C_FLT, field STARTF[4] (W1C)
 *
 * Hardware sets this bit when the I2C bus's start status is detected. The
 * STARTF bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0 - No start happens on I2C bus
 * - 1 - Start detected on I2C bus
 */
/*@{*/
#define BP_I2C_FLT_STARTF    (4U)          /*!< Bit position for I2C_FLT_STARTF. */
#define BM_I2C_FLT_STARTF    (0x10U)       /*!< Bit mask for I2C_FLT_STARTF. */
#define BS_I2C_FLT_STARTF    (1U)          /*!< Bit field size in bits for I2C_FLT_STARTF. */

/*! @brief Read current value of the I2C_FLT_STARTF field. */
#define BR_I2C_FLT_STARTF(x) (BITBAND_ACCESS8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_STARTF))

/*! @brief Format value for bitfield I2C_FLT_STARTF. */
#define BF_I2C_FLT_STARTF(v) ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_STARTF) & BM_I2C_FLT_STARTF)

/*! @brief Set the STARTF field to a new value. */
#define BW_I2C_FLT_STARTF(x, v) (BITBAND_ACCESS8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_STARTF) = (v))
/*@}*/

/*!
 * @name Register I2C_FLT, field SSIE[5] (RW)
 *
 * This bit enables the interrupt for I2C bus stop or start detection. To clear
 * the I2C bus stop or start detection interrupt: In the interrupt service
 * routine, first clear the STOPF or STARTF bit by writing 1 to it, and then clear the
 * IICIF bit in the status register. If this sequence is reversed, the IICIF bit
 * is asserted again.
 *
 * Values:
 * - 0 - Stop or start detection interrupt is disabled
 * - 1 - Stop or start detection interrupt is enabled
 */
/*@{*/
#define BP_I2C_FLT_SSIE      (5U)          /*!< Bit position for I2C_FLT_SSIE. */
#define BM_I2C_FLT_SSIE      (0x20U)       /*!< Bit mask for I2C_FLT_SSIE. */
#define BS_I2C_FLT_SSIE      (1U)          /*!< Bit field size in bits for I2C_FLT_SSIE. */

/*! @brief Read current value of the I2C_FLT_SSIE field. */
#define BR_I2C_FLT_SSIE(x)   (BITBAND_ACCESS8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_SSIE))

/*! @brief Format value for bitfield I2C_FLT_SSIE. */
#define BF_I2C_FLT_SSIE(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_SSIE) & BM_I2C_FLT_SSIE)

/*! @brief Set the SSIE field to a new value. */
#define BW_I2C_FLT_SSIE(x, v) (BITBAND_ACCESS8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_SSIE) = (v))
/*@}*/

/*!
 * @name Register I2C_FLT, field STOPF[6] (W1C)
 *
 * Hardware sets this bit when the I2C bus's stop status is detected. The STOPF
 * bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0 - No stop happens on I2C bus
 * - 1 - Stop detected on I2C bus
 */
/*@{*/
#define BP_I2C_FLT_STOPF     (6U)          /*!< Bit position for I2C_FLT_STOPF. */
#define BM_I2C_FLT_STOPF     (0x40U)       /*!< Bit mask for I2C_FLT_STOPF. */
#define BS_I2C_FLT_STOPF     (1U)          /*!< Bit field size in bits for I2C_FLT_STOPF. */

/*! @brief Read current value of the I2C_FLT_STOPF field. */
#define BR_I2C_FLT_STOPF(x)  (BITBAND_ACCESS8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_STOPF))

/*! @brief Format value for bitfield I2C_FLT_STOPF. */
#define BF_I2C_FLT_STOPF(v)  ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_STOPF) & BM_I2C_FLT_STOPF)

/*! @brief Set the STOPF field to a new value. */
#define BW_I2C_FLT_STOPF(x, v) (BITBAND_ACCESS8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_STOPF) = (v))
/*@}*/

/*!
 * @name Register I2C_FLT, field SHEN[7] (RW)
 *
 * Set this bit to hold off entry to stop mode when any data transmission or
 * reception is occurring. The following scenario explains the holdoff
 * functionality: The I2C module is configured for a basic transfer, and the SHEN bit is set
 * to 1. A transfer begins. The MCU signals the I2C module to enter stop mode. The
 * byte currently being transferred, including both address and data, completes
 * its transfer. The I2C slave or master acknowledges that the in-transfer byte
 * completed its transfer and acknowledges the request to enter stop mode. After
 * receiving the I2C module's acknowledgment of the request to enter stop mode,
 * the MCU determines whether to shut off the I2C module's clock. If the SHEN bit
 * is set to 1 and the I2C module is in an idle or disabled state when the MCU
 * signals to enter stop mode, the module immediately acknowledges the request to
 * enter stop mode. If SHEN is cleared to 0 and the overall data transmission or
 * reception that was suspended by stop mode entry was incomplete: To resume the
 * overall transmission or reception after the MCU exits stop mode, software must
 * reinitialize the transfer by resending the address of the slave. If the I2C
 * Control Register 1's IICIE bit was set to 1 before the MCU entered stop mode,
 * system software will receive the interrupt triggered by the I2C Status Register's
 * TCF bit after the MCU wakes from the stop mode.
 *
 * Values:
 * - 0 - Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
 * - 1 - Stop holdoff is enabled.
 */
/*@{*/
#define BP_I2C_FLT_SHEN      (7U)          /*!< Bit position for I2C_FLT_SHEN. */
#define BM_I2C_FLT_SHEN      (0x80U)       /*!< Bit mask for I2C_FLT_SHEN. */
#define BS_I2C_FLT_SHEN      (1U)          /*!< Bit field size in bits for I2C_FLT_SHEN. */

/*! @brief Read current value of the I2C_FLT_SHEN field. */
#define BR_I2C_FLT_SHEN(x)   (BITBAND_ACCESS8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_SHEN))

/*! @brief Format value for bitfield I2C_FLT_SHEN. */
#define BF_I2C_FLT_SHEN(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_FLT_SHEN) & BM_I2C_FLT_SHEN)

/*! @brief Set the SHEN field to a new value. */
#define BW_I2C_FLT_SHEN(x, v) (BITBAND_ACCESS8(HW_I2C_FLT_ADDR(x), BP_I2C_FLT_SHEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_I2C_RA - I2C Range Address register
 ******************************************************************************/

/*!
 * @brief HW_I2C_RA - I2C Range Address register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_ra
{
    uint8_t U;
    struct _hw_i2c_ra_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t RAD : 7;               /*!< [7:1] Range Slave Address */
    } B;
} hw_i2c_ra_t;

/*!
 * @name Constants and macros for entire I2C_RA register
 */
/*@{*/
#define HW_I2C_RA_ADDR(x)        ((uint32_t)(x) + 0x7U)

#define HW_I2C_RA(x)             (*(__IO hw_i2c_ra_t *) HW_I2C_RA_ADDR(x))
#define HW_I2C_RA_RD(x)          (HW_I2C_RA(x).U)
#define HW_I2C_RA_WR(x, v)       (HW_I2C_RA(x).U = (v))
#define HW_I2C_RA_SET(x, v)      (HW_I2C_RA_WR(x, HW_I2C_RA_RD(x) |  (v)))
#define HW_I2C_RA_CLR(x, v)      (HW_I2C_RA_WR(x, HW_I2C_RA_RD(x) & ~(v)))
#define HW_I2C_RA_TOG(x, v)      (HW_I2C_RA_WR(x, HW_I2C_RA_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_RA bitfields
 */

/*!
 * @name Register I2C_RA, field RAD[7:1] (RW)
 *
 * This field contains the slave address to be used by the I2C module. The field
 * is used in the 7-bit address scheme. If I2C_C2[RMEN] is set to 1, any nonzero
 * value write enables this register. This register value can be considered as a
 * maximum boundary in the range matching mode.
 */
/*@{*/
#define BP_I2C_RA_RAD        (1U)          /*!< Bit position for I2C_RA_RAD. */
#define BM_I2C_RA_RAD        (0xFEU)       /*!< Bit mask for I2C_RA_RAD. */
#define BS_I2C_RA_RAD        (7U)          /*!< Bit field size in bits for I2C_RA_RAD. */

/*! @brief Read current value of the I2C_RA_RAD field. */
#define BR_I2C_RA_RAD(x)     (HW_I2C_RA(x).B.RAD)

/*! @brief Format value for bitfield I2C_RA_RAD. */
#define BF_I2C_RA_RAD(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_RA_RAD) & BM_I2C_RA_RAD)

/*! @brief Set the RAD field to a new value. */
#define BW_I2C_RA_RAD(x, v)  (HW_I2C_RA_WR(x, (HW_I2C_RA_RD(x) & ~BM_I2C_RA_RAD) | BF_I2C_RA_RAD(v)))
/*@}*/

/*******************************************************************************
 * HW_I2C_SMB - I2C SMBus Control and Status register
 ******************************************************************************/

/*!
 * @brief HW_I2C_SMB - I2C SMBus Control and Status register (RW)
 *
 * Reset value: 0x00U
 *
 * When the SCL and SDA signals are held high for a length of time greater than
 * the high timeout period, the SHTF1 flag sets. Before reaching this threshold,
 * while the system is detecting how long these signals are being held high, a
 * master assumes that the bus is free. However, the SHTF1 bit is set to 1 in the
 * bus transmission process with the idle bus state. When the TCKSEL bit is set,
 * there is no need to monitor the SHTF1 bit because the bus speed is too high to
 * match the protocol of SMBus.
 */
typedef union _hw_i2c_smb
{
    uint8_t U;
    struct _hw_i2c_smb_bitfields
    {
        uint8_t SHTF2IE : 1;           /*!< [0] SHTF2 Interrupt Enable */
        uint8_t SHTF2 : 1;             /*!< [1] SCL High Timeout Flag 2 */
        uint8_t SHTF1 : 1;             /*!< [2] SCL High Timeout Flag 1 */
        uint8_t SLTF : 1;              /*!< [3] SCL Low Timeout Flag */
        uint8_t TCKSEL : 1;            /*!< [4] Timeout Counter Clock Select */
        uint8_t SIICAEN : 1;           /*!< [5] Second I2C Address Enable */
        uint8_t ALERTEN : 1;           /*!< [6] SMBus Alert Response Address Enable */
        uint8_t FACK : 1;              /*!< [7] Fast NACK/ACK Enable */
    } B;
} hw_i2c_smb_t;

/*!
 * @name Constants and macros for entire I2C_SMB register
 */
/*@{*/
#define HW_I2C_SMB_ADDR(x)       ((uint32_t)(x) + 0x8U)

#define HW_I2C_SMB(x)            (*(__IO hw_i2c_smb_t *) HW_I2C_SMB_ADDR(x))
#define HW_I2C_SMB_RD(x)         (HW_I2C_SMB(x).U)
#define HW_I2C_SMB_WR(x, v)      (HW_I2C_SMB(x).U = (v))
#define HW_I2C_SMB_SET(x, v)     (HW_I2C_SMB_WR(x, HW_I2C_SMB_RD(x) |  (v)))
#define HW_I2C_SMB_CLR(x, v)     (HW_I2C_SMB_WR(x, HW_I2C_SMB_RD(x) & ~(v)))
#define HW_I2C_SMB_TOG(x, v)     (HW_I2C_SMB_WR(x, HW_I2C_SMB_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_SMB bitfields
 */

/*!
 * @name Register I2C_SMB, field SHTF2IE[0] (RW)
 *
 * Enables SCL high and SDA low timeout interrupt.
 *
 * Values:
 * - 0 - SHTF2 interrupt is disabled
 * - 1 - SHTF2 interrupt is enabled
 */
/*@{*/
#define BP_I2C_SMB_SHTF2IE   (0U)          /*!< Bit position for I2C_SMB_SHTF2IE. */
#define BM_I2C_SMB_SHTF2IE   (0x01U)       /*!< Bit mask for I2C_SMB_SHTF2IE. */
#define BS_I2C_SMB_SHTF2IE   (1U)          /*!< Bit field size in bits for I2C_SMB_SHTF2IE. */

/*! @brief Read current value of the I2C_SMB_SHTF2IE field. */
#define BR_I2C_SMB_SHTF2IE(x) (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SHTF2IE))

/*! @brief Format value for bitfield I2C_SMB_SHTF2IE. */
#define BF_I2C_SMB_SHTF2IE(v) ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_SHTF2IE) & BM_I2C_SMB_SHTF2IE)

/*! @brief Set the SHTF2IE field to a new value. */
#define BW_I2C_SMB_SHTF2IE(x, v) (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SHTF2IE) = (v))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF2[1] (W1C)
 *
 * This bit sets when SCL is held high and SDA is held low more than clock *
 * LoValue / 512. Software clears this bit by writing 1 to it.
 *
 * Values:
 * - 0 - No SCL high and SDA low timeout occurs
 * - 1 - SCL high and SDA low timeout occurs
 */
/*@{*/
#define BP_I2C_SMB_SHTF2     (1U)          /*!< Bit position for I2C_SMB_SHTF2. */
#define BM_I2C_SMB_SHTF2     (0x02U)       /*!< Bit mask for I2C_SMB_SHTF2. */
#define BS_I2C_SMB_SHTF2     (1U)          /*!< Bit field size in bits for I2C_SMB_SHTF2. */

/*! @brief Read current value of the I2C_SMB_SHTF2 field. */
#define BR_I2C_SMB_SHTF2(x)  (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SHTF2))

/*! @brief Format value for bitfield I2C_SMB_SHTF2. */
#define BF_I2C_SMB_SHTF2(v)  ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_SHTF2) & BM_I2C_SMB_SHTF2)

/*! @brief Set the SHTF2 field to a new value. */
#define BW_I2C_SMB_SHTF2(x, v) (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SHTF2) = (v))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF1[2] (RO)
 *
 * This read-only bit sets when SCL and SDA are held high more than clock *
 * LoValue / 512, which indicates the bus is free. This bit is cleared automatically.
 *
 * Values:
 * - 0 - No SCL high and SDA high timeout occurs
 * - 1 - SCL high and SDA high timeout occurs
 */
/*@{*/
#define BP_I2C_SMB_SHTF1     (2U)          /*!< Bit position for I2C_SMB_SHTF1. */
#define BM_I2C_SMB_SHTF1     (0x04U)       /*!< Bit mask for I2C_SMB_SHTF1. */
#define BS_I2C_SMB_SHTF1     (1U)          /*!< Bit field size in bits for I2C_SMB_SHTF1. */

/*! @brief Read current value of the I2C_SMB_SHTF1 field. */
#define BR_I2C_SMB_SHTF1(x)  (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SHTF1))
/*@}*/

/*!
 * @name Register I2C_SMB, field SLTF[3] (W1C)
 *
 * This bit is set when the SLT register (consisting of the SLTH and SLTL
 * registers) is loaded with a non-zero value (LoValue) and an SCL low timeout occurs.
 * Software clears this bit by writing a logic 1 to it. The low timeout function
 * is disabled when the SLT register's value is 0.
 *
 * Values:
 * - 0 - No low timeout occurs
 * - 1 - Low timeout occurs
 */
/*@{*/
#define BP_I2C_SMB_SLTF      (3U)          /*!< Bit position for I2C_SMB_SLTF. */
#define BM_I2C_SMB_SLTF      (0x08U)       /*!< Bit mask for I2C_SMB_SLTF. */
#define BS_I2C_SMB_SLTF      (1U)          /*!< Bit field size in bits for I2C_SMB_SLTF. */

/*! @brief Read current value of the I2C_SMB_SLTF field. */
#define BR_I2C_SMB_SLTF(x)   (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SLTF))

/*! @brief Format value for bitfield I2C_SMB_SLTF. */
#define BF_I2C_SMB_SLTF(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_SLTF) & BM_I2C_SMB_SLTF)

/*! @brief Set the SLTF field to a new value. */
#define BW_I2C_SMB_SLTF(x, v) (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SLTF) = (v))
/*@}*/

/*!
 * @name Register I2C_SMB, field TCKSEL[4] (RW)
 *
 * Selects the clock source of the timeout counter.
 *
 * Values:
 * - 0 - Timeout counter counts at the frequency of the I2C module clock / 64
 * - 1 - Timeout counter counts at the frequency of the I2C module clock
 */
/*@{*/
#define BP_I2C_SMB_TCKSEL    (4U)          /*!< Bit position for I2C_SMB_TCKSEL. */
#define BM_I2C_SMB_TCKSEL    (0x10U)       /*!< Bit mask for I2C_SMB_TCKSEL. */
#define BS_I2C_SMB_TCKSEL    (1U)          /*!< Bit field size in bits for I2C_SMB_TCKSEL. */

/*! @brief Read current value of the I2C_SMB_TCKSEL field. */
#define BR_I2C_SMB_TCKSEL(x) (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_TCKSEL))

/*! @brief Format value for bitfield I2C_SMB_TCKSEL. */
#define BF_I2C_SMB_TCKSEL(v) ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_TCKSEL) & BM_I2C_SMB_TCKSEL)

/*! @brief Set the TCKSEL field to a new value. */
#define BW_I2C_SMB_TCKSEL(x, v) (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_TCKSEL) = (v))
/*@}*/

/*!
 * @name Register I2C_SMB, field SIICAEN[5] (RW)
 *
 * Enables or disables SMBus device default address.
 *
 * Values:
 * - 0 - I2C address register 2 matching is disabled
 * - 1 - I2C address register 2 matching is enabled
 */
/*@{*/
#define BP_I2C_SMB_SIICAEN   (5U)          /*!< Bit position for I2C_SMB_SIICAEN. */
#define BM_I2C_SMB_SIICAEN   (0x20U)       /*!< Bit mask for I2C_SMB_SIICAEN. */
#define BS_I2C_SMB_SIICAEN   (1U)          /*!< Bit field size in bits for I2C_SMB_SIICAEN. */

/*! @brief Read current value of the I2C_SMB_SIICAEN field. */
#define BR_I2C_SMB_SIICAEN(x) (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SIICAEN))

/*! @brief Format value for bitfield I2C_SMB_SIICAEN. */
#define BF_I2C_SMB_SIICAEN(v) ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_SIICAEN) & BM_I2C_SMB_SIICAEN)

/*! @brief Set the SIICAEN field to a new value. */
#define BW_I2C_SMB_SIICAEN(x, v) (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_SIICAEN) = (v))
/*@}*/

/*!
 * @name Register I2C_SMB, field ALERTEN[6] (RW)
 *
 * Enables or disables SMBus alert response address matching. After the host
 * responds to a device that used the alert response address, you must use software
 * to put the device's address on the bus. The alert protocol is described in the
 * SMBus specification.
 *
 * Values:
 * - 0 - SMBus alert response address matching is disabled
 * - 1 - SMBus alert response address matching is enabled
 */
/*@{*/
#define BP_I2C_SMB_ALERTEN   (6U)          /*!< Bit position for I2C_SMB_ALERTEN. */
#define BM_I2C_SMB_ALERTEN   (0x40U)       /*!< Bit mask for I2C_SMB_ALERTEN. */
#define BS_I2C_SMB_ALERTEN   (1U)          /*!< Bit field size in bits for I2C_SMB_ALERTEN. */

/*! @brief Read current value of the I2C_SMB_ALERTEN field. */
#define BR_I2C_SMB_ALERTEN(x) (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_ALERTEN))

/*! @brief Format value for bitfield I2C_SMB_ALERTEN. */
#define BF_I2C_SMB_ALERTEN(v) ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_ALERTEN) & BM_I2C_SMB_ALERTEN)

/*! @brief Set the ALERTEN field to a new value. */
#define BW_I2C_SMB_ALERTEN(x, v) (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_ALERTEN) = (v))
/*@}*/

/*!
 * @name Register I2C_SMB, field FACK[7] (RW)
 *
 * For SMBus packet error checking, the CPU must be able to issue an ACK or NACK
 * according to the result of receiving data byte.
 *
 * Values:
 * - 0 - An ACK or NACK is sent on the following receiving data byte
 * - 1 - Writing 0 to TXAK after receiving a data byte generates an ACK. Writing
 *     1 to TXAK after receiving a data byte generates a NACK.
 */
/*@{*/
#define BP_I2C_SMB_FACK      (7U)          /*!< Bit position for I2C_SMB_FACK. */
#define BM_I2C_SMB_FACK      (0x80U)       /*!< Bit mask for I2C_SMB_FACK. */
#define BS_I2C_SMB_FACK      (1U)          /*!< Bit field size in bits for I2C_SMB_FACK. */

/*! @brief Read current value of the I2C_SMB_FACK field. */
#define BR_I2C_SMB_FACK(x)   (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_FACK))

/*! @brief Format value for bitfield I2C_SMB_FACK. */
#define BF_I2C_SMB_FACK(v)   ((uint8_t)((uint8_t)(v) << BP_I2C_SMB_FACK) & BM_I2C_SMB_FACK)

/*! @brief Set the FACK field to a new value. */
#define BW_I2C_SMB_FACK(x, v) (BITBAND_ACCESS8(HW_I2C_SMB_ADDR(x), BP_I2C_SMB_FACK) = (v))
/*@}*/

/*******************************************************************************
 * HW_I2C_A2 - I2C Address Register 2
 ******************************************************************************/

/*!
 * @brief HW_I2C_A2 - I2C Address Register 2 (RW)
 *
 * Reset value: 0xC2U
 */
typedef union _hw_i2c_a2
{
    uint8_t U;
    struct _hw_i2c_a2_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t SAD : 7;               /*!< [7:1] SMBus Address */
    } B;
} hw_i2c_a2_t;

/*!
 * @name Constants and macros for entire I2C_A2 register
 */
/*@{*/
#define HW_I2C_A2_ADDR(x)        ((uint32_t)(x) + 0x9U)

#define HW_I2C_A2(x)             (*(__IO hw_i2c_a2_t *) HW_I2C_A2_ADDR(x))
#define HW_I2C_A2_RD(x)          (HW_I2C_A2(x).U)
#define HW_I2C_A2_WR(x, v)       (HW_I2C_A2(x).U = (v))
#define HW_I2C_A2_SET(x, v)      (HW_I2C_A2_WR(x, HW_I2C_A2_RD(x) |  (v)))
#define HW_I2C_A2_CLR(x, v)      (HW_I2C_A2_WR(x, HW_I2C_A2_RD(x) & ~(v)))
#define HW_I2C_A2_TOG(x, v)      (HW_I2C_A2_WR(x, HW_I2C_A2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_A2 bitfields
 */

/*!
 * @name Register I2C_A2, field SAD[7:1] (RW)
 *
 * Contains the slave address used by the SMBus. This field is used on the
 * device default address or other related addresses.
 */
/*@{*/
#define BP_I2C_A2_SAD        (1U)          /*!< Bit position for I2C_A2_SAD. */
#define BM_I2C_A2_SAD        (0xFEU)       /*!< Bit mask for I2C_A2_SAD. */
#define BS_I2C_A2_SAD        (7U)          /*!< Bit field size in bits for I2C_A2_SAD. */

/*! @brief Read current value of the I2C_A2_SAD field. */
#define BR_I2C_A2_SAD(x)     (HW_I2C_A2(x).B.SAD)

/*! @brief Format value for bitfield I2C_A2_SAD. */
#define BF_I2C_A2_SAD(v)     ((uint8_t)((uint8_t)(v) << BP_I2C_A2_SAD) & BM_I2C_A2_SAD)

/*! @brief Set the SAD field to a new value. */
#define BW_I2C_A2_SAD(x, v)  (HW_I2C_A2_WR(x, (HW_I2C_A2_RD(x) & ~BM_I2C_A2_SAD) | BF_I2C_A2_SAD(v)))
/*@}*/

/*******************************************************************************
 * HW_I2C_SLTH - I2C SCL Low Timeout Register High
 ******************************************************************************/

/*!
 * @brief HW_I2C_SLTH - I2C SCL Low Timeout Register High (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_slth
{
    uint8_t U;
    struct _hw_i2c_slth_bitfields
    {
        uint8_t SSLT : 8;              /*!< [7:0]  */
    } B;
} hw_i2c_slth_t;

/*!
 * @name Constants and macros for entire I2C_SLTH register
 */
/*@{*/
#define HW_I2C_SLTH_ADDR(x)      ((uint32_t)(x) + 0xAU)

#define HW_I2C_SLTH(x)           (*(__IO hw_i2c_slth_t *) HW_I2C_SLTH_ADDR(x))
#define HW_I2C_SLTH_RD(x)        (HW_I2C_SLTH(x).U)
#define HW_I2C_SLTH_WR(x, v)     (HW_I2C_SLTH(x).U = (v))
#define HW_I2C_SLTH_SET(x, v)    (HW_I2C_SLTH_WR(x, HW_I2C_SLTH_RD(x) |  (v)))
#define HW_I2C_SLTH_CLR(x, v)    (HW_I2C_SLTH_WR(x, HW_I2C_SLTH_RD(x) & ~(v)))
#define HW_I2C_SLTH_TOG(x, v)    (HW_I2C_SLTH_WR(x, HW_I2C_SLTH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_SLTH bitfields
 */

/*!
 * @name Register I2C_SLTH, field SSLT[7:0] (RW)
 *
 * Most significant byte of SCL low timeout value that determines the timeout
 * period of SCL low.
 */
/*@{*/
#define BP_I2C_SLTH_SSLT     (0U)          /*!< Bit position for I2C_SLTH_SSLT. */
#define BM_I2C_SLTH_SSLT     (0xFFU)       /*!< Bit mask for I2C_SLTH_SSLT. */
#define BS_I2C_SLTH_SSLT     (8U)          /*!< Bit field size in bits for I2C_SLTH_SSLT. */

/*! @brief Read current value of the I2C_SLTH_SSLT field. */
#define BR_I2C_SLTH_SSLT(x)  (HW_I2C_SLTH(x).U)

/*! @brief Format value for bitfield I2C_SLTH_SSLT. */
#define BF_I2C_SLTH_SSLT(v)  ((uint8_t)((uint8_t)(v) << BP_I2C_SLTH_SSLT) & BM_I2C_SLTH_SSLT)

/*! @brief Set the SSLT field to a new value. */
#define BW_I2C_SLTH_SSLT(x, v) (HW_I2C_SLTH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_I2C_SLTL - I2C SCL Low Timeout Register Low
 ******************************************************************************/

/*!
 * @brief HW_I2C_SLTL - I2C SCL Low Timeout Register Low (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_i2c_sltl
{
    uint8_t U;
    struct _hw_i2c_sltl_bitfields
    {
        uint8_t SSLT : 8;              /*!< [7:0]  */
    } B;
} hw_i2c_sltl_t;

/*!
 * @name Constants and macros for entire I2C_SLTL register
 */
/*@{*/
#define HW_I2C_SLTL_ADDR(x)      ((uint32_t)(x) + 0xBU)

#define HW_I2C_SLTL(x)           (*(__IO hw_i2c_sltl_t *) HW_I2C_SLTL_ADDR(x))
#define HW_I2C_SLTL_RD(x)        (HW_I2C_SLTL(x).U)
#define HW_I2C_SLTL_WR(x, v)     (HW_I2C_SLTL(x).U = (v))
#define HW_I2C_SLTL_SET(x, v)    (HW_I2C_SLTL_WR(x, HW_I2C_SLTL_RD(x) |  (v)))
#define HW_I2C_SLTL_CLR(x, v)    (HW_I2C_SLTL_WR(x, HW_I2C_SLTL_RD(x) & ~(v)))
#define HW_I2C_SLTL_TOG(x, v)    (HW_I2C_SLTL_WR(x, HW_I2C_SLTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2C_SLTL bitfields
 */

/*!
 * @name Register I2C_SLTL, field SSLT[7:0] (RW)
 *
 * Least significant byte of SCL low timeout value that determines the timeout
 * period of SCL low.
 */
/*@{*/
#define BP_I2C_SLTL_SSLT     (0U)          /*!< Bit position for I2C_SLTL_SSLT. */
#define BM_I2C_SLTL_SSLT     (0xFFU)       /*!< Bit mask for I2C_SLTL_SSLT. */
#define BS_I2C_SLTL_SSLT     (8U)          /*!< Bit field size in bits for I2C_SLTL_SSLT. */

/*! @brief Read current value of the I2C_SLTL_SSLT field. */
#define BR_I2C_SLTL_SSLT(x)  (HW_I2C_SLTL(x).U)

/*! @brief Format value for bitfield I2C_SLTL_SSLT. */
#define BF_I2C_SLTL_SSLT(v)  ((uint8_t)((uint8_t)(v) << BP_I2C_SLTL_SSLT) & BM_I2C_SLTL_SSLT)

/*! @brief Set the SSLT field to a new value. */
#define BW_I2C_SLTL_SSLT(x, v) (HW_I2C_SLTL_WR(x, v))
/*@}*/

/*******************************************************************************
 * hw_i2c_t - module struct
 ******************************************************************************/
/*!
 * @brief All I2C module registers.
 */
#pragma pack(1)
typedef struct _hw_i2c
{
    __IO hw_i2c_a1_t A1;                   /*!< [0x0] I2C Address Register 1 */
    __IO hw_i2c_f_t F;                     /*!< [0x1] I2C Frequency Divider register */
    __IO hw_i2c_c1_t C1;                   /*!< [0x2] I2C Control Register 1 */
    __IO hw_i2c_s_t S;                     /*!< [0x3] I2C Status register */
    __IO hw_i2c_d_t D;                     /*!< [0x4] I2C Data I/O register */
    __IO hw_i2c_c2_t C2;                   /*!< [0x5] I2C Control Register 2 */
    __IO hw_i2c_flt_t FLT;                 /*!< [0x6] I2C Programmable Input Glitch Filter register */
    __IO hw_i2c_ra_t RA;                   /*!< [0x7] I2C Range Address register */
    __IO hw_i2c_smb_t SMB;                 /*!< [0x8] I2C SMBus Control and Status register */
    __IO hw_i2c_a2_t A2;                   /*!< [0x9] I2C Address Register 2 */
    __IO hw_i2c_slth_t SLTH;               /*!< [0xA] I2C SCL Low Timeout Register High */
    __IO hw_i2c_sltl_t SLTL;               /*!< [0xB] I2C SCL Low Timeout Register Low */
} hw_i2c_t;
#pragma pack()

/*! @brief Macro to access all I2C registers. */
/*! @param x I2C module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_I2C_REGS(I2C0_BASE)</code>. */
#define HW_I2C_REGS(x) (*(hw_i2c_t *)(x))

/*
 * MK64F12 I2S
 *
 * Inter-IC Sound / Synchronous Audio Interface
 *
 * Registers defined in this header file:
 * - HW_I2S_TCSR - SAI Transmit Control Register
 * - HW_I2S_TCR1 - SAI Transmit Configuration 1 Register
 * - HW_I2S_TCR2 - SAI Transmit Configuration 2 Register
 * - HW_I2S_TCR3 - SAI Transmit Configuration 3 Register
 * - HW_I2S_TCR4 - SAI Transmit Configuration 4 Register
 * - HW_I2S_TCR5 - SAI Transmit Configuration 5 Register
 * - HW_I2S_TDRn - SAI Transmit Data Register
 * - HW_I2S_TFRn - SAI Transmit FIFO Register
 * - HW_I2S_TMR - SAI Transmit Mask Register
 * - HW_I2S_RCSR - SAI Receive Control Register
 * - HW_I2S_RCR1 - SAI Receive Configuration 1 Register
 * - HW_I2S_RCR2 - SAI Receive Configuration 2 Register
 * - HW_I2S_RCR3 - SAI Receive Configuration 3 Register
 * - HW_I2S_RCR4 - SAI Receive Configuration 4 Register
 * - HW_I2S_RCR5 - SAI Receive Configuration 5 Register
 * - HW_I2S_RDRn - SAI Receive Data Register
 * - HW_I2S_RFRn - SAI Receive FIFO Register
 * - HW_I2S_RMR - SAI Receive Mask Register
 * - HW_I2S_MCR - SAI MCLK Control Register
 * - HW_I2S_MDR - SAI MCLK Divide Register
 *
 * - hw_i2s_t - Struct containing all module registers.
 */

#define HW_I2S_INSTANCE_COUNT (1U) /*!< Number of instances of the I2S module. */
#define HW_I2S0 (0U) /*!< Instance number for I2S0. */

/*******************************************************************************
 * HW_I2S_TCSR - SAI Transmit Control Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TCSR - SAI Transmit Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_i2s_tcsr
{
    uint32_t U;
    struct _hw_i2s_tcsr_bitfields
    {
        uint32_t FRDE : 1;             /*!< [0] FIFO Request DMA Enable */
        uint32_t FWDE : 1;             /*!< [1] FIFO Warning DMA Enable */
        uint32_t RESERVED0 : 6;        /*!< [7:2]  */
        uint32_t FRIE : 1;             /*!< [8] FIFO Request Interrupt Enable */
        uint32_t FWIE : 1;             /*!< [9] FIFO Warning Interrupt Enable */
        uint32_t FEIE : 1;             /*!< [10] FIFO Error Interrupt Enable */
        uint32_t SEIE : 1;             /*!< [11] Sync Error Interrupt Enable */
        uint32_t WSIE : 1;             /*!< [12] Word Start Interrupt Enable */
        uint32_t RESERVED1 : 3;        /*!< [15:13]  */
        uint32_t FRF : 1;              /*!< [16] FIFO Request Flag */
        uint32_t FWF : 1;              /*!< [17] FIFO Warning Flag */
        uint32_t FEF : 1;              /*!< [18] FIFO Error Flag */
        uint32_t SEF : 1;              /*!< [19] Sync Error Flag */
        uint32_t WSF : 1;              /*!< [20] Word Start Flag */
        uint32_t RESERVED2 : 3;        /*!< [23:21]  */
        uint32_t SR : 1;               /*!< [24] Software Reset */
        uint32_t FR : 1;               /*!< [25] FIFO Reset */
        uint32_t RESERVED3 : 2;        /*!< [27:26]  */
        uint32_t BCE : 1;              /*!< [28] Bit Clock Enable */
        uint32_t DBGE : 1;             /*!< [29] Debug Enable */
        uint32_t STOPE : 1;            /*!< [30] Stop Enable */
        uint32_t TE : 1;               /*!< [31] Transmitter Enable */
    } B;
} hw_i2s_tcsr_t;

/*!
 * @name Constants and macros for entire I2S_TCSR register
 */
/*@{*/
#define HW_I2S_TCSR_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_I2S_TCSR(x)           (*(__IO hw_i2s_tcsr_t *) HW_I2S_TCSR_ADDR(x))
#define HW_I2S_TCSR_RD(x)        (HW_I2S_TCSR(x).U)
#define HW_I2S_TCSR_WR(x, v)     (HW_I2S_TCSR(x).U = (v))
#define HW_I2S_TCSR_SET(x, v)    (HW_I2S_TCSR_WR(x, HW_I2S_TCSR_RD(x) |  (v)))
#define HW_I2S_TCSR_CLR(x, v)    (HW_I2S_TCSR_WR(x, HW_I2S_TCSR_RD(x) & ~(v)))
#define HW_I2S_TCSR_TOG(x, v)    (HW_I2S_TCSR_WR(x, HW_I2S_TCSR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCSR bitfields
 */

/*!
 * @name Register I2S_TCSR, field FRDE[0] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
#define BP_I2S_TCSR_FRDE     (0U)          /*!< Bit position for I2S_TCSR_FRDE. */
#define BM_I2S_TCSR_FRDE     (0x00000001U) /*!< Bit mask for I2S_TCSR_FRDE. */
#define BS_I2S_TCSR_FRDE     (1U)          /*!< Bit field size in bits for I2S_TCSR_FRDE. */

/*! @brief Read current value of the I2S_TCSR_FRDE field. */
#define BR_I2S_TCSR_FRDE(x)  (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FRDE))

/*! @brief Format value for bitfield I2S_TCSR_FRDE. */
#define BF_I2S_TCSR_FRDE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FRDE) & BM_I2S_TCSR_FRDE)

/*! @brief Set the FRDE field to a new value. */
#define BW_I2S_TCSR_FRDE(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FRDE) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWDE[1] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
#define BP_I2S_TCSR_FWDE     (1U)          /*!< Bit position for I2S_TCSR_FWDE. */
#define BM_I2S_TCSR_FWDE     (0x00000002U) /*!< Bit mask for I2S_TCSR_FWDE. */
#define BS_I2S_TCSR_FWDE     (1U)          /*!< Bit field size in bits for I2S_TCSR_FWDE. */

/*! @brief Read current value of the I2S_TCSR_FWDE field. */
#define BR_I2S_TCSR_FWDE(x)  (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FWDE))

/*! @brief Format value for bitfield I2S_TCSR_FWDE. */
#define BF_I2S_TCSR_FWDE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FWDE) & BM_I2S_TCSR_FWDE)

/*! @brief Set the FWDE field to a new value. */
#define BW_I2S_TCSR_FWDE(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FWDE) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FRIE[8] (RW)
 *
 * Enables/disables FIFO request interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
#define BP_I2S_TCSR_FRIE     (8U)          /*!< Bit position for I2S_TCSR_FRIE. */
#define BM_I2S_TCSR_FRIE     (0x00000100U) /*!< Bit mask for I2S_TCSR_FRIE. */
#define BS_I2S_TCSR_FRIE     (1U)          /*!< Bit field size in bits for I2S_TCSR_FRIE. */

/*! @brief Read current value of the I2S_TCSR_FRIE field. */
#define BR_I2S_TCSR_FRIE(x)  (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FRIE))

/*! @brief Format value for bitfield I2S_TCSR_FRIE. */
#define BF_I2S_TCSR_FRIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FRIE) & BM_I2S_TCSR_FRIE)

/*! @brief Set the FRIE field to a new value. */
#define BW_I2S_TCSR_FRIE(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FRIE) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWIE[9] (RW)
 *
 * Enables/disables FIFO warning interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
#define BP_I2S_TCSR_FWIE     (9U)          /*!< Bit position for I2S_TCSR_FWIE. */
#define BM_I2S_TCSR_FWIE     (0x00000200U) /*!< Bit mask for I2S_TCSR_FWIE. */
#define BS_I2S_TCSR_FWIE     (1U)          /*!< Bit field size in bits for I2S_TCSR_FWIE. */

/*! @brief Read current value of the I2S_TCSR_FWIE field. */
#define BR_I2S_TCSR_FWIE(x)  (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FWIE))

/*! @brief Format value for bitfield I2S_TCSR_FWIE. */
#define BF_I2S_TCSR_FWIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FWIE) & BM_I2S_TCSR_FWIE)

/*! @brief Set the FWIE field to a new value. */
#define BW_I2S_TCSR_FWIE(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FWIE) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FEIE[10] (RW)
 *
 * Enables/disables FIFO error interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
#define BP_I2S_TCSR_FEIE     (10U)         /*!< Bit position for I2S_TCSR_FEIE. */
#define BM_I2S_TCSR_FEIE     (0x00000400U) /*!< Bit mask for I2S_TCSR_FEIE. */
#define BS_I2S_TCSR_FEIE     (1U)          /*!< Bit field size in bits for I2S_TCSR_FEIE. */

/*! @brief Read current value of the I2S_TCSR_FEIE field. */
#define BR_I2S_TCSR_FEIE(x)  (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FEIE))

/*! @brief Format value for bitfield I2S_TCSR_FEIE. */
#define BF_I2S_TCSR_FEIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FEIE) & BM_I2S_TCSR_FEIE)

/*! @brief Set the FEIE field to a new value. */
#define BW_I2S_TCSR_FEIE(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FEIE) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SEIE[11] (RW)
 *
 * Enables/disables sync error interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
#define BP_I2S_TCSR_SEIE     (11U)         /*!< Bit position for I2S_TCSR_SEIE. */
#define BM_I2S_TCSR_SEIE     (0x00000800U) /*!< Bit mask for I2S_TCSR_SEIE. */
#define BS_I2S_TCSR_SEIE     (1U)          /*!< Bit field size in bits for I2S_TCSR_SEIE. */

/*! @brief Read current value of the I2S_TCSR_SEIE field. */
#define BR_I2S_TCSR_SEIE(x)  (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_SEIE))

/*! @brief Format value for bitfield I2S_TCSR_SEIE. */
#define BF_I2S_TCSR_SEIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_SEIE) & BM_I2S_TCSR_SEIE)

/*! @brief Set the SEIE field to a new value. */
#define BW_I2S_TCSR_SEIE(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_SEIE) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field WSIE[12] (RW)
 *
 * Enables/disables word start interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
#define BP_I2S_TCSR_WSIE     (12U)         /*!< Bit position for I2S_TCSR_WSIE. */
#define BM_I2S_TCSR_WSIE     (0x00001000U) /*!< Bit mask for I2S_TCSR_WSIE. */
#define BS_I2S_TCSR_WSIE     (1U)          /*!< Bit field size in bits for I2S_TCSR_WSIE. */

/*! @brief Read current value of the I2S_TCSR_WSIE field. */
#define BR_I2S_TCSR_WSIE(x)  (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_WSIE))

/*! @brief Format value for bitfield I2S_TCSR_WSIE. */
#define BF_I2S_TCSR_WSIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_WSIE) & BM_I2S_TCSR_WSIE)

/*! @brief Set the WSIE field to a new value. */
#define BW_I2S_TCSR_WSIE(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_WSIE) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FRF[16] (RO)
 *
 * Indicates that the number of words in an enabled transmit channel FIFO is
 * less than or equal to the transmit FIFO watermark.
 *
 * Values:
 * - 0 - Transmit FIFO watermark has not been reached.
 * - 1 - Transmit FIFO watermark has been reached.
 */
/*@{*/
#define BP_I2S_TCSR_FRF      (16U)         /*!< Bit position for I2S_TCSR_FRF. */
#define BM_I2S_TCSR_FRF      (0x00010000U) /*!< Bit mask for I2S_TCSR_FRF. */
#define BS_I2S_TCSR_FRF      (1U)          /*!< Bit field size in bits for I2S_TCSR_FRF. */

/*! @brief Read current value of the I2S_TCSR_FRF field. */
#define BR_I2S_TCSR_FRF(x)   (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FRF))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWF[17] (RO)
 *
 * Indicates that an enabled transmit FIFO is empty.
 *
 * Values:
 * - 0 - No enabled transmit FIFO is empty.
 * - 1 - Enabled transmit FIFO is empty.
 */
/*@{*/
#define BP_I2S_TCSR_FWF      (17U)         /*!< Bit position for I2S_TCSR_FWF. */
#define BM_I2S_TCSR_FWF      (0x00020000U) /*!< Bit mask for I2S_TCSR_FWF. */
#define BS_I2S_TCSR_FWF      (1U)          /*!< Bit field size in bits for I2S_TCSR_FWF. */

/*! @brief Read current value of the I2S_TCSR_FWF field. */
#define BR_I2S_TCSR_FWF(x)   (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FWF))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FEF[18] (W1C)
 *
 * Indicates that an enabled transmit FIFO has underrun. Write a logic 1 to this
 * field to clear this flag.
 *
 * Values:
 * - 0 - Transmit underrun not detected.
 * - 1 - Transmit underrun detected.
 */
/*@{*/
#define BP_I2S_TCSR_FEF      (18U)         /*!< Bit position for I2S_TCSR_FEF. */
#define BM_I2S_TCSR_FEF      (0x00040000U) /*!< Bit mask for I2S_TCSR_FEF. */
#define BS_I2S_TCSR_FEF      (1U)          /*!< Bit field size in bits for I2S_TCSR_FEF. */

/*! @brief Read current value of the I2S_TCSR_FEF field. */
#define BR_I2S_TCSR_FEF(x)   (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FEF))

/*! @brief Format value for bitfield I2S_TCSR_FEF. */
#define BF_I2S_TCSR_FEF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FEF) & BM_I2S_TCSR_FEF)

/*! @brief Set the FEF field to a new value. */
#define BW_I2S_TCSR_FEF(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FEF) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SEF[19] (W1C)
 *
 * Indicates that an error in the externally-generated frame sync has been
 * detected. Write a logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Sync error not detected.
 * - 1 - Frame sync error detected.
 */
/*@{*/
#define BP_I2S_TCSR_SEF      (19U)         /*!< Bit position for I2S_TCSR_SEF. */
#define BM_I2S_TCSR_SEF      (0x00080000U) /*!< Bit mask for I2S_TCSR_SEF. */
#define BS_I2S_TCSR_SEF      (1U)          /*!< Bit field size in bits for I2S_TCSR_SEF. */

/*! @brief Read current value of the I2S_TCSR_SEF field. */
#define BR_I2S_TCSR_SEF(x)   (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_SEF))

/*! @brief Format value for bitfield I2S_TCSR_SEF. */
#define BF_I2S_TCSR_SEF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_SEF) & BM_I2S_TCSR_SEF)

/*! @brief Set the SEF field to a new value. */
#define BW_I2S_TCSR_SEF(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_SEF) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field WSF[20] (W1C)
 *
 * Indicates that the start of the configured word has been detected. Write a
 * logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Start of word not detected.
 * - 1 - Start of word detected.
 */
/*@{*/
#define BP_I2S_TCSR_WSF      (20U)         /*!< Bit position for I2S_TCSR_WSF. */
#define BM_I2S_TCSR_WSF      (0x00100000U) /*!< Bit mask for I2S_TCSR_WSF. */
#define BS_I2S_TCSR_WSF      (1U)          /*!< Bit field size in bits for I2S_TCSR_WSF. */

/*! @brief Read current value of the I2S_TCSR_WSF field. */
#define BR_I2S_TCSR_WSF(x)   (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_WSF))

/*! @brief Format value for bitfield I2S_TCSR_WSF. */
#define BF_I2S_TCSR_WSF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_WSF) & BM_I2S_TCSR_WSF)

/*! @brief Set the WSF field to a new value. */
#define BW_I2S_TCSR_WSF(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_WSF) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SR[24] (RW)
 *
 * When set, resets the internal transmitter logic including the FIFO pointers.
 * Software-visible registers are not affected, except for the status registers.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Software reset.
 */
/*@{*/
#define BP_I2S_TCSR_SR       (24U)         /*!< Bit position for I2S_TCSR_SR. */
#define BM_I2S_TCSR_SR       (0x01000000U) /*!< Bit mask for I2S_TCSR_SR. */
#define BS_I2S_TCSR_SR       (1U)          /*!< Bit field size in bits for I2S_TCSR_SR. */

/*! @brief Read current value of the I2S_TCSR_SR field. */
#define BR_I2S_TCSR_SR(x)    (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_SR))

/*! @brief Format value for bitfield I2S_TCSR_SR. */
#define BF_I2S_TCSR_SR(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_SR) & BM_I2S_TCSR_SR)

/*! @brief Set the SR field to a new value. */
#define BW_I2S_TCSR_SR(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_SR) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FR[25] (WORZ)
 *
 * Resets the FIFO pointers. Reading this field will always return zero. FIFO
 * pointers should only be reset when the transmitter is disabled or the FIFO error
 * flag is set.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - FIFO reset.
 */
/*@{*/
#define BP_I2S_TCSR_FR       (25U)         /*!< Bit position for I2S_TCSR_FR. */
#define BM_I2S_TCSR_FR       (0x02000000U) /*!< Bit mask for I2S_TCSR_FR. */
#define BS_I2S_TCSR_FR       (1U)          /*!< Bit field size in bits for I2S_TCSR_FR. */

/*! @brief Format value for bitfield I2S_TCSR_FR. */
#define BF_I2S_TCSR_FR(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_FR) & BM_I2S_TCSR_FR)

/*! @brief Set the FR field to a new value. */
#define BW_I2S_TCSR_FR(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_FR) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field BCE[28] (RW)
 *
 * Enables the transmit bit clock, separately from the TE. This field is
 * automatically set whenever TE is set. When software clears this field, the transmit
 * bit clock remains enabled, and this bit remains set, until the end of the
 * current frame.
 *
 * Values:
 * - 0 - Transmit bit clock is disabled.
 * - 1 - Transmit bit clock is enabled.
 */
/*@{*/
#define BP_I2S_TCSR_BCE      (28U)         /*!< Bit position for I2S_TCSR_BCE. */
#define BM_I2S_TCSR_BCE      (0x10000000U) /*!< Bit mask for I2S_TCSR_BCE. */
#define BS_I2S_TCSR_BCE      (1U)          /*!< Bit field size in bits for I2S_TCSR_BCE. */

/*! @brief Read current value of the I2S_TCSR_BCE field. */
#define BR_I2S_TCSR_BCE(x)   (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_BCE))

/*! @brief Format value for bitfield I2S_TCSR_BCE. */
#define BF_I2S_TCSR_BCE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_BCE) & BM_I2S_TCSR_BCE)

/*! @brief Set the BCE field to a new value. */
#define BW_I2S_TCSR_BCE(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_BCE) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field DBGE[29] (RW)
 *
 * Enables/disables transmitter operation in Debug mode. The transmit bit clock
 * is not affected by debug mode.
 *
 * Values:
 * - 0 - Transmitter is disabled in Debug mode, after completing the current
 *     frame.
 * - 1 - Transmitter is enabled in Debug mode.
 */
/*@{*/
#define BP_I2S_TCSR_DBGE     (29U)         /*!< Bit position for I2S_TCSR_DBGE. */
#define BM_I2S_TCSR_DBGE     (0x20000000U) /*!< Bit mask for I2S_TCSR_DBGE. */
#define BS_I2S_TCSR_DBGE     (1U)          /*!< Bit field size in bits for I2S_TCSR_DBGE. */

/*! @brief Read current value of the I2S_TCSR_DBGE field. */
#define BR_I2S_TCSR_DBGE(x)  (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_DBGE))

/*! @brief Format value for bitfield I2S_TCSR_DBGE. */
#define BF_I2S_TCSR_DBGE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_DBGE) & BM_I2S_TCSR_DBGE)

/*! @brief Set the DBGE field to a new value. */
#define BW_I2S_TCSR_DBGE(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_DBGE) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field STOPE[30] (RW)
 *
 * Configures transmitter operation in Stop mode. This field is ignored and the
 * transmitter is disabled in all low-leakage stop modes.
 *
 * Values:
 * - 0 - Transmitter disabled in Stop mode.
 * - 1 - Transmitter enabled in Stop mode.
 */
/*@{*/
#define BP_I2S_TCSR_STOPE    (30U)         /*!< Bit position for I2S_TCSR_STOPE. */
#define BM_I2S_TCSR_STOPE    (0x40000000U) /*!< Bit mask for I2S_TCSR_STOPE. */
#define BS_I2S_TCSR_STOPE    (1U)          /*!< Bit field size in bits for I2S_TCSR_STOPE. */

/*! @brief Read current value of the I2S_TCSR_STOPE field. */
#define BR_I2S_TCSR_STOPE(x) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_STOPE))

/*! @brief Format value for bitfield I2S_TCSR_STOPE. */
#define BF_I2S_TCSR_STOPE(v) ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_STOPE) & BM_I2S_TCSR_STOPE)

/*! @brief Set the STOPE field to a new value. */
#define BW_I2S_TCSR_STOPE(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_STOPE) = (v))
/*@}*/

/*!
 * @name Register I2S_TCSR, field TE[31] (RW)
 *
 * Enables/disables the transmitter. When software clears this field, the
 * transmitter remains enabled, and this bit remains set, until the end of the current
 * frame.
 *
 * Values:
 * - 0 - Transmitter is disabled.
 * - 1 - Transmitter is enabled, or transmitter has been disabled and has not
 *     yet reached end of frame.
 */
/*@{*/
#define BP_I2S_TCSR_TE       (31U)         /*!< Bit position for I2S_TCSR_TE. */
#define BM_I2S_TCSR_TE       (0x80000000U) /*!< Bit mask for I2S_TCSR_TE. */
#define BS_I2S_TCSR_TE       (1U)          /*!< Bit field size in bits for I2S_TCSR_TE. */

/*! @brief Read current value of the I2S_TCSR_TE field. */
#define BR_I2S_TCSR_TE(x)    (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_TE))

/*! @brief Format value for bitfield I2S_TCSR_TE. */
#define BF_I2S_TCSR_TE(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_TCSR_TE) & BM_I2S_TCSR_TE)

/*! @brief Set the TE field to a new value. */
#define BW_I2S_TCSR_TE(x, v) (BITBAND_ACCESS32(HW_I2S_TCSR_ADDR(x), BP_I2S_TCSR_TE) = (v))
/*@}*/

/*******************************************************************************
 * HW_I2S_TCR1 - SAI Transmit Configuration 1 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TCR1 - SAI Transmit Configuration 1 Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_i2s_tcr1
{
    uint32_t U;
    struct _hw_i2s_tcr1_bitfields
    {
        uint32_t TFW : 3;              /*!< [2:0] Transmit FIFO Watermark */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_i2s_tcr1_t;

/*!
 * @name Constants and macros for entire I2S_TCR1 register
 */
/*@{*/
#define HW_I2S_TCR1_ADDR(x)      ((uint32_t)(x) + 0x4U)

#define HW_I2S_TCR1(x)           (*(__IO hw_i2s_tcr1_t *) HW_I2S_TCR1_ADDR(x))
#define HW_I2S_TCR1_RD(x)        (HW_I2S_TCR1(x).U)
#define HW_I2S_TCR1_WR(x, v)     (HW_I2S_TCR1(x).U = (v))
#define HW_I2S_TCR1_SET(x, v)    (HW_I2S_TCR1_WR(x, HW_I2S_TCR1_RD(x) |  (v)))
#define HW_I2S_TCR1_CLR(x, v)    (HW_I2S_TCR1_WR(x, HW_I2S_TCR1_RD(x) & ~(v)))
#define HW_I2S_TCR1_TOG(x, v)    (HW_I2S_TCR1_WR(x, HW_I2S_TCR1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR1 bitfields
 */

/*!
 * @name Register I2S_TCR1, field TFW[2:0] (RW)
 *
 * Configures the watermark level for all enabled transmit channels.
 */
/*@{*/
#define BP_I2S_TCR1_TFW      (0U)          /*!< Bit position for I2S_TCR1_TFW. */
#define BM_I2S_TCR1_TFW      (0x00000007U) /*!< Bit mask for I2S_TCR1_TFW. */
#define BS_I2S_TCR1_TFW      (3U)          /*!< Bit field size in bits for I2S_TCR1_TFW. */

/*! @brief Read current value of the I2S_TCR1_TFW field. */
#define BR_I2S_TCR1_TFW(x)   (HW_I2S_TCR1(x).B.TFW)

/*! @brief Format value for bitfield I2S_TCR1_TFW. */
#define BF_I2S_TCR1_TFW(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR1_TFW) & BM_I2S_TCR1_TFW)

/*! @brief Set the TFW field to a new value. */
#define BW_I2S_TCR1_TFW(x, v) (HW_I2S_TCR1_WR(x, (HW_I2S_TCR1_RD(x) & ~BM_I2S_TCR1_TFW) | BF_I2S_TCR1_TFW(v)))
/*@}*/

/*******************************************************************************
 * HW_I2S_TCR2 - SAI Transmit Configuration 2 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TCR2 - SAI Transmit Configuration 2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
typedef union _hw_i2s_tcr2
{
    uint32_t U;
    struct _hw_i2s_tcr2_bitfields
    {
        uint32_t DIV : 8;              /*!< [7:0] Bit Clock Divide */
        uint32_t RESERVED0 : 16;       /*!< [23:8]  */
        uint32_t BCD : 1;              /*!< [24] Bit Clock Direction */
        uint32_t BCP : 1;              /*!< [25] Bit Clock Polarity */
        uint32_t MSEL : 2;             /*!< [27:26] MCLK Select */
        uint32_t BCI : 1;              /*!< [28] Bit Clock Input */
        uint32_t BCS : 1;              /*!< [29] Bit Clock Swap */
        uint32_t SYNC : 2;             /*!< [31:30] Synchronous Mode */
    } B;
} hw_i2s_tcr2_t;

/*!
 * @name Constants and macros for entire I2S_TCR2 register
 */
/*@{*/
#define HW_I2S_TCR2_ADDR(x)      ((uint32_t)(x) + 0x8U)

#define HW_I2S_TCR2(x)           (*(__IO hw_i2s_tcr2_t *) HW_I2S_TCR2_ADDR(x))
#define HW_I2S_TCR2_RD(x)        (HW_I2S_TCR2(x).U)
#define HW_I2S_TCR2_WR(x, v)     (HW_I2S_TCR2(x).U = (v))
#define HW_I2S_TCR2_SET(x, v)    (HW_I2S_TCR2_WR(x, HW_I2S_TCR2_RD(x) |  (v)))
#define HW_I2S_TCR2_CLR(x, v)    (HW_I2S_TCR2_WR(x, HW_I2S_TCR2_RD(x) & ~(v)))
#define HW_I2S_TCR2_TOG(x, v)    (HW_I2S_TCR2_WR(x, HW_I2S_TCR2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR2 bitfields
 */

/*!
 * @name Register I2S_TCR2, field DIV[7:0] (RW)
 *
 * Divides down the audio master clock to generate the bit clock when configured
 * for an internal bit clock. The division value is (DIV + 1) * 2.
 */
/*@{*/
#define BP_I2S_TCR2_DIV      (0U)          /*!< Bit position for I2S_TCR2_DIV. */
#define BM_I2S_TCR2_DIV      (0x000000FFU) /*!< Bit mask for I2S_TCR2_DIV. */
#define BS_I2S_TCR2_DIV      (8U)          /*!< Bit field size in bits for I2S_TCR2_DIV. */

/*! @brief Read current value of the I2S_TCR2_DIV field. */
#define BR_I2S_TCR2_DIV(x)   (HW_I2S_TCR2(x).B.DIV)

/*! @brief Format value for bitfield I2S_TCR2_DIV. */
#define BF_I2S_TCR2_DIV(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_DIV) & BM_I2S_TCR2_DIV)

/*! @brief Set the DIV field to a new value. */
#define BW_I2S_TCR2_DIV(x, v) (HW_I2S_TCR2_WR(x, (HW_I2S_TCR2_RD(x) & ~BM_I2S_TCR2_DIV) | BF_I2S_TCR2_DIV(v)))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCD[24] (RW)
 *
 * Configures the direction of the bit clock.
 *
 * Values:
 * - 0 - Bit clock is generated externally in Slave mode.
 * - 1 - Bit clock is generated internally in Master mode.
 */
/*@{*/
#define BP_I2S_TCR2_BCD      (24U)         /*!< Bit position for I2S_TCR2_BCD. */
#define BM_I2S_TCR2_BCD      (0x01000000U) /*!< Bit mask for I2S_TCR2_BCD. */
#define BS_I2S_TCR2_BCD      (1U)          /*!< Bit field size in bits for I2S_TCR2_BCD. */

/*! @brief Read current value of the I2S_TCR2_BCD field. */
#define BR_I2S_TCR2_BCD(x)   (BITBAND_ACCESS32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCD))

/*! @brief Format value for bitfield I2S_TCR2_BCD. */
#define BF_I2S_TCR2_BCD(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_BCD) & BM_I2S_TCR2_BCD)

/*! @brief Set the BCD field to a new value. */
#define BW_I2S_TCR2_BCD(x, v) (BITBAND_ACCESS32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCD) = (v))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCP[25] (RW)
 *
 * Configures the polarity of the bit clock.
 *
 * Values:
 * - 0 - Bit clock is active high with drive outputs on rising edge and sample
 *     inputs on falling edge.
 * - 1 - Bit clock is active low with drive outputs on falling edge and sample
 *     inputs on rising edge.
 */
/*@{*/
#define BP_I2S_TCR2_BCP      (25U)         /*!< Bit position for I2S_TCR2_BCP. */
#define BM_I2S_TCR2_BCP      (0x02000000U) /*!< Bit mask for I2S_TCR2_BCP. */
#define BS_I2S_TCR2_BCP      (1U)          /*!< Bit field size in bits for I2S_TCR2_BCP. */

/*! @brief Read current value of the I2S_TCR2_BCP field. */
#define BR_I2S_TCR2_BCP(x)   (BITBAND_ACCESS32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCP))

/*! @brief Format value for bitfield I2S_TCR2_BCP. */
#define BF_I2S_TCR2_BCP(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_BCP) & BM_I2S_TCR2_BCP)

/*! @brief Set the BCP field to a new value. */
#define BW_I2S_TCR2_BCP(x, v) (BITBAND_ACCESS32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCP) = (v))
/*@}*/

/*!
 * @name Register I2S_TCR2, field MSEL[27:26] (RW)
 *
 * Selects the audio Master Clock option used to generate an internally
 * generated bit clock. This field has no effect when configured for an externally
 * generated bit clock. Depending on the device, some Master Clock options might not be
 * available. See the chip configuration details for the availability and
 * chip-specific meaning of each option.
 *
 * Values:
 * - 00 - Bus Clock selected.
 * - 01 - Master Clock (MCLK) 1 option selected.
 * - 10 - Master Clock (MCLK) 2 option selected.
 * - 11 - Master Clock (MCLK) 3 option selected.
 */
/*@{*/
#define BP_I2S_TCR2_MSEL     (26U)         /*!< Bit position for I2S_TCR2_MSEL. */
#define BM_I2S_TCR2_MSEL     (0x0C000000U) /*!< Bit mask for I2S_TCR2_MSEL. */
#define BS_I2S_TCR2_MSEL     (2U)          /*!< Bit field size in bits for I2S_TCR2_MSEL. */

/*! @brief Read current value of the I2S_TCR2_MSEL field. */
#define BR_I2S_TCR2_MSEL(x)  (HW_I2S_TCR2(x).B.MSEL)

/*! @brief Format value for bitfield I2S_TCR2_MSEL. */
#define BF_I2S_TCR2_MSEL(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_MSEL) & BM_I2S_TCR2_MSEL)

/*! @brief Set the MSEL field to a new value. */
#define BW_I2S_TCR2_MSEL(x, v) (HW_I2S_TCR2_WR(x, (HW_I2S_TCR2_RD(x) & ~BM_I2S_TCR2_MSEL) | BF_I2S_TCR2_MSEL(v)))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCI[28] (RW)
 *
 * When this field is set and using an internally generated bit clock in either
 * synchronous or asynchronous mode, the bit clock actually used by the
 * transmitter is delayed by the pad output delay (the transmitter is clocked by the pad
 * input as if the clock was externally generated). This has the effect of
 * decreasing the data input setup time, but increasing the data output valid time. The
 * slave mode timing from the datasheet should be used for the transmitter when
 * this bit is set. In synchronous mode, this bit allows the transmitter to use
 * the slave mode timing from the datasheet, while the receiver uses the master
 * mode timing. This field has no effect when configured for an externally generated
 * bit clock or when synchronous to another SAI peripheral .
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Internal logic is clocked as if bit clock was externally generated.
 */
/*@{*/
#define BP_I2S_TCR2_BCI      (28U)         /*!< Bit position for I2S_TCR2_BCI. */
#define BM_I2S_TCR2_BCI      (0x10000000U) /*!< Bit mask for I2S_TCR2_BCI. */
#define BS_I2S_TCR2_BCI      (1U)          /*!< Bit field size in bits for I2S_TCR2_BCI. */

/*! @brief Read current value of the I2S_TCR2_BCI field. */
#define BR_I2S_TCR2_BCI(x)   (BITBAND_ACCESS32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCI))

/*! @brief Format value for bitfield I2S_TCR2_BCI. */
#define BF_I2S_TCR2_BCI(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_BCI) & BM_I2S_TCR2_BCI)

/*! @brief Set the BCI field to a new value. */
#define BW_I2S_TCR2_BCI(x, v) (BITBAND_ACCESS32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCI) = (v))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCS[29] (RW)
 *
 * This field swaps the bit clock used by the transmitter. When the transmitter
 * is configured in asynchronous mode and this bit is set, the transmitter is
 * clocked by the receiver bit clock (SAI_RX_BCLK). This allows the transmitter and
 * receiver to share the same bit clock, but the transmitter continues to use the
 * transmit frame sync (SAI_TX_SYNC). When the transmitter is configured in
 * synchronous mode, the transmitter BCS field and receiver BCS field must be set to
 * the same value. When both are set, the transmitter and receiver are both
 * clocked by the transmitter bit clock (SAI_TX_BCLK) but use the receiver frame sync
 * (SAI_RX_SYNC). This field has no effect when synchronous to another SAI
 * peripheral.
 *
 * Values:
 * - 0 - Use the normal bit clock source.
 * - 1 - Swap the bit clock source.
 */
/*@{*/
#define BP_I2S_TCR2_BCS      (29U)         /*!< Bit position for I2S_TCR2_BCS. */
#define BM_I2S_TCR2_BCS      (0x20000000U) /*!< Bit mask for I2S_TCR2_BCS. */
#define BS_I2S_TCR2_BCS      (1U)          /*!< Bit field size in bits for I2S_TCR2_BCS. */

/*! @brief Read current value of the I2S_TCR2_BCS field. */
#define BR_I2S_TCR2_BCS(x)   (BITBAND_ACCESS32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCS))

/*! @brief Format value for bitfield I2S_TCR2_BCS. */
#define BF_I2S_TCR2_BCS(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_BCS) & BM_I2S_TCR2_BCS)

/*! @brief Set the BCS field to a new value. */
#define BW_I2S_TCR2_BCS(x, v) (BITBAND_ACCESS32(HW_I2S_TCR2_ADDR(x), BP_I2S_TCR2_BCS) = (v))
/*@}*/

/*!
 * @name Register I2S_TCR2, field SYNC[31:30] (RW)
 *
 * Configures between asynchronous and synchronous modes of operation. When
 * configured for a synchronous mode of operation, the receiver or other SAI
 * peripheral must be configured for asynchronous operation.
 *
 * Values:
 * - 00 - Asynchronous mode.
 * - 01 - Synchronous with receiver.
 * - 10 - Synchronous with another SAI transmitter.
 * - 11 - Synchronous with another SAI receiver.
 */
/*@{*/
#define BP_I2S_TCR2_SYNC     (30U)         /*!< Bit position for I2S_TCR2_SYNC. */
#define BM_I2S_TCR2_SYNC     (0xC0000000U) /*!< Bit mask for I2S_TCR2_SYNC. */
#define BS_I2S_TCR2_SYNC     (2U)          /*!< Bit field size in bits for I2S_TCR2_SYNC. */

/*! @brief Read current value of the I2S_TCR2_SYNC field. */
#define BR_I2S_TCR2_SYNC(x)  (HW_I2S_TCR2(x).B.SYNC)

/*! @brief Format value for bitfield I2S_TCR2_SYNC. */
#define BF_I2S_TCR2_SYNC(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCR2_SYNC) & BM_I2S_TCR2_SYNC)

/*! @brief Set the SYNC field to a new value. */
#define BW_I2S_TCR2_SYNC(x, v) (HW_I2S_TCR2_WR(x, (HW_I2S_TCR2_RD(x) & ~BM_I2S_TCR2_SYNC) | BF_I2S_TCR2_SYNC(v)))
/*@}*/

/*******************************************************************************
 * HW_I2S_TCR3 - SAI Transmit Configuration 3 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TCR3 - SAI Transmit Configuration 3 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
typedef union _hw_i2s_tcr3
{
    uint32_t U;
    struct _hw_i2s_tcr3_bitfields
    {
        uint32_t WDFL : 5;             /*!< [4:0] Word Flag Configuration */
        uint32_t RESERVED0 : 11;       /*!< [15:5]  */
        uint32_t TCE : 2;              /*!< [17:16] Transmit Channel Enable */
        uint32_t RESERVED1 : 14;       /*!< [31:18]  */
    } B;
} hw_i2s_tcr3_t;

/*!
 * @name Constants and macros for entire I2S_TCR3 register
 */
/*@{*/
#define HW_I2S_TCR3_ADDR(x)      ((uint32_t)(x) + 0xCU)

#define HW_I2S_TCR3(x)           (*(__IO hw_i2s_tcr3_t *) HW_I2S_TCR3_ADDR(x))
#define HW_I2S_TCR3_RD(x)        (HW_I2S_TCR3(x).U)
#define HW_I2S_TCR3_WR(x, v)     (HW_I2S_TCR3(x).U = (v))
#define HW_I2S_TCR3_SET(x, v)    (HW_I2S_TCR3_WR(x, HW_I2S_TCR3_RD(x) |  (v)))
#define HW_I2S_TCR3_CLR(x, v)    (HW_I2S_TCR3_WR(x, HW_I2S_TCR3_RD(x) & ~(v)))
#define HW_I2S_TCR3_TOG(x, v)    (HW_I2S_TCR3_WR(x, HW_I2S_TCR3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR3 bitfields
 */

/*!
 * @name Register I2S_TCR3, field WDFL[4:0] (RW)
 *
 * Configures which word sets the start of word flag. The value written must be
 * one less than the word number. For example, writing 0 configures the first
 * word in the frame. When configured to a value greater than TCR4[FRSZ], then the
 * start of word flag is never set.
 */
/*@{*/
#define BP_I2S_TCR3_WDFL     (0U)          /*!< Bit position for I2S_TCR3_WDFL. */
#define BM_I2S_TCR3_WDFL     (0x0000001FU) /*!< Bit mask for I2S_TCR3_WDFL. */
#define BS_I2S_TCR3_WDFL     (5U)          /*!< Bit field size in bits for I2S_TCR3_WDFL. */

/*! @brief Read current value of the I2S_TCR3_WDFL field. */
#define BR_I2S_TCR3_WDFL(x)  (HW_I2S_TCR3(x).B.WDFL)

/*! @brief Format value for bitfield I2S_TCR3_WDFL. */
#define BF_I2S_TCR3_WDFL(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCR3_WDFL) & BM_I2S_TCR3_WDFL)

/*! @brief Set the WDFL field to a new value. */
#define BW_I2S_TCR3_WDFL(x, v) (HW_I2S_TCR3_WR(x, (HW_I2S_TCR3_RD(x) & ~BM_I2S_TCR3_WDFL) | BF_I2S_TCR3_WDFL(v)))
/*@}*/

/*!
 * @name Register I2S_TCR3, field TCE[17:16] (RW)
 *
 * Enables the corresponding data channel for transmit operation. A channel must
 * be enabled before its FIFO is accessed.
 *
 * Values:
 * - 0 - Transmit data channel N is disabled.
 * - 1 - Transmit data channel N is enabled.
 */
/*@{*/
#define BP_I2S_TCR3_TCE      (16U)         /*!< Bit position for I2S_TCR3_TCE. */
#define BM_I2S_TCR3_TCE      (0x00030000U) /*!< Bit mask for I2S_TCR3_TCE. */
#define BS_I2S_TCR3_TCE      (2U)          /*!< Bit field size in bits for I2S_TCR3_TCE. */

/*! @brief Read current value of the I2S_TCR3_TCE field. */
#define BR_I2S_TCR3_TCE(x)   (HW_I2S_TCR3(x).B.TCE)

/*! @brief Format value for bitfield I2S_TCR3_TCE. */
#define BF_I2S_TCR3_TCE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR3_TCE) & BM_I2S_TCR3_TCE)

/*! @brief Set the TCE field to a new value. */
#define BW_I2S_TCR3_TCE(x, v) (HW_I2S_TCR3_WR(x, (HW_I2S_TCR3_RD(x) & ~BM_I2S_TCR3_TCE) | BF_I2S_TCR3_TCE(v)))
/*@}*/

/*******************************************************************************
 * HW_I2S_TCR4 - SAI Transmit Configuration 4 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TCR4 - SAI Transmit Configuration 4 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
typedef union _hw_i2s_tcr4
{
    uint32_t U;
    struct _hw_i2s_tcr4_bitfields
    {
        uint32_t FSD : 1;              /*!< [0] Frame Sync Direction */
        uint32_t FSP : 1;              /*!< [1] Frame Sync Polarity */
        uint32_t RESERVED0 : 1;        /*!< [2]  */
        uint32_t FSE : 1;              /*!< [3] Frame Sync Early */
        uint32_t MF : 1;               /*!< [4] MSB First */
        uint32_t RESERVED1 : 3;        /*!< [7:5]  */
        uint32_t SYWD : 5;             /*!< [12:8] Sync Width */
        uint32_t RESERVED2 : 3;        /*!< [15:13]  */
        uint32_t FRSZ : 5;             /*!< [20:16] Frame size */
        uint32_t RESERVED3 : 11;       /*!< [31:21]  */
    } B;
} hw_i2s_tcr4_t;

/*!
 * @name Constants and macros for entire I2S_TCR4 register
 */
/*@{*/
#define HW_I2S_TCR4_ADDR(x)      ((uint32_t)(x) + 0x10U)

#define HW_I2S_TCR4(x)           (*(__IO hw_i2s_tcr4_t *) HW_I2S_TCR4_ADDR(x))
#define HW_I2S_TCR4_RD(x)        (HW_I2S_TCR4(x).U)
#define HW_I2S_TCR4_WR(x, v)     (HW_I2S_TCR4(x).U = (v))
#define HW_I2S_TCR4_SET(x, v)    (HW_I2S_TCR4_WR(x, HW_I2S_TCR4_RD(x) |  (v)))
#define HW_I2S_TCR4_CLR(x, v)    (HW_I2S_TCR4_WR(x, HW_I2S_TCR4_RD(x) & ~(v)))
#define HW_I2S_TCR4_TOG(x, v)    (HW_I2S_TCR4_WR(x, HW_I2S_TCR4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR4 bitfields
 */

/*!
 * @name Register I2S_TCR4, field FSD[0] (RW)
 *
 * Configures the direction of the frame sync.
 *
 * Values:
 * - 0 - Frame sync is generated externally in Slave mode.
 * - 1 - Frame sync is generated internally in Master mode.
 */
/*@{*/
#define BP_I2S_TCR4_FSD      (0U)          /*!< Bit position for I2S_TCR4_FSD. */
#define BM_I2S_TCR4_FSD      (0x00000001U) /*!< Bit mask for I2S_TCR4_FSD. */
#define BS_I2S_TCR4_FSD      (1U)          /*!< Bit field size in bits for I2S_TCR4_FSD. */

/*! @brief Read current value of the I2S_TCR4_FSD field. */
#define BR_I2S_TCR4_FSD(x)   (BITBAND_ACCESS32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FSD))

/*! @brief Format value for bitfield I2S_TCR4_FSD. */
#define BF_I2S_TCR4_FSD(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_FSD) & BM_I2S_TCR4_FSD)

/*! @brief Set the FSD field to a new value. */
#define BW_I2S_TCR4_FSD(x, v) (BITBAND_ACCESS32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FSD) = (v))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FSP[1] (RW)
 *
 * Configures the polarity of the frame sync.
 *
 * Values:
 * - 0 - Frame sync is active high.
 * - 1 - Frame sync is active low.
 */
/*@{*/
#define BP_I2S_TCR4_FSP      (1U)          /*!< Bit position for I2S_TCR4_FSP. */
#define BM_I2S_TCR4_FSP      (0x00000002U) /*!< Bit mask for I2S_TCR4_FSP. */
#define BS_I2S_TCR4_FSP      (1U)          /*!< Bit field size in bits for I2S_TCR4_FSP. */

/*! @brief Read current value of the I2S_TCR4_FSP field. */
#define BR_I2S_TCR4_FSP(x)   (BITBAND_ACCESS32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FSP))

/*! @brief Format value for bitfield I2S_TCR4_FSP. */
#define BF_I2S_TCR4_FSP(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_FSP) & BM_I2S_TCR4_FSP)

/*! @brief Set the FSP field to a new value. */
#define BW_I2S_TCR4_FSP(x, v) (BITBAND_ACCESS32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FSP) = (v))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FSE[3] (RW)
 *
 * Values:
 * - 0 - Frame sync asserts with the first bit of the frame.
 * - 1 - Frame sync asserts one bit before the first bit of the frame.
 */
/*@{*/
#define BP_I2S_TCR4_FSE      (3U)          /*!< Bit position for I2S_TCR4_FSE. */
#define BM_I2S_TCR4_FSE      (0x00000008U) /*!< Bit mask for I2S_TCR4_FSE. */
#define BS_I2S_TCR4_FSE      (1U)          /*!< Bit field size in bits for I2S_TCR4_FSE. */

/*! @brief Read current value of the I2S_TCR4_FSE field. */
#define BR_I2S_TCR4_FSE(x)   (BITBAND_ACCESS32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FSE))

/*! @brief Format value for bitfield I2S_TCR4_FSE. */
#define BF_I2S_TCR4_FSE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_FSE) & BM_I2S_TCR4_FSE)

/*! @brief Set the FSE field to a new value. */
#define BW_I2S_TCR4_FSE(x, v) (BITBAND_ACCESS32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_FSE) = (v))
/*@}*/

/*!
 * @name Register I2S_TCR4, field MF[4] (RW)
 *
 * Configures whether the LSB or the MSB is transmitted first.
 *
 * Values:
 * - 0 - LSB is transmitted first.
 * - 1 - MSB is transmitted first.
 */
/*@{*/
#define BP_I2S_TCR4_MF       (4U)          /*!< Bit position for I2S_TCR4_MF. */
#define BM_I2S_TCR4_MF       (0x00000010U) /*!< Bit mask for I2S_TCR4_MF. */
#define BS_I2S_TCR4_MF       (1U)          /*!< Bit field size in bits for I2S_TCR4_MF. */

/*! @brief Read current value of the I2S_TCR4_MF field. */
#define BR_I2S_TCR4_MF(x)    (BITBAND_ACCESS32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_MF))

/*! @brief Format value for bitfield I2S_TCR4_MF. */
#define BF_I2S_TCR4_MF(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_MF) & BM_I2S_TCR4_MF)

/*! @brief Set the MF field to a new value. */
#define BW_I2S_TCR4_MF(x, v) (BITBAND_ACCESS32(HW_I2S_TCR4_ADDR(x), BP_I2S_TCR4_MF) = (v))
/*@}*/

/*!
 * @name Register I2S_TCR4, field SYWD[12:8] (RW)
 *
 * Configures the length of the frame sync in number of bit clocks. The value
 * written must be one less than the number of bit clocks. For example, write 0 for
 * the frame sync to assert for one bit clock only. The sync width cannot be
 * configured longer than the first word of the frame.
 */
/*@{*/
#define BP_I2S_TCR4_SYWD     (8U)          /*!< Bit position for I2S_TCR4_SYWD. */
#define BM_I2S_TCR4_SYWD     (0x00001F00U) /*!< Bit mask for I2S_TCR4_SYWD. */
#define BS_I2S_TCR4_SYWD     (5U)          /*!< Bit field size in bits for I2S_TCR4_SYWD. */

/*! @brief Read current value of the I2S_TCR4_SYWD field. */
#define BR_I2S_TCR4_SYWD(x)  (HW_I2S_TCR4(x).B.SYWD)

/*! @brief Format value for bitfield I2S_TCR4_SYWD. */
#define BF_I2S_TCR4_SYWD(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_SYWD) & BM_I2S_TCR4_SYWD)

/*! @brief Set the SYWD field to a new value. */
#define BW_I2S_TCR4_SYWD(x, v) (HW_I2S_TCR4_WR(x, (HW_I2S_TCR4_RD(x) & ~BM_I2S_TCR4_SYWD) | BF_I2S_TCR4_SYWD(v)))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FRSZ[20:16] (RW)
 *
 * Configures the number of words in each frame. The value written must be one
 * less than the number of words in the frame. For example, write 0 for one word
 * per frame. The maximum supported frame size is 32 words.
 */
/*@{*/
#define BP_I2S_TCR4_FRSZ     (16U)         /*!< Bit position for I2S_TCR4_FRSZ. */
#define BM_I2S_TCR4_FRSZ     (0x001F0000U) /*!< Bit mask for I2S_TCR4_FRSZ. */
#define BS_I2S_TCR4_FRSZ     (5U)          /*!< Bit field size in bits for I2S_TCR4_FRSZ. */

/*! @brief Read current value of the I2S_TCR4_FRSZ field. */
#define BR_I2S_TCR4_FRSZ(x)  (HW_I2S_TCR4(x).B.FRSZ)

/*! @brief Format value for bitfield I2S_TCR4_FRSZ. */
#define BF_I2S_TCR4_FRSZ(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_TCR4_FRSZ) & BM_I2S_TCR4_FRSZ)

/*! @brief Set the FRSZ field to a new value. */
#define BW_I2S_TCR4_FRSZ(x, v) (HW_I2S_TCR4_WR(x, (HW_I2S_TCR4_RD(x) & ~BM_I2S_TCR4_FRSZ) | BF_I2S_TCR4_FRSZ(v)))
/*@}*/

/*******************************************************************************
 * HW_I2S_TCR5 - SAI Transmit Configuration 5 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TCR5 - SAI Transmit Configuration 5 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
typedef union _hw_i2s_tcr5
{
    uint32_t U;
    struct _hw_i2s_tcr5_bitfields
    {
        uint32_t RESERVED0 : 8;        /*!< [7:0]  */
        uint32_t FBT : 5;              /*!< [12:8] First Bit Shifted */
        uint32_t RESERVED1 : 3;        /*!< [15:13]  */
        uint32_t W0W : 5;              /*!< [20:16] Word 0 Width */
        uint32_t RESERVED2 : 3;        /*!< [23:21]  */
        uint32_t WNW : 5;              /*!< [28:24] Word N Width */
        uint32_t RESERVED3 : 3;        /*!< [31:29]  */
    } B;
} hw_i2s_tcr5_t;

/*!
 * @name Constants and macros for entire I2S_TCR5 register
 */
/*@{*/
#define HW_I2S_TCR5_ADDR(x)      ((uint32_t)(x) + 0x14U)

#define HW_I2S_TCR5(x)           (*(__IO hw_i2s_tcr5_t *) HW_I2S_TCR5_ADDR(x))
#define HW_I2S_TCR5_RD(x)        (HW_I2S_TCR5(x).U)
#define HW_I2S_TCR5_WR(x, v)     (HW_I2S_TCR5(x).U = (v))
#define HW_I2S_TCR5_SET(x, v)    (HW_I2S_TCR5_WR(x, HW_I2S_TCR5_RD(x) |  (v)))
#define HW_I2S_TCR5_CLR(x, v)    (HW_I2S_TCR5_WR(x, HW_I2S_TCR5_RD(x) & ~(v)))
#define HW_I2S_TCR5_TOG(x, v)    (HW_I2S_TCR5_WR(x, HW_I2S_TCR5_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR5 bitfields
 */

/*!
 * @name Register I2S_TCR5, field FBT[12:8] (RW)
 *
 * Configures the bit index for the first bit transmitted for each word in the
 * frame. If configured for MSB First, the index of the next bit transmitted is
 * one less than the current bit transmitted. If configured for LSB First, the
 * index of the next bit transmitted is one more than the current bit transmitted.
 * The value written must be greater than or equal to the word width when
 * configured for MSB First. The value written must be less than or equal to 31-word width
 * when configured for LSB First.
 */
/*@{*/
#define BP_I2S_TCR5_FBT      (8U)          /*!< Bit position for I2S_TCR5_FBT. */
#define BM_I2S_TCR5_FBT      (0x00001F00U) /*!< Bit mask for I2S_TCR5_FBT. */
#define BS_I2S_TCR5_FBT      (5U)          /*!< Bit field size in bits for I2S_TCR5_FBT. */

/*! @brief Read current value of the I2S_TCR5_FBT field. */
#define BR_I2S_TCR5_FBT(x)   (HW_I2S_TCR5(x).B.FBT)

/*! @brief Format value for bitfield I2S_TCR5_FBT. */
#define BF_I2S_TCR5_FBT(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR5_FBT) & BM_I2S_TCR5_FBT)

/*! @brief Set the FBT field to a new value. */
#define BW_I2S_TCR5_FBT(x, v) (HW_I2S_TCR5_WR(x, (HW_I2S_TCR5_RD(x) & ~BM_I2S_TCR5_FBT) | BF_I2S_TCR5_FBT(v)))
/*@}*/

/*!
 * @name Register I2S_TCR5, field W0W[20:16] (RW)
 *
 * Configures the number of bits in the first word in each frame. The value
 * written must be one less than the number of bits in the first word. Word width of
 * less than 8 bits is not supported if there is only one word per frame.
 */
/*@{*/
#define BP_I2S_TCR5_W0W      (16U)         /*!< Bit position for I2S_TCR5_W0W. */
#define BM_I2S_TCR5_W0W      (0x001F0000U) /*!< Bit mask for I2S_TCR5_W0W. */
#define BS_I2S_TCR5_W0W      (5U)          /*!< Bit field size in bits for I2S_TCR5_W0W. */

/*! @brief Read current value of the I2S_TCR5_W0W field. */
#define BR_I2S_TCR5_W0W(x)   (HW_I2S_TCR5(x).B.W0W)

/*! @brief Format value for bitfield I2S_TCR5_W0W. */
#define BF_I2S_TCR5_W0W(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR5_W0W) & BM_I2S_TCR5_W0W)

/*! @brief Set the W0W field to a new value. */
#define BW_I2S_TCR5_W0W(x, v) (HW_I2S_TCR5_WR(x, (HW_I2S_TCR5_RD(x) & ~BM_I2S_TCR5_W0W) | BF_I2S_TCR5_W0W(v)))
/*@}*/

/*!
 * @name Register I2S_TCR5, field WNW[28:24] (RW)
 *
 * Configures the number of bits in each word, for each word except the first in
 * the frame. The value written must be one less than the number of bits per
 * word. Word width of less than 8 bits is not supported.
 */
/*@{*/
#define BP_I2S_TCR5_WNW      (24U)         /*!< Bit position for I2S_TCR5_WNW. */
#define BM_I2S_TCR5_WNW      (0x1F000000U) /*!< Bit mask for I2S_TCR5_WNW. */
#define BS_I2S_TCR5_WNW      (5U)          /*!< Bit field size in bits for I2S_TCR5_WNW. */

/*! @brief Read current value of the I2S_TCR5_WNW field. */
#define BR_I2S_TCR5_WNW(x)   (HW_I2S_TCR5(x).B.WNW)

/*! @brief Format value for bitfield I2S_TCR5_WNW. */
#define BF_I2S_TCR5_WNW(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TCR5_WNW) & BM_I2S_TCR5_WNW)

/*! @brief Set the WNW field to a new value. */
#define BW_I2S_TCR5_WNW(x, v) (HW_I2S_TCR5_WR(x, (HW_I2S_TCR5_RD(x) & ~BM_I2S_TCR5_WNW) | BF_I2S_TCR5_WNW(v)))
/*@}*/

/*******************************************************************************
 * HW_I2S_TDRn - SAI Transmit Data Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TDRn - SAI Transmit Data Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_i2s_tdrn
{
    uint32_t U;
    struct _hw_i2s_tdrn_bitfields
    {
        uint32_t TDR : 32;             /*!< [31:0] Transmit Data Register */
    } B;
} hw_i2s_tdrn_t;

/*!
 * @name Constants and macros for entire I2S_TDRn register
 */
/*@{*/
#define HW_I2S_TDRn_COUNT (2U)

#define HW_I2S_TDRn_ADDR(x, n)   ((uint32_t)(x) + 0x20U + (0x4U * (n)))

#define HW_I2S_TDRn(x, n)        (*(__O hw_i2s_tdrn_t *) HW_I2S_TDRn_ADDR(x, n))
#define HW_I2S_TDRn_RD(x, n)     (HW_I2S_TDRn(x, n).U)
#define HW_I2S_TDRn_WR(x, n, v)  (HW_I2S_TDRn(x, n).U = (v))
/*@}*/

/*
 * Constants & macros for individual I2S_TDRn bitfields
 */

/*!
 * @name Register I2S_TDRn, field TDR[31:0] (WORZ)
 *
 * The corresponding TCR3[TCE] bit must be set before accessing the channel's
 * transmit data register. Writes to this register when the transmit FIFO is not
 * full will push the data written into the transmit data FIFO. Writes to this
 * register when the transmit FIFO is full are ignored.
 */
/*@{*/
#define BP_I2S_TDRn_TDR      (0U)          /*!< Bit position for I2S_TDRn_TDR. */
#define BM_I2S_TDRn_TDR      (0xFFFFFFFFU) /*!< Bit mask for I2S_TDRn_TDR. */
#define BS_I2S_TDRn_TDR      (32U)         /*!< Bit field size in bits for I2S_TDRn_TDR. */

/*! @brief Format value for bitfield I2S_TDRn_TDR. */
#define BF_I2S_TDRn_TDR(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_TDRn_TDR) & BM_I2S_TDRn_TDR)

/*! @brief Set the TDR field to a new value. */
#define BW_I2S_TDRn_TDR(x, n, v) (HW_I2S_TDRn_WR(x, n, v))
/*@}*/

/*******************************************************************************
 * HW_I2S_TFRn - SAI Transmit FIFO Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TFRn - SAI Transmit FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The MSB of the read and write pointers is used to distinguish between FIFO
 * full and empty conditions. If the read and write pointers are identical, then
 * the FIFO is empty. If the read and write pointers are identical except for the
 * MSB, then the FIFO is full.
 */
typedef union _hw_i2s_tfrn
{
    uint32_t U;
    struct _hw_i2s_tfrn_bitfields
    {
        uint32_t RFP : 4;              /*!< [3:0] Read FIFO Pointer */
        uint32_t RESERVED0 : 12;       /*!< [15:4]  */
        uint32_t WFP : 4;              /*!< [19:16] Write FIFO Pointer */
        uint32_t RESERVED1 : 12;       /*!< [31:20]  */
    } B;
} hw_i2s_tfrn_t;

/*!
 * @name Constants and macros for entire I2S_TFRn register
 */
/*@{*/
#define HW_I2S_TFRn_COUNT (2U)

#define HW_I2S_TFRn_ADDR(x, n)   ((uint32_t)(x) + 0x40U + (0x4U * (n)))

#define HW_I2S_TFRn(x, n)        (*(__I hw_i2s_tfrn_t *) HW_I2S_TFRn_ADDR(x, n))
#define HW_I2S_TFRn_RD(x, n)     (HW_I2S_TFRn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual I2S_TFRn bitfields
 */

/*!
 * @name Register I2S_TFRn, field RFP[3:0] (RO)
 *
 * FIFO read pointer for transmit data channel.
 */
/*@{*/
#define BP_I2S_TFRn_RFP      (0U)          /*!< Bit position for I2S_TFRn_RFP. */
#define BM_I2S_TFRn_RFP      (0x0000000FU) /*!< Bit mask for I2S_TFRn_RFP. */
#define BS_I2S_TFRn_RFP      (4U)          /*!< Bit field size in bits for I2S_TFRn_RFP. */

/*! @brief Read current value of the I2S_TFRn_RFP field. */
#define BR_I2S_TFRn_RFP(x, n) (HW_I2S_TFRn(x, n).B.RFP)
/*@}*/

/*!
 * @name Register I2S_TFRn, field WFP[19:16] (RO)
 *
 * FIFO write pointer for transmit data channel.
 */
/*@{*/
#define BP_I2S_TFRn_WFP      (16U)         /*!< Bit position for I2S_TFRn_WFP. */
#define BM_I2S_TFRn_WFP      (0x000F0000U) /*!< Bit mask for I2S_TFRn_WFP. */
#define BS_I2S_TFRn_WFP      (4U)          /*!< Bit field size in bits for I2S_TFRn_WFP. */

/*! @brief Read current value of the I2S_TFRn_WFP field. */
#define BR_I2S_TFRn_WFP(x, n) (HW_I2S_TFRn(x, n).B.WFP)
/*@}*/

/*******************************************************************************
 * HW_I2S_TMR - SAI Transmit Mask Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_TMR - SAI Transmit Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is double-buffered and updates: When TCSR[TE] is first set At
 * the end of each frame. This allows the masked words in each frame to change
 * from frame to frame.
 */
typedef union _hw_i2s_tmr
{
    uint32_t U;
    struct _hw_i2s_tmr_bitfields
    {
        uint32_t TWM : 32;             /*!< [31:0] Transmit Word Mask */
    } B;
} hw_i2s_tmr_t;

/*!
 * @name Constants and macros for entire I2S_TMR register
 */
/*@{*/
#define HW_I2S_TMR_ADDR(x)       ((uint32_t)(x) + 0x60U)

#define HW_I2S_TMR(x)            (*(__IO hw_i2s_tmr_t *) HW_I2S_TMR_ADDR(x))
#define HW_I2S_TMR_RD(x)         (HW_I2S_TMR(x).U)
#define HW_I2S_TMR_WR(x, v)      (HW_I2S_TMR(x).U = (v))
#define HW_I2S_TMR_SET(x, v)     (HW_I2S_TMR_WR(x, HW_I2S_TMR_RD(x) |  (v)))
#define HW_I2S_TMR_CLR(x, v)     (HW_I2S_TMR_WR(x, HW_I2S_TMR_RD(x) & ~(v)))
#define HW_I2S_TMR_TOG(x, v)     (HW_I2S_TMR_WR(x, HW_I2S_TMR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_TMR bitfields
 */

/*!
 * @name Register I2S_TMR, field TWM[31:0] (RW)
 *
 * Configures whether the transmit word is masked (transmit data pin tristated
 * and transmit data not read from FIFO) for the corresponding word in the frame.
 *
 * Values:
 * - 0 - Word N is enabled.
 * - 1 - Word N is masked. The transmit data pins are tri-stated when masked.
 */
/*@{*/
#define BP_I2S_TMR_TWM       (0U)          /*!< Bit position for I2S_TMR_TWM. */
#define BM_I2S_TMR_TWM       (0xFFFFFFFFU) /*!< Bit mask for I2S_TMR_TWM. */
#define BS_I2S_TMR_TWM       (32U)         /*!< Bit field size in bits for I2S_TMR_TWM. */

/*! @brief Read current value of the I2S_TMR_TWM field. */
#define BR_I2S_TMR_TWM(x)    (HW_I2S_TMR(x).U)

/*! @brief Format value for bitfield I2S_TMR_TWM. */
#define BF_I2S_TMR_TWM(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_TMR_TWM) & BM_I2S_TMR_TWM)

/*! @brief Set the TWM field to a new value. */
#define BW_I2S_TMR_TWM(x, v) (HW_I2S_TMR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_I2S_RCSR - SAI Receive Control Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RCSR - SAI Receive Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_i2s_rcsr
{
    uint32_t U;
    struct _hw_i2s_rcsr_bitfields
    {
        uint32_t FRDE : 1;             /*!< [0] FIFO Request DMA Enable */
        uint32_t FWDE : 1;             /*!< [1] FIFO Warning DMA Enable */
        uint32_t RESERVED0 : 6;        /*!< [7:2]  */
        uint32_t FRIE : 1;             /*!< [8] FIFO Request Interrupt Enable */
        uint32_t FWIE : 1;             /*!< [9] FIFO Warning Interrupt Enable */
        uint32_t FEIE : 1;             /*!< [10] FIFO Error Interrupt Enable */
        uint32_t SEIE : 1;             /*!< [11] Sync Error Interrupt Enable */
        uint32_t WSIE : 1;             /*!< [12] Word Start Interrupt Enable */
        uint32_t RESERVED1 : 3;        /*!< [15:13]  */
        uint32_t FRF : 1;              /*!< [16] FIFO Request Flag */
        uint32_t FWF : 1;              /*!< [17] FIFO Warning Flag */
        uint32_t FEF : 1;              /*!< [18] FIFO Error Flag */
        uint32_t SEF : 1;              /*!< [19] Sync Error Flag */
        uint32_t WSF : 1;              /*!< [20] Word Start Flag */
        uint32_t RESERVED2 : 3;        /*!< [23:21]  */
        uint32_t SR : 1;               /*!< [24] Software Reset */
        uint32_t FR : 1;               /*!< [25] FIFO Reset */
        uint32_t RESERVED3 : 2;        /*!< [27:26]  */
        uint32_t BCE : 1;              /*!< [28] Bit Clock Enable */
        uint32_t DBGE : 1;             /*!< [29] Debug Enable */
        uint32_t STOPE : 1;            /*!< [30] Stop Enable */
        uint32_t RE : 1;               /*!< [31] Receiver Enable */
    } B;
} hw_i2s_rcsr_t;

/*!
 * @name Constants and macros for entire I2S_RCSR register
 */
/*@{*/
#define HW_I2S_RCSR_ADDR(x)      ((uint32_t)(x) + 0x80U)

#define HW_I2S_RCSR(x)           (*(__IO hw_i2s_rcsr_t *) HW_I2S_RCSR_ADDR(x))
#define HW_I2S_RCSR_RD(x)        (HW_I2S_RCSR(x).U)
#define HW_I2S_RCSR_WR(x, v)     (HW_I2S_RCSR(x).U = (v))
#define HW_I2S_RCSR_SET(x, v)    (HW_I2S_RCSR_WR(x, HW_I2S_RCSR_RD(x) |  (v)))
#define HW_I2S_RCSR_CLR(x, v)    (HW_I2S_RCSR_WR(x, HW_I2S_RCSR_RD(x) & ~(v)))
#define HW_I2S_RCSR_TOG(x, v)    (HW_I2S_RCSR_WR(x, HW_I2S_RCSR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCSR bitfields
 */

/*!
 * @name Register I2S_RCSR, field FRDE[0] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
#define BP_I2S_RCSR_FRDE     (0U)          /*!< Bit position for I2S_RCSR_FRDE. */
#define BM_I2S_RCSR_FRDE     (0x00000001U) /*!< Bit mask for I2S_RCSR_FRDE. */
#define BS_I2S_RCSR_FRDE     (1U)          /*!< Bit field size in bits for I2S_RCSR_FRDE. */

/*! @brief Read current value of the I2S_RCSR_FRDE field. */
#define BR_I2S_RCSR_FRDE(x)  (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FRDE))

/*! @brief Format value for bitfield I2S_RCSR_FRDE. */
#define BF_I2S_RCSR_FRDE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FRDE) & BM_I2S_RCSR_FRDE)

/*! @brief Set the FRDE field to a new value. */
#define BW_I2S_RCSR_FRDE(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FRDE) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWDE[1] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
#define BP_I2S_RCSR_FWDE     (1U)          /*!< Bit position for I2S_RCSR_FWDE. */
#define BM_I2S_RCSR_FWDE     (0x00000002U) /*!< Bit mask for I2S_RCSR_FWDE. */
#define BS_I2S_RCSR_FWDE     (1U)          /*!< Bit field size in bits for I2S_RCSR_FWDE. */

/*! @brief Read current value of the I2S_RCSR_FWDE field. */
#define BR_I2S_RCSR_FWDE(x)  (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FWDE))

/*! @brief Format value for bitfield I2S_RCSR_FWDE. */
#define BF_I2S_RCSR_FWDE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FWDE) & BM_I2S_RCSR_FWDE)

/*! @brief Set the FWDE field to a new value. */
#define BW_I2S_RCSR_FWDE(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FWDE) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FRIE[8] (RW)
 *
 * Enables/disables FIFO request interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
#define BP_I2S_RCSR_FRIE     (8U)          /*!< Bit position for I2S_RCSR_FRIE. */
#define BM_I2S_RCSR_FRIE     (0x00000100U) /*!< Bit mask for I2S_RCSR_FRIE. */
#define BS_I2S_RCSR_FRIE     (1U)          /*!< Bit field size in bits for I2S_RCSR_FRIE. */

/*! @brief Read current value of the I2S_RCSR_FRIE field. */
#define BR_I2S_RCSR_FRIE(x)  (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FRIE))

/*! @brief Format value for bitfield I2S_RCSR_FRIE. */
#define BF_I2S_RCSR_FRIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FRIE) & BM_I2S_RCSR_FRIE)

/*! @brief Set the FRIE field to a new value. */
#define BW_I2S_RCSR_FRIE(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FRIE) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWIE[9] (RW)
 *
 * Enables/disables FIFO warning interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
#define BP_I2S_RCSR_FWIE     (9U)          /*!< Bit position for I2S_RCSR_FWIE. */
#define BM_I2S_RCSR_FWIE     (0x00000200U) /*!< Bit mask for I2S_RCSR_FWIE. */
#define BS_I2S_RCSR_FWIE     (1U)          /*!< Bit field size in bits for I2S_RCSR_FWIE. */

/*! @brief Read current value of the I2S_RCSR_FWIE field. */
#define BR_I2S_RCSR_FWIE(x)  (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FWIE))

/*! @brief Format value for bitfield I2S_RCSR_FWIE. */
#define BF_I2S_RCSR_FWIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FWIE) & BM_I2S_RCSR_FWIE)

/*! @brief Set the FWIE field to a new value. */
#define BW_I2S_RCSR_FWIE(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FWIE) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FEIE[10] (RW)
 *
 * Enables/disables FIFO error interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
#define BP_I2S_RCSR_FEIE     (10U)         /*!< Bit position for I2S_RCSR_FEIE. */
#define BM_I2S_RCSR_FEIE     (0x00000400U) /*!< Bit mask for I2S_RCSR_FEIE. */
#define BS_I2S_RCSR_FEIE     (1U)          /*!< Bit field size in bits for I2S_RCSR_FEIE. */

/*! @brief Read current value of the I2S_RCSR_FEIE field. */
#define BR_I2S_RCSR_FEIE(x)  (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FEIE))

/*! @brief Format value for bitfield I2S_RCSR_FEIE. */
#define BF_I2S_RCSR_FEIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FEIE) & BM_I2S_RCSR_FEIE)

/*! @brief Set the FEIE field to a new value. */
#define BW_I2S_RCSR_FEIE(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FEIE) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SEIE[11] (RW)
 *
 * Enables/disables sync error interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
#define BP_I2S_RCSR_SEIE     (11U)         /*!< Bit position for I2S_RCSR_SEIE. */
#define BM_I2S_RCSR_SEIE     (0x00000800U) /*!< Bit mask for I2S_RCSR_SEIE. */
#define BS_I2S_RCSR_SEIE     (1U)          /*!< Bit field size in bits for I2S_RCSR_SEIE. */

/*! @brief Read current value of the I2S_RCSR_SEIE field. */
#define BR_I2S_RCSR_SEIE(x)  (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_SEIE))

/*! @brief Format value for bitfield I2S_RCSR_SEIE. */
#define BF_I2S_RCSR_SEIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_SEIE) & BM_I2S_RCSR_SEIE)

/*! @brief Set the SEIE field to a new value. */
#define BW_I2S_RCSR_SEIE(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_SEIE) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field WSIE[12] (RW)
 *
 * Enables/disables word start interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
#define BP_I2S_RCSR_WSIE     (12U)         /*!< Bit position for I2S_RCSR_WSIE. */
#define BM_I2S_RCSR_WSIE     (0x00001000U) /*!< Bit mask for I2S_RCSR_WSIE. */
#define BS_I2S_RCSR_WSIE     (1U)          /*!< Bit field size in bits for I2S_RCSR_WSIE. */

/*! @brief Read current value of the I2S_RCSR_WSIE field. */
#define BR_I2S_RCSR_WSIE(x)  (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_WSIE))

/*! @brief Format value for bitfield I2S_RCSR_WSIE. */
#define BF_I2S_RCSR_WSIE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_WSIE) & BM_I2S_RCSR_WSIE)

/*! @brief Set the WSIE field to a new value. */
#define BW_I2S_RCSR_WSIE(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_WSIE) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FRF[16] (RO)
 *
 * Indicates that the number of words in an enabled receive channel FIFO is
 * greater than the receive FIFO watermark.
 *
 * Values:
 * - 0 - Receive FIFO watermark not reached.
 * - 1 - Receive FIFO watermark has been reached.
 */
/*@{*/
#define BP_I2S_RCSR_FRF      (16U)         /*!< Bit position for I2S_RCSR_FRF. */
#define BM_I2S_RCSR_FRF      (0x00010000U) /*!< Bit mask for I2S_RCSR_FRF. */
#define BS_I2S_RCSR_FRF      (1U)          /*!< Bit field size in bits for I2S_RCSR_FRF. */

/*! @brief Read current value of the I2S_RCSR_FRF field. */
#define BR_I2S_RCSR_FRF(x)   (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FRF))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWF[17] (RO)
 *
 * Indicates that an enabled receive FIFO is full.
 *
 * Values:
 * - 0 - No enabled receive FIFO is full.
 * - 1 - Enabled receive FIFO is full.
 */
/*@{*/
#define BP_I2S_RCSR_FWF      (17U)         /*!< Bit position for I2S_RCSR_FWF. */
#define BM_I2S_RCSR_FWF      (0x00020000U) /*!< Bit mask for I2S_RCSR_FWF. */
#define BS_I2S_RCSR_FWF      (1U)          /*!< Bit field size in bits for I2S_RCSR_FWF. */

/*! @brief Read current value of the I2S_RCSR_FWF field. */
#define BR_I2S_RCSR_FWF(x)   (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FWF))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FEF[18] (W1C)
 *
 * Indicates that an enabled receive FIFO has overflowed. Write a logic 1 to
 * this field to clear this flag.
 *
 * Values:
 * - 0 - Receive overflow not detected.
 * - 1 - Receive overflow detected.
 */
/*@{*/
#define BP_I2S_RCSR_FEF      (18U)         /*!< Bit position for I2S_RCSR_FEF. */
#define BM_I2S_RCSR_FEF      (0x00040000U) /*!< Bit mask for I2S_RCSR_FEF. */
#define BS_I2S_RCSR_FEF      (1U)          /*!< Bit field size in bits for I2S_RCSR_FEF. */

/*! @brief Read current value of the I2S_RCSR_FEF field. */
#define BR_I2S_RCSR_FEF(x)   (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FEF))

/*! @brief Format value for bitfield I2S_RCSR_FEF. */
#define BF_I2S_RCSR_FEF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FEF) & BM_I2S_RCSR_FEF)

/*! @brief Set the FEF field to a new value. */
#define BW_I2S_RCSR_FEF(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FEF) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SEF[19] (W1C)
 *
 * Indicates that an error in the externally-generated frame sync has been
 * detected. Write a logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Sync error not detected.
 * - 1 - Frame sync error detected.
 */
/*@{*/
#define BP_I2S_RCSR_SEF      (19U)         /*!< Bit position for I2S_RCSR_SEF. */
#define BM_I2S_RCSR_SEF      (0x00080000U) /*!< Bit mask for I2S_RCSR_SEF. */
#define BS_I2S_RCSR_SEF      (1U)          /*!< Bit field size in bits for I2S_RCSR_SEF. */

/*! @brief Read current value of the I2S_RCSR_SEF field. */
#define BR_I2S_RCSR_SEF(x)   (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_SEF))

/*! @brief Format value for bitfield I2S_RCSR_SEF. */
#define BF_I2S_RCSR_SEF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_SEF) & BM_I2S_RCSR_SEF)

/*! @brief Set the SEF field to a new value. */
#define BW_I2S_RCSR_SEF(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_SEF) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field WSF[20] (W1C)
 *
 * Indicates that the start of the configured word has been detected. Write a
 * logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Start of word not detected.
 * - 1 - Start of word detected.
 */
/*@{*/
#define BP_I2S_RCSR_WSF      (20U)         /*!< Bit position for I2S_RCSR_WSF. */
#define BM_I2S_RCSR_WSF      (0x00100000U) /*!< Bit mask for I2S_RCSR_WSF. */
#define BS_I2S_RCSR_WSF      (1U)          /*!< Bit field size in bits for I2S_RCSR_WSF. */

/*! @brief Read current value of the I2S_RCSR_WSF field. */
#define BR_I2S_RCSR_WSF(x)   (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_WSF))

/*! @brief Format value for bitfield I2S_RCSR_WSF. */
#define BF_I2S_RCSR_WSF(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_WSF) & BM_I2S_RCSR_WSF)

/*! @brief Set the WSF field to a new value. */
#define BW_I2S_RCSR_WSF(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_WSF) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SR[24] (RW)
 *
 * Resets the internal receiver logic including the FIFO pointers.
 * Software-visible registers are not affected, except for the status registers.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Software reset.
 */
/*@{*/
#define BP_I2S_RCSR_SR       (24U)         /*!< Bit position for I2S_RCSR_SR. */
#define BM_I2S_RCSR_SR       (0x01000000U) /*!< Bit mask for I2S_RCSR_SR. */
#define BS_I2S_RCSR_SR       (1U)          /*!< Bit field size in bits for I2S_RCSR_SR. */

/*! @brief Read current value of the I2S_RCSR_SR field. */
#define BR_I2S_RCSR_SR(x)    (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_SR))

/*! @brief Format value for bitfield I2S_RCSR_SR. */
#define BF_I2S_RCSR_SR(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_SR) & BM_I2S_RCSR_SR)

/*! @brief Set the SR field to a new value. */
#define BW_I2S_RCSR_SR(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_SR) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FR[25] (WORZ)
 *
 * Resets the FIFO pointers. Reading this field will always return zero. FIFO
 * pointers should only be reset when the receiver is disabled or the FIFO error
 * flag is set.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - FIFO reset.
 */
/*@{*/
#define BP_I2S_RCSR_FR       (25U)         /*!< Bit position for I2S_RCSR_FR. */
#define BM_I2S_RCSR_FR       (0x02000000U) /*!< Bit mask for I2S_RCSR_FR. */
#define BS_I2S_RCSR_FR       (1U)          /*!< Bit field size in bits for I2S_RCSR_FR. */

/*! @brief Format value for bitfield I2S_RCSR_FR. */
#define BF_I2S_RCSR_FR(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_FR) & BM_I2S_RCSR_FR)

/*! @brief Set the FR field to a new value. */
#define BW_I2S_RCSR_FR(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_FR) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field BCE[28] (RW)
 *
 * Enables the receive bit clock, separately from RE. This field is
 * automatically set whenever RE is set. When software clears this field, the receive bit
 * clock remains enabled, and this field remains set, until the end of the current
 * frame.
 *
 * Values:
 * - 0 - Receive bit clock is disabled.
 * - 1 - Receive bit clock is enabled.
 */
/*@{*/
#define BP_I2S_RCSR_BCE      (28U)         /*!< Bit position for I2S_RCSR_BCE. */
#define BM_I2S_RCSR_BCE      (0x10000000U) /*!< Bit mask for I2S_RCSR_BCE. */
#define BS_I2S_RCSR_BCE      (1U)          /*!< Bit field size in bits for I2S_RCSR_BCE. */

/*! @brief Read current value of the I2S_RCSR_BCE field. */
#define BR_I2S_RCSR_BCE(x)   (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_BCE))

/*! @brief Format value for bitfield I2S_RCSR_BCE. */
#define BF_I2S_RCSR_BCE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_BCE) & BM_I2S_RCSR_BCE)

/*! @brief Set the BCE field to a new value. */
#define BW_I2S_RCSR_BCE(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_BCE) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field DBGE[29] (RW)
 *
 * Enables/disables receiver operation in Debug mode. The receive bit clock is
 * not affected by Debug mode.
 *
 * Values:
 * - 0 - Receiver is disabled in Debug mode, after completing the current frame.
 * - 1 - Receiver is enabled in Debug mode.
 */
/*@{*/
#define BP_I2S_RCSR_DBGE     (29U)         /*!< Bit position for I2S_RCSR_DBGE. */
#define BM_I2S_RCSR_DBGE     (0x20000000U) /*!< Bit mask for I2S_RCSR_DBGE. */
#define BS_I2S_RCSR_DBGE     (1U)          /*!< Bit field size in bits for I2S_RCSR_DBGE. */

/*! @brief Read current value of the I2S_RCSR_DBGE field. */
#define BR_I2S_RCSR_DBGE(x)  (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_DBGE))

/*! @brief Format value for bitfield I2S_RCSR_DBGE. */
#define BF_I2S_RCSR_DBGE(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_DBGE) & BM_I2S_RCSR_DBGE)

/*! @brief Set the DBGE field to a new value. */
#define BW_I2S_RCSR_DBGE(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_DBGE) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field STOPE[30] (RW)
 *
 * Configures receiver operation in Stop mode. This bit is ignored and the
 * receiver is disabled in all low-leakage stop modes.
 *
 * Values:
 * - 0 - Receiver disabled in Stop mode.
 * - 1 - Receiver enabled in Stop mode.
 */
/*@{*/
#define BP_I2S_RCSR_STOPE    (30U)         /*!< Bit position for I2S_RCSR_STOPE. */
#define BM_I2S_RCSR_STOPE    (0x40000000U) /*!< Bit mask for I2S_RCSR_STOPE. */
#define BS_I2S_RCSR_STOPE    (1U)          /*!< Bit field size in bits for I2S_RCSR_STOPE. */

/*! @brief Read current value of the I2S_RCSR_STOPE field. */
#define BR_I2S_RCSR_STOPE(x) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_STOPE))

/*! @brief Format value for bitfield I2S_RCSR_STOPE. */
#define BF_I2S_RCSR_STOPE(v) ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_STOPE) & BM_I2S_RCSR_STOPE)

/*! @brief Set the STOPE field to a new value. */
#define BW_I2S_RCSR_STOPE(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_STOPE) = (v))
/*@}*/

/*!
 * @name Register I2S_RCSR, field RE[31] (RW)
 *
 * Enables/disables the receiver. When software clears this field, the receiver
 * remains enabled, and this bit remains set, until the end of the current frame.
 *
 * Values:
 * - 0 - Receiver is disabled.
 * - 1 - Receiver is enabled, or receiver has been disabled and has not yet
 *     reached end of frame.
 */
/*@{*/
#define BP_I2S_RCSR_RE       (31U)         /*!< Bit position for I2S_RCSR_RE. */
#define BM_I2S_RCSR_RE       (0x80000000U) /*!< Bit mask for I2S_RCSR_RE. */
#define BS_I2S_RCSR_RE       (1U)          /*!< Bit field size in bits for I2S_RCSR_RE. */

/*! @brief Read current value of the I2S_RCSR_RE field. */
#define BR_I2S_RCSR_RE(x)    (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_RE))

/*! @brief Format value for bitfield I2S_RCSR_RE. */
#define BF_I2S_RCSR_RE(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_RCSR_RE) & BM_I2S_RCSR_RE)

/*! @brief Set the RE field to a new value. */
#define BW_I2S_RCSR_RE(x, v) (BITBAND_ACCESS32(HW_I2S_RCSR_ADDR(x), BP_I2S_RCSR_RE) = (v))
/*@}*/

/*******************************************************************************
 * HW_I2S_RCR1 - SAI Receive Configuration 1 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RCR1 - SAI Receive Configuration 1 Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_i2s_rcr1
{
    uint32_t U;
    struct _hw_i2s_rcr1_bitfields
    {
        uint32_t RFW : 3;              /*!< [2:0] Receive FIFO Watermark */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_i2s_rcr1_t;

/*!
 * @name Constants and macros for entire I2S_RCR1 register
 */
/*@{*/
#define HW_I2S_RCR1_ADDR(x)      ((uint32_t)(x) + 0x84U)

#define HW_I2S_RCR1(x)           (*(__IO hw_i2s_rcr1_t *) HW_I2S_RCR1_ADDR(x))
#define HW_I2S_RCR1_RD(x)        (HW_I2S_RCR1(x).U)
#define HW_I2S_RCR1_WR(x, v)     (HW_I2S_RCR1(x).U = (v))
#define HW_I2S_RCR1_SET(x, v)    (HW_I2S_RCR1_WR(x, HW_I2S_RCR1_RD(x) |  (v)))
#define HW_I2S_RCR1_CLR(x, v)    (HW_I2S_RCR1_WR(x, HW_I2S_RCR1_RD(x) & ~(v)))
#define HW_I2S_RCR1_TOG(x, v)    (HW_I2S_RCR1_WR(x, HW_I2S_RCR1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR1 bitfields
 */

/*!
 * @name Register I2S_RCR1, field RFW[2:0] (RW)
 *
 * Configures the watermark level for all enabled receiver channels.
 */
/*@{*/
#define BP_I2S_RCR1_RFW      (0U)          /*!< Bit position for I2S_RCR1_RFW. */
#define BM_I2S_RCR1_RFW      (0x00000007U) /*!< Bit mask for I2S_RCR1_RFW. */
#define BS_I2S_RCR1_RFW      (3U)          /*!< Bit field size in bits for I2S_RCR1_RFW. */

/*! @brief Read current value of the I2S_RCR1_RFW field. */
#define BR_I2S_RCR1_RFW(x)   (HW_I2S_RCR1(x).B.RFW)

/*! @brief Format value for bitfield I2S_RCR1_RFW. */
#define BF_I2S_RCR1_RFW(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR1_RFW) & BM_I2S_RCR1_RFW)

/*! @brief Set the RFW field to a new value. */
#define BW_I2S_RCR1_RFW(x, v) (HW_I2S_RCR1_WR(x, (HW_I2S_RCR1_RD(x) & ~BM_I2S_RCR1_RFW) | BF_I2S_RCR1_RFW(v)))
/*@}*/

/*******************************************************************************
 * HW_I2S_RCR2 - SAI Receive Configuration 2 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RCR2 - SAI Receive Configuration 2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
typedef union _hw_i2s_rcr2
{
    uint32_t U;
    struct _hw_i2s_rcr2_bitfields
    {
        uint32_t DIV : 8;              /*!< [7:0] Bit Clock Divide */
        uint32_t RESERVED0 : 16;       /*!< [23:8]  */
        uint32_t BCD : 1;              /*!< [24] Bit Clock Direction */
        uint32_t BCP : 1;              /*!< [25] Bit Clock Polarity */
        uint32_t MSEL : 2;             /*!< [27:26] MCLK Select */
        uint32_t BCI : 1;              /*!< [28] Bit Clock Input */
        uint32_t BCS : 1;              /*!< [29] Bit Clock Swap */
        uint32_t SYNC : 2;             /*!< [31:30] Synchronous Mode */
    } B;
} hw_i2s_rcr2_t;

/*!
 * @name Constants and macros for entire I2S_RCR2 register
 */
/*@{*/
#define HW_I2S_RCR2_ADDR(x)      ((uint32_t)(x) + 0x88U)

#define HW_I2S_RCR2(x)           (*(__IO hw_i2s_rcr2_t *) HW_I2S_RCR2_ADDR(x))
#define HW_I2S_RCR2_RD(x)        (HW_I2S_RCR2(x).U)
#define HW_I2S_RCR2_WR(x, v)     (HW_I2S_RCR2(x).U = (v))
#define HW_I2S_RCR2_SET(x, v)    (HW_I2S_RCR2_WR(x, HW_I2S_RCR2_RD(x) |  (v)))
#define HW_I2S_RCR2_CLR(x, v)    (HW_I2S_RCR2_WR(x, HW_I2S_RCR2_RD(x) & ~(v)))
#define HW_I2S_RCR2_TOG(x, v)    (HW_I2S_RCR2_WR(x, HW_I2S_RCR2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR2 bitfields
 */

/*!
 * @name Register I2S_RCR2, field DIV[7:0] (RW)
 *
 * Divides down the audio master clock to generate the bit clock when configured
 * for an internal bit clock. The division value is (DIV + 1) * 2.
 */
/*@{*/
#define BP_I2S_RCR2_DIV      (0U)          /*!< Bit position for I2S_RCR2_DIV. */
#define BM_I2S_RCR2_DIV      (0x000000FFU) /*!< Bit mask for I2S_RCR2_DIV. */
#define BS_I2S_RCR2_DIV      (8U)          /*!< Bit field size in bits for I2S_RCR2_DIV. */

/*! @brief Read current value of the I2S_RCR2_DIV field. */
#define BR_I2S_RCR2_DIV(x)   (HW_I2S_RCR2(x).B.DIV)

/*! @brief Format value for bitfield I2S_RCR2_DIV. */
#define BF_I2S_RCR2_DIV(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_DIV) & BM_I2S_RCR2_DIV)

/*! @brief Set the DIV field to a new value. */
#define BW_I2S_RCR2_DIV(x, v) (HW_I2S_RCR2_WR(x, (HW_I2S_RCR2_RD(x) & ~BM_I2S_RCR2_DIV) | BF_I2S_RCR2_DIV(v)))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCD[24] (RW)
 *
 * Configures the direction of the bit clock.
 *
 * Values:
 * - 0 - Bit clock is generated externally in Slave mode.
 * - 1 - Bit clock is generated internally in Master mode.
 */
/*@{*/
#define BP_I2S_RCR2_BCD      (24U)         /*!< Bit position for I2S_RCR2_BCD. */
#define BM_I2S_RCR2_BCD      (0x01000000U) /*!< Bit mask for I2S_RCR2_BCD. */
#define BS_I2S_RCR2_BCD      (1U)          /*!< Bit field size in bits for I2S_RCR2_BCD. */

/*! @brief Read current value of the I2S_RCR2_BCD field. */
#define BR_I2S_RCR2_BCD(x)   (BITBAND_ACCESS32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCD))

/*! @brief Format value for bitfield I2S_RCR2_BCD. */
#define BF_I2S_RCR2_BCD(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_BCD) & BM_I2S_RCR2_BCD)

/*! @brief Set the BCD field to a new value. */
#define BW_I2S_RCR2_BCD(x, v) (BITBAND_ACCESS32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCD) = (v))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCP[25] (RW)
 *
 * Configures the polarity of the bit clock.
 *
 * Values:
 * - 0 - Bit Clock is active high with drive outputs on rising edge and sample
 *     inputs on falling edge.
 * - 1 - Bit Clock is active low with drive outputs on falling edge and sample
 *     inputs on rising edge.
 */
/*@{*/
#define BP_I2S_RCR2_BCP      (25U)         /*!< Bit position for I2S_RCR2_BCP. */
#define BM_I2S_RCR2_BCP      (0x02000000U) /*!< Bit mask for I2S_RCR2_BCP. */
#define BS_I2S_RCR2_BCP      (1U)          /*!< Bit field size in bits for I2S_RCR2_BCP. */

/*! @brief Read current value of the I2S_RCR2_BCP field. */
#define BR_I2S_RCR2_BCP(x)   (BITBAND_ACCESS32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCP))

/*! @brief Format value for bitfield I2S_RCR2_BCP. */
#define BF_I2S_RCR2_BCP(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_BCP) & BM_I2S_RCR2_BCP)

/*! @brief Set the BCP field to a new value. */
#define BW_I2S_RCR2_BCP(x, v) (BITBAND_ACCESS32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCP) = (v))
/*@}*/

/*!
 * @name Register I2S_RCR2, field MSEL[27:26] (RW)
 *
 * Selects the audio Master Clock option used to generate an internally
 * generated bit clock. This field has no effect when configured for an externally
 * generated bit clock. Depending on the device, some Master Clock options might not be
 * available. See the chip configuration details for the availability and
 * chip-specific meaning of each option.
 *
 * Values:
 * - 00 - Bus Clock selected.
 * - 01 - Master Clock (MCLK) 1 option selected.
 * - 10 - Master Clock (MCLK) 2 option selected.
 * - 11 - Master Clock (MCLK) 3 option selected.
 */
/*@{*/
#define BP_I2S_RCR2_MSEL     (26U)         /*!< Bit position for I2S_RCR2_MSEL. */
#define BM_I2S_RCR2_MSEL     (0x0C000000U) /*!< Bit mask for I2S_RCR2_MSEL. */
#define BS_I2S_RCR2_MSEL     (2U)          /*!< Bit field size in bits for I2S_RCR2_MSEL. */

/*! @brief Read current value of the I2S_RCR2_MSEL field. */
#define BR_I2S_RCR2_MSEL(x)  (HW_I2S_RCR2(x).B.MSEL)

/*! @brief Format value for bitfield I2S_RCR2_MSEL. */
#define BF_I2S_RCR2_MSEL(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_MSEL) & BM_I2S_RCR2_MSEL)

/*! @brief Set the MSEL field to a new value. */
#define BW_I2S_RCR2_MSEL(x, v) (HW_I2S_RCR2_WR(x, (HW_I2S_RCR2_RD(x) & ~BM_I2S_RCR2_MSEL) | BF_I2S_RCR2_MSEL(v)))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCI[28] (RW)
 *
 * When this field is set and using an internally generated bit clock in either
 * synchronous or asynchronous mode, the bit clock actually used by the receiver
 * is delayed by the pad output delay (the receiver is clocked by the pad input
 * as if the clock was externally generated). This has the effect of decreasing
 * the data input setup time, but increasing the data output valid time. The slave
 * mode timing from the datasheet should be used for the receiver when this bit
 * is set. In synchronous mode, this bit allows the receiver to use the slave mode
 * timing from the datasheet, while the transmitter uses the master mode timing.
 * This field has no effect when configured for an externally generated bit
 * clock or when synchronous to another SAI peripheral .
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Internal logic is clocked as if bit clock was externally generated.
 */
/*@{*/
#define BP_I2S_RCR2_BCI      (28U)         /*!< Bit position for I2S_RCR2_BCI. */
#define BM_I2S_RCR2_BCI      (0x10000000U) /*!< Bit mask for I2S_RCR2_BCI. */
#define BS_I2S_RCR2_BCI      (1U)          /*!< Bit field size in bits for I2S_RCR2_BCI. */

/*! @brief Read current value of the I2S_RCR2_BCI field. */
#define BR_I2S_RCR2_BCI(x)   (BITBAND_ACCESS32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCI))

/*! @brief Format value for bitfield I2S_RCR2_BCI. */
#define BF_I2S_RCR2_BCI(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_BCI) & BM_I2S_RCR2_BCI)

/*! @brief Set the BCI field to a new value. */
#define BW_I2S_RCR2_BCI(x, v) (BITBAND_ACCESS32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCI) = (v))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCS[29] (RW)
 *
 * This field swaps the bit clock used by the receiver. When the receiver is
 * configured in asynchronous mode and this bit is set, the receiver is clocked by
 * the transmitter bit clock (SAI_TX_BCLK). This allows the transmitter and
 * receiver to share the same bit clock, but the receiver continues to use the receiver
 * frame sync (SAI_RX_SYNC). When the receiver is configured in synchronous
 * mode, the transmitter BCS field and receiver BCS field must be set to the same
 * value. When both are set, the transmitter and receiver are both clocked by the
 * receiver bit clock (SAI_RX_BCLK) but use the transmitter frame sync
 * (SAI_TX_SYNC). This field has no effect when synchronous to another SAI peripheral.
 *
 * Values:
 * - 0 - Use the normal bit clock source.
 * - 1 - Swap the bit clock source.
 */
/*@{*/
#define BP_I2S_RCR2_BCS      (29U)         /*!< Bit position for I2S_RCR2_BCS. */
#define BM_I2S_RCR2_BCS      (0x20000000U) /*!< Bit mask for I2S_RCR2_BCS. */
#define BS_I2S_RCR2_BCS      (1U)          /*!< Bit field size in bits for I2S_RCR2_BCS. */

/*! @brief Read current value of the I2S_RCR2_BCS field. */
#define BR_I2S_RCR2_BCS(x)   (BITBAND_ACCESS32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCS))

/*! @brief Format value for bitfield I2S_RCR2_BCS. */
#define BF_I2S_RCR2_BCS(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_BCS) & BM_I2S_RCR2_BCS)

/*! @brief Set the BCS field to a new value. */
#define BW_I2S_RCR2_BCS(x, v) (BITBAND_ACCESS32(HW_I2S_RCR2_ADDR(x), BP_I2S_RCR2_BCS) = (v))
/*@}*/

/*!
 * @name Register I2S_RCR2, field SYNC[31:30] (RW)
 *
 * Configures between asynchronous and synchronous modes of operation. When
 * configured for a synchronous mode of operation, the transmitter or other SAI
 * peripheral must be configured for asynchronous operation.
 *
 * Values:
 * - 00 - Asynchronous mode.
 * - 01 - Synchronous with transmitter.
 * - 10 - Synchronous with another SAI receiver.
 * - 11 - Synchronous with another SAI transmitter.
 */
/*@{*/
#define BP_I2S_RCR2_SYNC     (30U)         /*!< Bit position for I2S_RCR2_SYNC. */
#define BM_I2S_RCR2_SYNC     (0xC0000000U) /*!< Bit mask for I2S_RCR2_SYNC. */
#define BS_I2S_RCR2_SYNC     (2U)          /*!< Bit field size in bits for I2S_RCR2_SYNC. */

/*! @brief Read current value of the I2S_RCR2_SYNC field. */
#define BR_I2S_RCR2_SYNC(x)  (HW_I2S_RCR2(x).B.SYNC)

/*! @brief Format value for bitfield I2S_RCR2_SYNC. */
#define BF_I2S_RCR2_SYNC(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCR2_SYNC) & BM_I2S_RCR2_SYNC)

/*! @brief Set the SYNC field to a new value. */
#define BW_I2S_RCR2_SYNC(x, v) (HW_I2S_RCR2_WR(x, (HW_I2S_RCR2_RD(x) & ~BM_I2S_RCR2_SYNC) | BF_I2S_RCR2_SYNC(v)))
/*@}*/

/*******************************************************************************
 * HW_I2S_RCR3 - SAI Receive Configuration 3 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RCR3 - SAI Receive Configuration 3 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
typedef union _hw_i2s_rcr3
{
    uint32_t U;
    struct _hw_i2s_rcr3_bitfields
    {
        uint32_t WDFL : 5;             /*!< [4:0] Word Flag Configuration */
        uint32_t RESERVED0 : 11;       /*!< [15:5]  */
        uint32_t RCE : 2;              /*!< [17:16] Receive Channel Enable */
        uint32_t RESERVED1 : 14;       /*!< [31:18]  */
    } B;
} hw_i2s_rcr3_t;

/*!
 * @name Constants and macros for entire I2S_RCR3 register
 */
/*@{*/
#define HW_I2S_RCR3_ADDR(x)      ((uint32_t)(x) + 0x8CU)

#define HW_I2S_RCR3(x)           (*(__IO hw_i2s_rcr3_t *) HW_I2S_RCR3_ADDR(x))
#define HW_I2S_RCR3_RD(x)        (HW_I2S_RCR3(x).U)
#define HW_I2S_RCR3_WR(x, v)     (HW_I2S_RCR3(x).U = (v))
#define HW_I2S_RCR3_SET(x, v)    (HW_I2S_RCR3_WR(x, HW_I2S_RCR3_RD(x) |  (v)))
#define HW_I2S_RCR3_CLR(x, v)    (HW_I2S_RCR3_WR(x, HW_I2S_RCR3_RD(x) & ~(v)))
#define HW_I2S_RCR3_TOG(x, v)    (HW_I2S_RCR3_WR(x, HW_I2S_RCR3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR3 bitfields
 */

/*!
 * @name Register I2S_RCR3, field WDFL[4:0] (RW)
 *
 * Configures which word the start of word flag is set. The value written should
 * be one less than the word number (for example, write zero to configure for
 * the first word in the frame). When configured to a value greater than the Frame
 * Size field, then the start of word flag is never set.
 */
/*@{*/
#define BP_I2S_RCR3_WDFL     (0U)          /*!< Bit position for I2S_RCR3_WDFL. */
#define BM_I2S_RCR3_WDFL     (0x0000001FU) /*!< Bit mask for I2S_RCR3_WDFL. */
#define BS_I2S_RCR3_WDFL     (5U)          /*!< Bit field size in bits for I2S_RCR3_WDFL. */

/*! @brief Read current value of the I2S_RCR3_WDFL field. */
#define BR_I2S_RCR3_WDFL(x)  (HW_I2S_RCR3(x).B.WDFL)

/*! @brief Format value for bitfield I2S_RCR3_WDFL. */
#define BF_I2S_RCR3_WDFL(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCR3_WDFL) & BM_I2S_RCR3_WDFL)

/*! @brief Set the WDFL field to a new value. */
#define BW_I2S_RCR3_WDFL(x, v) (HW_I2S_RCR3_WR(x, (HW_I2S_RCR3_RD(x) & ~BM_I2S_RCR3_WDFL) | BF_I2S_RCR3_WDFL(v)))
/*@}*/

/*!
 * @name Register I2S_RCR3, field RCE[17:16] (RW)
 *
 * Enables the corresponding data channel for receive operation. A channel must
 * be enabled before its FIFO is accessed.
 *
 * Values:
 * - 0 - Receive data channel N is disabled.
 * - 1 - Receive data channel N is enabled.
 */
/*@{*/
#define BP_I2S_RCR3_RCE      (16U)         /*!< Bit position for I2S_RCR3_RCE. */
#define BM_I2S_RCR3_RCE      (0x00030000U) /*!< Bit mask for I2S_RCR3_RCE. */
#define BS_I2S_RCR3_RCE      (2U)          /*!< Bit field size in bits for I2S_RCR3_RCE. */

/*! @brief Read current value of the I2S_RCR3_RCE field. */
#define BR_I2S_RCR3_RCE(x)   (HW_I2S_RCR3(x).B.RCE)

/*! @brief Format value for bitfield I2S_RCR3_RCE. */
#define BF_I2S_RCR3_RCE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR3_RCE) & BM_I2S_RCR3_RCE)

/*! @brief Set the RCE field to a new value. */
#define BW_I2S_RCR3_RCE(x, v) (HW_I2S_RCR3_WR(x, (HW_I2S_RCR3_RD(x) & ~BM_I2S_RCR3_RCE) | BF_I2S_RCR3_RCE(v)))
/*@}*/

/*******************************************************************************
 * HW_I2S_RCR4 - SAI Receive Configuration 4 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RCR4 - SAI Receive Configuration 4 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
typedef union _hw_i2s_rcr4
{
    uint32_t U;
    struct _hw_i2s_rcr4_bitfields
    {
        uint32_t FSD : 1;              /*!< [0] Frame Sync Direction */
        uint32_t FSP : 1;              /*!< [1] Frame Sync Polarity */
        uint32_t RESERVED0 : 1;        /*!< [2]  */
        uint32_t FSE : 1;              /*!< [3] Frame Sync Early */
        uint32_t MF : 1;               /*!< [4] MSB First */
        uint32_t RESERVED1 : 3;        /*!< [7:5]  */
        uint32_t SYWD : 5;             /*!< [12:8] Sync Width */
        uint32_t RESERVED2 : 3;        /*!< [15:13]  */
        uint32_t FRSZ : 5;             /*!< [20:16] Frame Size */
        uint32_t RESERVED3 : 11;       /*!< [31:21]  */
    } B;
} hw_i2s_rcr4_t;

/*!
 * @name Constants and macros for entire I2S_RCR4 register
 */
/*@{*/
#define HW_I2S_RCR4_ADDR(x)      ((uint32_t)(x) + 0x90U)

#define HW_I2S_RCR4(x)           (*(__IO hw_i2s_rcr4_t *) HW_I2S_RCR4_ADDR(x))
#define HW_I2S_RCR4_RD(x)        (HW_I2S_RCR4(x).U)
#define HW_I2S_RCR4_WR(x, v)     (HW_I2S_RCR4(x).U = (v))
#define HW_I2S_RCR4_SET(x, v)    (HW_I2S_RCR4_WR(x, HW_I2S_RCR4_RD(x) |  (v)))
#define HW_I2S_RCR4_CLR(x, v)    (HW_I2S_RCR4_WR(x, HW_I2S_RCR4_RD(x) & ~(v)))
#define HW_I2S_RCR4_TOG(x, v)    (HW_I2S_RCR4_WR(x, HW_I2S_RCR4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR4 bitfields
 */

/*!
 * @name Register I2S_RCR4, field FSD[0] (RW)
 *
 * Configures the direction of the frame sync.
 *
 * Values:
 * - 0 - Frame Sync is generated externally in Slave mode.
 * - 1 - Frame Sync is generated internally in Master mode.
 */
/*@{*/
#define BP_I2S_RCR4_FSD      (0U)          /*!< Bit position for I2S_RCR4_FSD. */
#define BM_I2S_RCR4_FSD      (0x00000001U) /*!< Bit mask for I2S_RCR4_FSD. */
#define BS_I2S_RCR4_FSD      (1U)          /*!< Bit field size in bits for I2S_RCR4_FSD. */

/*! @brief Read current value of the I2S_RCR4_FSD field. */
#define BR_I2S_RCR4_FSD(x)   (BITBAND_ACCESS32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FSD))

/*! @brief Format value for bitfield I2S_RCR4_FSD. */
#define BF_I2S_RCR4_FSD(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_FSD) & BM_I2S_RCR4_FSD)

/*! @brief Set the FSD field to a new value. */
#define BW_I2S_RCR4_FSD(x, v) (BITBAND_ACCESS32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FSD) = (v))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FSP[1] (RW)
 *
 * Configures the polarity of the frame sync.
 *
 * Values:
 * - 0 - Frame sync is active high.
 * - 1 - Frame sync is active low.
 */
/*@{*/
#define BP_I2S_RCR4_FSP      (1U)          /*!< Bit position for I2S_RCR4_FSP. */
#define BM_I2S_RCR4_FSP      (0x00000002U) /*!< Bit mask for I2S_RCR4_FSP. */
#define BS_I2S_RCR4_FSP      (1U)          /*!< Bit field size in bits for I2S_RCR4_FSP. */

/*! @brief Read current value of the I2S_RCR4_FSP field. */
#define BR_I2S_RCR4_FSP(x)   (BITBAND_ACCESS32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FSP))

/*! @brief Format value for bitfield I2S_RCR4_FSP. */
#define BF_I2S_RCR4_FSP(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_FSP) & BM_I2S_RCR4_FSP)

/*! @brief Set the FSP field to a new value. */
#define BW_I2S_RCR4_FSP(x, v) (BITBAND_ACCESS32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FSP) = (v))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FSE[3] (RW)
 *
 * Values:
 * - 0 - Frame sync asserts with the first bit of the frame.
 * - 1 - Frame sync asserts one bit before the first bit of the frame.
 */
/*@{*/
#define BP_I2S_RCR4_FSE      (3U)          /*!< Bit position for I2S_RCR4_FSE. */
#define BM_I2S_RCR4_FSE      (0x00000008U) /*!< Bit mask for I2S_RCR4_FSE. */
#define BS_I2S_RCR4_FSE      (1U)          /*!< Bit field size in bits for I2S_RCR4_FSE. */

/*! @brief Read current value of the I2S_RCR4_FSE field. */
#define BR_I2S_RCR4_FSE(x)   (BITBAND_ACCESS32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FSE))

/*! @brief Format value for bitfield I2S_RCR4_FSE. */
#define BF_I2S_RCR4_FSE(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_FSE) & BM_I2S_RCR4_FSE)

/*! @brief Set the FSE field to a new value. */
#define BW_I2S_RCR4_FSE(x, v) (BITBAND_ACCESS32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_FSE) = (v))
/*@}*/

/*!
 * @name Register I2S_RCR4, field MF[4] (RW)
 *
 * Configures whether the LSB or the MSB is received first.
 *
 * Values:
 * - 0 - LSB is received first.
 * - 1 - MSB is received first.
 */
/*@{*/
#define BP_I2S_RCR4_MF       (4U)          /*!< Bit position for I2S_RCR4_MF. */
#define BM_I2S_RCR4_MF       (0x00000010U) /*!< Bit mask for I2S_RCR4_MF. */
#define BS_I2S_RCR4_MF       (1U)          /*!< Bit field size in bits for I2S_RCR4_MF. */

/*! @brief Read current value of the I2S_RCR4_MF field. */
#define BR_I2S_RCR4_MF(x)    (BITBAND_ACCESS32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_MF))

/*! @brief Format value for bitfield I2S_RCR4_MF. */
#define BF_I2S_RCR4_MF(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_MF) & BM_I2S_RCR4_MF)

/*! @brief Set the MF field to a new value. */
#define BW_I2S_RCR4_MF(x, v) (BITBAND_ACCESS32(HW_I2S_RCR4_ADDR(x), BP_I2S_RCR4_MF) = (v))
/*@}*/

/*!
 * @name Register I2S_RCR4, field SYWD[12:8] (RW)
 *
 * Configures the length of the frame sync in number of bit clocks. The value
 * written must be one less than the number of bit clocks. For example, write 0 for
 * the frame sync to assert for one bit clock only. The sync width cannot be
 * configured longer than the first word of the frame.
 */
/*@{*/
#define BP_I2S_RCR4_SYWD     (8U)          /*!< Bit position for I2S_RCR4_SYWD. */
#define BM_I2S_RCR4_SYWD     (0x00001F00U) /*!< Bit mask for I2S_RCR4_SYWD. */
#define BS_I2S_RCR4_SYWD     (5U)          /*!< Bit field size in bits for I2S_RCR4_SYWD. */

/*! @brief Read current value of the I2S_RCR4_SYWD field. */
#define BR_I2S_RCR4_SYWD(x)  (HW_I2S_RCR4(x).B.SYWD)

/*! @brief Format value for bitfield I2S_RCR4_SYWD. */
#define BF_I2S_RCR4_SYWD(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_SYWD) & BM_I2S_RCR4_SYWD)

/*! @brief Set the SYWD field to a new value. */
#define BW_I2S_RCR4_SYWD(x, v) (HW_I2S_RCR4_WR(x, (HW_I2S_RCR4_RD(x) & ~BM_I2S_RCR4_SYWD) | BF_I2S_RCR4_SYWD(v)))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FRSZ[20:16] (RW)
 *
 * Configures the number of words in each frame. The value written must be one
 * less than the number of words in the frame. For example, write 0 for one word
 * per frame. The maximum supported frame size is 32 words.
 */
/*@{*/
#define BP_I2S_RCR4_FRSZ     (16U)         /*!< Bit position for I2S_RCR4_FRSZ. */
#define BM_I2S_RCR4_FRSZ     (0x001F0000U) /*!< Bit mask for I2S_RCR4_FRSZ. */
#define BS_I2S_RCR4_FRSZ     (5U)          /*!< Bit field size in bits for I2S_RCR4_FRSZ. */

/*! @brief Read current value of the I2S_RCR4_FRSZ field. */
#define BR_I2S_RCR4_FRSZ(x)  (HW_I2S_RCR4(x).B.FRSZ)

/*! @brief Format value for bitfield I2S_RCR4_FRSZ. */
#define BF_I2S_RCR4_FRSZ(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_RCR4_FRSZ) & BM_I2S_RCR4_FRSZ)

/*! @brief Set the FRSZ field to a new value. */
#define BW_I2S_RCR4_FRSZ(x, v) (HW_I2S_RCR4_WR(x, (HW_I2S_RCR4_RD(x) & ~BM_I2S_RCR4_FRSZ) | BF_I2S_RCR4_FRSZ(v)))
/*@}*/

/*******************************************************************************
 * HW_I2S_RCR5 - SAI Receive Configuration 5 Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RCR5 - SAI Receive Configuration 5 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
typedef union _hw_i2s_rcr5
{
    uint32_t U;
    struct _hw_i2s_rcr5_bitfields
    {
        uint32_t RESERVED0 : 8;        /*!< [7:0]  */
        uint32_t FBT : 5;              /*!< [12:8] First Bit Shifted */
        uint32_t RESERVED1 : 3;        /*!< [15:13]  */
        uint32_t W0W : 5;              /*!< [20:16] Word 0 Width */
        uint32_t RESERVED2 : 3;        /*!< [23:21]  */
        uint32_t WNW : 5;              /*!< [28:24] Word N Width */
        uint32_t RESERVED3 : 3;        /*!< [31:29]  */
    } B;
} hw_i2s_rcr5_t;

/*!
 * @name Constants and macros for entire I2S_RCR5 register
 */
/*@{*/
#define HW_I2S_RCR5_ADDR(x)      ((uint32_t)(x) + 0x94U)

#define HW_I2S_RCR5(x)           (*(__IO hw_i2s_rcr5_t *) HW_I2S_RCR5_ADDR(x))
#define HW_I2S_RCR5_RD(x)        (HW_I2S_RCR5(x).U)
#define HW_I2S_RCR5_WR(x, v)     (HW_I2S_RCR5(x).U = (v))
#define HW_I2S_RCR5_SET(x, v)    (HW_I2S_RCR5_WR(x, HW_I2S_RCR5_RD(x) |  (v)))
#define HW_I2S_RCR5_CLR(x, v)    (HW_I2S_RCR5_WR(x, HW_I2S_RCR5_RD(x) & ~(v)))
#define HW_I2S_RCR5_TOG(x, v)    (HW_I2S_RCR5_WR(x, HW_I2S_RCR5_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR5 bitfields
 */

/*!
 * @name Register I2S_RCR5, field FBT[12:8] (RW)
 *
 * Configures the bit index for the first bit received for each word in the
 * frame. If configured for MSB First, the index of the next bit received is one less
 * than the current bit received. If configured for LSB First, the index of the
 * next bit received is one more than the current bit received. The value written
 * must be greater than or equal to the word width when configured for MSB
 * First. The value written must be less than or equal to 31-word width when
 * configured for LSB First.
 */
/*@{*/
#define BP_I2S_RCR5_FBT      (8U)          /*!< Bit position for I2S_RCR5_FBT. */
#define BM_I2S_RCR5_FBT      (0x00001F00U) /*!< Bit mask for I2S_RCR5_FBT. */
#define BS_I2S_RCR5_FBT      (5U)          /*!< Bit field size in bits for I2S_RCR5_FBT. */

/*! @brief Read current value of the I2S_RCR5_FBT field. */
#define BR_I2S_RCR5_FBT(x)   (HW_I2S_RCR5(x).B.FBT)

/*! @brief Format value for bitfield I2S_RCR5_FBT. */
#define BF_I2S_RCR5_FBT(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR5_FBT) & BM_I2S_RCR5_FBT)

/*! @brief Set the FBT field to a new value. */
#define BW_I2S_RCR5_FBT(x, v) (HW_I2S_RCR5_WR(x, (HW_I2S_RCR5_RD(x) & ~BM_I2S_RCR5_FBT) | BF_I2S_RCR5_FBT(v)))
/*@}*/

/*!
 * @name Register I2S_RCR5, field W0W[20:16] (RW)
 *
 * Configures the number of bits in the first word in each frame. The value
 * written must be one less than the number of bits in the first word. Word width of
 * less than 8 bits is not supported if there is only one word per frame.
 */
/*@{*/
#define BP_I2S_RCR5_W0W      (16U)         /*!< Bit position for I2S_RCR5_W0W. */
#define BM_I2S_RCR5_W0W      (0x001F0000U) /*!< Bit mask for I2S_RCR5_W0W. */
#define BS_I2S_RCR5_W0W      (5U)          /*!< Bit field size in bits for I2S_RCR5_W0W. */

/*! @brief Read current value of the I2S_RCR5_W0W field. */
#define BR_I2S_RCR5_W0W(x)   (HW_I2S_RCR5(x).B.W0W)

/*! @brief Format value for bitfield I2S_RCR5_W0W. */
#define BF_I2S_RCR5_W0W(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR5_W0W) & BM_I2S_RCR5_W0W)

/*! @brief Set the W0W field to a new value. */
#define BW_I2S_RCR5_W0W(x, v) (HW_I2S_RCR5_WR(x, (HW_I2S_RCR5_RD(x) & ~BM_I2S_RCR5_W0W) | BF_I2S_RCR5_W0W(v)))
/*@}*/

/*!
 * @name Register I2S_RCR5, field WNW[28:24] (RW)
 *
 * Configures the number of bits in each word, for each word except the first in
 * the frame. The value written must be one less than the number of bits per
 * word. Word width of less than 8 bits is not supported.
 */
/*@{*/
#define BP_I2S_RCR5_WNW      (24U)         /*!< Bit position for I2S_RCR5_WNW. */
#define BM_I2S_RCR5_WNW      (0x1F000000U) /*!< Bit mask for I2S_RCR5_WNW. */
#define BS_I2S_RCR5_WNW      (5U)          /*!< Bit field size in bits for I2S_RCR5_WNW. */

/*! @brief Read current value of the I2S_RCR5_WNW field. */
#define BR_I2S_RCR5_WNW(x)   (HW_I2S_RCR5(x).B.WNW)

/*! @brief Format value for bitfield I2S_RCR5_WNW. */
#define BF_I2S_RCR5_WNW(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_RCR5_WNW) & BM_I2S_RCR5_WNW)

/*! @brief Set the WNW field to a new value. */
#define BW_I2S_RCR5_WNW(x, v) (HW_I2S_RCR5_WR(x, (HW_I2S_RCR5_RD(x) & ~BM_I2S_RCR5_WNW) | BF_I2S_RCR5_WNW(v)))
/*@}*/

/*******************************************************************************
 * HW_I2S_RDRn - SAI Receive Data Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RDRn - SAI Receive Data Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Reading this register introduces one additional peripheral clock wait state
 * on each read.
 */
typedef union _hw_i2s_rdrn
{
    uint32_t U;
    struct _hw_i2s_rdrn_bitfields
    {
        uint32_t RDR : 32;             /*!< [31:0] Receive Data Register */
    } B;
} hw_i2s_rdrn_t;

/*!
 * @name Constants and macros for entire I2S_RDRn register
 */
/*@{*/
#define HW_I2S_RDRn_COUNT (2U)

#define HW_I2S_RDRn_ADDR(x, n)   ((uint32_t)(x) + 0xA0U + (0x4U * (n)))

#define HW_I2S_RDRn(x, n)        (*(__I hw_i2s_rdrn_t *) HW_I2S_RDRn_ADDR(x, n))
#define HW_I2S_RDRn_RD(x, n)     (HW_I2S_RDRn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual I2S_RDRn bitfields
 */

/*!
 * @name Register I2S_RDRn, field RDR[31:0] (RO)
 *
 * The corresponding RCR3[RCE] bit must be set before accessing the channel's
 * receive data register. Reads from this register when the receive FIFO is not
 * empty will return the data from the top of the receive FIFO. Reads from this
 * register when the receive FIFO is empty are ignored.
 */
/*@{*/
#define BP_I2S_RDRn_RDR      (0U)          /*!< Bit position for I2S_RDRn_RDR. */
#define BM_I2S_RDRn_RDR      (0xFFFFFFFFU) /*!< Bit mask for I2S_RDRn_RDR. */
#define BS_I2S_RDRn_RDR      (32U)         /*!< Bit field size in bits for I2S_RDRn_RDR. */

/*! @brief Read current value of the I2S_RDRn_RDR field. */
#define BR_I2S_RDRn_RDR(x, n) (HW_I2S_RDRn(x, n).U)
/*@}*/

/*******************************************************************************
 * HW_I2S_RFRn - SAI Receive FIFO Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RFRn - SAI Receive FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The MSB of the read and write pointers is used to distinguish between FIFO
 * full and empty conditions. If the read and write pointers are identical, then
 * the FIFO is empty. If the read and write pointers are identical except for the
 * MSB, then the FIFO is full.
 */
typedef union _hw_i2s_rfrn
{
    uint32_t U;
    struct _hw_i2s_rfrn_bitfields
    {
        uint32_t RFP : 4;              /*!< [3:0] Read FIFO Pointer */
        uint32_t RESERVED0 : 12;       /*!< [15:4]  */
        uint32_t WFP : 4;              /*!< [19:16] Write FIFO Pointer */
        uint32_t RESERVED1 : 12;       /*!< [31:20]  */
    } B;
} hw_i2s_rfrn_t;

/*!
 * @name Constants and macros for entire I2S_RFRn register
 */
/*@{*/
#define HW_I2S_RFRn_COUNT (2U)

#define HW_I2S_RFRn_ADDR(x, n)   ((uint32_t)(x) + 0xC0U + (0x4U * (n)))

#define HW_I2S_RFRn(x, n)        (*(__I hw_i2s_rfrn_t *) HW_I2S_RFRn_ADDR(x, n))
#define HW_I2S_RFRn_RD(x, n)     (HW_I2S_RFRn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual I2S_RFRn bitfields
 */

/*!
 * @name Register I2S_RFRn, field RFP[3:0] (RO)
 *
 * FIFO read pointer for receive data channel.
 */
/*@{*/
#define BP_I2S_RFRn_RFP      (0U)          /*!< Bit position for I2S_RFRn_RFP. */
#define BM_I2S_RFRn_RFP      (0x0000000FU) /*!< Bit mask for I2S_RFRn_RFP. */
#define BS_I2S_RFRn_RFP      (4U)          /*!< Bit field size in bits for I2S_RFRn_RFP. */

/*! @brief Read current value of the I2S_RFRn_RFP field. */
#define BR_I2S_RFRn_RFP(x, n) (HW_I2S_RFRn(x, n).B.RFP)
/*@}*/

/*!
 * @name Register I2S_RFRn, field WFP[19:16] (RO)
 *
 * FIFO write pointer for receive data channel.
 */
/*@{*/
#define BP_I2S_RFRn_WFP      (16U)         /*!< Bit position for I2S_RFRn_WFP. */
#define BM_I2S_RFRn_WFP      (0x000F0000U) /*!< Bit mask for I2S_RFRn_WFP. */
#define BS_I2S_RFRn_WFP      (4U)          /*!< Bit field size in bits for I2S_RFRn_WFP. */

/*! @brief Read current value of the I2S_RFRn_WFP field. */
#define BR_I2S_RFRn_WFP(x, n) (HW_I2S_RFRn(x, n).B.WFP)
/*@}*/

/*******************************************************************************
 * HW_I2S_RMR - SAI Receive Mask Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_RMR - SAI Receive Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is double-buffered and updates: When RCSR[RE] is first set At
 * the end of each frame This allows the masked words in each frame to change from
 * frame to frame.
 */
typedef union _hw_i2s_rmr
{
    uint32_t U;
    struct _hw_i2s_rmr_bitfields
    {
        uint32_t RWM : 32;             /*!< [31:0] Receive Word Mask */
    } B;
} hw_i2s_rmr_t;

/*!
 * @name Constants and macros for entire I2S_RMR register
 */
/*@{*/
#define HW_I2S_RMR_ADDR(x)       ((uint32_t)(x) + 0xE0U)

#define HW_I2S_RMR(x)            (*(__IO hw_i2s_rmr_t *) HW_I2S_RMR_ADDR(x))
#define HW_I2S_RMR_RD(x)         (HW_I2S_RMR(x).U)
#define HW_I2S_RMR_WR(x, v)      (HW_I2S_RMR(x).U = (v))
#define HW_I2S_RMR_SET(x, v)     (HW_I2S_RMR_WR(x, HW_I2S_RMR_RD(x) |  (v)))
#define HW_I2S_RMR_CLR(x, v)     (HW_I2S_RMR_WR(x, HW_I2S_RMR_RD(x) & ~(v)))
#define HW_I2S_RMR_TOG(x, v)     (HW_I2S_RMR_WR(x, HW_I2S_RMR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_RMR bitfields
 */

/*!
 * @name Register I2S_RMR, field RWM[31:0] (RW)
 *
 * Configures whether the receive word is masked (received data ignored and not
 * written to receive FIFO) for the corresponding word in the frame.
 *
 * Values:
 * - 0 - Word N is enabled.
 * - 1 - Word N is masked.
 */
/*@{*/
#define BP_I2S_RMR_RWM       (0U)          /*!< Bit position for I2S_RMR_RWM. */
#define BM_I2S_RMR_RWM       (0xFFFFFFFFU) /*!< Bit mask for I2S_RMR_RWM. */
#define BS_I2S_RMR_RWM       (32U)         /*!< Bit field size in bits for I2S_RMR_RWM. */

/*! @brief Read current value of the I2S_RMR_RWM field. */
#define BR_I2S_RMR_RWM(x)    (HW_I2S_RMR(x).U)

/*! @brief Format value for bitfield I2S_RMR_RWM. */
#define BF_I2S_RMR_RWM(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_RMR_RWM) & BM_I2S_RMR_RWM)

/*! @brief Set the RWM field to a new value. */
#define BW_I2S_RMR_RWM(x, v) (HW_I2S_RMR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_I2S_MCR - SAI MCLK Control Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_MCR - SAI MCLK Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCLK Control Register (MCR) controls the clock source and direction of
 * the audio master clock.
 */
typedef union _hw_i2s_mcr
{
    uint32_t U;
    struct _hw_i2s_mcr_bitfields
    {
        uint32_t RESERVED0 : 24;       /*!< [23:0]  */
        uint32_t MICS : 2;             /*!< [25:24] MCLK Input Clock Select */
        uint32_t RESERVED1 : 4;        /*!< [29:26]  */
        uint32_t MOE : 1;              /*!< [30] MCLK Output Enable */
        uint32_t DUF : 1;              /*!< [31] Divider Update Flag */
    } B;
} hw_i2s_mcr_t;

/*!
 * @name Constants and macros for entire I2S_MCR register
 */
/*@{*/
#define HW_I2S_MCR_ADDR(x)       ((uint32_t)(x) + 0x100U)

#define HW_I2S_MCR(x)            (*(__IO hw_i2s_mcr_t *) HW_I2S_MCR_ADDR(x))
#define HW_I2S_MCR_RD(x)         (HW_I2S_MCR(x).U)
#define HW_I2S_MCR_WR(x, v)      (HW_I2S_MCR(x).U = (v))
#define HW_I2S_MCR_SET(x, v)     (HW_I2S_MCR_WR(x, HW_I2S_MCR_RD(x) |  (v)))
#define HW_I2S_MCR_CLR(x, v)     (HW_I2S_MCR_WR(x, HW_I2S_MCR_RD(x) & ~(v)))
#define HW_I2S_MCR_TOG(x, v)     (HW_I2S_MCR_WR(x, HW_I2S_MCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_MCR bitfields
 */

/*!
 * @name Register I2S_MCR, field MICS[25:24] (RW)
 *
 * Selects the clock input to the MCLK divider. This field cannot be changed
 * while the MCLK divider is enabled. See the chip configuration details for
 * information about the connections to these inputs.
 *
 * Values:
 * - 00 - MCLK divider input clock 0 selected.
 * - 01 - MCLK divider input clock 1 selected.
 * - 10 - MCLK divider input clock 2 selected.
 * - 11 - MCLK divider input clock 3 selected.
 */
/*@{*/
#define BP_I2S_MCR_MICS      (24U)         /*!< Bit position for I2S_MCR_MICS. */
#define BM_I2S_MCR_MICS      (0x03000000U) /*!< Bit mask for I2S_MCR_MICS. */
#define BS_I2S_MCR_MICS      (2U)          /*!< Bit field size in bits for I2S_MCR_MICS. */

/*! @brief Read current value of the I2S_MCR_MICS field. */
#define BR_I2S_MCR_MICS(x)   (HW_I2S_MCR(x).B.MICS)

/*! @brief Format value for bitfield I2S_MCR_MICS. */
#define BF_I2S_MCR_MICS(v)   ((uint32_t)((uint32_t)(v) << BP_I2S_MCR_MICS) & BM_I2S_MCR_MICS)

/*! @brief Set the MICS field to a new value. */
#define BW_I2S_MCR_MICS(x, v) (HW_I2S_MCR_WR(x, (HW_I2S_MCR_RD(x) & ~BM_I2S_MCR_MICS) | BF_I2S_MCR_MICS(v)))
/*@}*/

/*!
 * @name Register I2S_MCR, field MOE[30] (RW)
 *
 * Enables the MCLK divider and configures the MCLK signal pin as an output.
 * When software clears this field, it remains set until the MCLK divider is fully
 * disabled.
 *
 * Values:
 * - 0 - MCLK signal pin is configured as an input that bypasses the MCLK
 *     divider.
 * - 1 - MCLK signal pin is configured as an output from the MCLK divider and
 *     the MCLK divider is enabled.
 */
/*@{*/
#define BP_I2S_MCR_MOE       (30U)         /*!< Bit position for I2S_MCR_MOE. */
#define BM_I2S_MCR_MOE       (0x40000000U) /*!< Bit mask for I2S_MCR_MOE. */
#define BS_I2S_MCR_MOE       (1U)          /*!< Bit field size in bits for I2S_MCR_MOE. */

/*! @brief Read current value of the I2S_MCR_MOE field. */
#define BR_I2S_MCR_MOE(x)    (BITBAND_ACCESS32(HW_I2S_MCR_ADDR(x), BP_I2S_MCR_MOE))

/*! @brief Format value for bitfield I2S_MCR_MOE. */
#define BF_I2S_MCR_MOE(v)    ((uint32_t)((uint32_t)(v) << BP_I2S_MCR_MOE) & BM_I2S_MCR_MOE)

/*! @brief Set the MOE field to a new value. */
#define BW_I2S_MCR_MOE(x, v) (BITBAND_ACCESS32(HW_I2S_MCR_ADDR(x), BP_I2S_MCR_MOE) = (v))
/*@}*/

/*!
 * @name Register I2S_MCR, field DUF[31] (RO)
 *
 * Provides the status of on-the-fly updates to the MCLK divider ratio.
 *
 * Values:
 * - 0 - MCLK divider ratio is not being updated currently.
 * - 1 - MCLK divider ratio is updating on-the-fly. Further updates to the MCLK
 *     divider ratio are blocked while this flag remains set.
 */
/*@{*/
#define BP_I2S_MCR_DUF       (31U)         /*!< Bit position for I2S_MCR_DUF. */
#define BM_I2S_MCR_DUF       (0x80000000U) /*!< Bit mask for I2S_MCR_DUF. */
#define BS_I2S_MCR_DUF       (1U)          /*!< Bit field size in bits for I2S_MCR_DUF. */

/*! @brief Read current value of the I2S_MCR_DUF field. */
#define BR_I2S_MCR_DUF(x)    (BITBAND_ACCESS32(HW_I2S_MCR_ADDR(x), BP_I2S_MCR_DUF))
/*@}*/

/*******************************************************************************
 * HW_I2S_MDR - SAI MCLK Divide Register
 ******************************************************************************/

/*!
 * @brief HW_I2S_MDR - SAI MCLK Divide Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCLK Divide Register (MDR) configures the MCLK divide ratio. Although the
 * MDR can be changed when the MCLK divider clock is enabled, additional writes
 * to the MDR are blocked while MCR[DUF] is set. Writes to the MDR when the MCLK
 * divided clock is disabled do not set MCR[DUF].
 */
typedef union _hw_i2s_mdr
{
    uint32_t U;
    struct _hw_i2s_mdr_bitfields
    {
        uint32_t DIVIDE : 12;          /*!< [11:0] MCLK Divide */
        uint32_t FRACT : 8;            /*!< [19:12] MCLK Fraction */
        uint32_t RESERVED0 : 12;       /*!< [31:20]  */
    } B;
} hw_i2s_mdr_t;

/*!
 * @name Constants and macros for entire I2S_MDR register
 */
/*@{*/
#define HW_I2S_MDR_ADDR(x)       ((uint32_t)(x) + 0x104U)

#define HW_I2S_MDR(x)            (*(__IO hw_i2s_mdr_t *) HW_I2S_MDR_ADDR(x))
#define HW_I2S_MDR_RD(x)         (HW_I2S_MDR(x).U)
#define HW_I2S_MDR_WR(x, v)      (HW_I2S_MDR(x).U = (v))
#define HW_I2S_MDR_SET(x, v)     (HW_I2S_MDR_WR(x, HW_I2S_MDR_RD(x) |  (v)))
#define HW_I2S_MDR_CLR(x, v)     (HW_I2S_MDR_WR(x, HW_I2S_MDR_RD(x) & ~(v)))
#define HW_I2S_MDR_TOG(x, v)     (HW_I2S_MDR_WR(x, HW_I2S_MDR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual I2S_MDR bitfields
 */

/*!
 * @name Register I2S_MDR, field DIVIDE[11:0] (RW)
 *
 * Sets the MCLK divide ratio such that: MCLK output = MCLK input * ( (FRACT +
 * 1) / (DIVIDE + 1) ). FRACT must be set equal or less than the value in the
 * DIVIDE field.
 */
/*@{*/
#define BP_I2S_MDR_DIVIDE    (0U)          /*!< Bit position for I2S_MDR_DIVIDE. */
#define BM_I2S_MDR_DIVIDE    (0x00000FFFU) /*!< Bit mask for I2S_MDR_DIVIDE. */
#define BS_I2S_MDR_DIVIDE    (12U)         /*!< Bit field size in bits for I2S_MDR_DIVIDE. */

/*! @brief Read current value of the I2S_MDR_DIVIDE field. */
#define BR_I2S_MDR_DIVIDE(x) (HW_I2S_MDR(x).B.DIVIDE)

/*! @brief Format value for bitfield I2S_MDR_DIVIDE. */
#define BF_I2S_MDR_DIVIDE(v) ((uint32_t)((uint32_t)(v) << BP_I2S_MDR_DIVIDE) & BM_I2S_MDR_DIVIDE)

/*! @brief Set the DIVIDE field to a new value. */
#define BW_I2S_MDR_DIVIDE(x, v) (HW_I2S_MDR_WR(x, (HW_I2S_MDR_RD(x) & ~BM_I2S_MDR_DIVIDE) | BF_I2S_MDR_DIVIDE(v)))
/*@}*/

/*!
 * @name Register I2S_MDR, field FRACT[19:12] (RW)
 *
 * Sets the MCLK divide ratio such that: MCLK output = MCLK input * ( (FRACT +
 * 1) / (DIVIDE + 1) ). FRACT must be set equal or less than the value in the
 * DIVIDE field.
 */
/*@{*/
#define BP_I2S_MDR_FRACT     (12U)         /*!< Bit position for I2S_MDR_FRACT. */
#define BM_I2S_MDR_FRACT     (0x000FF000U) /*!< Bit mask for I2S_MDR_FRACT. */
#define BS_I2S_MDR_FRACT     (8U)          /*!< Bit field size in bits for I2S_MDR_FRACT. */

/*! @brief Read current value of the I2S_MDR_FRACT field. */
#define BR_I2S_MDR_FRACT(x)  (HW_I2S_MDR(x).B.FRACT)

/*! @brief Format value for bitfield I2S_MDR_FRACT. */
#define BF_I2S_MDR_FRACT(v)  ((uint32_t)((uint32_t)(v) << BP_I2S_MDR_FRACT) & BM_I2S_MDR_FRACT)

/*! @brief Set the FRACT field to a new value. */
#define BW_I2S_MDR_FRACT(x, v) (HW_I2S_MDR_WR(x, (HW_I2S_MDR_RD(x) & ~BM_I2S_MDR_FRACT) | BF_I2S_MDR_FRACT(v)))
/*@}*/

/*******************************************************************************
 * hw_i2s_t - module struct
 ******************************************************************************/
/*!
 * @brief All I2S module registers.
 */
#pragma pack(1)
typedef struct _hw_i2s
{
    __IO hw_i2s_tcsr_t TCSR;               /*!< [0x0] SAI Transmit Control Register */
    __IO hw_i2s_tcr1_t TCR1;               /*!< [0x4] SAI Transmit Configuration 1 Register */
    __IO hw_i2s_tcr2_t TCR2;               /*!< [0x8] SAI Transmit Configuration 2 Register */
    __IO hw_i2s_tcr3_t TCR3;               /*!< [0xC] SAI Transmit Configuration 3 Register */
    __IO hw_i2s_tcr4_t TCR4;               /*!< [0x10] SAI Transmit Configuration 4 Register */
    __IO hw_i2s_tcr5_t TCR5;               /*!< [0x14] SAI Transmit Configuration 5 Register */
    uint8_t _reserved0[8];
    __O hw_i2s_tdrn_t TDRn[2];             /*!< [0x20] SAI Transmit Data Register */
    uint8_t _reserved1[24];
    __I hw_i2s_tfrn_t TFRn[2];             /*!< [0x40] SAI Transmit FIFO Register */
    uint8_t _reserved2[24];
    __IO hw_i2s_tmr_t TMR;                 /*!< [0x60] SAI Transmit Mask Register */
    uint8_t _reserved3[28];
    __IO hw_i2s_rcsr_t RCSR;               /*!< [0x80] SAI Receive Control Register */
    __IO hw_i2s_rcr1_t RCR1;               /*!< [0x84] SAI Receive Configuration 1 Register */
    __IO hw_i2s_rcr2_t RCR2;               /*!< [0x88] SAI Receive Configuration 2 Register */
    __IO hw_i2s_rcr3_t RCR3;               /*!< [0x8C] SAI Receive Configuration 3 Register */
    __IO hw_i2s_rcr4_t RCR4;               /*!< [0x90] SAI Receive Configuration 4 Register */
    __IO hw_i2s_rcr5_t RCR5;               /*!< [0x94] SAI Receive Configuration 5 Register */
    uint8_t _reserved4[8];
    __I hw_i2s_rdrn_t RDRn[2];             /*!< [0xA0] SAI Receive Data Register */
    uint8_t _reserved5[24];
    __I hw_i2s_rfrn_t RFRn[2];             /*!< [0xC0] SAI Receive FIFO Register */
    uint8_t _reserved6[24];
    __IO hw_i2s_rmr_t RMR;                 /*!< [0xE0] SAI Receive Mask Register */
    uint8_t _reserved7[28];
    __IO hw_i2s_mcr_t MCR;                 /*!< [0x100] SAI MCLK Control Register */
    __IO hw_i2s_mdr_t MDR;                 /*!< [0x104] SAI MCLK Divide Register */
} hw_i2s_t;
#pragma pack()

/*! @brief Macro to access all I2S registers. */
/*! @param x I2S module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_I2S_REGS(I2S0_BASE)</code>. */
#define HW_I2S_REGS(x) (*(hw_i2s_t *)(x))

/*
 * MK64F12 LLWU
 *
 * Low leakage wakeup unit
 *
 * Registers defined in this header file:
 * - HW_LLWU_PE1 - LLWU Pin Enable 1 register
 * - HW_LLWU_PE2 - LLWU Pin Enable 2 register
 * - HW_LLWU_PE3 - LLWU Pin Enable 3 register
 * - HW_LLWU_PE4 - LLWU Pin Enable 4 register
 * - HW_LLWU_ME - LLWU Module Enable register
 * - HW_LLWU_F1 - LLWU Flag 1 register
 * - HW_LLWU_F2 - LLWU Flag 2 register
 * - HW_LLWU_F3 - LLWU Flag 3 register
 * - HW_LLWU_FILT1 - LLWU Pin Filter 1 register
 * - HW_LLWU_FILT2 - LLWU Pin Filter 2 register
 * - HW_LLWU_RST - LLWU Reset Enable register
 *
 * - hw_llwu_t - Struct containing all module registers.
 */

#define HW_LLWU_INSTANCE_COUNT (1U) /*!< Number of instances of the LLWU module. */
#define HW_LLWU (0U) /*!< Instance number for LLWU. */

/*******************************************************************************
 * HW_LLWU_PE1 - LLWU Pin Enable 1 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_PE1 - LLWU Pin Enable 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE1 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P3-LLWU_P0. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_pe1
{
    uint8_t U;
    struct _hw_llwu_pe1_bitfields
    {
        uint8_t WUPE0 : 2;             /*!< [1:0] Wakeup Pin Enable For LLWU_P0 */
        uint8_t WUPE1 : 2;             /*!< [3:2] Wakeup Pin Enable For LLWU_P1 */
        uint8_t WUPE2 : 2;             /*!< [5:4] Wakeup Pin Enable For LLWU_P2 */
        uint8_t WUPE3 : 2;             /*!< [7:6] Wakeup Pin Enable For LLWU_P3 */
    } B;
} hw_llwu_pe1_t;

/*!
 * @name Constants and macros for entire LLWU_PE1 register
 */
/*@{*/
#define HW_LLWU_PE1_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_LLWU_PE1(x)           (*(__IO hw_llwu_pe1_t *) HW_LLWU_PE1_ADDR(x))
#define HW_LLWU_PE1_RD(x)        (HW_LLWU_PE1(x).U)
#define HW_LLWU_PE1_WR(x, v)     (HW_LLWU_PE1(x).U = (v))
#define HW_LLWU_PE1_SET(x, v)    (HW_LLWU_PE1_WR(x, HW_LLWU_PE1_RD(x) |  (v)))
#define HW_LLWU_PE1_CLR(x, v)    (HW_LLWU_PE1_WR(x, HW_LLWU_PE1_RD(x) & ~(v)))
#define HW_LLWU_PE1_TOG(x, v)    (HW_LLWU_PE1_WR(x, HW_LLWU_PE1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE1 bitfields
 */

/*!
 * @name Register LLWU_PE1, field WUPE0[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE1_WUPE0    (0U)          /*!< Bit position for LLWU_PE1_WUPE0. */
#define BM_LLWU_PE1_WUPE0    (0x03U)       /*!< Bit mask for LLWU_PE1_WUPE0. */
#define BS_LLWU_PE1_WUPE0    (2U)          /*!< Bit field size in bits for LLWU_PE1_WUPE0. */

/*! @brief Read current value of the LLWU_PE1_WUPE0 field. */
#define BR_LLWU_PE1_WUPE0(x) (HW_LLWU_PE1(x).B.WUPE0)

/*! @brief Format value for bitfield LLWU_PE1_WUPE0. */
#define BF_LLWU_PE1_WUPE0(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE1_WUPE0) & BM_LLWU_PE1_WUPE0)

/*! @brief Set the WUPE0 field to a new value. */
#define BW_LLWU_PE1_WUPE0(x, v) (HW_LLWU_PE1_WR(x, (HW_LLWU_PE1_RD(x) & ~BM_LLWU_PE1_WUPE0) | BF_LLWU_PE1_WUPE0(v)))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE1[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE1_WUPE1    (2U)          /*!< Bit position for LLWU_PE1_WUPE1. */
#define BM_LLWU_PE1_WUPE1    (0x0CU)       /*!< Bit mask for LLWU_PE1_WUPE1. */
#define BS_LLWU_PE1_WUPE1    (2U)          /*!< Bit field size in bits for LLWU_PE1_WUPE1. */

/*! @brief Read current value of the LLWU_PE1_WUPE1 field. */
#define BR_LLWU_PE1_WUPE1(x) (HW_LLWU_PE1(x).B.WUPE1)

/*! @brief Format value for bitfield LLWU_PE1_WUPE1. */
#define BF_LLWU_PE1_WUPE1(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE1_WUPE1) & BM_LLWU_PE1_WUPE1)

/*! @brief Set the WUPE1 field to a new value. */
#define BW_LLWU_PE1_WUPE1(x, v) (HW_LLWU_PE1_WR(x, (HW_LLWU_PE1_RD(x) & ~BM_LLWU_PE1_WUPE1) | BF_LLWU_PE1_WUPE1(v)))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE2[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE1_WUPE2    (4U)          /*!< Bit position for LLWU_PE1_WUPE2. */
#define BM_LLWU_PE1_WUPE2    (0x30U)       /*!< Bit mask for LLWU_PE1_WUPE2. */
#define BS_LLWU_PE1_WUPE2    (2U)          /*!< Bit field size in bits for LLWU_PE1_WUPE2. */

/*! @brief Read current value of the LLWU_PE1_WUPE2 field. */
#define BR_LLWU_PE1_WUPE2(x) (HW_LLWU_PE1(x).B.WUPE2)

/*! @brief Format value for bitfield LLWU_PE1_WUPE2. */
#define BF_LLWU_PE1_WUPE2(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE1_WUPE2) & BM_LLWU_PE1_WUPE2)

/*! @brief Set the WUPE2 field to a new value. */
#define BW_LLWU_PE1_WUPE2(x, v) (HW_LLWU_PE1_WR(x, (HW_LLWU_PE1_RD(x) & ~BM_LLWU_PE1_WUPE2) | BF_LLWU_PE1_WUPE2(v)))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE3[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE1_WUPE3    (6U)          /*!< Bit position for LLWU_PE1_WUPE3. */
#define BM_LLWU_PE1_WUPE3    (0xC0U)       /*!< Bit mask for LLWU_PE1_WUPE3. */
#define BS_LLWU_PE1_WUPE3    (2U)          /*!< Bit field size in bits for LLWU_PE1_WUPE3. */

/*! @brief Read current value of the LLWU_PE1_WUPE3 field. */
#define BR_LLWU_PE1_WUPE3(x) (HW_LLWU_PE1(x).B.WUPE3)

/*! @brief Format value for bitfield LLWU_PE1_WUPE3. */
#define BF_LLWU_PE1_WUPE3(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE1_WUPE3) & BM_LLWU_PE1_WUPE3)

/*! @brief Set the WUPE3 field to a new value. */
#define BW_LLWU_PE1_WUPE3(x, v) (HW_LLWU_PE1_WR(x, (HW_LLWU_PE1_RD(x) & ~BM_LLWU_PE1_WUPE3) | BF_LLWU_PE1_WUPE3(v)))
/*@}*/

/*******************************************************************************
 * HW_LLWU_PE2 - LLWU Pin Enable 2 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_PE2 - LLWU Pin Enable 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE2 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P7-LLWU_P4. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_pe2
{
    uint8_t U;
    struct _hw_llwu_pe2_bitfields
    {
        uint8_t WUPE4 : 2;             /*!< [1:0] Wakeup Pin Enable For LLWU_P4 */
        uint8_t WUPE5 : 2;             /*!< [3:2] Wakeup Pin Enable For LLWU_P5 */
        uint8_t WUPE6 : 2;             /*!< [5:4] Wakeup Pin Enable For LLWU_P6 */
        uint8_t WUPE7 : 2;             /*!< [7:6] Wakeup Pin Enable For LLWU_P7 */
    } B;
} hw_llwu_pe2_t;

/*!
 * @name Constants and macros for entire LLWU_PE2 register
 */
/*@{*/
#define HW_LLWU_PE2_ADDR(x)      ((uint32_t)(x) + 0x1U)

#define HW_LLWU_PE2(x)           (*(__IO hw_llwu_pe2_t *) HW_LLWU_PE2_ADDR(x))
#define HW_LLWU_PE2_RD(x)        (HW_LLWU_PE2(x).U)
#define HW_LLWU_PE2_WR(x, v)     (HW_LLWU_PE2(x).U = (v))
#define HW_LLWU_PE2_SET(x, v)    (HW_LLWU_PE2_WR(x, HW_LLWU_PE2_RD(x) |  (v)))
#define HW_LLWU_PE2_CLR(x, v)    (HW_LLWU_PE2_WR(x, HW_LLWU_PE2_RD(x) & ~(v)))
#define HW_LLWU_PE2_TOG(x, v)    (HW_LLWU_PE2_WR(x, HW_LLWU_PE2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE2 bitfields
 */

/*!
 * @name Register LLWU_PE2, field WUPE4[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE2_WUPE4    (0U)          /*!< Bit position for LLWU_PE2_WUPE4. */
#define BM_LLWU_PE2_WUPE4    (0x03U)       /*!< Bit mask for LLWU_PE2_WUPE4. */
#define BS_LLWU_PE2_WUPE4    (2U)          /*!< Bit field size in bits for LLWU_PE2_WUPE4. */

/*! @brief Read current value of the LLWU_PE2_WUPE4 field. */
#define BR_LLWU_PE2_WUPE4(x) (HW_LLWU_PE2(x).B.WUPE4)

/*! @brief Format value for bitfield LLWU_PE2_WUPE4. */
#define BF_LLWU_PE2_WUPE4(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE2_WUPE4) & BM_LLWU_PE2_WUPE4)

/*! @brief Set the WUPE4 field to a new value. */
#define BW_LLWU_PE2_WUPE4(x, v) (HW_LLWU_PE2_WR(x, (HW_LLWU_PE2_RD(x) & ~BM_LLWU_PE2_WUPE4) | BF_LLWU_PE2_WUPE4(v)))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE5[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE2_WUPE5    (2U)          /*!< Bit position for LLWU_PE2_WUPE5. */
#define BM_LLWU_PE2_WUPE5    (0x0CU)       /*!< Bit mask for LLWU_PE2_WUPE5. */
#define BS_LLWU_PE2_WUPE5    (2U)          /*!< Bit field size in bits for LLWU_PE2_WUPE5. */

/*! @brief Read current value of the LLWU_PE2_WUPE5 field. */
#define BR_LLWU_PE2_WUPE5(x) (HW_LLWU_PE2(x).B.WUPE5)

/*! @brief Format value for bitfield LLWU_PE2_WUPE5. */
#define BF_LLWU_PE2_WUPE5(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE2_WUPE5) & BM_LLWU_PE2_WUPE5)

/*! @brief Set the WUPE5 field to a new value. */
#define BW_LLWU_PE2_WUPE5(x, v) (HW_LLWU_PE2_WR(x, (HW_LLWU_PE2_RD(x) & ~BM_LLWU_PE2_WUPE5) | BF_LLWU_PE2_WUPE5(v)))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE6[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE2_WUPE6    (4U)          /*!< Bit position for LLWU_PE2_WUPE6. */
#define BM_LLWU_PE2_WUPE6    (0x30U)       /*!< Bit mask for LLWU_PE2_WUPE6. */
#define BS_LLWU_PE2_WUPE6    (2U)          /*!< Bit field size in bits for LLWU_PE2_WUPE6. */

/*! @brief Read current value of the LLWU_PE2_WUPE6 field. */
#define BR_LLWU_PE2_WUPE6(x) (HW_LLWU_PE2(x).B.WUPE6)

/*! @brief Format value for bitfield LLWU_PE2_WUPE6. */
#define BF_LLWU_PE2_WUPE6(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE2_WUPE6) & BM_LLWU_PE2_WUPE6)

/*! @brief Set the WUPE6 field to a new value. */
#define BW_LLWU_PE2_WUPE6(x, v) (HW_LLWU_PE2_WR(x, (HW_LLWU_PE2_RD(x) & ~BM_LLWU_PE2_WUPE6) | BF_LLWU_PE2_WUPE6(v)))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE7[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE2_WUPE7    (6U)          /*!< Bit position for LLWU_PE2_WUPE7. */
#define BM_LLWU_PE2_WUPE7    (0xC0U)       /*!< Bit mask for LLWU_PE2_WUPE7. */
#define BS_LLWU_PE2_WUPE7    (2U)          /*!< Bit field size in bits for LLWU_PE2_WUPE7. */

/*! @brief Read current value of the LLWU_PE2_WUPE7 field. */
#define BR_LLWU_PE2_WUPE7(x) (HW_LLWU_PE2(x).B.WUPE7)

/*! @brief Format value for bitfield LLWU_PE2_WUPE7. */
#define BF_LLWU_PE2_WUPE7(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE2_WUPE7) & BM_LLWU_PE2_WUPE7)

/*! @brief Set the WUPE7 field to a new value. */
#define BW_LLWU_PE2_WUPE7(x, v) (HW_LLWU_PE2_WR(x, (HW_LLWU_PE2_RD(x) & ~BM_LLWU_PE2_WUPE7) | BF_LLWU_PE2_WUPE7(v)))
/*@}*/

/*******************************************************************************
 * HW_LLWU_PE3 - LLWU Pin Enable 3 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_PE3 - LLWU Pin Enable 3 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE3 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P11-LLWU_P8. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_pe3
{
    uint8_t U;
    struct _hw_llwu_pe3_bitfields
    {
        uint8_t WUPE8 : 2;             /*!< [1:0] Wakeup Pin Enable For LLWU_P8 */
        uint8_t WUPE9 : 2;             /*!< [3:2] Wakeup Pin Enable For LLWU_P9 */
        uint8_t WUPE10 : 2;            /*!< [5:4] Wakeup Pin Enable For LLWU_P10 */
        uint8_t WUPE11 : 2;            /*!< [7:6] Wakeup Pin Enable For LLWU_P11 */
    } B;
} hw_llwu_pe3_t;

/*!
 * @name Constants and macros for entire LLWU_PE3 register
 */
/*@{*/
#define HW_LLWU_PE3_ADDR(x)      ((uint32_t)(x) + 0x2U)

#define HW_LLWU_PE3(x)           (*(__IO hw_llwu_pe3_t *) HW_LLWU_PE3_ADDR(x))
#define HW_LLWU_PE3_RD(x)        (HW_LLWU_PE3(x).U)
#define HW_LLWU_PE3_WR(x, v)     (HW_LLWU_PE3(x).U = (v))
#define HW_LLWU_PE3_SET(x, v)    (HW_LLWU_PE3_WR(x, HW_LLWU_PE3_RD(x) |  (v)))
#define HW_LLWU_PE3_CLR(x, v)    (HW_LLWU_PE3_WR(x, HW_LLWU_PE3_RD(x) & ~(v)))
#define HW_LLWU_PE3_TOG(x, v)    (HW_LLWU_PE3_WR(x, HW_LLWU_PE3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE3 bitfields
 */

/*!
 * @name Register LLWU_PE3, field WUPE8[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE3_WUPE8    (0U)          /*!< Bit position for LLWU_PE3_WUPE8. */
#define BM_LLWU_PE3_WUPE8    (0x03U)       /*!< Bit mask for LLWU_PE3_WUPE8. */
#define BS_LLWU_PE3_WUPE8    (2U)          /*!< Bit field size in bits for LLWU_PE3_WUPE8. */

/*! @brief Read current value of the LLWU_PE3_WUPE8 field. */
#define BR_LLWU_PE3_WUPE8(x) (HW_LLWU_PE3(x).B.WUPE8)

/*! @brief Format value for bitfield LLWU_PE3_WUPE8. */
#define BF_LLWU_PE3_WUPE8(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE3_WUPE8) & BM_LLWU_PE3_WUPE8)

/*! @brief Set the WUPE8 field to a new value. */
#define BW_LLWU_PE3_WUPE8(x, v) (HW_LLWU_PE3_WR(x, (HW_LLWU_PE3_RD(x) & ~BM_LLWU_PE3_WUPE8) | BF_LLWU_PE3_WUPE8(v)))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE9[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE3_WUPE9    (2U)          /*!< Bit position for LLWU_PE3_WUPE9. */
#define BM_LLWU_PE3_WUPE9    (0x0CU)       /*!< Bit mask for LLWU_PE3_WUPE9. */
#define BS_LLWU_PE3_WUPE9    (2U)          /*!< Bit field size in bits for LLWU_PE3_WUPE9. */

/*! @brief Read current value of the LLWU_PE3_WUPE9 field. */
#define BR_LLWU_PE3_WUPE9(x) (HW_LLWU_PE3(x).B.WUPE9)

/*! @brief Format value for bitfield LLWU_PE3_WUPE9. */
#define BF_LLWU_PE3_WUPE9(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE3_WUPE9) & BM_LLWU_PE3_WUPE9)

/*! @brief Set the WUPE9 field to a new value. */
#define BW_LLWU_PE3_WUPE9(x, v) (HW_LLWU_PE3_WR(x, (HW_LLWU_PE3_RD(x) & ~BM_LLWU_PE3_WUPE9) | BF_LLWU_PE3_WUPE9(v)))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE10[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE3_WUPE10   (4U)          /*!< Bit position for LLWU_PE3_WUPE10. */
#define BM_LLWU_PE3_WUPE10   (0x30U)       /*!< Bit mask for LLWU_PE3_WUPE10. */
#define BS_LLWU_PE3_WUPE10   (2U)          /*!< Bit field size in bits for LLWU_PE3_WUPE10. */

/*! @brief Read current value of the LLWU_PE3_WUPE10 field. */
#define BR_LLWU_PE3_WUPE10(x) (HW_LLWU_PE3(x).B.WUPE10)

/*! @brief Format value for bitfield LLWU_PE3_WUPE10. */
#define BF_LLWU_PE3_WUPE10(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE3_WUPE10) & BM_LLWU_PE3_WUPE10)

/*! @brief Set the WUPE10 field to a new value. */
#define BW_LLWU_PE3_WUPE10(x, v) (HW_LLWU_PE3_WR(x, (HW_LLWU_PE3_RD(x) & ~BM_LLWU_PE3_WUPE10) | BF_LLWU_PE3_WUPE10(v)))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE11[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE3_WUPE11   (6U)          /*!< Bit position for LLWU_PE3_WUPE11. */
#define BM_LLWU_PE3_WUPE11   (0xC0U)       /*!< Bit mask for LLWU_PE3_WUPE11. */
#define BS_LLWU_PE3_WUPE11   (2U)          /*!< Bit field size in bits for LLWU_PE3_WUPE11. */

/*! @brief Read current value of the LLWU_PE3_WUPE11 field. */
#define BR_LLWU_PE3_WUPE11(x) (HW_LLWU_PE3(x).B.WUPE11)

/*! @brief Format value for bitfield LLWU_PE3_WUPE11. */
#define BF_LLWU_PE3_WUPE11(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE3_WUPE11) & BM_LLWU_PE3_WUPE11)

/*! @brief Set the WUPE11 field to a new value. */
#define BW_LLWU_PE3_WUPE11(x, v) (HW_LLWU_PE3_WR(x, (HW_LLWU_PE3_RD(x) & ~BM_LLWU_PE3_WUPE11) | BF_LLWU_PE3_WUPE11(v)))
/*@}*/

/*******************************************************************************
 * HW_LLWU_PE4 - LLWU Pin Enable 4 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_PE4 - LLWU Pin Enable 4 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE4 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P15-LLWU_P12. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_pe4
{
    uint8_t U;
    struct _hw_llwu_pe4_bitfields
    {
        uint8_t WUPE12 : 2;            /*!< [1:0] Wakeup Pin Enable For LLWU_P12 */
        uint8_t WUPE13 : 2;            /*!< [3:2] Wakeup Pin Enable For LLWU_P13 */
        uint8_t WUPE14 : 2;            /*!< [5:4] Wakeup Pin Enable For LLWU_P14 */
        uint8_t WUPE15 : 2;            /*!< [7:6] Wakeup Pin Enable For LLWU_P15 */
    } B;
} hw_llwu_pe4_t;

/*!
 * @name Constants and macros for entire LLWU_PE4 register
 */
/*@{*/
#define HW_LLWU_PE4_ADDR(x)      ((uint32_t)(x) + 0x3U)

#define HW_LLWU_PE4(x)           (*(__IO hw_llwu_pe4_t *) HW_LLWU_PE4_ADDR(x))
#define HW_LLWU_PE4_RD(x)        (HW_LLWU_PE4(x).U)
#define HW_LLWU_PE4_WR(x, v)     (HW_LLWU_PE4(x).U = (v))
#define HW_LLWU_PE4_SET(x, v)    (HW_LLWU_PE4_WR(x, HW_LLWU_PE4_RD(x) |  (v)))
#define HW_LLWU_PE4_CLR(x, v)    (HW_LLWU_PE4_WR(x, HW_LLWU_PE4_RD(x) & ~(v)))
#define HW_LLWU_PE4_TOG(x, v)    (HW_LLWU_PE4_WR(x, HW_LLWU_PE4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE4 bitfields
 */

/*!
 * @name Register LLWU_PE4, field WUPE12[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE4_WUPE12   (0U)          /*!< Bit position for LLWU_PE4_WUPE12. */
#define BM_LLWU_PE4_WUPE12   (0x03U)       /*!< Bit mask for LLWU_PE4_WUPE12. */
#define BS_LLWU_PE4_WUPE12   (2U)          /*!< Bit field size in bits for LLWU_PE4_WUPE12. */

/*! @brief Read current value of the LLWU_PE4_WUPE12 field. */
#define BR_LLWU_PE4_WUPE12(x) (HW_LLWU_PE4(x).B.WUPE12)

/*! @brief Format value for bitfield LLWU_PE4_WUPE12. */
#define BF_LLWU_PE4_WUPE12(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE4_WUPE12) & BM_LLWU_PE4_WUPE12)

/*! @brief Set the WUPE12 field to a new value. */
#define BW_LLWU_PE4_WUPE12(x, v) (HW_LLWU_PE4_WR(x, (HW_LLWU_PE4_RD(x) & ~BM_LLWU_PE4_WUPE12) | BF_LLWU_PE4_WUPE12(v)))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE13[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE4_WUPE13   (2U)          /*!< Bit position for LLWU_PE4_WUPE13. */
#define BM_LLWU_PE4_WUPE13   (0x0CU)       /*!< Bit mask for LLWU_PE4_WUPE13. */
#define BS_LLWU_PE4_WUPE13   (2U)          /*!< Bit field size in bits for LLWU_PE4_WUPE13. */

/*! @brief Read current value of the LLWU_PE4_WUPE13 field. */
#define BR_LLWU_PE4_WUPE13(x) (HW_LLWU_PE4(x).B.WUPE13)

/*! @brief Format value for bitfield LLWU_PE4_WUPE13. */
#define BF_LLWU_PE4_WUPE13(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE4_WUPE13) & BM_LLWU_PE4_WUPE13)

/*! @brief Set the WUPE13 field to a new value. */
#define BW_LLWU_PE4_WUPE13(x, v) (HW_LLWU_PE4_WR(x, (HW_LLWU_PE4_RD(x) & ~BM_LLWU_PE4_WUPE13) | BF_LLWU_PE4_WUPE13(v)))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE14[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE4_WUPE14   (4U)          /*!< Bit position for LLWU_PE4_WUPE14. */
#define BM_LLWU_PE4_WUPE14   (0x30U)       /*!< Bit mask for LLWU_PE4_WUPE14. */
#define BS_LLWU_PE4_WUPE14   (2U)          /*!< Bit field size in bits for LLWU_PE4_WUPE14. */

/*! @brief Read current value of the LLWU_PE4_WUPE14 field. */
#define BR_LLWU_PE4_WUPE14(x) (HW_LLWU_PE4(x).B.WUPE14)

/*! @brief Format value for bitfield LLWU_PE4_WUPE14. */
#define BF_LLWU_PE4_WUPE14(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE4_WUPE14) & BM_LLWU_PE4_WUPE14)

/*! @brief Set the WUPE14 field to a new value. */
#define BW_LLWU_PE4_WUPE14(x, v) (HW_LLWU_PE4_WR(x, (HW_LLWU_PE4_RD(x) & ~BM_LLWU_PE4_WUPE14) | BF_LLWU_PE4_WUPE14(v)))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE15[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
#define BP_LLWU_PE4_WUPE15   (6U)          /*!< Bit position for LLWU_PE4_WUPE15. */
#define BM_LLWU_PE4_WUPE15   (0xC0U)       /*!< Bit mask for LLWU_PE4_WUPE15. */
#define BS_LLWU_PE4_WUPE15   (2U)          /*!< Bit field size in bits for LLWU_PE4_WUPE15. */

/*! @brief Read current value of the LLWU_PE4_WUPE15 field. */
#define BR_LLWU_PE4_WUPE15(x) (HW_LLWU_PE4(x).B.WUPE15)

/*! @brief Format value for bitfield LLWU_PE4_WUPE15. */
#define BF_LLWU_PE4_WUPE15(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_PE4_WUPE15) & BM_LLWU_PE4_WUPE15)

/*! @brief Set the WUPE15 field to a new value. */
#define BW_LLWU_PE4_WUPE15(x, v) (HW_LLWU_PE4_WR(x, (HW_LLWU_PE4_RD(x) & ~BM_LLWU_PE4_WUPE15) | BF_LLWU_PE4_WUPE15(v)))
/*@}*/

/*******************************************************************************
 * HW_LLWU_ME - LLWU Module Enable register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_ME - LLWU Module Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_ME contains the bits to enable the internal module flag as a wakeup
 * input source for inputs MWUF7-MWUF0. This register is reset on Chip Reset not VLLS
 * and by reset types that trigger Chip Reset not VLLS. It is unaffected by
 * reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module (RCM). The
 * RCM implements many of the reset functions for the chip. See the chip's reset
 * chapter for more information. details for more information.
 */
typedef union _hw_llwu_me
{
    uint8_t U;
    struct _hw_llwu_me_bitfields
    {
        uint8_t WUME0 : 1;             /*!< [0] Wakeup Module Enable For Module 0 */
        uint8_t WUME1 : 1;             /*!< [1] Wakeup Module Enable for Module 1 */
        uint8_t WUME2 : 1;             /*!< [2] Wakeup Module Enable For Module 2 */
        uint8_t WUME3 : 1;             /*!< [3] Wakeup Module Enable For Module 3 */
        uint8_t WUME4 : 1;             /*!< [4] Wakeup Module Enable For Module 4 */
        uint8_t WUME5 : 1;             /*!< [5] Wakeup Module Enable For Module 5 */
        uint8_t WUME6 : 1;             /*!< [6] Wakeup Module Enable For Module 6 */
        uint8_t WUME7 : 1;             /*!< [7] Wakeup Module Enable For Module 7 */
    } B;
} hw_llwu_me_t;

/*!
 * @name Constants and macros for entire LLWU_ME register
 */
/*@{*/
#define HW_LLWU_ME_ADDR(x)       ((uint32_t)(x) + 0x4U)

#define HW_LLWU_ME(x)            (*(__IO hw_llwu_me_t *) HW_LLWU_ME_ADDR(x))
#define HW_LLWU_ME_RD(x)         (HW_LLWU_ME(x).U)
#define HW_LLWU_ME_WR(x, v)      (HW_LLWU_ME(x).U = (v))
#define HW_LLWU_ME_SET(x, v)     (HW_LLWU_ME_WR(x, HW_LLWU_ME_RD(x) |  (v)))
#define HW_LLWU_ME_CLR(x, v)     (HW_LLWU_ME_WR(x, HW_LLWU_ME_RD(x) & ~(v)))
#define HW_LLWU_ME_TOG(x, v)     (HW_LLWU_ME_WR(x, HW_LLWU_ME_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_ME bitfields
 */

/*!
 * @name Register LLWU_ME, field WUME0[0] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME0     (0U)          /*!< Bit position for LLWU_ME_WUME0. */
#define BM_LLWU_ME_WUME0     (0x01U)       /*!< Bit mask for LLWU_ME_WUME0. */
#define BS_LLWU_ME_WUME0     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME0. */

/*! @brief Read current value of the LLWU_ME_WUME0 field. */
#define BR_LLWU_ME_WUME0(x)  (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME0))

/*! @brief Format value for bitfield LLWU_ME_WUME0. */
#define BF_LLWU_ME_WUME0(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME0) & BM_LLWU_ME_WUME0)

/*! @brief Set the WUME0 field to a new value. */
#define BW_LLWU_ME_WUME0(x, v) (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME0) = (v))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME1[1] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME1     (1U)          /*!< Bit position for LLWU_ME_WUME1. */
#define BM_LLWU_ME_WUME1     (0x02U)       /*!< Bit mask for LLWU_ME_WUME1. */
#define BS_LLWU_ME_WUME1     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME1. */

/*! @brief Read current value of the LLWU_ME_WUME1 field. */
#define BR_LLWU_ME_WUME1(x)  (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME1))

/*! @brief Format value for bitfield LLWU_ME_WUME1. */
#define BF_LLWU_ME_WUME1(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME1) & BM_LLWU_ME_WUME1)

/*! @brief Set the WUME1 field to a new value. */
#define BW_LLWU_ME_WUME1(x, v) (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME1) = (v))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME2[2] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME2     (2U)          /*!< Bit position for LLWU_ME_WUME2. */
#define BM_LLWU_ME_WUME2     (0x04U)       /*!< Bit mask for LLWU_ME_WUME2. */
#define BS_LLWU_ME_WUME2     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME2. */

/*! @brief Read current value of the LLWU_ME_WUME2 field. */
#define BR_LLWU_ME_WUME2(x)  (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME2))

/*! @brief Format value for bitfield LLWU_ME_WUME2. */
#define BF_LLWU_ME_WUME2(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME2) & BM_LLWU_ME_WUME2)

/*! @brief Set the WUME2 field to a new value. */
#define BW_LLWU_ME_WUME2(x, v) (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME2) = (v))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME3[3] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME3     (3U)          /*!< Bit position for LLWU_ME_WUME3. */
#define BM_LLWU_ME_WUME3     (0x08U)       /*!< Bit mask for LLWU_ME_WUME3. */
#define BS_LLWU_ME_WUME3     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME3. */

/*! @brief Read current value of the LLWU_ME_WUME3 field. */
#define BR_LLWU_ME_WUME3(x)  (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME3))

/*! @brief Format value for bitfield LLWU_ME_WUME3. */
#define BF_LLWU_ME_WUME3(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME3) & BM_LLWU_ME_WUME3)

/*! @brief Set the WUME3 field to a new value. */
#define BW_LLWU_ME_WUME3(x, v) (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME3) = (v))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME4[4] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME4     (4U)          /*!< Bit position for LLWU_ME_WUME4. */
#define BM_LLWU_ME_WUME4     (0x10U)       /*!< Bit mask for LLWU_ME_WUME4. */
#define BS_LLWU_ME_WUME4     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME4. */

/*! @brief Read current value of the LLWU_ME_WUME4 field. */
#define BR_LLWU_ME_WUME4(x)  (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME4))

/*! @brief Format value for bitfield LLWU_ME_WUME4. */
#define BF_LLWU_ME_WUME4(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME4) & BM_LLWU_ME_WUME4)

/*! @brief Set the WUME4 field to a new value. */
#define BW_LLWU_ME_WUME4(x, v) (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME4) = (v))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME5[5] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME5     (5U)          /*!< Bit position for LLWU_ME_WUME5. */
#define BM_LLWU_ME_WUME5     (0x20U)       /*!< Bit mask for LLWU_ME_WUME5. */
#define BS_LLWU_ME_WUME5     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME5. */

/*! @brief Read current value of the LLWU_ME_WUME5 field. */
#define BR_LLWU_ME_WUME5(x)  (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME5))

/*! @brief Format value for bitfield LLWU_ME_WUME5. */
#define BF_LLWU_ME_WUME5(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME5) & BM_LLWU_ME_WUME5)

/*! @brief Set the WUME5 field to a new value. */
#define BW_LLWU_ME_WUME5(x, v) (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME5) = (v))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME6[6] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME6     (6U)          /*!< Bit position for LLWU_ME_WUME6. */
#define BM_LLWU_ME_WUME6     (0x40U)       /*!< Bit mask for LLWU_ME_WUME6. */
#define BS_LLWU_ME_WUME6     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME6. */

/*! @brief Read current value of the LLWU_ME_WUME6 field. */
#define BR_LLWU_ME_WUME6(x)  (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME6))

/*! @brief Format value for bitfield LLWU_ME_WUME6. */
#define BF_LLWU_ME_WUME6(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME6) & BM_LLWU_ME_WUME6)

/*! @brief Set the WUME6 field to a new value. */
#define BW_LLWU_ME_WUME6(x, v) (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME6) = (v))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME7[7] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
#define BP_LLWU_ME_WUME7     (7U)          /*!< Bit position for LLWU_ME_WUME7. */
#define BM_LLWU_ME_WUME7     (0x80U)       /*!< Bit mask for LLWU_ME_WUME7. */
#define BS_LLWU_ME_WUME7     (1U)          /*!< Bit field size in bits for LLWU_ME_WUME7. */

/*! @brief Read current value of the LLWU_ME_WUME7 field. */
#define BR_LLWU_ME_WUME7(x)  (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME7))

/*! @brief Format value for bitfield LLWU_ME_WUME7. */
#define BF_LLWU_ME_WUME7(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_ME_WUME7) & BM_LLWU_ME_WUME7)

/*! @brief Set the WUME7 field to a new value. */
#define BW_LLWU_ME_WUME7(x, v) (BITBAND_ACCESS8(HW_LLWU_ME_ADDR(x), BP_LLWU_ME_WUME7) = (v))
/*@}*/

/*******************************************************************************
 * HW_LLWU_F1 - LLWU Flag 1 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_F1 - LLWU Flag 1 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_F1 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this is the source causing the CPU
 * interrupt flow. For VLLS, this is the source causing the MCU reset flow. The
 * external wakeup flags are read-only and clearing a flag is accomplished by a write
 * of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if set, will
 * remain set if the associated WUPEx bit is cleared. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_f1
{
    uint8_t U;
    struct _hw_llwu_f1_bitfields
    {
        uint8_t WUF0 : 1;              /*!< [0] Wakeup Flag For LLWU_P0 */
        uint8_t WUF1 : 1;              /*!< [1] Wakeup Flag For LLWU_P1 */
        uint8_t WUF2 : 1;              /*!< [2] Wakeup Flag For LLWU_P2 */
        uint8_t WUF3 : 1;              /*!< [3] Wakeup Flag For LLWU_P3 */
        uint8_t WUF4 : 1;              /*!< [4] Wakeup Flag For LLWU_P4 */
        uint8_t WUF5 : 1;              /*!< [5] Wakeup Flag For LLWU_P5 */
        uint8_t WUF6 : 1;              /*!< [6] Wakeup Flag For LLWU_P6 */
        uint8_t WUF7 : 1;              /*!< [7] Wakeup Flag For LLWU_P7 */
    } B;
} hw_llwu_f1_t;

/*!
 * @name Constants and macros for entire LLWU_F1 register
 */
/*@{*/
#define HW_LLWU_F1_ADDR(x)       ((uint32_t)(x) + 0x5U)

#define HW_LLWU_F1(x)            (*(__IO hw_llwu_f1_t *) HW_LLWU_F1_ADDR(x))
#define HW_LLWU_F1_RD(x)         (HW_LLWU_F1(x).U)
#define HW_LLWU_F1_WR(x, v)      (HW_LLWU_F1(x).U = (v))
#define HW_LLWU_F1_SET(x, v)     (HW_LLWU_F1_WR(x, HW_LLWU_F1_RD(x) |  (v)))
#define HW_LLWU_F1_CLR(x, v)     (HW_LLWU_F1_WR(x, HW_LLWU_F1_RD(x) & ~(v)))
#define HW_LLWU_F1_TOG(x, v)     (HW_LLWU_F1_WR(x, HW_LLWU_F1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_F1 bitfields
 */

/*!
 * @name Register LLWU_F1, field WUF0[0] (W1C)
 *
 * Indicates that an enabled external wake-up pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF0.
 *
 * Values:
 * - 0 - LLWU_P0 input was not a wakeup source
 * - 1 - LLWU_P0 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF0      (0U)          /*!< Bit position for LLWU_F1_WUF0. */
#define BM_LLWU_F1_WUF0      (0x01U)       /*!< Bit mask for LLWU_F1_WUF0. */
#define BS_LLWU_F1_WUF0      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF0. */

/*! @brief Read current value of the LLWU_F1_WUF0 field. */
#define BR_LLWU_F1_WUF0(x)   (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF0))

/*! @brief Format value for bitfield LLWU_F1_WUF0. */
#define BF_LLWU_F1_WUF0(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF0) & BM_LLWU_F1_WUF0)

/*! @brief Set the WUF0 field to a new value. */
#define BW_LLWU_F1_WUF0(x, v) (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF0) = (v))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF1[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF1.
 *
 * Values:
 * - 0 - LLWU_P1 input was not a wakeup source
 * - 1 - LLWU_P1 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF1      (1U)          /*!< Bit position for LLWU_F1_WUF1. */
#define BM_LLWU_F1_WUF1      (0x02U)       /*!< Bit mask for LLWU_F1_WUF1. */
#define BS_LLWU_F1_WUF1      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF1. */

/*! @brief Read current value of the LLWU_F1_WUF1 field. */
#define BR_LLWU_F1_WUF1(x)   (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF1))

/*! @brief Format value for bitfield LLWU_F1_WUF1. */
#define BF_LLWU_F1_WUF1(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF1) & BM_LLWU_F1_WUF1)

/*! @brief Set the WUF1 field to a new value. */
#define BW_LLWU_F1_WUF1(x, v) (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF1) = (v))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF2[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF2.
 *
 * Values:
 * - 0 - LLWU_P2 input was not a wakeup source
 * - 1 - LLWU_P2 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF2      (2U)          /*!< Bit position for LLWU_F1_WUF2. */
#define BM_LLWU_F1_WUF2      (0x04U)       /*!< Bit mask for LLWU_F1_WUF2. */
#define BS_LLWU_F1_WUF2      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF2. */

/*! @brief Read current value of the LLWU_F1_WUF2 field. */
#define BR_LLWU_F1_WUF2(x)   (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF2))

/*! @brief Format value for bitfield LLWU_F1_WUF2. */
#define BF_LLWU_F1_WUF2(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF2) & BM_LLWU_F1_WUF2)

/*! @brief Set the WUF2 field to a new value. */
#define BW_LLWU_F1_WUF2(x, v) (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF2) = (v))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF3[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF3.
 *
 * Values:
 * - 0 - LLWU_P3 input was not a wake-up source
 * - 1 - LLWU_P3 input was a wake-up source
 */
/*@{*/
#define BP_LLWU_F1_WUF3      (3U)          /*!< Bit position for LLWU_F1_WUF3. */
#define BM_LLWU_F1_WUF3      (0x08U)       /*!< Bit mask for LLWU_F1_WUF3. */
#define BS_LLWU_F1_WUF3      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF3. */

/*! @brief Read current value of the LLWU_F1_WUF3 field. */
#define BR_LLWU_F1_WUF3(x)   (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF3))

/*! @brief Format value for bitfield LLWU_F1_WUF3. */
#define BF_LLWU_F1_WUF3(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF3) & BM_LLWU_F1_WUF3)

/*! @brief Set the WUF3 field to a new value. */
#define BW_LLWU_F1_WUF3(x, v) (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF3) = (v))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF4[4] (W1C)
 *
 * Indicates that an enabled external wake-up pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF4.
 *
 * Values:
 * - 0 - LLWU_P4 input was not a wakeup source
 * - 1 - LLWU_P4 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF4      (4U)          /*!< Bit position for LLWU_F1_WUF4. */
#define BM_LLWU_F1_WUF4      (0x10U)       /*!< Bit mask for LLWU_F1_WUF4. */
#define BS_LLWU_F1_WUF4      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF4. */

/*! @brief Read current value of the LLWU_F1_WUF4 field. */
#define BR_LLWU_F1_WUF4(x)   (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF4))

/*! @brief Format value for bitfield LLWU_F1_WUF4. */
#define BF_LLWU_F1_WUF4(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF4) & BM_LLWU_F1_WUF4)

/*! @brief Set the WUF4 field to a new value. */
#define BW_LLWU_F1_WUF4(x, v) (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF4) = (v))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF5[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF5.
 *
 * Values:
 * - 0 - LLWU_P5 input was not a wakeup source
 * - 1 - LLWU_P5 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF5      (5U)          /*!< Bit position for LLWU_F1_WUF5. */
#define BM_LLWU_F1_WUF5      (0x20U)       /*!< Bit mask for LLWU_F1_WUF5. */
#define BS_LLWU_F1_WUF5      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF5. */

/*! @brief Read current value of the LLWU_F1_WUF5 field. */
#define BR_LLWU_F1_WUF5(x)   (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF5))

/*! @brief Format value for bitfield LLWU_F1_WUF5. */
#define BF_LLWU_F1_WUF5(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF5) & BM_LLWU_F1_WUF5)

/*! @brief Set the WUF5 field to a new value. */
#define BW_LLWU_F1_WUF5(x, v) (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF5) = (v))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF6[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF6.
 *
 * Values:
 * - 0 - LLWU_P6 input was not a wakeup source
 * - 1 - LLWU_P6 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF6      (6U)          /*!< Bit position for LLWU_F1_WUF6. */
#define BM_LLWU_F1_WUF6      (0x40U)       /*!< Bit mask for LLWU_F1_WUF6. */
#define BS_LLWU_F1_WUF6      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF6. */

/*! @brief Read current value of the LLWU_F1_WUF6 field. */
#define BR_LLWU_F1_WUF6(x)   (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF6))

/*! @brief Format value for bitfield LLWU_F1_WUF6. */
#define BF_LLWU_F1_WUF6(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF6) & BM_LLWU_F1_WUF6)

/*! @brief Set the WUF6 field to a new value. */
#define BW_LLWU_F1_WUF6(x, v) (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF6) = (v))
/*@}*/

/*!
 * @name Register LLWU_F1, field WUF7[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF7.
 *
 * Values:
 * - 0 - LLWU_P7 input was not a wakeup source
 * - 1 - LLWU_P7 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F1_WUF7      (7U)          /*!< Bit position for LLWU_F1_WUF7. */
#define BM_LLWU_F1_WUF7      (0x80U)       /*!< Bit mask for LLWU_F1_WUF7. */
#define BS_LLWU_F1_WUF7      (1U)          /*!< Bit field size in bits for LLWU_F1_WUF7. */

/*! @brief Read current value of the LLWU_F1_WUF7 field. */
#define BR_LLWU_F1_WUF7(x)   (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF7))

/*! @brief Format value for bitfield LLWU_F1_WUF7. */
#define BF_LLWU_F1_WUF7(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F1_WUF7) & BM_LLWU_F1_WUF7)

/*! @brief Set the WUF7 field to a new value. */
#define BW_LLWU_F1_WUF7(x, v) (BITBAND_ACCESS8(HW_LLWU_F1_ADDR(x), BP_LLWU_F1_WUF7) = (v))
/*@}*/

/*******************************************************************************
 * HW_LLWU_F2 - LLWU Flag 2 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_F2 - LLWU Flag 2 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_F2 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this is the source causing the CPU
 * interrupt flow. For VLLS, this is the source causing the MCU reset flow. The
 * external wakeup flags are read-only and clearing a flag is accomplished by a write
 * of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if set, will
 * remain set if the associated WUPEx bit is cleared. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_f2
{
    uint8_t U;
    struct _hw_llwu_f2_bitfields
    {
        uint8_t WUF8 : 1;              /*!< [0] Wakeup Flag For LLWU_P8 */
        uint8_t WUF9 : 1;              /*!< [1] Wakeup Flag For LLWU_P9 */
        uint8_t WUF10 : 1;             /*!< [2] Wakeup Flag For LLWU_P10 */
        uint8_t WUF11 : 1;             /*!< [3] Wakeup Flag For LLWU_P11 */
        uint8_t WUF12 : 1;             /*!< [4] Wakeup Flag For LLWU_P12 */
        uint8_t WUF13 : 1;             /*!< [5] Wakeup Flag For LLWU_P13 */
        uint8_t WUF14 : 1;             /*!< [6] Wakeup Flag For LLWU_P14 */
        uint8_t WUF15 : 1;             /*!< [7] Wakeup Flag For LLWU_P15 */
    } B;
} hw_llwu_f2_t;

/*!
 * @name Constants and macros for entire LLWU_F2 register
 */
/*@{*/
#define HW_LLWU_F2_ADDR(x)       ((uint32_t)(x) + 0x6U)

#define HW_LLWU_F2(x)            (*(__IO hw_llwu_f2_t *) HW_LLWU_F2_ADDR(x))
#define HW_LLWU_F2_RD(x)         (HW_LLWU_F2(x).U)
#define HW_LLWU_F2_WR(x, v)      (HW_LLWU_F2(x).U = (v))
#define HW_LLWU_F2_SET(x, v)     (HW_LLWU_F2_WR(x, HW_LLWU_F2_RD(x) |  (v)))
#define HW_LLWU_F2_CLR(x, v)     (HW_LLWU_F2_WR(x, HW_LLWU_F2_RD(x) & ~(v)))
#define HW_LLWU_F2_TOG(x, v)     (HW_LLWU_F2_WR(x, HW_LLWU_F2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_F2 bitfields
 */

/*!
 * @name Register LLWU_F2, field WUF8[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF8.
 *
 * Values:
 * - 0 - LLWU_P8 input was not a wakeup source
 * - 1 - LLWU_P8 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF8      (0U)          /*!< Bit position for LLWU_F2_WUF8. */
#define BM_LLWU_F2_WUF8      (0x01U)       /*!< Bit mask for LLWU_F2_WUF8. */
#define BS_LLWU_F2_WUF8      (1U)          /*!< Bit field size in bits for LLWU_F2_WUF8. */

/*! @brief Read current value of the LLWU_F2_WUF8 field. */
#define BR_LLWU_F2_WUF8(x)   (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF8))

/*! @brief Format value for bitfield LLWU_F2_WUF8. */
#define BF_LLWU_F2_WUF8(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF8) & BM_LLWU_F2_WUF8)

/*! @brief Set the WUF8 field to a new value. */
#define BW_LLWU_F2_WUF8(x, v) (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF8) = (v))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF9[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF9.
 *
 * Values:
 * - 0 - LLWU_P9 input was not a wakeup source
 * - 1 - LLWU_P9 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF9      (1U)          /*!< Bit position for LLWU_F2_WUF9. */
#define BM_LLWU_F2_WUF9      (0x02U)       /*!< Bit mask for LLWU_F2_WUF9. */
#define BS_LLWU_F2_WUF9      (1U)          /*!< Bit field size in bits for LLWU_F2_WUF9. */

/*! @brief Read current value of the LLWU_F2_WUF9 field. */
#define BR_LLWU_F2_WUF9(x)   (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF9))

/*! @brief Format value for bitfield LLWU_F2_WUF9. */
#define BF_LLWU_F2_WUF9(v)   ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF9) & BM_LLWU_F2_WUF9)

/*! @brief Set the WUF9 field to a new value. */
#define BW_LLWU_F2_WUF9(x, v) (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF9) = (v))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF10[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF10.
 *
 * Values:
 * - 0 - LLWU_P10 input was not a wakeup source
 * - 1 - LLWU_P10 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF10     (2U)          /*!< Bit position for LLWU_F2_WUF10. */
#define BM_LLWU_F2_WUF10     (0x04U)       /*!< Bit mask for LLWU_F2_WUF10. */
#define BS_LLWU_F2_WUF10     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF10. */

/*! @brief Read current value of the LLWU_F2_WUF10 field. */
#define BR_LLWU_F2_WUF10(x)  (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF10))

/*! @brief Format value for bitfield LLWU_F2_WUF10. */
#define BF_LLWU_F2_WUF10(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF10) & BM_LLWU_F2_WUF10)

/*! @brief Set the WUF10 field to a new value. */
#define BW_LLWU_F2_WUF10(x, v) (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF10) = (v))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF11[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF11.
 *
 * Values:
 * - 0 - LLWU_P11 input was not a wakeup source
 * - 1 - LLWU_P11 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF11     (3U)          /*!< Bit position for LLWU_F2_WUF11. */
#define BM_LLWU_F2_WUF11     (0x08U)       /*!< Bit mask for LLWU_F2_WUF11. */
#define BS_LLWU_F2_WUF11     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF11. */

/*! @brief Read current value of the LLWU_F2_WUF11 field. */
#define BR_LLWU_F2_WUF11(x)  (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF11))

/*! @brief Format value for bitfield LLWU_F2_WUF11. */
#define BF_LLWU_F2_WUF11(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF11) & BM_LLWU_F2_WUF11)

/*! @brief Set the WUF11 field to a new value. */
#define BW_LLWU_F2_WUF11(x, v) (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF11) = (v))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF12[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF12.
 *
 * Values:
 * - 0 - LLWU_P12 input was not a wakeup source
 * - 1 - LLWU_P12 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF12     (4U)          /*!< Bit position for LLWU_F2_WUF12. */
#define BM_LLWU_F2_WUF12     (0x10U)       /*!< Bit mask for LLWU_F2_WUF12. */
#define BS_LLWU_F2_WUF12     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF12. */

/*! @brief Read current value of the LLWU_F2_WUF12 field. */
#define BR_LLWU_F2_WUF12(x)  (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF12))

/*! @brief Format value for bitfield LLWU_F2_WUF12. */
#define BF_LLWU_F2_WUF12(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF12) & BM_LLWU_F2_WUF12)

/*! @brief Set the WUF12 field to a new value. */
#define BW_LLWU_F2_WUF12(x, v) (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF12) = (v))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF13[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF13.
 *
 * Values:
 * - 0 - LLWU_P13 input was not a wakeup source
 * - 1 - LLWU_P13 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF13     (5U)          /*!< Bit position for LLWU_F2_WUF13. */
#define BM_LLWU_F2_WUF13     (0x20U)       /*!< Bit mask for LLWU_F2_WUF13. */
#define BS_LLWU_F2_WUF13     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF13. */

/*! @brief Read current value of the LLWU_F2_WUF13 field. */
#define BR_LLWU_F2_WUF13(x)  (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF13))

/*! @brief Format value for bitfield LLWU_F2_WUF13. */
#define BF_LLWU_F2_WUF13(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF13) & BM_LLWU_F2_WUF13)

/*! @brief Set the WUF13 field to a new value. */
#define BW_LLWU_F2_WUF13(x, v) (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF13) = (v))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF14[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF14.
 *
 * Values:
 * - 0 - LLWU_P14 input was not a wakeup source
 * - 1 - LLWU_P14 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF14     (6U)          /*!< Bit position for LLWU_F2_WUF14. */
#define BM_LLWU_F2_WUF14     (0x40U)       /*!< Bit mask for LLWU_F2_WUF14. */
#define BS_LLWU_F2_WUF14     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF14. */

/*! @brief Read current value of the LLWU_F2_WUF14 field. */
#define BR_LLWU_F2_WUF14(x)  (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF14))

/*! @brief Format value for bitfield LLWU_F2_WUF14. */
#define BF_LLWU_F2_WUF14(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF14) & BM_LLWU_F2_WUF14)

/*! @brief Set the WUF14 field to a new value. */
#define BW_LLWU_F2_WUF14(x, v) (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF14) = (v))
/*@}*/

/*!
 * @name Register LLWU_F2, field WUF15[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag, write a 1 to WUF15.
 *
 * Values:
 * - 0 - LLWU_P15 input was not a wakeup source
 * - 1 - LLWU_P15 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F2_WUF15     (7U)          /*!< Bit position for LLWU_F2_WUF15. */
#define BM_LLWU_F2_WUF15     (0x80U)       /*!< Bit mask for LLWU_F2_WUF15. */
#define BS_LLWU_F2_WUF15     (1U)          /*!< Bit field size in bits for LLWU_F2_WUF15. */

/*! @brief Read current value of the LLWU_F2_WUF15 field. */
#define BR_LLWU_F2_WUF15(x)  (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF15))

/*! @brief Format value for bitfield LLWU_F2_WUF15. */
#define BF_LLWU_F2_WUF15(v)  ((uint8_t)((uint8_t)(v) << BP_LLWU_F2_WUF15) & BM_LLWU_F2_WUF15)

/*! @brief Set the WUF15 field to a new value. */
#define BW_LLWU_F2_WUF15(x, v) (BITBAND_ACCESS8(HW_LLWU_F2_ADDR(x), BP_LLWU_F2_WUF15) = (v))
/*@}*/

/*******************************************************************************
 * HW_LLWU_F3 - LLWU Flag 3 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_F3 - LLWU Flag 3 register (RO)
 *
 * Reset value: 0x00U
 *
 * LLWU_F3 contains the wakeup flags indicating which internal wakeup source
 * caused the MCU to exit LLS or VLLS mode. For LLS, this is the source causing the
 * CPU interrupt flow. For VLLS, this is the source causing the MCU reset flow.
 * For internal peripherals that are capable of running in a low-leakage power
 * mode, such as a real time clock module or CMP module, the flag from the
 * associated peripheral is accessible as the MWUFx bit. The flag will need to be cleared
 * in the peripheral instead of writing a 1 to the MWUFx bit. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS. See
 * the IntroductionInformation found here describes the registers of the Reset
 * Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
typedef union _hw_llwu_f3
{
    uint8_t U;
    struct _hw_llwu_f3_bitfields
    {
        uint8_t MWUF0 : 1;             /*!< [0] Wakeup flag For module 0 */
        uint8_t MWUF1 : 1;             /*!< [1] Wakeup flag For module 1 */
        uint8_t MWUF2 : 1;             /*!< [2] Wakeup flag For module 2 */
        uint8_t MWUF3 : 1;             /*!< [3] Wakeup flag For module 3 */
        uint8_t MWUF4 : 1;             /*!< [4] Wakeup flag For module 4 */
        uint8_t MWUF5 : 1;             /*!< [5] Wakeup flag For module 5 */
        uint8_t MWUF6 : 1;             /*!< [6] Wakeup flag For module 6 */
        uint8_t MWUF7 : 1;             /*!< [7] Wakeup flag For module 7 */
    } B;
} hw_llwu_f3_t;

/*!
 * @name Constants and macros for entire LLWU_F3 register
 */
/*@{*/
#define HW_LLWU_F3_ADDR(x)       ((uint32_t)(x) + 0x7U)

#define HW_LLWU_F3(x)            (*(__I hw_llwu_f3_t *) HW_LLWU_F3_ADDR(x))
#define HW_LLWU_F3_RD(x)         (HW_LLWU_F3(x).U)
/*@}*/

/*
 * Constants & macros for individual LLWU_F3 bitfields
 */

/*!
 * @name Register LLWU_F3, field MWUF0[0] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 0 input was not a wakeup source
 * - 1 - Module 0 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF0     (0U)          /*!< Bit position for LLWU_F3_MWUF0. */
#define BM_LLWU_F3_MWUF0     (0x01U)       /*!< Bit mask for LLWU_F3_MWUF0. */
#define BS_LLWU_F3_MWUF0     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF0. */

/*! @brief Read current value of the LLWU_F3_MWUF0 field. */
#define BR_LLWU_F3_MWUF0(x)  (BITBAND_ACCESS8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF0))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF1[1] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 1 input was not a wakeup source
 * - 1 - Module 1 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF1     (1U)          /*!< Bit position for LLWU_F3_MWUF1. */
#define BM_LLWU_F3_MWUF1     (0x02U)       /*!< Bit mask for LLWU_F3_MWUF1. */
#define BS_LLWU_F3_MWUF1     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF1. */

/*! @brief Read current value of the LLWU_F3_MWUF1 field. */
#define BR_LLWU_F3_MWUF1(x)  (BITBAND_ACCESS8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF1))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF2[2] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 2 input was not a wakeup source
 * - 1 - Module 2 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF2     (2U)          /*!< Bit position for LLWU_F3_MWUF2. */
#define BM_LLWU_F3_MWUF2     (0x04U)       /*!< Bit mask for LLWU_F3_MWUF2. */
#define BS_LLWU_F3_MWUF2     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF2. */

/*! @brief Read current value of the LLWU_F3_MWUF2 field. */
#define BR_LLWU_F3_MWUF2(x)  (BITBAND_ACCESS8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF2))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF3[3] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 3 input was not a wakeup source
 * - 1 - Module 3 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF3     (3U)          /*!< Bit position for LLWU_F3_MWUF3. */
#define BM_LLWU_F3_MWUF3     (0x08U)       /*!< Bit mask for LLWU_F3_MWUF3. */
#define BS_LLWU_F3_MWUF3     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF3. */

/*! @brief Read current value of the LLWU_F3_MWUF3 field. */
#define BR_LLWU_F3_MWUF3(x)  (BITBAND_ACCESS8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF3))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF4[4] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 4 input was not a wakeup source
 * - 1 - Module 4 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF4     (4U)          /*!< Bit position for LLWU_F3_MWUF4. */
#define BM_LLWU_F3_MWUF4     (0x10U)       /*!< Bit mask for LLWU_F3_MWUF4. */
#define BS_LLWU_F3_MWUF4     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF4. */

/*! @brief Read current value of the LLWU_F3_MWUF4 field. */
#define BR_LLWU_F3_MWUF4(x)  (BITBAND_ACCESS8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF4))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF5[5] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 5 input was not a wakeup source
 * - 1 - Module 5 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF5     (5U)          /*!< Bit position for LLWU_F3_MWUF5. */
#define BM_LLWU_F3_MWUF5     (0x20U)       /*!< Bit mask for LLWU_F3_MWUF5. */
#define BS_LLWU_F3_MWUF5     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF5. */

/*! @brief Read current value of the LLWU_F3_MWUF5 field. */
#define BR_LLWU_F3_MWUF5(x)  (BITBAND_ACCESS8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF5))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF6[6] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 6 input was not a wakeup source
 * - 1 - Module 6 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF6     (6U)          /*!< Bit position for LLWU_F3_MWUF6. */
#define BM_LLWU_F3_MWUF6     (0x40U)       /*!< Bit mask for LLWU_F3_MWUF6. */
#define BS_LLWU_F3_MWUF6     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF6. */

/*! @brief Read current value of the LLWU_F3_MWUF6 field. */
#define BR_LLWU_F3_MWUF6(x)  (BITBAND_ACCESS8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF6))
/*@}*/

/*!
 * @name Register LLWU_F3, field MWUF7[7] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 7 input was not a wakeup source
 * - 1 - Module 7 input was a wakeup source
 */
/*@{*/
#define BP_LLWU_F3_MWUF7     (7U)          /*!< Bit position for LLWU_F3_MWUF7. */
#define BM_LLWU_F3_MWUF7     (0x80U)       /*!< Bit mask for LLWU_F3_MWUF7. */
#define BS_LLWU_F3_MWUF7     (1U)          /*!< Bit field size in bits for LLWU_F3_MWUF7. */

/*! @brief Read current value of the LLWU_F3_MWUF7 field. */
#define BR_LLWU_F3_MWUF7(x)  (BITBAND_ACCESS8(HW_LLWU_F3_ADDR(x), BP_LLWU_F3_MWUF7))
/*@}*/

/*******************************************************************************
 * HW_LLWU_FILT1 - LLWU Pin Filter 1 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_FILT1 - LLWU Pin Filter 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT1 is a control and status register that is used to enable/disable
 * the digital filter 1 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_filt1
{
    uint8_t U;
    struct _hw_llwu_filt1_bitfields
    {
        uint8_t FILTSEL : 4;           /*!< [3:0] Filter Pin Select */
        uint8_t RESERVED0 : 1;         /*!< [4]  */
        uint8_t FILTE : 2;             /*!< [6:5] Digital Filter On External Pin */
        uint8_t FILTF : 1;             /*!< [7] Filter Detect Flag */
    } B;
} hw_llwu_filt1_t;

/*!
 * @name Constants and macros for entire LLWU_FILT1 register
 */
/*@{*/
#define HW_LLWU_FILT1_ADDR(x)    ((uint32_t)(x) + 0x8U)

#define HW_LLWU_FILT1(x)         (*(__IO hw_llwu_filt1_t *) HW_LLWU_FILT1_ADDR(x))
#define HW_LLWU_FILT1_RD(x)      (HW_LLWU_FILT1(x).U)
#define HW_LLWU_FILT1_WR(x, v)   (HW_LLWU_FILT1(x).U = (v))
#define HW_LLWU_FILT1_SET(x, v)  (HW_LLWU_FILT1_WR(x, HW_LLWU_FILT1_RD(x) |  (v)))
#define HW_LLWU_FILT1_CLR(x, v)  (HW_LLWU_FILT1_WR(x, HW_LLWU_FILT1_RD(x) & ~(v)))
#define HW_LLWU_FILT1_TOG(x, v)  (HW_LLWU_FILT1_WR(x, HW_LLWU_FILT1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT1 bitfields
 */

/*!
 * @name Register LLWU_FILT1, field FILTSEL[3:0] (RW)
 *
 * Selects 1 out of the 16 wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0000 - Select LLWU_P0 for filter
 * - 1111 - Select LLWU_P15 for filter
 */
/*@{*/
#define BP_LLWU_FILT1_FILTSEL (0U)         /*!< Bit position for LLWU_FILT1_FILTSEL. */
#define BM_LLWU_FILT1_FILTSEL (0x0FU)      /*!< Bit mask for LLWU_FILT1_FILTSEL. */
#define BS_LLWU_FILT1_FILTSEL (4U)         /*!< Bit field size in bits for LLWU_FILT1_FILTSEL. */

/*! @brief Read current value of the LLWU_FILT1_FILTSEL field. */
#define BR_LLWU_FILT1_FILTSEL(x) (HW_LLWU_FILT1(x).B.FILTSEL)

/*! @brief Format value for bitfield LLWU_FILT1_FILTSEL. */
#define BF_LLWU_FILT1_FILTSEL(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT1_FILTSEL) & BM_LLWU_FILT1_FILTSEL)

/*! @brief Set the FILTSEL field to a new value. */
#define BW_LLWU_FILT1_FILTSEL(x, v) (HW_LLWU_FILT1_WR(x, (HW_LLWU_FILT1_RD(x) & ~BM_LLWU_FILT1_FILTSEL) | BF_LLWU_FILT1_FILTSEL(v)))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 00 - Filter disabled
 * - 01 - Filter posedge detect enabled
 * - 10 - Filter negedge detect enabled
 * - 11 - Filter any edge detect enabled
 */
/*@{*/
#define BP_LLWU_FILT1_FILTE  (5U)          /*!< Bit position for LLWU_FILT1_FILTE. */
#define BM_LLWU_FILT1_FILTE  (0x60U)       /*!< Bit mask for LLWU_FILT1_FILTE. */
#define BS_LLWU_FILT1_FILTE  (2U)          /*!< Bit field size in bits for LLWU_FILT1_FILTE. */

/*! @brief Read current value of the LLWU_FILT1_FILTE field. */
#define BR_LLWU_FILT1_FILTE(x) (HW_LLWU_FILT1(x).B.FILTE)

/*! @brief Format value for bitfield LLWU_FILT1_FILTE. */
#define BF_LLWU_FILT1_FILTE(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT1_FILTE) & BM_LLWU_FILT1_FILTE)

/*! @brief Set the FILTE field to a new value. */
#define BW_LLWU_FILT1_FILTE(x, v) (HW_LLWU_FILT1_WR(x, (HW_LLWU_FILT1_RD(x) & ~BM_LLWU_FILT1_FILTE) | BF_LLWU_FILT1_FILTE(v)))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0 - Pin Filter 1 was not a wakeup source
 * - 1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
#define BP_LLWU_FILT1_FILTF  (7U)          /*!< Bit position for LLWU_FILT1_FILTF. */
#define BM_LLWU_FILT1_FILTF  (0x80U)       /*!< Bit mask for LLWU_FILT1_FILTF. */
#define BS_LLWU_FILT1_FILTF  (1U)          /*!< Bit field size in bits for LLWU_FILT1_FILTF. */

/*! @brief Read current value of the LLWU_FILT1_FILTF field. */
#define BR_LLWU_FILT1_FILTF(x) (BITBAND_ACCESS8(HW_LLWU_FILT1_ADDR(x), BP_LLWU_FILT1_FILTF))

/*! @brief Format value for bitfield LLWU_FILT1_FILTF. */
#define BF_LLWU_FILT1_FILTF(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT1_FILTF) & BM_LLWU_FILT1_FILTF)

/*! @brief Set the FILTF field to a new value. */
#define BW_LLWU_FILT1_FILTF(x, v) (BITBAND_ACCESS8(HW_LLWU_FILT1_ADDR(x), BP_LLWU_FILT1_FILTF) = (v))
/*@}*/

/*******************************************************************************
 * HW_LLWU_FILT2 - LLWU Pin Filter 2 register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_FILT2 - LLWU Pin Filter 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT2 is a control and status register that is used to enable/disable
 * the digital filter 2 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_filt2
{
    uint8_t U;
    struct _hw_llwu_filt2_bitfields
    {
        uint8_t FILTSEL : 4;           /*!< [3:0] Filter Pin Select */
        uint8_t RESERVED0 : 1;         /*!< [4]  */
        uint8_t FILTE : 2;             /*!< [6:5] Digital Filter On External Pin */
        uint8_t FILTF : 1;             /*!< [7] Filter Detect Flag */
    } B;
} hw_llwu_filt2_t;

/*!
 * @name Constants and macros for entire LLWU_FILT2 register
 */
/*@{*/
#define HW_LLWU_FILT2_ADDR(x)    ((uint32_t)(x) + 0x9U)

#define HW_LLWU_FILT2(x)         (*(__IO hw_llwu_filt2_t *) HW_LLWU_FILT2_ADDR(x))
#define HW_LLWU_FILT2_RD(x)      (HW_LLWU_FILT2(x).U)
#define HW_LLWU_FILT2_WR(x, v)   (HW_LLWU_FILT2(x).U = (v))
#define HW_LLWU_FILT2_SET(x, v)  (HW_LLWU_FILT2_WR(x, HW_LLWU_FILT2_RD(x) |  (v)))
#define HW_LLWU_FILT2_CLR(x, v)  (HW_LLWU_FILT2_WR(x, HW_LLWU_FILT2_RD(x) & ~(v)))
#define HW_LLWU_FILT2_TOG(x, v)  (HW_LLWU_FILT2_WR(x, HW_LLWU_FILT2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT2 bitfields
 */

/*!
 * @name Register LLWU_FILT2, field FILTSEL[3:0] (RW)
 *
 * Selects 1 out of the 16 wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0000 - Select LLWU_P0 for filter
 * - 1111 - Select LLWU_P15 for filter
 */
/*@{*/
#define BP_LLWU_FILT2_FILTSEL (0U)         /*!< Bit position for LLWU_FILT2_FILTSEL. */
#define BM_LLWU_FILT2_FILTSEL (0x0FU)      /*!< Bit mask for LLWU_FILT2_FILTSEL. */
#define BS_LLWU_FILT2_FILTSEL (4U)         /*!< Bit field size in bits for LLWU_FILT2_FILTSEL. */

/*! @brief Read current value of the LLWU_FILT2_FILTSEL field. */
#define BR_LLWU_FILT2_FILTSEL(x) (HW_LLWU_FILT2(x).B.FILTSEL)

/*! @brief Format value for bitfield LLWU_FILT2_FILTSEL. */
#define BF_LLWU_FILT2_FILTSEL(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT2_FILTSEL) & BM_LLWU_FILT2_FILTSEL)

/*! @brief Set the FILTSEL field to a new value. */
#define BW_LLWU_FILT2_FILTSEL(x, v) (HW_LLWU_FILT2_WR(x, (HW_LLWU_FILT2_RD(x) & ~BM_LLWU_FILT2_FILTSEL) | BF_LLWU_FILT2_FILTSEL(v)))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 00 - Filter disabled
 * - 01 - Filter posedge detect enabled
 * - 10 - Filter negedge detect enabled
 * - 11 - Filter any edge detect enabled
 */
/*@{*/
#define BP_LLWU_FILT2_FILTE  (5U)          /*!< Bit position for LLWU_FILT2_FILTE. */
#define BM_LLWU_FILT2_FILTE  (0x60U)       /*!< Bit mask for LLWU_FILT2_FILTE. */
#define BS_LLWU_FILT2_FILTE  (2U)          /*!< Bit field size in bits for LLWU_FILT2_FILTE. */

/*! @brief Read current value of the LLWU_FILT2_FILTE field. */
#define BR_LLWU_FILT2_FILTE(x) (HW_LLWU_FILT2(x).B.FILTE)

/*! @brief Format value for bitfield LLWU_FILT2_FILTE. */
#define BF_LLWU_FILT2_FILTE(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT2_FILTE) & BM_LLWU_FILT2_FILTE)

/*! @brief Set the FILTE field to a new value. */
#define BW_LLWU_FILT2_FILTE(x, v) (HW_LLWU_FILT2_WR(x, (HW_LLWU_FILT2_RD(x) & ~BM_LLWU_FILT2_FILTE) | BF_LLWU_FILT2_FILTE(v)))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0 - Pin Filter 2 was not a wakeup source
 * - 1 - Pin Filter 2 was a wakeup source
 */
/*@{*/
#define BP_LLWU_FILT2_FILTF  (7U)          /*!< Bit position for LLWU_FILT2_FILTF. */
#define BM_LLWU_FILT2_FILTF  (0x80U)       /*!< Bit mask for LLWU_FILT2_FILTF. */
#define BS_LLWU_FILT2_FILTF  (1U)          /*!< Bit field size in bits for LLWU_FILT2_FILTF. */

/*! @brief Read current value of the LLWU_FILT2_FILTF field. */
#define BR_LLWU_FILT2_FILTF(x) (BITBAND_ACCESS8(HW_LLWU_FILT2_ADDR(x), BP_LLWU_FILT2_FILTF))

/*! @brief Format value for bitfield LLWU_FILT2_FILTF. */
#define BF_LLWU_FILT2_FILTF(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_FILT2_FILTF) & BM_LLWU_FILT2_FILTF)

/*! @brief Set the FILTF field to a new value. */
#define BW_LLWU_FILT2_FILTF(x, v) (BITBAND_ACCESS8(HW_LLWU_FILT2_ADDR(x), BP_LLWU_FILT2_FILTF) = (v))
/*@}*/

/*******************************************************************************
 * HW_LLWU_RST - LLWU Reset Enable register
 ******************************************************************************/

/*!
 * @brief HW_LLWU_RST - LLWU Reset Enable register (RW)
 *
 * Reset value: 0x02U
 *
 * LLWU_RST is a control register that is used to enable/disable the digital
 * filter for the external pin detect and RESET pin. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
typedef union _hw_llwu_rst
{
    uint8_t U;
    struct _hw_llwu_rst_bitfields
    {
        uint8_t RSTFILT : 1;           /*!< [0] Digital Filter On RESET Pin */
        uint8_t LLRSTE : 1;            /*!< [1] Low-Leakage Mode RESET Enable */
        uint8_t RESERVED0 : 6;         /*!< [7:2]  */
    } B;
} hw_llwu_rst_t;

/*!
 * @name Constants and macros for entire LLWU_RST register
 */
/*@{*/
#define HW_LLWU_RST_ADDR(x)      ((uint32_t)(x) + 0xAU)

#define HW_LLWU_RST(x)           (*(__IO hw_llwu_rst_t *) HW_LLWU_RST_ADDR(x))
#define HW_LLWU_RST_RD(x)        (HW_LLWU_RST(x).U)
#define HW_LLWU_RST_WR(x, v)     (HW_LLWU_RST(x).U = (v))
#define HW_LLWU_RST_SET(x, v)    (HW_LLWU_RST_WR(x, HW_LLWU_RST_RD(x) |  (v)))
#define HW_LLWU_RST_CLR(x, v)    (HW_LLWU_RST_WR(x, HW_LLWU_RST_RD(x) & ~(v)))
#define HW_LLWU_RST_TOG(x, v)    (HW_LLWU_RST_WR(x, HW_LLWU_RST_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LLWU_RST bitfields
 */

/*!
 * @name Register LLWU_RST, field RSTFILT[0] (RW)
 *
 * Enables the digital filter for the RESET pin during LLS, VLLS3, VLLS2, or
 * VLLS1 modes.
 *
 * Values:
 * - 0 - Filter not enabled
 * - 1 - Filter enabled
 */
/*@{*/
#define BP_LLWU_RST_RSTFILT  (0U)          /*!< Bit position for LLWU_RST_RSTFILT. */
#define BM_LLWU_RST_RSTFILT  (0x01U)       /*!< Bit mask for LLWU_RST_RSTFILT. */
#define BS_LLWU_RST_RSTFILT  (1U)          /*!< Bit field size in bits for LLWU_RST_RSTFILT. */

/*! @brief Read current value of the LLWU_RST_RSTFILT field. */
#define BR_LLWU_RST_RSTFILT(x) (BITBAND_ACCESS8(HW_LLWU_RST_ADDR(x), BP_LLWU_RST_RSTFILT))

/*! @brief Format value for bitfield LLWU_RST_RSTFILT. */
#define BF_LLWU_RST_RSTFILT(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_RST_RSTFILT) & BM_LLWU_RST_RSTFILT)

/*! @brief Set the RSTFILT field to a new value. */
#define BW_LLWU_RST_RSTFILT(x, v) (BITBAND_ACCESS8(HW_LLWU_RST_ADDR(x), BP_LLWU_RST_RSTFILT) = (v))
/*@}*/

/*!
 * @name Register LLWU_RST, field LLRSTE[1] (RW)
 *
 * This bit must be set to allow the device to be reset while in a low-leakage
 * power mode. On devices where Reset is not a dedicated pin, the RESET pin must
 * also be enabled in the explicit port mux control.
 *
 * Values:
 * - 0 - RESET pin not enabled as a leakage mode exit source
 * - 1 - RESET pin enabled as a low leakage mode exit source
 */
/*@{*/
#define BP_LLWU_RST_LLRSTE   (1U)          /*!< Bit position for LLWU_RST_LLRSTE. */
#define BM_LLWU_RST_LLRSTE   (0x02U)       /*!< Bit mask for LLWU_RST_LLRSTE. */
#define BS_LLWU_RST_LLRSTE   (1U)          /*!< Bit field size in bits for LLWU_RST_LLRSTE. */

/*! @brief Read current value of the LLWU_RST_LLRSTE field. */
#define BR_LLWU_RST_LLRSTE(x) (BITBAND_ACCESS8(HW_LLWU_RST_ADDR(x), BP_LLWU_RST_LLRSTE))

/*! @brief Format value for bitfield LLWU_RST_LLRSTE. */
#define BF_LLWU_RST_LLRSTE(v) ((uint8_t)((uint8_t)(v) << BP_LLWU_RST_LLRSTE) & BM_LLWU_RST_LLRSTE)

/*! @brief Set the LLRSTE field to a new value. */
#define BW_LLWU_RST_LLRSTE(x, v) (BITBAND_ACCESS8(HW_LLWU_RST_ADDR(x), BP_LLWU_RST_LLRSTE) = (v))
/*@}*/

/*******************************************************************************
 * hw_llwu_t - module struct
 ******************************************************************************/
/*!
 * @brief All LLWU module registers.
 */
#pragma pack(1)
typedef struct _hw_llwu
{
    __IO hw_llwu_pe1_t PE1;                /*!< [0x0] LLWU Pin Enable 1 register */
    __IO hw_llwu_pe2_t PE2;                /*!< [0x1] LLWU Pin Enable 2 register */
    __IO hw_llwu_pe3_t PE3;                /*!< [0x2] LLWU Pin Enable 3 register */
    __IO hw_llwu_pe4_t PE4;                /*!< [0x3] LLWU Pin Enable 4 register */
    __IO hw_llwu_me_t ME;                  /*!< [0x4] LLWU Module Enable register */
    __IO hw_llwu_f1_t F1;                  /*!< [0x5] LLWU Flag 1 register */
    __IO hw_llwu_f2_t F2;                  /*!< [0x6] LLWU Flag 2 register */
    __I hw_llwu_f3_t F3;                   /*!< [0x7] LLWU Flag 3 register */
    __IO hw_llwu_filt1_t FILT1;            /*!< [0x8] LLWU Pin Filter 1 register */
    __IO hw_llwu_filt2_t FILT2;            /*!< [0x9] LLWU Pin Filter 2 register */
    __IO hw_llwu_rst_t RST;                /*!< [0xA] LLWU Reset Enable register */
} hw_llwu_t;
#pragma pack()

/*! @brief Macro to access all LLWU registers. */
/*! @param x LLWU module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_LLWU_REGS(LLWU_BASE)</code>. */
#define HW_LLWU_REGS(x) (*(hw_llwu_t *)(x))

/*
 * MK64F12 LPTMR
 *
 * Low Power Timer
 *
 * Registers defined in this header file:
 * - HW_LPTMR_CSR - Low Power Timer Control Status Register
 * - HW_LPTMR_PSR - Low Power Timer Prescale Register
 * - HW_LPTMR_CMR - Low Power Timer Compare Register
 * - HW_LPTMR_CNR - Low Power Timer Counter Register
 *
 * - hw_lptmr_t - Struct containing all module registers.
 */

#define HW_LPTMR_INSTANCE_COUNT (1U) /*!< Number of instances of the LPTMR module. */
#define HW_LPTMR0 (0U) /*!< Instance number for LPTMR0. */

/*******************************************************************************
 * HW_LPTMR_CSR - Low Power Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief HW_LPTMR_CSR - Low Power Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_lptmr_csr
{
    uint32_t U;
    struct _hw_lptmr_csr_bitfields
    {
        uint32_t TEN : 1;              /*!< [0] Timer Enable */
        uint32_t TMS : 1;              /*!< [1] Timer Mode Select */
        uint32_t TFC : 1;              /*!< [2] Timer Free-Running Counter */
        uint32_t TPP : 1;              /*!< [3] Timer Pin Polarity */
        uint32_t TPS : 2;              /*!< [5:4] Timer Pin Select */
        uint32_t TIE : 1;              /*!< [6] Timer Interrupt Enable */
        uint32_t TCF : 1;              /*!< [7] Timer Compare Flag */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_lptmr_csr_t;

/*!
 * @name Constants and macros for entire LPTMR_CSR register
 */
/*@{*/
#define HW_LPTMR_CSR_ADDR(x)     ((uint32_t)(x) + 0x0U)

#define HW_LPTMR_CSR(x)          (*(__IO hw_lptmr_csr_t *) HW_LPTMR_CSR_ADDR(x))
#define HW_LPTMR_CSR_RD(x)       (HW_LPTMR_CSR(x).U)
#define HW_LPTMR_CSR_WR(x, v)    (HW_LPTMR_CSR(x).U = (v))
#define HW_LPTMR_CSR_SET(x, v)   (HW_LPTMR_CSR_WR(x, HW_LPTMR_CSR_RD(x) |  (v)))
#define HW_LPTMR_CSR_CLR(x, v)   (HW_LPTMR_CSR_WR(x, HW_LPTMR_CSR_RD(x) & ~(v)))
#define HW_LPTMR_CSR_TOG(x, v)   (HW_LPTMR_CSR_WR(x, HW_LPTMR_CSR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CSR bitfields
 */

/*!
 * @name Register LPTMR_CSR, field TEN[0] (RW)
 *
 * When TEN is clear, it resets the LPTMR internal logic, including the CNR and
 * TCF. When TEN is set, the LPTMR is enabled. While writing 1 to this field,
 * CSR[5:1] must not be altered.
 *
 * Values:
 * - 0 - LPTMR is disabled and internal logic is reset.
 * - 1 - LPTMR is enabled.
 */
/*@{*/
#define BP_LPTMR_CSR_TEN     (0U)          /*!< Bit position for LPTMR_CSR_TEN. */
#define BM_LPTMR_CSR_TEN     (0x00000001U) /*!< Bit mask for LPTMR_CSR_TEN. */
#define BS_LPTMR_CSR_TEN     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TEN. */

/*! @brief Read current value of the LPTMR_CSR_TEN field. */
#define BR_LPTMR_CSR_TEN(x)  (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TEN))

/*! @brief Format value for bitfield LPTMR_CSR_TEN. */
#define BF_LPTMR_CSR_TEN(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TEN) & BM_LPTMR_CSR_TEN)

/*! @brief Set the TEN field to a new value. */
#define BW_LPTMR_CSR_TEN(x, v) (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TEN) = (v))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TMS[1] (RW)
 *
 * Configures the mode of the LPTMR. TMS must be altered only when the LPTMR is
 * disabled.
 *
 * Values:
 * - 0 - Time Counter mode.
 * - 1 - Pulse Counter mode.
 */
/*@{*/
#define BP_LPTMR_CSR_TMS     (1U)          /*!< Bit position for LPTMR_CSR_TMS. */
#define BM_LPTMR_CSR_TMS     (0x00000002U) /*!< Bit mask for LPTMR_CSR_TMS. */
#define BS_LPTMR_CSR_TMS     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TMS. */

/*! @brief Read current value of the LPTMR_CSR_TMS field. */
#define BR_LPTMR_CSR_TMS(x)  (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TMS))

/*! @brief Format value for bitfield LPTMR_CSR_TMS. */
#define BF_LPTMR_CSR_TMS(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TMS) & BM_LPTMR_CSR_TMS)

/*! @brief Set the TMS field to a new value. */
#define BW_LPTMR_CSR_TMS(x, v) (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TMS) = (v))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TFC[2] (RW)
 *
 * When clear, TFC configures the CNR to reset whenever TCF is set. When set,
 * TFC configures the CNR to reset on overflow. TFC must be altered only when the
 * LPTMR is disabled.
 *
 * Values:
 * - 0 - CNR is reset whenever TCF is set.
 * - 1 - CNR is reset on overflow.
 */
/*@{*/
#define BP_LPTMR_CSR_TFC     (2U)          /*!< Bit position for LPTMR_CSR_TFC. */
#define BM_LPTMR_CSR_TFC     (0x00000004U) /*!< Bit mask for LPTMR_CSR_TFC. */
#define BS_LPTMR_CSR_TFC     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TFC. */

/*! @brief Read current value of the LPTMR_CSR_TFC field. */
#define BR_LPTMR_CSR_TFC(x)  (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TFC))

/*! @brief Format value for bitfield LPTMR_CSR_TFC. */
#define BF_LPTMR_CSR_TFC(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TFC) & BM_LPTMR_CSR_TFC)

/*! @brief Set the TFC field to a new value. */
#define BW_LPTMR_CSR_TFC(x, v) (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TFC) = (v))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPP[3] (RW)
 *
 * Configures the polarity of the input source in Pulse Counter mode. TPP must
 * be changed only when the LPTMR is disabled.
 *
 * Values:
 * - 0 - Pulse Counter input source is active-high, and the CNR will increment
 *     on the rising-edge.
 * - 1 - Pulse Counter input source is active-low, and the CNR will increment on
 *     the falling-edge.
 */
/*@{*/
#define BP_LPTMR_CSR_TPP     (3U)          /*!< Bit position for LPTMR_CSR_TPP. */
#define BM_LPTMR_CSR_TPP     (0x00000008U) /*!< Bit mask for LPTMR_CSR_TPP. */
#define BS_LPTMR_CSR_TPP     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TPP. */

/*! @brief Read current value of the LPTMR_CSR_TPP field. */
#define BR_LPTMR_CSR_TPP(x)  (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TPP))

/*! @brief Format value for bitfield LPTMR_CSR_TPP. */
#define BF_LPTMR_CSR_TPP(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TPP) & BM_LPTMR_CSR_TPP)

/*! @brief Set the TPP field to a new value. */
#define BW_LPTMR_CSR_TPP(x, v) (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TPP) = (v))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPS[5:4] (RW)
 *
 * Configures the input source to be used in Pulse Counter mode. TPS must be
 * altered only when the LPTMR is disabled. The input connections vary by device.
 * See the chip configuration details for information on the connections to these
 * inputs.
 *
 * Values:
 * - 00 - Pulse counter input 0 is selected.
 * - 01 - Pulse counter input 1 is selected.
 * - 10 - Pulse counter input 2 is selected.
 * - 11 - Pulse counter input 3 is selected.
 */
/*@{*/
#define BP_LPTMR_CSR_TPS     (4U)          /*!< Bit position for LPTMR_CSR_TPS. */
#define BM_LPTMR_CSR_TPS     (0x00000030U) /*!< Bit mask for LPTMR_CSR_TPS. */
#define BS_LPTMR_CSR_TPS     (2U)          /*!< Bit field size in bits for LPTMR_CSR_TPS. */

/*! @brief Read current value of the LPTMR_CSR_TPS field. */
#define BR_LPTMR_CSR_TPS(x)  (HW_LPTMR_CSR(x).B.TPS)

/*! @brief Format value for bitfield LPTMR_CSR_TPS. */
#define BF_LPTMR_CSR_TPS(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TPS) & BM_LPTMR_CSR_TPS)

/*! @brief Set the TPS field to a new value. */
#define BW_LPTMR_CSR_TPS(x, v) (HW_LPTMR_CSR_WR(x, (HW_LPTMR_CSR_RD(x) & ~BM_LPTMR_CSR_TPS) | BF_LPTMR_CSR_TPS(v)))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TIE[6] (RW)
 *
 * When TIE is set, the LPTMR Interrupt is generated whenever TCF is also set.
 *
 * Values:
 * - 0 - Timer interrupt disabled.
 * - 1 - Timer interrupt enabled.
 */
/*@{*/
#define BP_LPTMR_CSR_TIE     (6U)          /*!< Bit position for LPTMR_CSR_TIE. */
#define BM_LPTMR_CSR_TIE     (0x00000040U) /*!< Bit mask for LPTMR_CSR_TIE. */
#define BS_LPTMR_CSR_TIE     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TIE. */

/*! @brief Read current value of the LPTMR_CSR_TIE field. */
#define BR_LPTMR_CSR_TIE(x)  (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TIE))

/*! @brief Format value for bitfield LPTMR_CSR_TIE. */
#define BF_LPTMR_CSR_TIE(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TIE) & BM_LPTMR_CSR_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_LPTMR_CSR_TIE(x, v) (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TIE) = (v))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TCF[7] (W1C)
 *
 * TCF is set when the LPTMR is enabled and the CNR equals the CMR and
 * increments. TCF is cleared when the LPTMR is disabled or a logic 1 is written to it.
 *
 * Values:
 * - 0 - The value of CNR is not equal to CMR and increments.
 * - 1 - The value of CNR is equal to CMR and increments.
 */
/*@{*/
#define BP_LPTMR_CSR_TCF     (7U)          /*!< Bit position for LPTMR_CSR_TCF. */
#define BM_LPTMR_CSR_TCF     (0x00000080U) /*!< Bit mask for LPTMR_CSR_TCF. */
#define BS_LPTMR_CSR_TCF     (1U)          /*!< Bit field size in bits for LPTMR_CSR_TCF. */

/*! @brief Read current value of the LPTMR_CSR_TCF field. */
#define BR_LPTMR_CSR_TCF(x)  (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TCF))

/*! @brief Format value for bitfield LPTMR_CSR_TCF. */
#define BF_LPTMR_CSR_TCF(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_CSR_TCF) & BM_LPTMR_CSR_TCF)

/*! @brief Set the TCF field to a new value. */
#define BW_LPTMR_CSR_TCF(x, v) (BITBAND_ACCESS32(HW_LPTMR_CSR_ADDR(x), BP_LPTMR_CSR_TCF) = (v))
/*@}*/

/*******************************************************************************
 * HW_LPTMR_PSR - Low Power Timer Prescale Register
 ******************************************************************************/

/*!
 * @brief HW_LPTMR_PSR - Low Power Timer Prescale Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_lptmr_psr
{
    uint32_t U;
    struct _hw_lptmr_psr_bitfields
    {
        uint32_t PCS : 2;              /*!< [1:0] Prescaler Clock Select */
        uint32_t PBYP : 1;             /*!< [2] Prescaler Bypass */
        uint32_t PRESCALE : 4;         /*!< [6:3] Prescale Value */
        uint32_t RESERVED0 : 25;       /*!< [31:7]  */
    } B;
} hw_lptmr_psr_t;

/*!
 * @name Constants and macros for entire LPTMR_PSR register
 */
/*@{*/
#define HW_LPTMR_PSR_ADDR(x)     ((uint32_t)(x) + 0x4U)

#define HW_LPTMR_PSR(x)          (*(__IO hw_lptmr_psr_t *) HW_LPTMR_PSR_ADDR(x))
#define HW_LPTMR_PSR_RD(x)       (HW_LPTMR_PSR(x).U)
#define HW_LPTMR_PSR_WR(x, v)    (HW_LPTMR_PSR(x).U = (v))
#define HW_LPTMR_PSR_SET(x, v)   (HW_LPTMR_PSR_WR(x, HW_LPTMR_PSR_RD(x) |  (v)))
#define HW_LPTMR_PSR_CLR(x, v)   (HW_LPTMR_PSR_WR(x, HW_LPTMR_PSR_RD(x) & ~(v)))
#define HW_LPTMR_PSR_TOG(x, v)   (HW_LPTMR_PSR_WR(x, HW_LPTMR_PSR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_PSR bitfields
 */

/*!
 * @name Register LPTMR_PSR, field PCS[1:0] (RW)
 *
 * Selects the clock to be used by the LPTMR prescaler/glitch filter. PCS must
 * be altered only when the LPTMR is disabled. The clock connections vary by
 * device. See the chip configuration details for information on the connections to
 * these inputs.
 *
 * Values:
 * - 00 - Prescaler/glitch filter clock 0 selected.
 * - 01 - Prescaler/glitch filter clock 1 selected.
 * - 10 - Prescaler/glitch filter clock 2 selected.
 * - 11 - Prescaler/glitch filter clock 3 selected.
 */
/*@{*/
#define BP_LPTMR_PSR_PCS     (0U)          /*!< Bit position for LPTMR_PSR_PCS. */
#define BM_LPTMR_PSR_PCS     (0x00000003U) /*!< Bit mask for LPTMR_PSR_PCS. */
#define BS_LPTMR_PSR_PCS     (2U)          /*!< Bit field size in bits for LPTMR_PSR_PCS. */

/*! @brief Read current value of the LPTMR_PSR_PCS field. */
#define BR_LPTMR_PSR_PCS(x)  (HW_LPTMR_PSR(x).B.PCS)

/*! @brief Format value for bitfield LPTMR_PSR_PCS. */
#define BF_LPTMR_PSR_PCS(v)  ((uint32_t)((uint32_t)(v) << BP_LPTMR_PSR_PCS) & BM_LPTMR_PSR_PCS)

/*! @brief Set the PCS field to a new value. */
#define BW_LPTMR_PSR_PCS(x, v) (HW_LPTMR_PSR_WR(x, (HW_LPTMR_PSR_RD(x) & ~BM_LPTMR_PSR_PCS) | BF_LPTMR_PSR_PCS(v)))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PBYP[2] (RW)
 *
 * When PBYP is set, the selected prescaler clock in Time Counter mode or
 * selected input source in Pulse Counter mode directly clocks the CNR. When PBYP is
 * clear, the CNR is clocked by the output of the prescaler/glitch filter. PBYP
 * must be altered only when the LPTMR is disabled.
 *
 * Values:
 * - 0 - Prescaler/glitch filter is enabled.
 * - 1 - Prescaler/glitch filter is bypassed.
 */
/*@{*/
#define BP_LPTMR_PSR_PBYP    (2U)          /*!< Bit position for LPTMR_PSR_PBYP. */
#define BM_LPTMR_PSR_PBYP    (0x00000004U) /*!< Bit mask for LPTMR_PSR_PBYP. */
#define BS_LPTMR_PSR_PBYP    (1U)          /*!< Bit field size in bits for LPTMR_PSR_PBYP. */

/*! @brief Read current value of the LPTMR_PSR_PBYP field. */
#define BR_LPTMR_PSR_PBYP(x) (BITBAND_ACCESS32(HW_LPTMR_PSR_ADDR(x), BP_LPTMR_PSR_PBYP))

/*! @brief Format value for bitfield LPTMR_PSR_PBYP. */
#define BF_LPTMR_PSR_PBYP(v) ((uint32_t)((uint32_t)(v) << BP_LPTMR_PSR_PBYP) & BM_LPTMR_PSR_PBYP)

/*! @brief Set the PBYP field to a new value. */
#define BW_LPTMR_PSR_PBYP(x, v) (BITBAND_ACCESS32(HW_LPTMR_PSR_ADDR(x), BP_LPTMR_PSR_PBYP) = (v))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PRESCALE[6:3] (RW)
 *
 * Configures the size of the Prescaler in Time Counter mode or width of the
 * glitch filter in Pulse Counter mode. PRESCALE must be altered only when the LPTMR
 * is disabled.
 *
 * Values:
 * - 0000 - Prescaler divides the prescaler clock by 2; glitch filter does not
 *     support this configuration.
 * - 0001 - Prescaler divides the prescaler clock by 4; glitch filter recognizes
 *     change on input pin after 2 rising clock edges.
 * - 0010 - Prescaler divides the prescaler clock by 8; glitch filter recognizes
 *     change on input pin after 4 rising clock edges.
 * - 0011 - Prescaler divides the prescaler clock by 16; glitch filter
 *     recognizes change on input pin after 8 rising clock edges.
 * - 0100 - Prescaler divides the prescaler clock by 32; glitch filter
 *     recognizes change on input pin after 16 rising clock edges.
 * - 0101 - Prescaler divides the prescaler clock by 64; glitch filter
 *     recognizes change on input pin after 32 rising clock edges.
 * - 0110 - Prescaler divides the prescaler clock by 128; glitch filter
 *     recognizes change on input pin after 64 rising clock edges.
 * - 0111 - Prescaler divides the prescaler clock by 256; glitch filter
 *     recognizes change on input pin after 128 rising clock edges.
 * - 1000 - Prescaler divides the prescaler clock by 512; glitch filter
 *     recognizes change on input pin after 256 rising clock edges.
 * - 1001 - Prescaler divides the prescaler clock by 1024; glitch filter
 *     recognizes change on input pin after 512 rising clock edges.
 * - 1010 - Prescaler divides the prescaler clock by 2048; glitch filter
 *     recognizes change on input pin after 1024 rising clock edges.
 * - 1011 - Prescaler divides the prescaler clock by 4096; glitch filter
 *     recognizes change on input pin after 2048 rising clock edges.
 * - 1100 - Prescaler divides the prescaler clock by 8192; glitch filter
 *     recognizes change on input pin after 4096 rising clock edges.
 * - 1101 - Prescaler divides the prescaler clock by 16,384; glitch filter
 *     recognizes change on input pin after 8192 rising clock edges.
 * - 1110 - Prescaler divides the prescaler clock by 32,768; glitch filter
 *     recognizes change on input pin after 16,384 rising clock edges.
 * - 1111 - Prescaler divides the prescaler clock by 65,536; glitch filter
 *     recognizes change on input pin after 32,768 rising clock edges.
 */
/*@{*/
#define BP_LPTMR_PSR_PRESCALE (3U)         /*!< Bit position for LPTMR_PSR_PRESCALE. */
#define BM_LPTMR_PSR_PRESCALE (0x00000078U) /*!< Bit mask for LPTMR_PSR_PRESCALE. */
#define BS_LPTMR_PSR_PRESCALE (4U)         /*!< Bit field size in bits for LPTMR_PSR_PRESCALE. */

/*! @brief Read current value of the LPTMR_PSR_PRESCALE field. */
#define BR_LPTMR_PSR_PRESCALE(x) (HW_LPTMR_PSR(x).B.PRESCALE)

/*! @brief Format value for bitfield LPTMR_PSR_PRESCALE. */
#define BF_LPTMR_PSR_PRESCALE(v) ((uint32_t)((uint32_t)(v) << BP_LPTMR_PSR_PRESCALE) & BM_LPTMR_PSR_PRESCALE)

/*! @brief Set the PRESCALE field to a new value. */
#define BW_LPTMR_PSR_PRESCALE(x, v) (HW_LPTMR_PSR_WR(x, (HW_LPTMR_PSR_RD(x) & ~BM_LPTMR_PSR_PRESCALE) | BF_LPTMR_PSR_PRESCALE(v)))
/*@}*/

/*******************************************************************************
 * HW_LPTMR_CMR - Low Power Timer Compare Register
 ******************************************************************************/

/*!
 * @brief HW_LPTMR_CMR - Low Power Timer Compare Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_lptmr_cmr
{
    uint32_t U;
    struct _hw_lptmr_cmr_bitfields
    {
        uint32_t COMPARE : 16;         /*!< [15:0] Compare Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_lptmr_cmr_t;

/*!
 * @name Constants and macros for entire LPTMR_CMR register
 */
/*@{*/
#define HW_LPTMR_CMR_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_LPTMR_CMR(x)          (*(__IO hw_lptmr_cmr_t *) HW_LPTMR_CMR_ADDR(x))
#define HW_LPTMR_CMR_RD(x)       (HW_LPTMR_CMR(x).U)
#define HW_LPTMR_CMR_WR(x, v)    (HW_LPTMR_CMR(x).U = (v))
#define HW_LPTMR_CMR_SET(x, v)   (HW_LPTMR_CMR_WR(x, HW_LPTMR_CMR_RD(x) |  (v)))
#define HW_LPTMR_CMR_CLR(x, v)   (HW_LPTMR_CMR_WR(x, HW_LPTMR_CMR_RD(x) & ~(v)))
#define HW_LPTMR_CMR_TOG(x, v)   (HW_LPTMR_CMR_WR(x, HW_LPTMR_CMR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CMR bitfields
 */

/*!
 * @name Register LPTMR_CMR, field COMPARE[15:0] (RW)
 *
 * When the LPTMR is enabled and the CNR equals the value in the CMR and
 * increments, TCF is set and the hardware trigger asserts until the next time the CNR
 * increments. If the CMR is 0, the hardware trigger will remain asserted until
 * the LPTMR is disabled. If the LPTMR is enabled, the CMR must be altered only
 * when TCF is set.
 */
/*@{*/
#define BP_LPTMR_CMR_COMPARE (0U)          /*!< Bit position for LPTMR_CMR_COMPARE. */
#define BM_LPTMR_CMR_COMPARE (0x0000FFFFU) /*!< Bit mask for LPTMR_CMR_COMPARE. */
#define BS_LPTMR_CMR_COMPARE (16U)         /*!< Bit field size in bits for LPTMR_CMR_COMPARE. */

/*! @brief Read current value of the LPTMR_CMR_COMPARE field. */
#define BR_LPTMR_CMR_COMPARE(x) (HW_LPTMR_CMR(x).B.COMPARE)

/*! @brief Format value for bitfield LPTMR_CMR_COMPARE. */
#define BF_LPTMR_CMR_COMPARE(v) ((uint32_t)((uint32_t)(v) << BP_LPTMR_CMR_COMPARE) & BM_LPTMR_CMR_COMPARE)

/*! @brief Set the COMPARE field to a new value. */
#define BW_LPTMR_CMR_COMPARE(x, v) (HW_LPTMR_CMR_WR(x, (HW_LPTMR_CMR_RD(x) & ~BM_LPTMR_CMR_COMPARE) | BF_LPTMR_CMR_COMPARE(v)))
/*@}*/

/*******************************************************************************
 * HW_LPTMR_CNR - Low Power Timer Counter Register
 ******************************************************************************/

/*!
 * @brief HW_LPTMR_CNR - Low Power Timer Counter Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_lptmr_cnr
{
    uint32_t U;
    struct _hw_lptmr_cnr_bitfields
    {
        uint32_t COUNTER : 16;         /*!< [15:0] Counter Value */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_lptmr_cnr_t;

/*!
 * @name Constants and macros for entire LPTMR_CNR register
 */
/*@{*/
#define HW_LPTMR_CNR_ADDR(x)     ((uint32_t)(x) + 0xCU)

#define HW_LPTMR_CNR(x)          (*(__IO hw_lptmr_cnr_t *) HW_LPTMR_CNR_ADDR(x))
#define HW_LPTMR_CNR_RD(x)       (HW_LPTMR_CNR(x).U)
#define HW_LPTMR_CNR_WR(x, v)    (HW_LPTMR_CNR(x).U = (v))
#define HW_LPTMR_CNR_SET(x, v)   (HW_LPTMR_CNR_WR(x, HW_LPTMR_CNR_RD(x) |  (v)))
#define HW_LPTMR_CNR_CLR(x, v)   (HW_LPTMR_CNR_WR(x, HW_LPTMR_CNR_RD(x) & ~(v)))
#define HW_LPTMR_CNR_TOG(x, v)   (HW_LPTMR_CNR_WR(x, HW_LPTMR_CNR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CNR bitfields
 */

/*!
 * @name Register LPTMR_CNR, field COUNTER[15:0] (RW)
 */
/*@{*/
#define BP_LPTMR_CNR_COUNTER (0U)          /*!< Bit position for LPTMR_CNR_COUNTER. */
#define BM_LPTMR_CNR_COUNTER (0x0000FFFFU) /*!< Bit mask for LPTMR_CNR_COUNTER. */
#define BS_LPTMR_CNR_COUNTER (16U)         /*!< Bit field size in bits for LPTMR_CNR_COUNTER. */

/*! @brief Read current value of the LPTMR_CNR_COUNTER field. */
#define BR_LPTMR_CNR_COUNTER(x) (HW_LPTMR_CNR(x).B.COUNTER)

/*! @brief Format value for bitfield LPTMR_CNR_COUNTER. */
#define BF_LPTMR_CNR_COUNTER(v) ((uint32_t)((uint32_t)(v) << BP_LPTMR_CNR_COUNTER) & BM_LPTMR_CNR_COUNTER)

/*! @brief Set the COUNTER field to a new value. */
#define BW_LPTMR_CNR_COUNTER(x, v) (HW_LPTMR_CNR_WR(x, (HW_LPTMR_CNR_RD(x) & ~BM_LPTMR_CNR_COUNTER) | BF_LPTMR_CNR_COUNTER(v)))
/*@}*/

/*******************************************************************************
 * hw_lptmr_t - module struct
 ******************************************************************************/
/*!
 * @brief All LPTMR module registers.
 */
#pragma pack(1)
typedef struct _hw_lptmr
{
    __IO hw_lptmr_csr_t CSR;               /*!< [0x0] Low Power Timer Control Status Register */
    __IO hw_lptmr_psr_t PSR;               /*!< [0x4] Low Power Timer Prescale Register */
    __IO hw_lptmr_cmr_t CMR;               /*!< [0x8] Low Power Timer Compare Register */
    __IO hw_lptmr_cnr_t CNR;               /*!< [0xC] Low Power Timer Counter Register */
} hw_lptmr_t;
#pragma pack()

/*! @brief Macro to access all LPTMR registers. */
/*! @param x LPTMR module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_LPTMR_REGS(LPTMR0_BASE)</code>. */
#define HW_LPTMR_REGS(x) (*(hw_lptmr_t *)(x))

/*
 * MK64F12 MCG
 *
 * Multipurpose Clock Generator module
 *
 * Registers defined in this header file:
 * - HW_MCG_C1 - MCG Control 1 Register
 * - HW_MCG_C2 - MCG Control 2 Register
 * - HW_MCG_C3 - MCG Control 3 Register
 * - HW_MCG_C4 - MCG Control 4 Register
 * - HW_MCG_C5 - MCG Control 5 Register
 * - HW_MCG_C6 - MCG Control 6 Register
 * - HW_MCG_S - MCG Status Register
 * - HW_MCG_SC - MCG Status and Control Register
 * - HW_MCG_ATCVH - MCG Auto Trim Compare Value High Register
 * - HW_MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 * - HW_MCG_C7 - MCG Control 7 Register
 * - HW_MCG_C8 - MCG Control 8 Register
 *
 * - hw_mcg_t - Struct containing all module registers.
 */

#define HW_MCG_INSTANCE_COUNT (1U) /*!< Number of instances of the MCG module. */
#define HW_MCG (0U) /*!< Instance number for MCG. */

/*******************************************************************************
 * HW_MCG_C1 - MCG Control 1 Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_C1 - MCG Control 1 Register (RW)
 *
 * Reset value: 0x04U
 */
typedef union _hw_mcg_c1
{
    uint8_t U;
    struct _hw_mcg_c1_bitfields
    {
        uint8_t IREFSTEN : 1;          /*!< [0] Internal Reference Stop Enable */
        uint8_t IRCLKEN : 1;           /*!< [1] Internal Reference Clock Enable */
        uint8_t IREFS : 1;             /*!< [2] Internal Reference Select */
        uint8_t FRDIV : 3;             /*!< [5:3] FLL External Reference Divider */
        uint8_t CLKS : 2;              /*!< [7:6] Clock Source Select */
    } B;
} hw_mcg_c1_t;

/*!
 * @name Constants and macros for entire MCG_C1 register
 */
/*@{*/
#define HW_MCG_C1_ADDR(x)        ((uint32_t)(x) + 0x0U)

#define HW_MCG_C1(x)             (*(__IO hw_mcg_c1_t *) HW_MCG_C1_ADDR(x))
#define HW_MCG_C1_RD(x)          (HW_MCG_C1(x).U)
#define HW_MCG_C1_WR(x, v)       (HW_MCG_C1(x).U = (v))
#define HW_MCG_C1_SET(x, v)      (HW_MCG_C1_WR(x, HW_MCG_C1_RD(x) |  (v)))
#define HW_MCG_C1_CLR(x, v)      (HW_MCG_C1_WR(x, HW_MCG_C1_RD(x) & ~(v)))
#define HW_MCG_C1_TOG(x, v)      (HW_MCG_C1_WR(x, HW_MCG_C1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_C1 bitfields
 */

/*!
 * @name Register MCG_C1, field IREFSTEN[0] (RW)
 *
 * Controls whether or not the internal reference clock remains enabled when the
 * MCG enters Stop mode.
 *
 * Values:
 * - 0 - Internal reference clock is disabled in Stop mode.
 * - 1 - Internal reference clock is enabled in Stop mode if IRCLKEN is set or
 *     if MCG is in FEI, FBI, or BLPI modes before entering Stop mode.
 */
/*@{*/
#define BP_MCG_C1_IREFSTEN   (0U)          /*!< Bit position for MCG_C1_IREFSTEN. */
#define BM_MCG_C1_IREFSTEN   (0x01U)       /*!< Bit mask for MCG_C1_IREFSTEN. */
#define BS_MCG_C1_IREFSTEN   (1U)          /*!< Bit field size in bits for MCG_C1_IREFSTEN. */

/*! @brief Read current value of the MCG_C1_IREFSTEN field. */
#define BR_MCG_C1_IREFSTEN(x) (BITBAND_ACCESS8(HW_MCG_C1_ADDR(x), BP_MCG_C1_IREFSTEN))

/*! @brief Format value for bitfield MCG_C1_IREFSTEN. */
#define BF_MCG_C1_IREFSTEN(v) ((uint8_t)((uint8_t)(v) << BP_MCG_C1_IREFSTEN) & BM_MCG_C1_IREFSTEN)

/*! @brief Set the IREFSTEN field to a new value. */
#define BW_MCG_C1_IREFSTEN(x, v) (BITBAND_ACCESS8(HW_MCG_C1_ADDR(x), BP_MCG_C1_IREFSTEN) = (v))
/*@}*/

/*!
 * @name Register MCG_C1, field IRCLKEN[1] (RW)
 *
 * Enables the internal reference clock for use as MCGIRCLK.
 *
 * Values:
 * - 0 - MCGIRCLK inactive.
 * - 1 - MCGIRCLK active.
 */
/*@{*/
#define BP_MCG_C1_IRCLKEN    (1U)          /*!< Bit position for MCG_C1_IRCLKEN. */
#define BM_MCG_C1_IRCLKEN    (0x02U)       /*!< Bit mask for MCG_C1_IRCLKEN. */
#define BS_MCG_C1_IRCLKEN    (1U)          /*!< Bit field size in bits for MCG_C1_IRCLKEN. */

/*! @brief Read current value of the MCG_C1_IRCLKEN field. */
#define BR_MCG_C1_IRCLKEN(x) (BITBAND_ACCESS8(HW_MCG_C1_ADDR(x), BP_MCG_C1_IRCLKEN))

/*! @brief Format value for bitfield MCG_C1_IRCLKEN. */
#define BF_MCG_C1_IRCLKEN(v) ((uint8_t)((uint8_t)(v) << BP_MCG_C1_IRCLKEN) & BM_MCG_C1_IRCLKEN)

/*! @brief Set the IRCLKEN field to a new value. */
#define BW_MCG_C1_IRCLKEN(x, v) (BITBAND_ACCESS8(HW_MCG_C1_ADDR(x), BP_MCG_C1_IRCLKEN) = (v))
/*@}*/

/*!
 * @name Register MCG_C1, field IREFS[2] (RW)
 *
 * Selects the reference clock source for the FLL.
 *
 * Values:
 * - 0 - External reference clock is selected.
 * - 1 - The slow internal reference clock is selected.
 */
/*@{*/
#define BP_MCG_C1_IREFS      (2U)          /*!< Bit position for MCG_C1_IREFS. */
#define BM_MCG_C1_IREFS      (0x04U)       /*!< Bit mask for MCG_C1_IREFS. */
#define BS_MCG_C1_IREFS      (1U)          /*!< Bit field size in bits for MCG_C1_IREFS. */

/*! @brief Read current value of the MCG_C1_IREFS field. */
#define BR_MCG_C1_IREFS(x)   (BITBAND_ACCESS8(HW_MCG_C1_ADDR(x), BP_MCG_C1_IREFS))

/*! @brief Format value for bitfield MCG_C1_IREFS. */
#define BF_MCG_C1_IREFS(v)   ((uint8_t)((uint8_t)(v) << BP_MCG_C1_IREFS) & BM_MCG_C1_IREFS)

/*! @brief Set the IREFS field to a new value. */
#define BW_MCG_C1_IREFS(x, v) (BITBAND_ACCESS8(HW_MCG_C1_ADDR(x), BP_MCG_C1_IREFS) = (v))
/*@}*/

/*!
 * @name Register MCG_C1, field FRDIV[5:3] (RW)
 *
 * Selects the amount to divide down the external reference clock for the FLL.
 * The resulting frequency must be in the range 31.25 kHz to 39.0625 kHz (This is
 * required when FLL/DCO is the clock source for MCGOUTCLK . In FBE mode, it is
 * not required to meet this range, but it is recommended in the cases when trying
 * to enter a FLL mode from FBE).
 *
 * Values:
 * - 000 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 1; for all other RANGE
 *     values, Divide Factor is 32.
 * - 001 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 2; for all other RANGE
 *     values, Divide Factor is 64.
 * - 010 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 4; for all other RANGE
 *     values, Divide Factor is 128.
 * - 011 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 8; for all other RANGE
 *     values, Divide Factor is 256.
 * - 100 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 16; for all other RANGE
 *     values, Divide Factor is 512.
 * - 101 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 32; for all other RANGE
 *     values, Divide Factor is 1024.
 * - 110 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 64; for all other RANGE
 *     values, Divide Factor is 1280 .
 * - 111 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 128; for all other RANGE
 *     values, Divide Factor is 1536 .
 */
/*@{*/
#define BP_MCG_C1_FRDIV      (3U)          /*!< Bit position for MCG_C1_FRDIV. */
#define BM_MCG_C1_FRDIV      (0x38U)       /*!< Bit mask for MCG_C1_FRDIV. */
#define BS_MCG_C1_FRDIV      (3U)          /*!< Bit field size in bits for MCG_C1_FRDIV. */

/*! @brief Read current value of the MCG_C1_FRDIV field. */
#define BR_MCG_C1_FRDIV(x)   (HW_MCG_C1(x).B.FRDIV)

/*! @brief Format value for bitfield MCG_C1_FRDIV. */
#define BF_MCG_C1_FRDIV(v)   ((uint8_t)((uint8_t)(v) << BP_MCG_C1_FRDIV) & BM_MCG_C1_FRDIV)

/*! @brief Set the FRDIV field to a new value. */
#define BW_MCG_C1_FRDIV(x, v) (HW_MCG_C1_WR(x, (HW_MCG_C1_RD(x) & ~BM_MCG_C1_FRDIV) | BF_MCG_C1_FRDIV(v)))
/*@}*/

/*!
 * @name Register MCG_C1, field CLKS[7:6] (RW)
 *
 * Selects the clock source for MCGOUTCLK .
 *
 * Values:
 * - 00 - Encoding 0 - Output of FLL or PLL is selected (depends on PLLS control
 *     bit).
 * - 01 - Encoding 1 - Internal reference clock is selected.
 * - 10 - Encoding 2 - External reference clock is selected.
 * - 11 - Encoding 3 - Reserved.
 */
/*@{*/
#define BP_MCG_C1_CLKS       (6U)          /*!< Bit position for MCG_C1_CLKS. */
#define BM_MCG_C1_CLKS       (0xC0U)       /*!< Bit mask for MCG_C1_CLKS. */
#define BS_MCG_C1_CLKS       (2U)          /*!< Bit field size in bits for MCG_C1_CLKS. */

/*! @brief Read current value of the MCG_C1_CLKS field. */
#define BR_MCG_C1_CLKS(x)    (HW_MCG_C1(x).B.CLKS)

/*! @brief Format value for bitfield MCG_C1_CLKS. */
#define BF_MCG_C1_CLKS(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_C1_CLKS) & BM_MCG_C1_CLKS)

/*! @brief Set the CLKS field to a new value. */
#define BW_MCG_C1_CLKS(x, v) (HW_MCG_C1_WR(x, (HW_MCG_C1_RD(x) & ~BM_MCG_C1_CLKS) | BF_MCG_C1_CLKS(v)))
/*@}*/

/*******************************************************************************
 * HW_MCG_C2 - MCG Control 2 Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_C2 - MCG Control 2 Register (RW)
 *
 * Reset value: 0x80U
 */
typedef union _hw_mcg_c2
{
    uint8_t U;
    struct _hw_mcg_c2_bitfields
    {
        uint8_t IRCS : 1;              /*!< [0] Internal Reference Clock Select */
        uint8_t LP : 1;                /*!< [1] Low Power Select */
        uint8_t EREFS : 1;             /*!< [2] External Reference Select */
        uint8_t HGO : 1;               /*!< [3] High Gain Oscillator Select */
        uint8_t RANGE : 2;             /*!< [5:4] Frequency Range Select */
        uint8_t FCFTRIM : 1;           /*!< [6] Fast Internal Reference Clock Fine Trim
                                        * */
        uint8_t LOCRE0 : 1;            /*!< [7] Loss of Clock Reset Enable */
    } B;
} hw_mcg_c2_t;

/*!
 * @name Constants and macros for entire MCG_C2 register
 */
/*@{*/
#define HW_MCG_C2_ADDR(x)        ((uint32_t)(x) + 0x1U)

#define HW_MCG_C2(x)             (*(__IO hw_mcg_c2_t *) HW_MCG_C2_ADDR(x))
#define HW_MCG_C2_RD(x)          (HW_MCG_C2(x).U)
#define HW_MCG_C2_WR(x, v)       (HW_MCG_C2(x).U = (v))
#define HW_MCG_C2_SET(x, v)      (HW_MCG_C2_WR(x, HW_MCG_C2_RD(x) |  (v)))
#define HW_MCG_C2_CLR(x, v)      (HW_MCG_C2_WR(x, HW_MCG_C2_RD(x) & ~(v)))
#define HW_MCG_C2_TOG(x, v)      (HW_MCG_C2_WR(x, HW_MCG_C2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_C2 bitfields
 */

/*!
 * @name Register MCG_C2, field IRCS[0] (RW)
 *
 * Selects between the fast or slow internal reference clock source.
 *
 * Values:
 * - 0 - Slow internal reference clock selected.
 * - 1 - Fast internal reference clock selected.
 */
/*@{*/
#define BP_MCG_C2_IRCS       (0U)          /*!< Bit position for MCG_C2_IRCS. */
#define BM_MCG_C2_IRCS       (0x01U)       /*!< Bit mask for MCG_C2_IRCS. */
#define BS_MCG_C2_IRCS       (1U)          /*!< Bit field size in bits for MCG_C2_IRCS. */

/*! @brief Read current value of the MCG_C2_IRCS field. */
#define BR_MCG_C2_IRCS(x)    (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_IRCS))

/*! @brief Format value for bitfield MCG_C2_IRCS. */
#define BF_MCG_C2_IRCS(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_C2_IRCS) & BM_MCG_C2_IRCS)

/*! @brief Set the IRCS field to a new value. */
#define BW_MCG_C2_IRCS(x, v) (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_IRCS) = (v))
/*@}*/

/*!
 * @name Register MCG_C2, field LP[1] (RW)
 *
 * Controls whether the FLL or PLL is disabled in BLPI and BLPE modes. In FBE or
 * PBE modes, setting this bit to 1 will transition the MCG into BLPE mode; in
 * FBI mode, setting this bit to 1 will transition the MCG into BLPI mode. In any
 * other MCG mode, LP bit has no affect.
 *
 * Values:
 * - 0 - FLL or PLL is not disabled in bypass modes.
 * - 1 - FLL or PLL is disabled in bypass modes (lower power)
 */
/*@{*/
#define BP_MCG_C2_LP         (1U)          /*!< Bit position for MCG_C2_LP. */
#define BM_MCG_C2_LP         (0x02U)       /*!< Bit mask for MCG_C2_LP. */
#define BS_MCG_C2_LP         (1U)          /*!< Bit field size in bits for MCG_C2_LP. */

/*! @brief Read current value of the MCG_C2_LP field. */
#define BR_MCG_C2_LP(x)      (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_LP))

/*! @brief Format value for bitfield MCG_C2_LP. */
#define BF_MCG_C2_LP(v)      ((uint8_t)((uint8_t)(v) << BP_MCG_C2_LP) & BM_MCG_C2_LP)

/*! @brief Set the LP field to a new value. */
#define BW_MCG_C2_LP(x, v)   (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_LP) = (v))
/*@}*/

/*!
 * @name Register MCG_C2, field EREFS[2] (RW)
 *
 * Selects the source for the external reference clock. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0 - External reference clock requested.
 * - 1 - Oscillator requested.
 */
/*@{*/
#define BP_MCG_C2_EREFS      (2U)          /*!< Bit position for MCG_C2_EREFS. */
#define BM_MCG_C2_EREFS      (0x04U)       /*!< Bit mask for MCG_C2_EREFS. */
#define BS_MCG_C2_EREFS      (1U)          /*!< Bit field size in bits for MCG_C2_EREFS. */

/*! @brief Read current value of the MCG_C2_EREFS field. */
#define BR_MCG_C2_EREFS(x)   (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_EREFS))

/*! @brief Format value for bitfield MCG_C2_EREFS. */
#define BF_MCG_C2_EREFS(v)   ((uint8_t)((uint8_t)(v) << BP_MCG_C2_EREFS) & BM_MCG_C2_EREFS)

/*! @brief Set the EREFS field to a new value. */
#define BW_MCG_C2_EREFS(x, v) (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_EREFS) = (v))
/*@}*/

/*!
 * @name Register MCG_C2, field HGO[3] (RW)
 *
 * Controls the crystal oscillator mode of operation. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0 - Configure crystal oscillator for low-power operation.
 * - 1 - Configure crystal oscillator for high-gain operation.
 */
/*@{*/
#define BP_MCG_C2_HGO        (3U)          /*!< Bit position for MCG_C2_HGO. */
#define BM_MCG_C2_HGO        (0x08U)       /*!< Bit mask for MCG_C2_HGO. */
#define BS_MCG_C2_HGO        (1U)          /*!< Bit field size in bits for MCG_C2_HGO. */

/*! @brief Read current value of the MCG_C2_HGO field. */
#define BR_MCG_C2_HGO(x)     (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_HGO))

/*! @brief Format value for bitfield MCG_C2_HGO. */
#define BF_MCG_C2_HGO(v)     ((uint8_t)((uint8_t)(v) << BP_MCG_C2_HGO) & BM_MCG_C2_HGO)

/*! @brief Set the HGO field to a new value. */
#define BW_MCG_C2_HGO(x, v)  (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_HGO) = (v))
/*@}*/

/*!
 * @name Register MCG_C2, field RANGE[5:4] (RW)
 *
 * Selects the frequency range for the crystal oscillator or external clock
 * source. See the Oscillator (OSC) chapter for more details and the device data
 * sheet for the frequency ranges used.
 *
 * Values:
 * - 00 - Encoding 0 - Low frequency range selected for the crystal oscillator .
 * - 01 - Encoding 1 - High frequency range selected for the crystal oscillator .
 */
/*@{*/
#define BP_MCG_C2_RANGE      (4U)          /*!< Bit position for MCG_C2_RANGE. */
#define BM_MCG_C2_RANGE      (0x30U)       /*!< Bit mask for MCG_C2_RANGE. */
#define BS_MCG_C2_RANGE      (2U)          /*!< Bit field size in bits for MCG_C2_RANGE. */

/*! @brief Read current value of the MCG_C2_RANGE field. */
#define BR_MCG_C2_RANGE(x)   (HW_MCG_C2(x).B.RANGE)

/*! @brief Format value for bitfield MCG_C2_RANGE. */
#define BF_MCG_C2_RANGE(v)   ((uint8_t)((uint8_t)(v) << BP_MCG_C2_RANGE) & BM_MCG_C2_RANGE)

/*! @brief Set the RANGE field to a new value. */
#define BW_MCG_C2_RANGE(x, v) (HW_MCG_C2_WR(x, (HW_MCG_C2_RD(x) & ~BM_MCG_C2_RANGE) | BF_MCG_C2_RANGE(v)))
/*@}*/

/*!
 * @name Register MCG_C2, field FCFTRIM[6] (RW)
 *
 * FCFTRIM controls the smallest adjustment of the fast internal reference clock
 * frequency. Setting FCFTRIM increases the period and clearing FCFTRIM
 * decreases the period by the smallest amount possible. If an FCFTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this bit.
 */
/*@{*/
#define BP_MCG_C2_FCFTRIM    (6U)          /*!< Bit position for MCG_C2_FCFTRIM. */
#define BM_MCG_C2_FCFTRIM    (0x40U)       /*!< Bit mask for MCG_C2_FCFTRIM. */
#define BS_MCG_C2_FCFTRIM    (1U)          /*!< Bit field size in bits for MCG_C2_FCFTRIM. */

/*! @brief Read current value of the MCG_C2_FCFTRIM field. */
#define BR_MCG_C2_FCFTRIM(x) (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_FCFTRIM))

/*! @brief Format value for bitfield MCG_C2_FCFTRIM. */
#define BF_MCG_C2_FCFTRIM(v) ((uint8_t)((uint8_t)(v) << BP_MCG_C2_FCFTRIM) & BM_MCG_C2_FCFTRIM)

/*! @brief Set the FCFTRIM field to a new value. */
#define BW_MCG_C2_FCFTRIM(x, v) (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_FCFTRIM) = (v))
/*@}*/

/*!
 * @name Register MCG_C2, field LOCRE0[7] (RW)
 *
 * Determines whether an interrupt or a reset request is made following a loss
 * of OSC0 external reference clock. The LOCRE0 only has an affect when CME0 is
 * set.
 *
 * Values:
 * - 0 - Interrupt request is generated on a loss of OSC0 external reference
 *     clock.
 * - 1 - Generate a reset request on a loss of OSC0 external reference clock.
 */
/*@{*/
#define BP_MCG_C2_LOCRE0     (7U)          /*!< Bit position for MCG_C2_LOCRE0. */
#define BM_MCG_C2_LOCRE0     (0x80U)       /*!< Bit mask for MCG_C2_LOCRE0. */
#define BS_MCG_C2_LOCRE0     (1U)          /*!< Bit field size in bits for MCG_C2_LOCRE0. */

/*! @brief Read current value of the MCG_C2_LOCRE0 field. */
#define BR_MCG_C2_LOCRE0(x)  (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_LOCRE0))

/*! @brief Format value for bitfield MCG_C2_LOCRE0. */
#define BF_MCG_C2_LOCRE0(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_C2_LOCRE0) & BM_MCG_C2_LOCRE0)

/*! @brief Set the LOCRE0 field to a new value. */
#define BW_MCG_C2_LOCRE0(x, v) (BITBAND_ACCESS8(HW_MCG_C2_ADDR(x), BP_MCG_C2_LOCRE0) = (v))
/*@}*/

/*******************************************************************************
 * HW_MCG_C3 - MCG Control 3 Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_C3 - MCG Control 3 Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_c3
{
    uint8_t U;
    struct _hw_mcg_c3_bitfields
    {
        uint8_t SCTRIM : 8;            /*!< [7:0] Slow Internal Reference Clock Trim
                                        * Setting */
    } B;
} hw_mcg_c3_t;

/*!
 * @name Constants and macros for entire MCG_C3 register
 */
/*@{*/
#define HW_MCG_C3_ADDR(x)        ((uint32_t)(x) + 0x2U)

#define HW_MCG_C3(x)             (*(__IO hw_mcg_c3_t *) HW_MCG_C3_ADDR(x))
#define HW_MCG_C3_RD(x)          (HW_MCG_C3(x).U)
#define HW_MCG_C3_WR(x, v)       (HW_MCG_C3(x).U = (v))
#define HW_MCG_C3_SET(x, v)      (HW_MCG_C3_WR(x, HW_MCG_C3_RD(x) |  (v)))
#define HW_MCG_C3_CLR(x, v)      (HW_MCG_C3_WR(x, HW_MCG_C3_RD(x) & ~(v)))
#define HW_MCG_C3_TOG(x, v)      (HW_MCG_C3_WR(x, HW_MCG_C3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_C3 bitfields
 */

/*!
 * @name Register MCG_C3, field SCTRIM[7:0] (RW)
 *
 * SCTRIM A value for SCTRIM is loaded during reset from a factory programmed
 * location. controls the slow internal reference clock frequency by controlling
 * the slow internal reference clock period. The SCTRIM bits are binary weighted,
 * that is, bit 1 adjusts twice as much as bit 0. Increasing the binary value
 * increases the period, and decreasing the value decreases the period. An additional
 * fine trim bit is available in C4 register as the SCFTRIM bit. Upon reset,
 * this value is loaded with a factory trim value. If an SCTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this register.
 */
/*@{*/
#define BP_MCG_C3_SCTRIM     (0U)          /*!< Bit position for MCG_C3_SCTRIM. */
#define BM_MCG_C3_SCTRIM     (0xFFU)       /*!< Bit mask for MCG_C3_SCTRIM. */
#define BS_MCG_C3_SCTRIM     (8U)          /*!< Bit field size in bits for MCG_C3_SCTRIM. */

/*! @brief Read current value of the MCG_C3_SCTRIM field. */
#define BR_MCG_C3_SCTRIM(x)  (HW_MCG_C3(x).U)

/*! @brief Format value for bitfield MCG_C3_SCTRIM. */
#define BF_MCG_C3_SCTRIM(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_C3_SCTRIM) & BM_MCG_C3_SCTRIM)

/*! @brief Set the SCTRIM field to a new value. */
#define BW_MCG_C3_SCTRIM(x, v) (HW_MCG_C3_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_MCG_C4 - MCG Control 4 Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_C4 - MCG Control 4 Register (RW)
 *
 * Reset value: 0x00U
 *
 * Reset values for DRST and DMX32 bits are 0.
 */
typedef union _hw_mcg_c4
{
    uint8_t U;
    struct _hw_mcg_c4_bitfields
    {
        uint8_t SCFTRIM : 1;           /*!< [0] Slow Internal Reference Clock Fine Trim
                                        * */
        uint8_t FCTRIM : 4;            /*!< [4:1] Fast Internal Reference Clock Trim
                                        * Setting */
        uint8_t DRST_DRS : 2;          /*!< [6:5] DCO Range Select */
        uint8_t DMX32 : 1;             /*!< [7] DCO Maximum Frequency with 32.768 kHz
                                        * Reference */
    } B;
} hw_mcg_c4_t;

/*!
 * @name Constants and macros for entire MCG_C4 register
 */
/*@{*/
#define HW_MCG_C4_ADDR(x)        ((uint32_t)(x) + 0x3U)

#define HW_MCG_C4(x)             (*(__IO hw_mcg_c4_t *) HW_MCG_C4_ADDR(x))
#define HW_MCG_C4_RD(x)          (HW_MCG_C4(x).U)
#define HW_MCG_C4_WR(x, v)       (HW_MCG_C4(x).U = (v))
#define HW_MCG_C4_SET(x, v)      (HW_MCG_C4_WR(x, HW_MCG_C4_RD(x) |  (v)))
#define HW_MCG_C4_CLR(x, v)      (HW_MCG_C4_WR(x, HW_MCG_C4_RD(x) & ~(v)))
#define HW_MCG_C4_TOG(x, v)      (HW_MCG_C4_WR(x, HW_MCG_C4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_C4 bitfields
 */

/*!
 * @name Register MCG_C4, field SCFTRIM[0] (RW)
 *
 * SCFTRIM A value for SCFTRIM is loaded during reset from a factory programmed
 * location . controls the smallest adjustment of the slow internal reference
 * clock frequency. Setting SCFTRIM increases the period and clearing SCFTRIM
 * decreases the period by the smallest amount possible. If an SCFTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this bit.
 */
/*@{*/
#define BP_MCG_C4_SCFTRIM    (0U)          /*!< Bit position for MCG_C4_SCFTRIM. */
#define BM_MCG_C4_SCFTRIM    (0x01U)       /*!< Bit mask for MCG_C4_SCFTRIM. */
#define BS_MCG_C4_SCFTRIM    (1U)          /*!< Bit field size in bits for MCG_C4_SCFTRIM. */

/*! @brief Read current value of the MCG_C4_SCFTRIM field. */
#define BR_MCG_C4_SCFTRIM(x) (BITBAND_ACCESS8(HW_MCG_C4_ADDR(x), BP_MCG_C4_SCFTRIM))

/*! @brief Format value for bitfield MCG_C4_SCFTRIM. */
#define BF_MCG_C4_SCFTRIM(v) ((uint8_t)((uint8_t)(v) << BP_MCG_C4_SCFTRIM) & BM_MCG_C4_SCFTRIM)

/*! @brief Set the SCFTRIM field to a new value. */
#define BW_MCG_C4_SCFTRIM(x, v) (BITBAND_ACCESS8(HW_MCG_C4_ADDR(x), BP_MCG_C4_SCFTRIM) = (v))
/*@}*/

/*!
 * @name Register MCG_C4, field FCTRIM[4:1] (RW)
 *
 * FCTRIM A value for FCTRIM is loaded during reset from a factory programmed
 * location. controls the fast internal reference clock frequency by controlling
 * the fast internal reference clock period. The FCTRIM bits are binary weighted,
 * that is, bit 1 adjusts twice as much as bit 0. Increasing the binary value
 * increases the period, and decreasing the value decreases the period. If an
 * FCTRIM[3:0] value stored in nonvolatile memory is to be used, it is your
 * responsibility to copy that value from the nonvolatile memory location to this register.
 */
/*@{*/
#define BP_MCG_C4_FCTRIM     (1U)          /*!< Bit position for MCG_C4_FCTRIM. */
#define BM_MCG_C4_FCTRIM     (0x1EU)       /*!< Bit mask for MCG_C4_FCTRIM. */
#define BS_MCG_C4_FCTRIM     (4U)          /*!< Bit field size in bits for MCG_C4_FCTRIM. */

/*! @brief Read current value of the MCG_C4_FCTRIM field. */
#define BR_MCG_C4_FCTRIM(x)  (HW_MCG_C4(x).B.FCTRIM)

/*! @brief Format value for bitfield MCG_C4_FCTRIM. */
#define BF_MCG_C4_FCTRIM(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_C4_FCTRIM) & BM_MCG_C4_FCTRIM)

/*! @brief Set the FCTRIM field to a new value. */
#define BW_MCG_C4_FCTRIM(x, v) (HW_MCG_C4_WR(x, (HW_MCG_C4_RD(x) & ~BM_MCG_C4_FCTRIM) | BF_MCG_C4_FCTRIM(v)))
/*@}*/

/*!
 * @name Register MCG_C4, field DRST_DRS[6:5] (RW)
 *
 * The DRS bits select the frequency range for the FLL output, DCOOUT. When the
 * LP bit is set, writes to the DRS bits are ignored. The DRST read field
 * indicates the current frequency range for DCOOUT. The DRST field does not update
 * immediately after a write to the DRS field due to internal synchronization between
 * clock domains. See the DCO Frequency Range table for more details.
 *
 * Values:
 * - 00 - Encoding 0 - Low range (reset default).
 * - 01 - Encoding 1 - Mid range.
 * - 10 - Encoding 2 - Mid-high range.
 * - 11 - Encoding 3 - High range.
 */
/*@{*/
#define BP_MCG_C4_DRST_DRS   (5U)          /*!< Bit position for MCG_C4_DRST_DRS. */
#define BM_MCG_C4_DRST_DRS   (0x60U)       /*!< Bit mask for MCG_C4_DRST_DRS. */
#define BS_MCG_C4_DRST_DRS   (2U)          /*!< Bit field size in bits for MCG_C4_DRST_DRS. */

/*! @brief Read current value of the MCG_C4_DRST_DRS field. */
#define BR_MCG_C4_DRST_DRS(x) (HW_MCG_C4(x).B.DRST_DRS)

/*! @brief Format value for bitfield MCG_C4_DRST_DRS. */
#define BF_MCG_C4_DRST_DRS(v) ((uint8_t)((uint8_t)(v) << BP_MCG_C4_DRST_DRS) & BM_MCG_C4_DRST_DRS)

/*! @brief Set the DRST_DRS field to a new value. */
#define BW_MCG_C4_DRST_DRS(x, v) (HW_MCG_C4_WR(x, (HW_MCG_C4_RD(x) & ~BM_MCG_C4_DRST_DRS) | BF_MCG_C4_DRST_DRS(v)))
/*@}*/

/*!
 * @name Register MCG_C4, field DMX32[7] (RW)
 *
 * The DMX32 bit controls whether the DCO frequency range is narrowed to its
 * maximum frequency with a 32.768 kHz reference. The following table identifies
 * settings for the DCO frequency range. The system clocks derived from this source
 * should not exceed their specified maximums. DRST_DRS DMX32 Reference Range FLL
 * Factor DCO Range 00 0 31.25-39.0625 kHz 640 20-25 MHz 1 32.768 kHz 732 24 MHz
 * 01 0 31.25-39.0625 kHz 1280 40-50 MHz 1 32.768 kHz 1464 48 MHz 10 0
 * 31.25-39.0625 kHz 1920 60-75 MHz 1 32.768 kHz 2197 72 MHz 11 0 31.25-39.0625 kHz 2560
 * 80-100 MHz 1 32.768 kHz 2929 96 MHz
 *
 * Values:
 * - 0 - DCO has a default range of 25%.
 * - 1 - DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
 */
/*@{*/
#define BP_MCG_C4_DMX32      (7U)          /*!< Bit position for MCG_C4_DMX32. */
#define BM_MCG_C4_DMX32      (0x80U)       /*!< Bit mask for MCG_C4_DMX32. */
#define BS_MCG_C4_DMX32      (1U)          /*!< Bit field size in bits for MCG_C4_DMX32. */

/*! @brief Read current value of the MCG_C4_DMX32 field. */
#define BR_MCG_C4_DMX32(x)   (BITBAND_ACCESS8(HW_MCG_C4_ADDR(x), BP_MCG_C4_DMX32))

/*! @brief Format value for bitfield MCG_C4_DMX32. */
#define BF_MCG_C4_DMX32(v)   ((uint8_t)((uint8_t)(v) << BP_MCG_C4_DMX32) & BM_MCG_C4_DMX32)

/*! @brief Set the DMX32 field to a new value. */
#define BW_MCG_C4_DMX32(x, v) (BITBAND_ACCESS8(HW_MCG_C4_ADDR(x), BP_MCG_C4_DMX32) = (v))
/*@}*/

/*******************************************************************************
 * HW_MCG_C5 - MCG Control 5 Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_C5 - MCG Control 5 Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_c5
{
    uint8_t U;
    struct _hw_mcg_c5_bitfields
    {
        uint8_t PRDIV0 : 5;            /*!< [4:0] PLL External Reference Divider */
        uint8_t PLLSTEN0 : 1;          /*!< [5] PLL Stop Enable */
        uint8_t PLLCLKEN0 : 1;         /*!< [6] PLL Clock Enable */
        uint8_t RESERVED0 : 1;         /*!< [7]  */
    } B;
} hw_mcg_c5_t;

/*!
 * @name Constants and macros for entire MCG_C5 register
 */
/*@{*/
#define HW_MCG_C5_ADDR(x)        ((uint32_t)(x) + 0x4U)

#define HW_MCG_C5(x)             (*(__IO hw_mcg_c5_t *) HW_MCG_C5_ADDR(x))
#define HW_MCG_C5_RD(x)          (HW_MCG_C5(x).U)
#define HW_MCG_C5_WR(x, v)       (HW_MCG_C5(x).U = (v))
#define HW_MCG_C5_SET(x, v)      (HW_MCG_C5_WR(x, HW_MCG_C5_RD(x) |  (v)))
#define HW_MCG_C5_CLR(x, v)      (HW_MCG_C5_WR(x, HW_MCG_C5_RD(x) & ~(v)))
#define HW_MCG_C5_TOG(x, v)      (HW_MCG_C5_WR(x, HW_MCG_C5_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_C5 bitfields
 */

/*!
 * @name Register MCG_C5, field PRDIV0[4:0] (RW)
 *
 * Selects the amount to divide down the external reference clock for the PLL.
 * The resulting frequency must be in the range of 2 MHz to 4 MHz. After the PLL
 * is enabled (by setting either PLLCLKEN 0 or PLLS), the PRDIV 0 value must not
 * be changed when LOCK0 is zero. PLL External Reference Divide Factor PRDIV 0
 * Divide Factor PRDIV 0 Divide Factor PRDIV 0 Divide Factor PRDIV 0 Divide Factor
 * 00000 1 01000 9 10000 17 11000 25 00001 2 01001 10 10001 18 11001 Reserved
 * 00010 3 01010 11 10010 19 11010 Reserved 00011 4 01011 12 10011 20 11011 Reserved
 * 00100 5 01100 13 10100 21 11100 Reserved 00101 6 01101 14 10101 22 11101
 * Reserved 00110 7 01110 15 10110 23 11110 Reserved 00111 8 01111 16 10111 24 11111
 * Reserved
 */
/*@{*/
#define BP_MCG_C5_PRDIV0     (0U)          /*!< Bit position for MCG_C5_PRDIV0. */
#define BM_MCG_C5_PRDIV0     (0x1FU)       /*!< Bit mask for MCG_C5_PRDIV0. */
#define BS_MCG_C5_PRDIV0     (5U)          /*!< Bit field size in bits for MCG_C5_PRDIV0. */

/*! @brief Read current value of the MCG_C5_PRDIV0 field. */
#define BR_MCG_C5_PRDIV0(x)  (HW_MCG_C5(x).B.PRDIV0)

/*! @brief Format value for bitfield MCG_C5_PRDIV0. */
#define BF_MCG_C5_PRDIV0(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_C5_PRDIV0) & BM_MCG_C5_PRDIV0)

/*! @brief Set the PRDIV0 field to a new value. */
#define BW_MCG_C5_PRDIV0(x, v) (HW_MCG_C5_WR(x, (HW_MCG_C5_RD(x) & ~BM_MCG_C5_PRDIV0) | BF_MCG_C5_PRDIV0(v)))
/*@}*/

/*!
 * @name Register MCG_C5, field PLLSTEN0[5] (RW)
 *
 * Enables the PLL Clock during Normal Stop. In Low Power Stop mode, the PLL
 * clock gets disabled even if PLLSTEN 0 =1. All other power modes, PLLSTEN 0 bit
 * has no affect and does not enable the PLL Clock to run if it is written to 1.
 *
 * Values:
 * - 0 - MCGPLLCLK is disabled in any of the Stop modes.
 * - 1 - MCGPLLCLK is enabled if system is in Normal Stop mode.
 */
/*@{*/
#define BP_MCG_C5_PLLSTEN0   (5U)          /*!< Bit position for MCG_C5_PLLSTEN0. */
#define BM_MCG_C5_PLLSTEN0   (0x20U)       /*!< Bit mask for MCG_C5_PLLSTEN0. */
#define BS_MCG_C5_PLLSTEN0   (1U)          /*!< Bit field size in bits for MCG_C5_PLLSTEN0. */

/*! @brief Read current value of the MCG_C5_PLLSTEN0 field. */
#define BR_MCG_C5_PLLSTEN0(x) (BITBAND_ACCESS8(HW_MCG_C5_ADDR(x), BP_MCG_C5_PLLSTEN0))

/*! @brief Format value for bitfield MCG_C5_PLLSTEN0. */
#define BF_MCG_C5_PLLSTEN0(v) ((uint8_t)((uint8_t)(v) << BP_MCG_C5_PLLSTEN0) & BM_MCG_C5_PLLSTEN0)

/*! @brief Set the PLLSTEN0 field to a new value. */
#define BW_MCG_C5_PLLSTEN0(x, v) (BITBAND_ACCESS8(HW_MCG_C5_ADDR(x), BP_MCG_C5_PLLSTEN0) = (v))
/*@}*/

/*!
 * @name Register MCG_C5, field PLLCLKEN0[6] (RW)
 *
 * Enables the PLL independent of PLLS and enables the PLL clock for use as
 * MCGPLLCLK. (PRDIV 0 needs to be programmed to the correct divider to generate a
 * PLL reference clock in the range of 2 - 4 MHz range prior to setting the
 * PLLCLKEN 0 bit). Setting PLLCLKEN 0 will enable the external oscillator if not
 * already enabled. Whenever the PLL is being enabled by means of the PLLCLKEN 0 bit,
 * and the external oscillator is being used as the reference clock, the OSCINIT 0
 * bit should be checked to make sure it is set.
 *
 * Values:
 * - 0 - MCGPLLCLK is inactive.
 * - 1 - MCGPLLCLK is active.
 */
/*@{*/
#define BP_MCG_C5_PLLCLKEN0  (6U)          /*!< Bit position for MCG_C5_PLLCLKEN0. */
#define BM_MCG_C5_PLLCLKEN0  (0x40U)       /*!< Bit mask for MCG_C5_PLLCLKEN0. */
#define BS_MCG_C5_PLLCLKEN0  (1U)          /*!< Bit field size in bits for MCG_C5_PLLCLKEN0. */

/*! @brief Read current value of the MCG_C5_PLLCLKEN0 field. */
#define BR_MCG_C5_PLLCLKEN0(x) (BITBAND_ACCESS8(HW_MCG_C5_ADDR(x), BP_MCG_C5_PLLCLKEN0))

/*! @brief Format value for bitfield MCG_C5_PLLCLKEN0. */
#define BF_MCG_C5_PLLCLKEN0(v) ((uint8_t)((uint8_t)(v) << BP_MCG_C5_PLLCLKEN0) & BM_MCG_C5_PLLCLKEN0)

/*! @brief Set the PLLCLKEN0 field to a new value. */
#define BW_MCG_C5_PLLCLKEN0(x, v) (BITBAND_ACCESS8(HW_MCG_C5_ADDR(x), BP_MCG_C5_PLLCLKEN0) = (v))
/*@}*/

/*******************************************************************************
 * HW_MCG_C6 - MCG Control 6 Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_C6 - MCG Control 6 Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_c6
{
    uint8_t U;
    struct _hw_mcg_c6_bitfields
    {
        uint8_t VDIV0 : 5;             /*!< [4:0] VCO 0 Divider */
        uint8_t CME0 : 1;              /*!< [5] Clock Monitor Enable */
        uint8_t PLLS : 1;              /*!< [6] PLL Select */
        uint8_t LOLIE0 : 1;            /*!< [7] Loss of Lock Interrrupt Enable */
    } B;
} hw_mcg_c6_t;

/*!
 * @name Constants and macros for entire MCG_C6 register
 */
/*@{*/
#define HW_MCG_C6_ADDR(x)        ((uint32_t)(x) + 0x5U)

#define HW_MCG_C6(x)             (*(__IO hw_mcg_c6_t *) HW_MCG_C6_ADDR(x))
#define HW_MCG_C6_RD(x)          (HW_MCG_C6(x).U)
#define HW_MCG_C6_WR(x, v)       (HW_MCG_C6(x).U = (v))
#define HW_MCG_C6_SET(x, v)      (HW_MCG_C6_WR(x, HW_MCG_C6_RD(x) |  (v)))
#define HW_MCG_C6_CLR(x, v)      (HW_MCG_C6_WR(x, HW_MCG_C6_RD(x) & ~(v)))
#define HW_MCG_C6_TOG(x, v)      (HW_MCG_C6_WR(x, HW_MCG_C6_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_C6 bitfields
 */

/*!
 * @name Register MCG_C6, field VDIV0[4:0] (RW)
 *
 * Selects the amount to divide the VCO output of the PLL. The VDIV 0 bits
 * establish the multiplication factor (M) applied to the reference clock frequency.
 * After the PLL is enabled (by setting either PLLCLKEN 0 or PLLS), the VDIV 0
 * value must not be changed when LOCK 0 is zero. PLL VCO Divide Factor VDIV 0
 * Multiply Factor VDIV 0 Multiply Factor VDIV 0 Multiply Factor VDIV 0 Multiply
 * Factor 00000 24 01000 32 10000 40 11000 48 00001 25 01001 33 10001 41 11001 49
 * 00010 26 01010 34 10010 42 11010 50 00011 27 01011 35 10011 43 11011 51 00100 28
 * 01100 36 10100 44 11100 52 00101 29 01101 37 10101 45 11101 53 00110 30 01110
 * 38 10110 46 11110 54 00111 31 01111 39 10111 47 11111 55
 */
/*@{*/
#define BP_MCG_C6_VDIV0      (0U)          /*!< Bit position for MCG_C6_VDIV0. */
#define BM_MCG_C6_VDIV0      (0x1FU)       /*!< Bit mask for MCG_C6_VDIV0. */
#define BS_MCG_C6_VDIV0      (5U)          /*!< Bit field size in bits for MCG_C6_VDIV0. */

/*! @brief Read current value of the MCG_C6_VDIV0 field. */
#define BR_MCG_C6_VDIV0(x)   (HW_MCG_C6(x).B.VDIV0)

/*! @brief Format value for bitfield MCG_C6_VDIV0. */
#define BF_MCG_C6_VDIV0(v)   ((uint8_t)((uint8_t)(v) << BP_MCG_C6_VDIV0) & BM_MCG_C6_VDIV0)

/*! @brief Set the VDIV0 field to a new value. */
#define BW_MCG_C6_VDIV0(x, v) (HW_MCG_C6_WR(x, (HW_MCG_C6_RD(x) & ~BM_MCG_C6_VDIV0) | BF_MCG_C6_VDIV0(v)))
/*@}*/

/*!
 * @name Register MCG_C6, field CME0[5] (RW)
 *
 * Enables the loss of clock monitoring circuit for the OSC0 external reference
 * mux select. The LOCRE0 bit will determine if a interrupt or a reset request is
 * generated following a loss of OSC0 indication. The CME0 bit must only be set
 * to a logic 1 when the MCG is in an operational mode that uses the external
 * clock (FEE, FBE, PEE, PBE, or BLPE) . Whenever the CME0 bit is set to a logic 1,
 * the value of the RANGE0 bits in the C2 register should not be changed. CME0
 * bit should be set to a logic 0 before the MCG enters any Stop mode. Otherwise, a
 * reset request may occur while in Stop mode. CME0 should also be set to a
 * logic 0 before entering VLPR or VLPW power modes if the MCG is in BLPE mode.
 *
 * Values:
 * - 0 - External clock monitor is disabled for OSC0.
 * - 1 - External clock monitor is enabled for OSC0.
 */
/*@{*/
#define BP_MCG_C6_CME0       (5U)          /*!< Bit position for MCG_C6_CME0. */
#define BM_MCG_C6_CME0       (0x20U)       /*!< Bit mask for MCG_C6_CME0. */
#define BS_MCG_C6_CME0       (1U)          /*!< Bit field size in bits for MCG_C6_CME0. */

/*! @brief Read current value of the MCG_C6_CME0 field. */
#define BR_MCG_C6_CME0(x)    (BITBAND_ACCESS8(HW_MCG_C6_ADDR(x), BP_MCG_C6_CME0))

/*! @brief Format value for bitfield MCG_C6_CME0. */
#define BF_MCG_C6_CME0(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_C6_CME0) & BM_MCG_C6_CME0)

/*! @brief Set the CME0 field to a new value. */
#define BW_MCG_C6_CME0(x, v) (BITBAND_ACCESS8(HW_MCG_C6_ADDR(x), BP_MCG_C6_CME0) = (v))
/*@}*/

/*!
 * @name Register MCG_C6, field PLLS[6] (RW)
 *
 * Controls whether the PLL or FLL output is selected as the MCG source when
 * CLKS[1:0]=00. If the PLLS bit is cleared and PLLCLKEN 0 is not set, the PLL is
 * disabled in all modes. If the PLLS is set, the FLL is disabled in all modes.
 *
 * Values:
 * - 0 - FLL is selected.
 * - 1 - PLL is selected (PRDIV 0 need to be programmed to the correct divider
 *     to generate a PLL reference clock in the range of 2-4 MHz prior to setting
 *     the PLLS bit).
 */
/*@{*/
#define BP_MCG_C6_PLLS       (6U)          /*!< Bit position for MCG_C6_PLLS. */
#define BM_MCG_C6_PLLS       (0x40U)       /*!< Bit mask for MCG_C6_PLLS. */
#define BS_MCG_C6_PLLS       (1U)          /*!< Bit field size in bits for MCG_C6_PLLS. */

/*! @brief Read current value of the MCG_C6_PLLS field. */
#define BR_MCG_C6_PLLS(x)    (BITBAND_ACCESS8(HW_MCG_C6_ADDR(x), BP_MCG_C6_PLLS))

/*! @brief Format value for bitfield MCG_C6_PLLS. */
#define BF_MCG_C6_PLLS(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_C6_PLLS) & BM_MCG_C6_PLLS)

/*! @brief Set the PLLS field to a new value. */
#define BW_MCG_C6_PLLS(x, v) (BITBAND_ACCESS8(HW_MCG_C6_ADDR(x), BP_MCG_C6_PLLS) = (v))
/*@}*/

/*!
 * @name Register MCG_C6, field LOLIE0[7] (RW)
 *
 * Determines if an interrupt request is made following a loss of lock
 * indication. This bit only has an effect when LOLS 0 is set.
 *
 * Values:
 * - 0 - No interrupt request is generated on loss of lock.
 * - 1 - Generate an interrupt request on loss of lock.
 */
/*@{*/
#define BP_MCG_C6_LOLIE0     (7U)          /*!< Bit position for MCG_C6_LOLIE0. */
#define BM_MCG_C6_LOLIE0     (0x80U)       /*!< Bit mask for MCG_C6_LOLIE0. */
#define BS_MCG_C6_LOLIE0     (1U)          /*!< Bit field size in bits for MCG_C6_LOLIE0. */

/*! @brief Read current value of the MCG_C6_LOLIE0 field. */
#define BR_MCG_C6_LOLIE0(x)  (BITBAND_ACCESS8(HW_MCG_C6_ADDR(x), BP_MCG_C6_LOLIE0))

/*! @brief Format value for bitfield MCG_C6_LOLIE0. */
#define BF_MCG_C6_LOLIE0(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_C6_LOLIE0) & BM_MCG_C6_LOLIE0)

/*! @brief Set the LOLIE0 field to a new value. */
#define BW_MCG_C6_LOLIE0(x, v) (BITBAND_ACCESS8(HW_MCG_C6_ADDR(x), BP_MCG_C6_LOLIE0) = (v))
/*@}*/

/*******************************************************************************
 * HW_MCG_S - MCG Status Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_S - MCG Status Register (RW)
 *
 * Reset value: 0x10U
 */
typedef union _hw_mcg_s
{
    uint8_t U;
    struct _hw_mcg_s_bitfields
    {
        uint8_t IRCST : 1;             /*!< [0] Internal Reference Clock Status */
        uint8_t OSCINIT0 : 1;          /*!< [1] OSC Initialization */
        uint8_t CLKST : 2;             /*!< [3:2] Clock Mode Status */
        uint8_t IREFST : 1;            /*!< [4] Internal Reference Status */
        uint8_t PLLST : 1;             /*!< [5] PLL Select Status */
        uint8_t LOCK0 : 1;             /*!< [6] Lock Status */
        uint8_t LOLS0 : 1;             /*!< [7] Loss of Lock Status */
    } B;
} hw_mcg_s_t;

/*!
 * @name Constants and macros for entire MCG_S register
 */
/*@{*/
#define HW_MCG_S_ADDR(x)         ((uint32_t)(x) + 0x6U)

#define HW_MCG_S(x)              (*(__IO hw_mcg_s_t *) HW_MCG_S_ADDR(x))
#define HW_MCG_S_RD(x)           (HW_MCG_S(x).U)
#define HW_MCG_S_WR(x, v)        (HW_MCG_S(x).U = (v))
#define HW_MCG_S_SET(x, v)       (HW_MCG_S_WR(x, HW_MCG_S_RD(x) |  (v)))
#define HW_MCG_S_CLR(x, v)       (HW_MCG_S_WR(x, HW_MCG_S_RD(x) & ~(v)))
#define HW_MCG_S_TOG(x, v)       (HW_MCG_S_WR(x, HW_MCG_S_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_S bitfields
 */

/*!
 * @name Register MCG_S, field IRCST[0] (RO)
 *
 * The IRCST bit indicates the current source for the internal reference clock
 * select clock (IRCSCLK). The IRCST bit does not update immediately after a write
 * to the IRCS bit due to internal synchronization between clock domains. The
 * IRCST bit will only be updated if the internal reference clock is enabled,
 * either by the MCG being in a mode that uses the IRC or by setting the C1[IRCLKEN]
 * bit .
 *
 * Values:
 * - 0 - Source of internal reference clock is the slow clock (32 kHz IRC).
 * - 1 - Source of internal reference clock is the fast clock (4 MHz IRC).
 */
/*@{*/
#define BP_MCG_S_IRCST       (0U)          /*!< Bit position for MCG_S_IRCST. */
#define BM_MCG_S_IRCST       (0x01U)       /*!< Bit mask for MCG_S_IRCST. */
#define BS_MCG_S_IRCST       (1U)          /*!< Bit field size in bits for MCG_S_IRCST. */

/*! @brief Read current value of the MCG_S_IRCST field. */
#define BR_MCG_S_IRCST(x)    (BITBAND_ACCESS8(HW_MCG_S_ADDR(x), BP_MCG_S_IRCST))
/*@}*/

/*!
 * @name Register MCG_S, field OSCINIT0[1] (RO)
 *
 * This bit, which resets to 0, is set to 1 after the initialization cycles of
 * the crystal oscillator clock have completed. After being set, the bit is
 * cleared to 0 if the OSC is subsequently disabled. See the OSC module's detailed
 * description for more information.
 */
/*@{*/
#define BP_MCG_S_OSCINIT0    (1U)          /*!< Bit position for MCG_S_OSCINIT0. */
#define BM_MCG_S_OSCINIT0    (0x02U)       /*!< Bit mask for MCG_S_OSCINIT0. */
#define BS_MCG_S_OSCINIT0    (1U)          /*!< Bit field size in bits for MCG_S_OSCINIT0. */

/*! @brief Read current value of the MCG_S_OSCINIT0 field. */
#define BR_MCG_S_OSCINIT0(x) (BITBAND_ACCESS8(HW_MCG_S_ADDR(x), BP_MCG_S_OSCINIT0))
/*@}*/

/*!
 * @name Register MCG_S, field CLKST[3:2] (RO)
 *
 * These bits indicate the current clock mode. The CLKST bits do not update
 * immediately after a write to the CLKS bits due to internal synchronization between
 * clock domains.
 *
 * Values:
 * - 00 - Encoding 0 - Output of the FLL is selected (reset default).
 * - 01 - Encoding 1 - Internal reference clock is selected.
 * - 10 - Encoding 2 - External reference clock is selected.
 * - 11 - Encoding 3 - Output of the PLL is selected.
 */
/*@{*/
#define BP_MCG_S_CLKST       (2U)          /*!< Bit position for MCG_S_CLKST. */
#define BM_MCG_S_CLKST       (0x0CU)       /*!< Bit mask for MCG_S_CLKST. */
#define BS_MCG_S_CLKST       (2U)          /*!< Bit field size in bits for MCG_S_CLKST. */

/*! @brief Read current value of the MCG_S_CLKST field. */
#define BR_MCG_S_CLKST(x)    (HW_MCG_S(x).B.CLKST)
/*@}*/

/*!
 * @name Register MCG_S, field IREFST[4] (RO)
 *
 * This bit indicates the current source for the FLL reference clock. The IREFST
 * bit does not update immediately after a write to the IREFS bit due to
 * internal synchronization between clock domains.
 *
 * Values:
 * - 0 - Source of FLL reference clock is the external reference clock.
 * - 1 - Source of FLL reference clock is the internal reference clock.
 */
/*@{*/
#define BP_MCG_S_IREFST      (4U)          /*!< Bit position for MCG_S_IREFST. */
#define BM_MCG_S_IREFST      (0x10U)       /*!< Bit mask for MCG_S_IREFST. */
#define BS_MCG_S_IREFST      (1U)          /*!< Bit field size in bits for MCG_S_IREFST. */

/*! @brief Read current value of the MCG_S_IREFST field. */
#define BR_MCG_S_IREFST(x)   (BITBAND_ACCESS8(HW_MCG_S_ADDR(x), BP_MCG_S_IREFST))
/*@}*/

/*!
 * @name Register MCG_S, field PLLST[5] (RO)
 *
 * This bit indicates the clock source selected by PLLS . The PLLST bit does not
 * update immediately after a write to the PLLS bit due to internal
 * synchronization between clock domains.
 *
 * Values:
 * - 0 - Source of PLLS clock is FLL clock.
 * - 1 - Source of PLLS clock is PLL output clock.
 */
/*@{*/
#define BP_MCG_S_PLLST       (5U)          /*!< Bit position for MCG_S_PLLST. */
#define BM_MCG_S_PLLST       (0x20U)       /*!< Bit mask for MCG_S_PLLST. */
#define BS_MCG_S_PLLST       (1U)          /*!< Bit field size in bits for MCG_S_PLLST. */

/*! @brief Read current value of the MCG_S_PLLST field. */
#define BR_MCG_S_PLLST(x)    (BITBAND_ACCESS8(HW_MCG_S_ADDR(x), BP_MCG_S_PLLST))
/*@}*/

/*!
 * @name Register MCG_S, field LOCK0[6] (RO)
 *
 * This bit indicates whether the PLL has acquired lock. Lock detection is only
 * enabled when the PLL is enabled (either through clock mode selection or
 * PLLCLKEN0=1 setting). While the PLL clock is locking to the desired frequency, the
 * MCG PLL clock (MCGPLLCLK) will be gated off until the LOCK bit gets asserted.
 * If the lock status bit is set, changing the value of the PRDIV0 [4:0] bits in
 * the C5 register or the VDIV0[4:0] bits in the C6 register causes the lock
 * status bit to clear and stay cleared until the PLL has reacquired lock. Loss of PLL
 * reference clock will also cause the LOCK0 bit to clear until the PLL has
 * reacquired lock. Entry into LLS, VLPS, or regular Stop with PLLSTEN=0 also causes
 * the lock status bit to clear and stay cleared until the Stop mode is exited
 * and the PLL has reacquired lock. Any time the PLL is enabled and the LOCK0 bit
 * is cleared, the MCGPLLCLK will be gated off until the LOCK0 bit is asserted
 * again.
 *
 * Values:
 * - 0 - PLL is currently unlocked.
 * - 1 - PLL is currently locked.
 */
/*@{*/
#define BP_MCG_S_LOCK0       (6U)          /*!< Bit position for MCG_S_LOCK0. */
#define BM_MCG_S_LOCK0       (0x40U)       /*!< Bit mask for MCG_S_LOCK0. */
#define BS_MCG_S_LOCK0       (1U)          /*!< Bit field size in bits for MCG_S_LOCK0. */

/*! @brief Read current value of the MCG_S_LOCK0 field. */
#define BR_MCG_S_LOCK0(x)    (BITBAND_ACCESS8(HW_MCG_S_ADDR(x), BP_MCG_S_LOCK0))
/*@}*/

/*!
 * @name Register MCG_S, field LOLS0[7] (W1C)
 *
 * This bit is a sticky bit indicating the lock status for the PLL. LOLS is set
 * if after acquiring lock, the PLL output frequency has fallen outside the lock
 * exit frequency tolerance, D unl . LOLIE determines whether an interrupt
 * request is made when LOLS is set. LOLRE determines whether a reset request is made
 * when LOLS is set. This bit is cleared by reset or by writing a logic 1 to it
 * when set. Writing a logic 0 to this bit has no effect.
 *
 * Values:
 * - 0 - PLL has not lost lock since LOLS 0 was last cleared.
 * - 1 - PLL has lost lock since LOLS 0 was last cleared.
 */
/*@{*/
#define BP_MCG_S_LOLS0       (7U)          /*!< Bit position for MCG_S_LOLS0. */
#define BM_MCG_S_LOLS0       (0x80U)       /*!< Bit mask for MCG_S_LOLS0. */
#define BS_MCG_S_LOLS0       (1U)          /*!< Bit field size in bits for MCG_S_LOLS0. */

/*! @brief Read current value of the MCG_S_LOLS0 field. */
#define BR_MCG_S_LOLS0(x)    (BITBAND_ACCESS8(HW_MCG_S_ADDR(x), BP_MCG_S_LOLS0))

/*! @brief Format value for bitfield MCG_S_LOLS0. */
#define BF_MCG_S_LOLS0(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_S_LOLS0) & BM_MCG_S_LOLS0)

/*! @brief Set the LOLS0 field to a new value. */
#define BW_MCG_S_LOLS0(x, v) (BITBAND_ACCESS8(HW_MCG_S_ADDR(x), BP_MCG_S_LOLS0) = (v))
/*@}*/

/*******************************************************************************
 * HW_MCG_SC - MCG Status and Control Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_SC - MCG Status and Control Register (RW)
 *
 * Reset value: 0x02U
 */
typedef union _hw_mcg_sc
{
    uint8_t U;
    struct _hw_mcg_sc_bitfields
    {
        uint8_t LOCS0 : 1;             /*!< [0] OSC0 Loss of Clock Status */
        uint8_t FCRDIV : 3;            /*!< [3:1] Fast Clock Internal Reference Divider
                                        * */
        uint8_t FLTPRSRV : 1;          /*!< [4] FLL Filter Preserve Enable */
        uint8_t ATMF : 1;              /*!< [5] Automatic Trim Machine Fail Flag */
        uint8_t ATMS : 1;              /*!< [6] Automatic Trim Machine Select */
        uint8_t ATME : 1;              /*!< [7] Automatic Trim Machine Enable */
    } B;
} hw_mcg_sc_t;

/*!
 * @name Constants and macros for entire MCG_SC register
 */
/*@{*/
#define HW_MCG_SC_ADDR(x)        ((uint32_t)(x) + 0x8U)

#define HW_MCG_SC(x)             (*(__IO hw_mcg_sc_t *) HW_MCG_SC_ADDR(x))
#define HW_MCG_SC_RD(x)          (HW_MCG_SC(x).U)
#define HW_MCG_SC_WR(x, v)       (HW_MCG_SC(x).U = (v))
#define HW_MCG_SC_SET(x, v)      (HW_MCG_SC_WR(x, HW_MCG_SC_RD(x) |  (v)))
#define HW_MCG_SC_CLR(x, v)      (HW_MCG_SC_WR(x, HW_MCG_SC_RD(x) & ~(v)))
#define HW_MCG_SC_TOG(x, v)      (HW_MCG_SC_WR(x, HW_MCG_SC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_SC bitfields
 */

/*!
 * @name Register MCG_SC, field LOCS0[0] (W1C)
 *
 * The LOCS0 indicates when a loss of OSC0 reference clock has occurred. The
 * LOCS0 bit only has an effect when CME0 is set. This bit is cleared by writing a
 * logic 1 to it when set.
 *
 * Values:
 * - 0 - Loss of OSC0 has not occurred.
 * - 1 - Loss of OSC0 has occurred.
 */
/*@{*/
#define BP_MCG_SC_LOCS0      (0U)          /*!< Bit position for MCG_SC_LOCS0. */
#define BM_MCG_SC_LOCS0      (0x01U)       /*!< Bit mask for MCG_SC_LOCS0. */
#define BS_MCG_SC_LOCS0      (1U)          /*!< Bit field size in bits for MCG_SC_LOCS0. */

/*! @brief Read current value of the MCG_SC_LOCS0 field. */
#define BR_MCG_SC_LOCS0(x)   (BITBAND_ACCESS8(HW_MCG_SC_ADDR(x), BP_MCG_SC_LOCS0))

/*! @brief Format value for bitfield MCG_SC_LOCS0. */
#define BF_MCG_SC_LOCS0(v)   ((uint8_t)((uint8_t)(v) << BP_MCG_SC_LOCS0) & BM_MCG_SC_LOCS0)

/*! @brief Set the LOCS0 field to a new value. */
#define BW_MCG_SC_LOCS0(x, v) (BITBAND_ACCESS8(HW_MCG_SC_ADDR(x), BP_MCG_SC_LOCS0) = (v))
/*@}*/

/*!
 * @name Register MCG_SC, field FCRDIV[3:1] (RW)
 *
 * Selects the amount to divide down the fast internal reference clock. The
 * resulting frequency will be in the range 31.25 kHz to 4 MHz (Note: Changing the
 * divider when the Fast IRC is enabled is not supported).
 *
 * Values:
 * - 000 - Divide Factor is 1
 * - 001 - Divide Factor is 2.
 * - 010 - Divide Factor is 4.
 * - 011 - Divide Factor is 8.
 * - 100 - Divide Factor is 16
 * - 101 - Divide Factor is 32
 * - 110 - Divide Factor is 64
 * - 111 - Divide Factor is 128.
 */
/*@{*/
#define BP_MCG_SC_FCRDIV     (1U)          /*!< Bit position for MCG_SC_FCRDIV. */
#define BM_MCG_SC_FCRDIV     (0x0EU)       /*!< Bit mask for MCG_SC_FCRDIV. */
#define BS_MCG_SC_FCRDIV     (3U)          /*!< Bit field size in bits for MCG_SC_FCRDIV. */

/*! @brief Read current value of the MCG_SC_FCRDIV field. */
#define BR_MCG_SC_FCRDIV(x)  (HW_MCG_SC(x).B.FCRDIV)

/*! @brief Format value for bitfield MCG_SC_FCRDIV. */
#define BF_MCG_SC_FCRDIV(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_SC_FCRDIV) & BM_MCG_SC_FCRDIV)

/*! @brief Set the FCRDIV field to a new value. */
#define BW_MCG_SC_FCRDIV(x, v) (HW_MCG_SC_WR(x, (HW_MCG_SC_RD(x) & ~BM_MCG_SC_FCRDIV) | BF_MCG_SC_FCRDIV(v)))
/*@}*/

/*!
 * @name Register MCG_SC, field FLTPRSRV[4] (RW)
 *
 * This bit will prevent the FLL filter values from resetting allowing the FLL
 * output frequency to remain the same during clock mode changes where the FLL/DCO
 * output is still valid. (Note: This requires that the FLL reference frequency
 * to remain the same as what it was prior to the new clock mode switch.
 * Otherwise FLL filter and frequency values will change.)
 *
 * Values:
 * - 0 - FLL filter and FLL frequency will reset on changes to currect clock
 *     mode.
 * - 1 - Fll filter and FLL frequency retain their previous values during new
 *     clock mode change.
 */
/*@{*/
#define BP_MCG_SC_FLTPRSRV   (4U)          /*!< Bit position for MCG_SC_FLTPRSRV. */
#define BM_MCG_SC_FLTPRSRV   (0x10U)       /*!< Bit mask for MCG_SC_FLTPRSRV. */
#define BS_MCG_SC_FLTPRSRV   (1U)          /*!< Bit field size in bits for MCG_SC_FLTPRSRV. */

/*! @brief Read current value of the MCG_SC_FLTPRSRV field. */
#define BR_MCG_SC_FLTPRSRV(x) (BITBAND_ACCESS8(HW_MCG_SC_ADDR(x), BP_MCG_SC_FLTPRSRV))

/*! @brief Format value for bitfield MCG_SC_FLTPRSRV. */
#define BF_MCG_SC_FLTPRSRV(v) ((uint8_t)((uint8_t)(v) << BP_MCG_SC_FLTPRSRV) & BM_MCG_SC_FLTPRSRV)

/*! @brief Set the FLTPRSRV field to a new value. */
#define BW_MCG_SC_FLTPRSRV(x, v) (BITBAND_ACCESS8(HW_MCG_SC_ADDR(x), BP_MCG_SC_FLTPRSRV) = (v))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMF[5] (RW)
 *
 * Fail flag for the Automatic Trim Machine (ATM). This bit asserts when the
 * Automatic Trim Machine is enabled, ATME=1, and a write to the C1, C3, C4, and SC
 * registers is detected or the MCG enters into any Stop mode. A write to ATMF
 * clears the flag.
 *
 * Values:
 * - 0 - Automatic Trim Machine completed normally.
 * - 1 - Automatic Trim Machine failed.
 */
/*@{*/
#define BP_MCG_SC_ATMF       (5U)          /*!< Bit position for MCG_SC_ATMF. */
#define BM_MCG_SC_ATMF       (0x20U)       /*!< Bit mask for MCG_SC_ATMF. */
#define BS_MCG_SC_ATMF       (1U)          /*!< Bit field size in bits for MCG_SC_ATMF. */

/*! @brief Read current value of the MCG_SC_ATMF field. */
#define BR_MCG_SC_ATMF(x)    (BITBAND_ACCESS8(HW_MCG_SC_ADDR(x), BP_MCG_SC_ATMF))

/*! @brief Format value for bitfield MCG_SC_ATMF. */
#define BF_MCG_SC_ATMF(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_SC_ATMF) & BM_MCG_SC_ATMF)

/*! @brief Set the ATMF field to a new value. */
#define BW_MCG_SC_ATMF(x, v) (BITBAND_ACCESS8(HW_MCG_SC_ADDR(x), BP_MCG_SC_ATMF) = (v))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMS[6] (RW)
 *
 * Selects the IRCS clock for Auto Trim Test.
 *
 * Values:
 * - 0 - 32 kHz Internal Reference Clock selected.
 * - 1 - 4 MHz Internal Reference Clock selected.
 */
/*@{*/
#define BP_MCG_SC_ATMS       (6U)          /*!< Bit position for MCG_SC_ATMS. */
#define BM_MCG_SC_ATMS       (0x40U)       /*!< Bit mask for MCG_SC_ATMS. */
#define BS_MCG_SC_ATMS       (1U)          /*!< Bit field size in bits for MCG_SC_ATMS. */

/*! @brief Read current value of the MCG_SC_ATMS field. */
#define BR_MCG_SC_ATMS(x)    (BITBAND_ACCESS8(HW_MCG_SC_ADDR(x), BP_MCG_SC_ATMS))

/*! @brief Format value for bitfield MCG_SC_ATMS. */
#define BF_MCG_SC_ATMS(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_SC_ATMS) & BM_MCG_SC_ATMS)

/*! @brief Set the ATMS field to a new value. */
#define BW_MCG_SC_ATMS(x, v) (BITBAND_ACCESS8(HW_MCG_SC_ADDR(x), BP_MCG_SC_ATMS) = (v))
/*@}*/

/*!
 * @name Register MCG_SC, field ATME[7] (RW)
 *
 * Enables the Auto Trim Machine to start automatically trimming the selected
 * Internal Reference Clock. ATME deasserts after the Auto Trim Machine has
 * completed trimming all trim bits of the IRCS clock selected by the ATMS bit. Writing
 * to C1, C3, C4, and SC registers or entering Stop mode aborts the auto trim
 * operation and clears this bit.
 *
 * Values:
 * - 0 - Auto Trim Machine disabled.
 * - 1 - Auto Trim Machine enabled.
 */
/*@{*/
#define BP_MCG_SC_ATME       (7U)          /*!< Bit position for MCG_SC_ATME. */
#define BM_MCG_SC_ATME       (0x80U)       /*!< Bit mask for MCG_SC_ATME. */
#define BS_MCG_SC_ATME       (1U)          /*!< Bit field size in bits for MCG_SC_ATME. */

/*! @brief Read current value of the MCG_SC_ATME field. */
#define BR_MCG_SC_ATME(x)    (BITBAND_ACCESS8(HW_MCG_SC_ADDR(x), BP_MCG_SC_ATME))

/*! @brief Format value for bitfield MCG_SC_ATME. */
#define BF_MCG_SC_ATME(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_SC_ATME) & BM_MCG_SC_ATME)

/*! @brief Set the ATME field to a new value. */
#define BW_MCG_SC_ATME(x, v) (BITBAND_ACCESS8(HW_MCG_SC_ADDR(x), BP_MCG_SC_ATME) = (v))
/*@}*/

/*******************************************************************************
 * HW_MCG_ATCVH - MCG Auto Trim Compare Value High Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_ATCVH - MCG Auto Trim Compare Value High Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_atcvh
{
    uint8_t U;
    struct _hw_mcg_atcvh_bitfields
    {
        uint8_t ATCVH : 8;             /*!< [7:0] ATM Compare Value High */
    } B;
} hw_mcg_atcvh_t;

/*!
 * @name Constants and macros for entire MCG_ATCVH register
 */
/*@{*/
#define HW_MCG_ATCVH_ADDR(x)     ((uint32_t)(x) + 0xAU)

#define HW_MCG_ATCVH(x)          (*(__IO hw_mcg_atcvh_t *) HW_MCG_ATCVH_ADDR(x))
#define HW_MCG_ATCVH_RD(x)       (HW_MCG_ATCVH(x).U)
#define HW_MCG_ATCVH_WR(x, v)    (HW_MCG_ATCVH(x).U = (v))
#define HW_MCG_ATCVH_SET(x, v)   (HW_MCG_ATCVH_WR(x, HW_MCG_ATCVH_RD(x) |  (v)))
#define HW_MCG_ATCVH_CLR(x, v)   (HW_MCG_ATCVH_WR(x, HW_MCG_ATCVH_RD(x) & ~(v)))
#define HW_MCG_ATCVH_TOG(x, v)   (HW_MCG_ATCVH_WR(x, HW_MCG_ATCVH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_ATCVH bitfields
 */

/*!
 * @name Register MCG_ATCVH, field ATCVH[7:0] (RW)
 *
 * Values are used by Auto Trim Machine to compare and adjust Internal Reference
 * trim values during ATM SAR conversion.
 */
/*@{*/
#define BP_MCG_ATCVH_ATCVH   (0U)          /*!< Bit position for MCG_ATCVH_ATCVH. */
#define BM_MCG_ATCVH_ATCVH   (0xFFU)       /*!< Bit mask for MCG_ATCVH_ATCVH. */
#define BS_MCG_ATCVH_ATCVH   (8U)          /*!< Bit field size in bits for MCG_ATCVH_ATCVH. */

/*! @brief Read current value of the MCG_ATCVH_ATCVH field. */
#define BR_MCG_ATCVH_ATCVH(x) (HW_MCG_ATCVH(x).U)

/*! @brief Format value for bitfield MCG_ATCVH_ATCVH. */
#define BF_MCG_ATCVH_ATCVH(v) ((uint8_t)((uint8_t)(v) << BP_MCG_ATCVH_ATCVH) & BM_MCG_ATCVH_ATCVH)

/*! @brief Set the ATCVH field to a new value. */
#define BW_MCG_ATCVH_ATCVH(x, v) (HW_MCG_ATCVH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_ATCVL - MCG Auto Trim Compare Value Low Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_atcvl
{
    uint8_t U;
    struct _hw_mcg_atcvl_bitfields
    {
        uint8_t ATCVL : 8;             /*!< [7:0] ATM Compare Value Low */
    } B;
} hw_mcg_atcvl_t;

/*!
 * @name Constants and macros for entire MCG_ATCVL register
 */
/*@{*/
#define HW_MCG_ATCVL_ADDR(x)     ((uint32_t)(x) + 0xBU)

#define HW_MCG_ATCVL(x)          (*(__IO hw_mcg_atcvl_t *) HW_MCG_ATCVL_ADDR(x))
#define HW_MCG_ATCVL_RD(x)       (HW_MCG_ATCVL(x).U)
#define HW_MCG_ATCVL_WR(x, v)    (HW_MCG_ATCVL(x).U = (v))
#define HW_MCG_ATCVL_SET(x, v)   (HW_MCG_ATCVL_WR(x, HW_MCG_ATCVL_RD(x) |  (v)))
#define HW_MCG_ATCVL_CLR(x, v)   (HW_MCG_ATCVL_WR(x, HW_MCG_ATCVL_RD(x) & ~(v)))
#define HW_MCG_ATCVL_TOG(x, v)   (HW_MCG_ATCVL_WR(x, HW_MCG_ATCVL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_ATCVL bitfields
 */

/*!
 * @name Register MCG_ATCVL, field ATCVL[7:0] (RW)
 *
 * Values are used by Auto Trim Machine to compare and adjust Internal Reference
 * trim values during ATM SAR conversion.
 */
/*@{*/
#define BP_MCG_ATCVL_ATCVL   (0U)          /*!< Bit position for MCG_ATCVL_ATCVL. */
#define BM_MCG_ATCVL_ATCVL   (0xFFU)       /*!< Bit mask for MCG_ATCVL_ATCVL. */
#define BS_MCG_ATCVL_ATCVL   (8U)          /*!< Bit field size in bits for MCG_ATCVL_ATCVL. */

/*! @brief Read current value of the MCG_ATCVL_ATCVL field. */
#define BR_MCG_ATCVL_ATCVL(x) (HW_MCG_ATCVL(x).U)

/*! @brief Format value for bitfield MCG_ATCVL_ATCVL. */
#define BF_MCG_ATCVL_ATCVL(v) ((uint8_t)((uint8_t)(v) << BP_MCG_ATCVL_ATCVL) & BM_MCG_ATCVL_ATCVL)

/*! @brief Set the ATCVL field to a new value. */
#define BW_MCG_ATCVL_ATCVL(x, v) (HW_MCG_ATCVL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_MCG_C7 - MCG Control 7 Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_C7 - MCG Control 7 Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_mcg_c7
{
    uint8_t U;
    struct _hw_mcg_c7_bitfields
    {
        uint8_t OSCSEL : 2;            /*!< [1:0] MCG OSC Clock Select */
        uint8_t RESERVED0 : 6;         /*!< [7:2]  */
    } B;
} hw_mcg_c7_t;

/*!
 * @name Constants and macros for entire MCG_C7 register
 */
/*@{*/
#define HW_MCG_C7_ADDR(x)        ((uint32_t)(x) + 0xCU)

#define HW_MCG_C7(x)             (*(__IO hw_mcg_c7_t *) HW_MCG_C7_ADDR(x))
#define HW_MCG_C7_RD(x)          (HW_MCG_C7(x).U)
#define HW_MCG_C7_WR(x, v)       (HW_MCG_C7(x).U = (v))
#define HW_MCG_C7_SET(x, v)      (HW_MCG_C7_WR(x, HW_MCG_C7_RD(x) |  (v)))
#define HW_MCG_C7_CLR(x, v)      (HW_MCG_C7_WR(x, HW_MCG_C7_RD(x) & ~(v)))
#define HW_MCG_C7_TOG(x, v)      (HW_MCG_C7_WR(x, HW_MCG_C7_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_C7 bitfields
 */

/*!
 * @name Register MCG_C7, field OSCSEL[1:0] (RW)
 *
 * Selects the MCG FLL external reference clock
 *
 * Values:
 * - 00 - Selects Oscillator (OSCCLK0).
 * - 01 - Selects 32 kHz RTC Oscillator.
 * - 10 - Selects Oscillator (OSCCLK1).
 * - 11 - RESERVED
 */
/*@{*/
#define BP_MCG_C7_OSCSEL     (0U)          /*!< Bit position for MCG_C7_OSCSEL. */
#define BM_MCG_C7_OSCSEL     (0x03U)       /*!< Bit mask for MCG_C7_OSCSEL. */
#define BS_MCG_C7_OSCSEL     (2U)          /*!< Bit field size in bits for MCG_C7_OSCSEL. */

/*! @brief Read current value of the MCG_C7_OSCSEL field. */
#define BR_MCG_C7_OSCSEL(x)  (HW_MCG_C7(x).B.OSCSEL)

/*! @brief Format value for bitfield MCG_C7_OSCSEL. */
#define BF_MCG_C7_OSCSEL(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_C7_OSCSEL) & BM_MCG_C7_OSCSEL)

/*! @brief Set the OSCSEL field to a new value. */
#define BW_MCG_C7_OSCSEL(x, v) (HW_MCG_C7_WR(x, (HW_MCG_C7_RD(x) & ~BM_MCG_C7_OSCSEL) | BF_MCG_C7_OSCSEL(v)))
/*@}*/

/*******************************************************************************
 * HW_MCG_C8 - MCG Control 8 Register
 ******************************************************************************/

/*!
 * @brief HW_MCG_C8 - MCG Control 8 Register (RW)
 *
 * Reset value: 0x80U
 */
typedef union _hw_mcg_c8
{
    uint8_t U;
    struct _hw_mcg_c8_bitfields
    {
        uint8_t LOCS1 : 1;             /*!< [0] RTC Loss of Clock Status */
        uint8_t RESERVED0 : 4;         /*!< [4:1]  */
        uint8_t CME1 : 1;              /*!< [5] Clock Monitor Enable1 */
        uint8_t LOLRE : 1;             /*!< [6] PLL Loss of Lock Reset Enable */
        uint8_t LOCRE1 : 1;            /*!< [7] Loss of Clock Reset Enable */
    } B;
} hw_mcg_c8_t;

/*!
 * @name Constants and macros for entire MCG_C8 register
 */
/*@{*/
#define HW_MCG_C8_ADDR(x)        ((uint32_t)(x) + 0xDU)

#define HW_MCG_C8(x)             (*(__IO hw_mcg_c8_t *) HW_MCG_C8_ADDR(x))
#define HW_MCG_C8_RD(x)          (HW_MCG_C8(x).U)
#define HW_MCG_C8_WR(x, v)       (HW_MCG_C8(x).U = (v))
#define HW_MCG_C8_SET(x, v)      (HW_MCG_C8_WR(x, HW_MCG_C8_RD(x) |  (v)))
#define HW_MCG_C8_CLR(x, v)      (HW_MCG_C8_WR(x, HW_MCG_C8_RD(x) & ~(v)))
#define HW_MCG_C8_TOG(x, v)      (HW_MCG_C8_WR(x, HW_MCG_C8_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCG_C8 bitfields
 */

/*!
 * @name Register MCG_C8, field LOCS1[0] (W1C)
 *
 * This bit indicates when a loss of clock has occurred. This bit is cleared by
 * writing a logic 1 to it when set.
 *
 * Values:
 * - 0 - Loss of RTC has not occur.
 * - 1 - Loss of RTC has occur
 */
/*@{*/
#define BP_MCG_C8_LOCS1      (0U)          /*!< Bit position for MCG_C8_LOCS1. */
#define BM_MCG_C8_LOCS1      (0x01U)       /*!< Bit mask for MCG_C8_LOCS1. */
#define BS_MCG_C8_LOCS1      (1U)          /*!< Bit field size in bits for MCG_C8_LOCS1. */

/*! @brief Read current value of the MCG_C8_LOCS1 field. */
#define BR_MCG_C8_LOCS1(x)   (BITBAND_ACCESS8(HW_MCG_C8_ADDR(x), BP_MCG_C8_LOCS1))

/*! @brief Format value for bitfield MCG_C8_LOCS1. */
#define BF_MCG_C8_LOCS1(v)   ((uint8_t)((uint8_t)(v) << BP_MCG_C8_LOCS1) & BM_MCG_C8_LOCS1)

/*! @brief Set the LOCS1 field to a new value. */
#define BW_MCG_C8_LOCS1(x, v) (BITBAND_ACCESS8(HW_MCG_C8_ADDR(x), BP_MCG_C8_LOCS1) = (v))
/*@}*/

/*!
 * @name Register MCG_C8, field CME1[5] (RW)
 *
 * Enables the loss of clock monitoring circuit for the output of the RTC
 * external reference clock. The LOCRE1 bit will determine whether an interrupt or a
 * reset request is generated following a loss of RTC clock indication. The CME1
 * bit should be set to a logic 1 when the MCG is in an operational mode that uses
 * the RTC as its external reference clock or if the RTC is operational. CME1 bit
 * must be set to a logic 0 before the MCG enters any Stop mode. Otherwise, a
 * reset request may occur when in Stop mode. CME1 should also be set to a logic 0
 * before entering VLPR or VLPW power modes.
 *
 * Values:
 * - 0 - External clock monitor is disabled for RTC clock.
 * - 1 - External clock monitor is enabled for RTC clock.
 */
/*@{*/
#define BP_MCG_C8_CME1       (5U)          /*!< Bit position for MCG_C8_CME1. */
#define BM_MCG_C8_CME1       (0x20U)       /*!< Bit mask for MCG_C8_CME1. */
#define BS_MCG_C8_CME1       (1U)          /*!< Bit field size in bits for MCG_C8_CME1. */

/*! @brief Read current value of the MCG_C8_CME1 field. */
#define BR_MCG_C8_CME1(x)    (BITBAND_ACCESS8(HW_MCG_C8_ADDR(x), BP_MCG_C8_CME1))

/*! @brief Format value for bitfield MCG_C8_CME1. */
#define BF_MCG_C8_CME1(v)    ((uint8_t)((uint8_t)(v) << BP_MCG_C8_CME1) & BM_MCG_C8_CME1)

/*! @brief Set the CME1 field to a new value. */
#define BW_MCG_C8_CME1(x, v) (BITBAND_ACCESS8(HW_MCG_C8_ADDR(x), BP_MCG_C8_CME1) = (v))
/*@}*/

/*!
 * @name Register MCG_C8, field LOLRE[6] (RW)
 *
 * Determines if an interrupt or a reset request is made following a PLL loss of
 * lock.
 *
 * Values:
 * - 0 - Interrupt request is generated on a PLL loss of lock indication. The
 *     PLL loss of lock interrupt enable bit must also be set to generate the
 *     interrupt request.
 * - 1 - Generate a reset request on a PLL loss of lock indication.
 */
/*@{*/
#define BP_MCG_C8_LOLRE      (6U)          /*!< Bit position for MCG_C8_LOLRE. */
#define BM_MCG_C8_LOLRE      (0x40U)       /*!< Bit mask for MCG_C8_LOLRE. */
#define BS_MCG_C8_LOLRE      (1U)          /*!< Bit field size in bits for MCG_C8_LOLRE. */

/*! @brief Read current value of the MCG_C8_LOLRE field. */
#define BR_MCG_C8_LOLRE(x)   (BITBAND_ACCESS8(HW_MCG_C8_ADDR(x), BP_MCG_C8_LOLRE))

/*! @brief Format value for bitfield MCG_C8_LOLRE. */
#define BF_MCG_C8_LOLRE(v)   ((uint8_t)((uint8_t)(v) << BP_MCG_C8_LOLRE) & BM_MCG_C8_LOLRE)

/*! @brief Set the LOLRE field to a new value. */
#define BW_MCG_C8_LOLRE(x, v) (BITBAND_ACCESS8(HW_MCG_C8_ADDR(x), BP_MCG_C8_LOLRE) = (v))
/*@}*/

/*!
 * @name Register MCG_C8, field LOCRE1[7] (RW)
 *
 * Determines if a interrupt or a reset request is made following a loss of RTC
 * external reference clock. The LOCRE1 only has an affect when CME1 is set.
 *
 * Values:
 * - 0 - Interrupt request is generated on a loss of RTC external reference
 *     clock.
 * - 1 - Generate a reset request on a loss of RTC external reference clock
 */
/*@{*/
#define BP_MCG_C8_LOCRE1     (7U)          /*!< Bit position for MCG_C8_LOCRE1. */
#define BM_MCG_C8_LOCRE1     (0x80U)       /*!< Bit mask for MCG_C8_LOCRE1. */
#define BS_MCG_C8_LOCRE1     (1U)          /*!< Bit field size in bits for MCG_C8_LOCRE1. */

/*! @brief Read current value of the MCG_C8_LOCRE1 field. */
#define BR_MCG_C8_LOCRE1(x)  (BITBAND_ACCESS8(HW_MCG_C8_ADDR(x), BP_MCG_C8_LOCRE1))

/*! @brief Format value for bitfield MCG_C8_LOCRE1. */
#define BF_MCG_C8_LOCRE1(v)  ((uint8_t)((uint8_t)(v) << BP_MCG_C8_LOCRE1) & BM_MCG_C8_LOCRE1)

/*! @brief Set the LOCRE1 field to a new value. */
#define BW_MCG_C8_LOCRE1(x, v) (BITBAND_ACCESS8(HW_MCG_C8_ADDR(x), BP_MCG_C8_LOCRE1) = (v))
/*@}*/

/*******************************************************************************
 * hw_mcg_t - module struct
 ******************************************************************************/
/*!
 * @brief All MCG module registers.
 */
#pragma pack(1)
typedef struct _hw_mcg
{
    __IO hw_mcg_c1_t C1;                   /*!< [0x0] MCG Control 1 Register */
    __IO hw_mcg_c2_t C2;                   /*!< [0x1] MCG Control 2 Register */
    __IO hw_mcg_c3_t C3;                   /*!< [0x2] MCG Control 3 Register */
    __IO hw_mcg_c4_t C4;                   /*!< [0x3] MCG Control 4 Register */
    __IO hw_mcg_c5_t C5;                   /*!< [0x4] MCG Control 5 Register */
    __IO hw_mcg_c6_t C6;                   /*!< [0x5] MCG Control 6 Register */
    __IO hw_mcg_s_t S;                     /*!< [0x6] MCG Status Register */
    uint8_t _reserved0[1];
    __IO hw_mcg_sc_t SC;                   /*!< [0x8] MCG Status and Control Register */
    uint8_t _reserved1[1];
    __IO hw_mcg_atcvh_t ATCVH;             /*!< [0xA] MCG Auto Trim Compare Value High Register */
    __IO hw_mcg_atcvl_t ATCVL;             /*!< [0xB] MCG Auto Trim Compare Value Low Register */
    __IO hw_mcg_c7_t C7;                   /*!< [0xC] MCG Control 7 Register */
    __IO hw_mcg_c8_t C8;                   /*!< [0xD] MCG Control 8 Register */
} hw_mcg_t;
#pragma pack()

/*! @brief Macro to access all MCG registers. */
/*! @param x MCG module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_MCG_REGS(MCG_BASE)</code>. */
#define HW_MCG_REGS(x) (*(hw_mcg_t *)(x))

/*
 * MK64F12 MCM
 *
 * Core Platform Miscellaneous Control Module
 *
 * Registers defined in this header file:
 * - HW_MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 * - HW_MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 * - HW_MCM_CR - Control Register
 * - HW_MCM_ISCR - Interrupt Status Register
 * - HW_MCM_ETBCC - ETB Counter Control register
 * - HW_MCM_ETBRL - ETB Reload register
 * - HW_MCM_ETBCNT - ETB Counter Value register
 * - HW_MCM_PID - Process ID register
 *
 * - hw_mcm_t - Struct containing all module registers.
 */

#define HW_MCM_INSTANCE_COUNT (1U) /*!< Number of instances of the MCM module. */
#define HW_MCM (0U) /*!< Instance number for MCM. */

/*******************************************************************************
 * HW_MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 ******************************************************************************/

/*!
 * @brief HW_MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration (RO)
 *
 * Reset value: 0x001FU
 *
 * PLASC is a 16-bit read-only register identifying the presence/absence of bus
 * slave connections to the device's crossbar switch.
 */
typedef union _hw_mcm_plasc
{
    uint16_t U;
    struct _hw_mcm_plasc_bitfields
    {
        uint16_t ASC : 8;              /*!< [7:0] Each bit in the ASC field indicates
                                        * whether there is a corresponding connection to the crossbar switch's slave
                                        * input port. */
        uint16_t RESERVED0 : 8;        /*!< [15:8]  */
    } B;
} hw_mcm_plasc_t;

/*!
 * @name Constants and macros for entire MCM_PLASC register
 */
/*@{*/
#define HW_MCM_PLASC_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_MCM_PLASC(x)          (*(__I hw_mcm_plasc_t *) HW_MCM_PLASC_ADDR(x))
#define HW_MCM_PLASC_RD(x)       (HW_MCM_PLASC(x).U)
/*@}*/

/*
 * Constants & macros for individual MCM_PLASC bitfields
 */

/*!
 * @name Register MCM_PLASC, field ASC[7:0] (RO)
 *
 * Values:
 * - 0 - A bus slave connection to AXBS input port n is absent
 * - 1 - A bus slave connection to AXBS input port n is present
 */
/*@{*/
#define BP_MCM_PLASC_ASC     (0U)          /*!< Bit position for MCM_PLASC_ASC. */
#define BM_MCM_PLASC_ASC     (0x00FFU)     /*!< Bit mask for MCM_PLASC_ASC. */
#define BS_MCM_PLASC_ASC     (8U)          /*!< Bit field size in bits for MCM_PLASC_ASC. */

/*! @brief Read current value of the MCM_PLASC_ASC field. */
#define BR_MCM_PLASC_ASC(x)  (HW_MCM_PLASC(x).B.ASC)
/*@}*/

/*******************************************************************************
 * HW_MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 ******************************************************************************/

/*!
 * @brief HW_MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration (RO)
 *
 * Reset value: 0x0037U
 *
 * PLAMC is a 16-bit read-only register identifying the presence/absence of bus
 * master connections to the device's crossbar switch.
 */
typedef union _hw_mcm_plamc
{
    uint16_t U;
    struct _hw_mcm_plamc_bitfields
    {
        uint16_t AMC : 8;              /*!< [7:0] Each bit in the AMC field indicates
                                        * whether there is a corresponding connection to the AXBS master input port. */
        uint16_t RESERVED0 : 8;        /*!< [15:8]  */
    } B;
} hw_mcm_plamc_t;

/*!
 * @name Constants and macros for entire MCM_PLAMC register
 */
/*@{*/
#define HW_MCM_PLAMC_ADDR(x)     ((uint32_t)(x) + 0xAU)

#define HW_MCM_PLAMC(x)          (*(__I hw_mcm_plamc_t *) HW_MCM_PLAMC_ADDR(x))
#define HW_MCM_PLAMC_RD(x)       (HW_MCM_PLAMC(x).U)
/*@}*/

/*
 * Constants & macros for individual MCM_PLAMC bitfields
 */

/*!
 * @name Register MCM_PLAMC, field AMC[7:0] (RO)
 *
 * Values:
 * - 0 - A bus master connection to AXBS input port n is absent
 * - 1 - A bus master connection to AXBS input port n is present
 */
/*@{*/
#define BP_MCM_PLAMC_AMC     (0U)          /*!< Bit position for MCM_PLAMC_AMC. */
#define BM_MCM_PLAMC_AMC     (0x00FFU)     /*!< Bit mask for MCM_PLAMC_AMC. */
#define BS_MCM_PLAMC_AMC     (8U)          /*!< Bit field size in bits for MCM_PLAMC_AMC. */

/*! @brief Read current value of the MCM_PLAMC_AMC field. */
#define BR_MCM_PLAMC_AMC(x)  (HW_MCM_PLAMC(x).B.AMC)
/*@}*/

/*******************************************************************************
 * HW_MCM_CR - Control Register
 ******************************************************************************/

/*!
 * @brief HW_MCM_CR - Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * CR defines the arbitration and protection schemes for the two system RAM
 * arrays.
 */
typedef union _hw_mcm_cr
{
    uint32_t U;
    struct _hw_mcm_cr_bitfields
    {
        uint32_t RESERVED0 : 24;       /*!< [23:0]  */
        uint32_t SRAMUAP : 2;          /*!< [25:24] SRAM_U arbitration priority */
        uint32_t SRAMUWP : 1;          /*!< [26] SRAM_U write protect */
        uint32_t RESERVED1 : 1;        /*!< [27]  */
        uint32_t SRAMLAP : 2;          /*!< [29:28] SRAM_L arbitration priority */
        uint32_t SRAMLWP : 1;          /*!< [30] SRAM_L Write Protect */
        uint32_t RESERVED2 : 1;        /*!< [31]  */
    } B;
} hw_mcm_cr_t;

/*!
 * @name Constants and macros for entire MCM_CR register
 */
/*@{*/
#define HW_MCM_CR_ADDR(x)        ((uint32_t)(x) + 0xCU)

#define HW_MCM_CR(x)             (*(__IO hw_mcm_cr_t *) HW_MCM_CR_ADDR(x))
#define HW_MCM_CR_RD(x)          (HW_MCM_CR(x).U)
#define HW_MCM_CR_WR(x, v)       (HW_MCM_CR(x).U = (v))
#define HW_MCM_CR_SET(x, v)      (HW_MCM_CR_WR(x, HW_MCM_CR_RD(x) |  (v)))
#define HW_MCM_CR_CLR(x, v)      (HW_MCM_CR_WR(x, HW_MCM_CR_RD(x) & ~(v)))
#define HW_MCM_CR_TOG(x, v)      (HW_MCM_CR_WR(x, HW_MCM_CR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCM_CR bitfields
 */

/*!
 * @name Register MCM_CR, field SRAMUAP[25:24] (RW)
 *
 * Defines the arbitration scheme and priority for the processor and SRAM
 * backdoor accesses to the SRAM_U array.
 *
 * Values:
 * - 00 - Round robin
 * - 01 - Special round robin (favors SRAM backoor accesses over the processor)
 * - 10 - Fixed priority. Processor has highest, backdoor has lowest
 * - 11 - Fixed priority. Backdoor has highest, processor has lowest
 */
/*@{*/
#define BP_MCM_CR_SRAMUAP    (24U)         /*!< Bit position for MCM_CR_SRAMUAP. */
#define BM_MCM_CR_SRAMUAP    (0x03000000U) /*!< Bit mask for MCM_CR_SRAMUAP. */
#define BS_MCM_CR_SRAMUAP    (2U)          /*!< Bit field size in bits for MCM_CR_SRAMUAP. */

/*! @brief Read current value of the MCM_CR_SRAMUAP field. */
#define BR_MCM_CR_SRAMUAP(x) (HW_MCM_CR(x).B.SRAMUAP)

/*! @brief Format value for bitfield MCM_CR_SRAMUAP. */
#define BF_MCM_CR_SRAMUAP(v) ((uint32_t)((uint32_t)(v) << BP_MCM_CR_SRAMUAP) & BM_MCM_CR_SRAMUAP)

/*! @brief Set the SRAMUAP field to a new value. */
#define BW_MCM_CR_SRAMUAP(x, v) (HW_MCM_CR_WR(x, (HW_MCM_CR_RD(x) & ~BM_MCM_CR_SRAMUAP) | BF_MCM_CR_SRAMUAP(v)))
/*@}*/

/*!
 * @name Register MCM_CR, field SRAMUWP[26] (RW)
 *
 * When this bit is set, writes to SRAM_U array generates a bus error.
 */
/*@{*/
#define BP_MCM_CR_SRAMUWP    (26U)         /*!< Bit position for MCM_CR_SRAMUWP. */
#define BM_MCM_CR_SRAMUWP    (0x04000000U) /*!< Bit mask for MCM_CR_SRAMUWP. */
#define BS_MCM_CR_SRAMUWP    (1U)          /*!< Bit field size in bits for MCM_CR_SRAMUWP. */

/*! @brief Read current value of the MCM_CR_SRAMUWP field. */
#define BR_MCM_CR_SRAMUWP(x) (HW_MCM_CR(x).B.SRAMUWP)

/*! @brief Format value for bitfield MCM_CR_SRAMUWP. */
#define BF_MCM_CR_SRAMUWP(v) ((uint32_t)((uint32_t)(v) << BP_MCM_CR_SRAMUWP) & BM_MCM_CR_SRAMUWP)

/*! @brief Set the SRAMUWP field to a new value. */
#define BW_MCM_CR_SRAMUWP(x, v) (HW_MCM_CR_WR(x, (HW_MCM_CR_RD(x) & ~BM_MCM_CR_SRAMUWP) | BF_MCM_CR_SRAMUWP(v)))
/*@}*/

/*!
 * @name Register MCM_CR, field SRAMLAP[29:28] (RW)
 *
 * Defines the arbitration scheme and priority for the processor and SRAM
 * backdoor accesses to the SRAM_L array.
 *
 * Values:
 * - 00 - Round robin
 * - 01 - Special round robin (favors SRAM backoor accesses over the processor)
 * - 10 - Fixed priority. Processor has highest, backdoor has lowest
 * - 11 - Fixed priority. Backdoor has highest, processor has lowest
 */
/*@{*/
#define BP_MCM_CR_SRAMLAP    (28U)         /*!< Bit position for MCM_CR_SRAMLAP. */
#define BM_MCM_CR_SRAMLAP    (0x30000000U) /*!< Bit mask for MCM_CR_SRAMLAP. */
#define BS_MCM_CR_SRAMLAP    (2U)          /*!< Bit field size in bits for MCM_CR_SRAMLAP. */

/*! @brief Read current value of the MCM_CR_SRAMLAP field. */
#define BR_MCM_CR_SRAMLAP(x) (HW_MCM_CR(x).B.SRAMLAP)

/*! @brief Format value for bitfield MCM_CR_SRAMLAP. */
#define BF_MCM_CR_SRAMLAP(v) ((uint32_t)((uint32_t)(v) << BP_MCM_CR_SRAMLAP) & BM_MCM_CR_SRAMLAP)

/*! @brief Set the SRAMLAP field to a new value. */
#define BW_MCM_CR_SRAMLAP(x, v) (HW_MCM_CR_WR(x, (HW_MCM_CR_RD(x) & ~BM_MCM_CR_SRAMLAP) | BF_MCM_CR_SRAMLAP(v)))
/*@}*/

/*!
 * @name Register MCM_CR, field SRAMLWP[30] (RW)
 *
 * When this bit is set, writes to SRAM_L array generates a bus error.
 */
/*@{*/
#define BP_MCM_CR_SRAMLWP    (30U)         /*!< Bit position for MCM_CR_SRAMLWP. */
#define BM_MCM_CR_SRAMLWP    (0x40000000U) /*!< Bit mask for MCM_CR_SRAMLWP. */
#define BS_MCM_CR_SRAMLWP    (1U)          /*!< Bit field size in bits for MCM_CR_SRAMLWP. */

/*! @brief Read current value of the MCM_CR_SRAMLWP field. */
#define BR_MCM_CR_SRAMLWP(x) (HW_MCM_CR(x).B.SRAMLWP)

/*! @brief Format value for bitfield MCM_CR_SRAMLWP. */
#define BF_MCM_CR_SRAMLWP(v) ((uint32_t)((uint32_t)(v) << BP_MCM_CR_SRAMLWP) & BM_MCM_CR_SRAMLWP)

/*! @brief Set the SRAMLWP field to a new value. */
#define BW_MCM_CR_SRAMLWP(x, v) (HW_MCM_CR_WR(x, (HW_MCM_CR_RD(x) & ~BM_MCM_CR_SRAMLWP) | BF_MCM_CR_SRAMLWP(v)))
/*@}*/

/*******************************************************************************
 * HW_MCM_ISCR - Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief HW_MCM_ISCR - Interrupt Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_mcm_iscr
{
    uint32_t U;
    struct _hw_mcm_iscr_bitfields
    {
        uint32_t RESERVED0 : 1;        /*!< [0]  */
        uint32_t IRQ : 1;              /*!< [1] Normal Interrupt Pending */
        uint32_t NMI : 1;              /*!< [2] Non-maskable Interrupt Pending */
        uint32_t DHREQ : 1;            /*!< [3] Debug Halt Request Indicator */
        uint32_t RESERVED1 : 4;        /*!< [7:4]  */
        uint32_t FIOC : 1;             /*!< [8] FPU invalid operation interrupt status */
        uint32_t FDZC : 1;             /*!< [9] FPU divide-by-zero interrupt status */
        uint32_t FOFC : 1;             /*!< [10] FPU overflow interrupt status */
        uint32_t FUFC : 1;             /*!< [11] FPU underflow interrupt status */
        uint32_t FIXC : 1;             /*!< [12] FPU inexact interrupt status */
        uint32_t RESERVED2 : 2;        /*!< [14:13]  */
        uint32_t FIDC : 1;             /*!< [15] FPU input denormal interrupt status */
        uint32_t RESERVED3 : 8;        /*!< [23:16]  */
        uint32_t FIOCE : 1;            /*!< [24] FPU invalid operation interrupt enable
                                        * */
        uint32_t FDZCE : 1;            /*!< [25] FPU divide-by-zero interrupt enable */
        uint32_t FOFCE : 1;            /*!< [26] FPU overflow interrupt enable */
        uint32_t FUFCE : 1;            /*!< [27] FPU underflow interrupt enable */
        uint32_t FIXCE : 1;            /*!< [28] FPU inexact interrupt enable */
        uint32_t RESERVED4 : 2;        /*!< [30:29]  */
        uint32_t FIDCE : 1;            /*!< [31] FPU input denormal interrupt enable */
    } B;
} hw_mcm_iscr_t;

/*!
 * @name Constants and macros for entire MCM_ISCR register
 */
/*@{*/
#define HW_MCM_ISCR_ADDR(x)      ((uint32_t)(x) + 0x10U)

#define HW_MCM_ISCR(x)           (*(__IO hw_mcm_iscr_t *) HW_MCM_ISCR_ADDR(x))
#define HW_MCM_ISCR_RD(x)        (HW_MCM_ISCR(x).U)
#define HW_MCM_ISCR_WR(x, v)     (HW_MCM_ISCR(x).U = (v))
#define HW_MCM_ISCR_SET(x, v)    (HW_MCM_ISCR_WR(x, HW_MCM_ISCR_RD(x) |  (v)))
#define HW_MCM_ISCR_CLR(x, v)    (HW_MCM_ISCR_WR(x, HW_MCM_ISCR_RD(x) & ~(v)))
#define HW_MCM_ISCR_TOG(x, v)    (HW_MCM_ISCR_WR(x, HW_MCM_ISCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCM_ISCR bitfields
 */

/*!
 * @name Register MCM_ISCR, field IRQ[1] (W1C)
 *
 * If ETBCC[RSPT] is set to 01b, this bit is set when the ETB counter expires.
 *
 * Values:
 * - 0 - No pending interrupt
 * - 1 - Due to the ETB counter expiring, a normal interrupt is pending
 */
/*@{*/
#define BP_MCM_ISCR_IRQ      (1U)          /*!< Bit position for MCM_ISCR_IRQ. */
#define BM_MCM_ISCR_IRQ      (0x00000002U) /*!< Bit mask for MCM_ISCR_IRQ. */
#define BS_MCM_ISCR_IRQ      (1U)          /*!< Bit field size in bits for MCM_ISCR_IRQ. */

/*! @brief Read current value of the MCM_ISCR_IRQ field. */
#define BR_MCM_ISCR_IRQ(x)   (HW_MCM_ISCR(x).B.IRQ)

/*! @brief Format value for bitfield MCM_ISCR_IRQ. */
#define BF_MCM_ISCR_IRQ(v)   ((uint32_t)((uint32_t)(v) << BP_MCM_ISCR_IRQ) & BM_MCM_ISCR_IRQ)

/*! @brief Set the IRQ field to a new value. */
#define BW_MCM_ISCR_IRQ(x, v) (HW_MCM_ISCR_WR(x, (HW_MCM_ISCR_RD(x) & ~BM_MCM_ISCR_IRQ) | BF_MCM_ISCR_IRQ(v)))
/*@}*/

/*!
 * @name Register MCM_ISCR, field NMI[2] (W1C)
 *
 * If ETBCC[RSPT] is set to 10b, this bit is set when the ETB counter expires.
 *
 * Values:
 * - 0 - No pending NMI
 * - 1 - Due to the ETB counter expiring, an NMI is pending
 */
/*@{*/
#define BP_MCM_ISCR_NMI      (2U)          /*!< Bit position for MCM_ISCR_NMI. */
#define BM_MCM_ISCR_NMI      (0x00000004U) /*!< Bit mask for MCM_ISCR_NMI. */
#define BS_MCM_ISCR_NMI      (1U)          /*!< Bit field size in bits for MCM_ISCR_NMI. */

/*! @brief Read current value of the MCM_ISCR_NMI field. */
#define BR_MCM_ISCR_NMI(x)   (HW_MCM_ISCR(x).B.NMI)

/*! @brief Format value for bitfield MCM_ISCR_NMI. */
#define BF_MCM_ISCR_NMI(v)   ((uint32_t)((uint32_t)(v) << BP_MCM_ISCR_NMI) & BM_MCM_ISCR_NMI)

/*! @brief Set the NMI field to a new value. */
#define BW_MCM_ISCR_NMI(x, v) (HW_MCM_ISCR_WR(x, (HW_MCM_ISCR_RD(x) & ~BM_MCM_ISCR_NMI) | BF_MCM_ISCR_NMI(v)))
/*@}*/

/*!
 * @name Register MCM_ISCR, field DHREQ[3] (RO)
 *
 * Indicates that a debug halt request is initiated due to a ETB counter
 * expiration, ETBCC[2:0] = 3b111 & ETBCV[10:0] = 11h0. This bit is cleared when the
 * counter is disabled or when the ETB counter is reloaded.
 *
 * Values:
 * - 0 - No debug halt request
 * - 1 - Debug halt request initiated
 */
/*@{*/
#define BP_MCM_ISCR_DHREQ    (3U)          /*!< Bit position for MCM_ISCR_DHREQ. */
#define BM_MCM_ISCR_DHREQ    (0x00000008U) /*!< Bit mask for MCM_ISCR_DHREQ. */
#define BS_MCM_ISCR_DHREQ    (1U)          /*!< Bit field size in bits for MCM_ISCR_DHREQ. */

/*! @brief Read current value of the MCM_ISCR_DHREQ field. */
#define BR_MCM_ISCR_DHREQ(x) (HW_MCM_ISCR(x).B.DHREQ)
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIOC[8] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[IOC] bit and signals an
 * illegal operation has been detected in the processor's FPU. Once set, this bit
 * remains set until software clears the FPSCR[IOC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
#define BP_MCM_ISCR_FIOC     (8U)          /*!< Bit position for MCM_ISCR_FIOC. */
#define BM_MCM_ISCR_FIOC     (0x00000100U) /*!< Bit mask for MCM_ISCR_FIOC. */
#define BS_MCM_ISCR_FIOC     (1U)          /*!< Bit field size in bits for MCM_ISCR_FIOC. */

/*! @brief Read current value of the MCM_ISCR_FIOC field. */
#define BR_MCM_ISCR_FIOC(x)  (HW_MCM_ISCR(x).B.FIOC)
/*@}*/

/*!
 * @name Register MCM_ISCR, field FDZC[9] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[DZC] bit and signals a
 * divide by zero has been detected in the processor's FPU. Once set, this bit remains
 * set until software clears the FPSCR[DZC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
#define BP_MCM_ISCR_FDZC     (9U)          /*!< Bit position for MCM_ISCR_FDZC. */
#define BM_MCM_ISCR_FDZC     (0x00000200U) /*!< Bit mask for MCM_ISCR_FDZC. */
#define BS_MCM_ISCR_FDZC     (1U)          /*!< Bit field size in bits for MCM_ISCR_FDZC. */

/*! @brief Read current value of the MCM_ISCR_FDZC field. */
#define BR_MCM_ISCR_FDZC(x)  (HW_MCM_ISCR(x).B.FDZC)
/*@}*/

/*!
 * @name Register MCM_ISCR, field FOFC[10] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[OFC] bit and signals an
 * overflow has been detected in the processor's FPU. Once set, this bit remains set
 * until software clears the FPSCR[OFC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
#define BP_MCM_ISCR_FOFC     (10U)         /*!< Bit position for MCM_ISCR_FOFC. */
#define BM_MCM_ISCR_FOFC     (0x00000400U) /*!< Bit mask for MCM_ISCR_FOFC. */
#define BS_MCM_ISCR_FOFC     (1U)          /*!< Bit field size in bits for MCM_ISCR_FOFC. */

/*! @brief Read current value of the MCM_ISCR_FOFC field. */
#define BR_MCM_ISCR_FOFC(x)  (HW_MCM_ISCR(x).B.FOFC)
/*@}*/

/*!
 * @name Register MCM_ISCR, field FUFC[11] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[UFC] bit and signals an
 * underflow has been detected in the processor's FPU. Once set, this bit remains set
 * until software clears the FPSCR[UFC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
#define BP_MCM_ISCR_FUFC     (11U)         /*!< Bit position for MCM_ISCR_FUFC. */
#define BM_MCM_ISCR_FUFC     (0x00000800U) /*!< Bit mask for MCM_ISCR_FUFC. */
#define BS_MCM_ISCR_FUFC     (1U)          /*!< Bit field size in bits for MCM_ISCR_FUFC. */

/*! @brief Read current value of the MCM_ISCR_FUFC field. */
#define BR_MCM_ISCR_FUFC(x)  (HW_MCM_ISCR(x).B.FUFC)
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIXC[12] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[IXC] bit and signals an
 * inexact number has been detected in the processor's FPU. Once set, this bit
 * remains set until software clears the FPSCR[IXC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
#define BP_MCM_ISCR_FIXC     (12U)         /*!< Bit position for MCM_ISCR_FIXC. */
#define BM_MCM_ISCR_FIXC     (0x00001000U) /*!< Bit mask for MCM_ISCR_FIXC. */
#define BS_MCM_ISCR_FIXC     (1U)          /*!< Bit field size in bits for MCM_ISCR_FIXC. */

/*! @brief Read current value of the MCM_ISCR_FIXC field. */
#define BR_MCM_ISCR_FIXC(x)  (HW_MCM_ISCR(x).B.FIXC)
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIDC[15] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[IDC] bit and signals input
 * denormalized number has been detected in the processor's FPU. Once set, this
 * bit remains set until software clears the FPSCR[IDC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
#define BP_MCM_ISCR_FIDC     (15U)         /*!< Bit position for MCM_ISCR_FIDC. */
#define BM_MCM_ISCR_FIDC     (0x00008000U) /*!< Bit mask for MCM_ISCR_FIDC. */
#define BS_MCM_ISCR_FIDC     (1U)          /*!< Bit field size in bits for MCM_ISCR_FIDC. */

/*! @brief Read current value of the MCM_ISCR_FIDC field. */
#define BR_MCM_ISCR_FIDC(x)  (HW_MCM_ISCR(x).B.FIDC)
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIOCE[24] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
#define BP_MCM_ISCR_FIOCE    (24U)         /*!< Bit position for MCM_ISCR_FIOCE. */
#define BM_MCM_ISCR_FIOCE    (0x01000000U) /*!< Bit mask for MCM_ISCR_FIOCE. */
#define BS_MCM_ISCR_FIOCE    (1U)          /*!< Bit field size in bits for MCM_ISCR_FIOCE. */

/*! @brief Read current value of the MCM_ISCR_FIOCE field. */
#define BR_MCM_ISCR_FIOCE(x) (HW_MCM_ISCR(x).B.FIOCE)

/*! @brief Format value for bitfield MCM_ISCR_FIOCE. */
#define BF_MCM_ISCR_FIOCE(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ISCR_FIOCE) & BM_MCM_ISCR_FIOCE)

/*! @brief Set the FIOCE field to a new value. */
#define BW_MCM_ISCR_FIOCE(x, v) (HW_MCM_ISCR_WR(x, (HW_MCM_ISCR_RD(x) & ~BM_MCM_ISCR_FIOCE) | BF_MCM_ISCR_FIOCE(v)))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FDZCE[25] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
#define BP_MCM_ISCR_FDZCE    (25U)         /*!< Bit position for MCM_ISCR_FDZCE. */
#define BM_MCM_ISCR_FDZCE    (0x02000000U) /*!< Bit mask for MCM_ISCR_FDZCE. */
#define BS_MCM_ISCR_FDZCE    (1U)          /*!< Bit field size in bits for MCM_ISCR_FDZCE. */

/*! @brief Read current value of the MCM_ISCR_FDZCE field. */
#define BR_MCM_ISCR_FDZCE(x) (HW_MCM_ISCR(x).B.FDZCE)

/*! @brief Format value for bitfield MCM_ISCR_FDZCE. */
#define BF_MCM_ISCR_FDZCE(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ISCR_FDZCE) & BM_MCM_ISCR_FDZCE)

/*! @brief Set the FDZCE field to a new value. */
#define BW_MCM_ISCR_FDZCE(x, v) (HW_MCM_ISCR_WR(x, (HW_MCM_ISCR_RD(x) & ~BM_MCM_ISCR_FDZCE) | BF_MCM_ISCR_FDZCE(v)))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FOFCE[26] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
#define BP_MCM_ISCR_FOFCE    (26U)         /*!< Bit position for MCM_ISCR_FOFCE. */
#define BM_MCM_ISCR_FOFCE    (0x04000000U) /*!< Bit mask for MCM_ISCR_FOFCE. */
#define BS_MCM_ISCR_FOFCE    (1U)          /*!< Bit field size in bits for MCM_ISCR_FOFCE. */

/*! @brief Read current value of the MCM_ISCR_FOFCE field. */
#define BR_MCM_ISCR_FOFCE(x) (HW_MCM_ISCR(x).B.FOFCE)

/*! @brief Format value for bitfield MCM_ISCR_FOFCE. */
#define BF_MCM_ISCR_FOFCE(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ISCR_FOFCE) & BM_MCM_ISCR_FOFCE)

/*! @brief Set the FOFCE field to a new value. */
#define BW_MCM_ISCR_FOFCE(x, v) (HW_MCM_ISCR_WR(x, (HW_MCM_ISCR_RD(x) & ~BM_MCM_ISCR_FOFCE) | BF_MCM_ISCR_FOFCE(v)))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FUFCE[27] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
#define BP_MCM_ISCR_FUFCE    (27U)         /*!< Bit position for MCM_ISCR_FUFCE. */
#define BM_MCM_ISCR_FUFCE    (0x08000000U) /*!< Bit mask for MCM_ISCR_FUFCE. */
#define BS_MCM_ISCR_FUFCE    (1U)          /*!< Bit field size in bits for MCM_ISCR_FUFCE. */

/*! @brief Read current value of the MCM_ISCR_FUFCE field. */
#define BR_MCM_ISCR_FUFCE(x) (HW_MCM_ISCR(x).B.FUFCE)

/*! @brief Format value for bitfield MCM_ISCR_FUFCE. */
#define BF_MCM_ISCR_FUFCE(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ISCR_FUFCE) & BM_MCM_ISCR_FUFCE)

/*! @brief Set the FUFCE field to a new value. */
#define BW_MCM_ISCR_FUFCE(x, v) (HW_MCM_ISCR_WR(x, (HW_MCM_ISCR_RD(x) & ~BM_MCM_ISCR_FUFCE) | BF_MCM_ISCR_FUFCE(v)))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIXCE[28] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
#define BP_MCM_ISCR_FIXCE    (28U)         /*!< Bit position for MCM_ISCR_FIXCE. */
#define BM_MCM_ISCR_FIXCE    (0x10000000U) /*!< Bit mask for MCM_ISCR_FIXCE. */
#define BS_MCM_ISCR_FIXCE    (1U)          /*!< Bit field size in bits for MCM_ISCR_FIXCE. */

/*! @brief Read current value of the MCM_ISCR_FIXCE field. */
#define BR_MCM_ISCR_FIXCE(x) (HW_MCM_ISCR(x).B.FIXCE)

/*! @brief Format value for bitfield MCM_ISCR_FIXCE. */
#define BF_MCM_ISCR_FIXCE(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ISCR_FIXCE) & BM_MCM_ISCR_FIXCE)

/*! @brief Set the FIXCE field to a new value. */
#define BW_MCM_ISCR_FIXCE(x, v) (HW_MCM_ISCR_WR(x, (HW_MCM_ISCR_RD(x) & ~BM_MCM_ISCR_FIXCE) | BF_MCM_ISCR_FIXCE(v)))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIDCE[31] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
#define BP_MCM_ISCR_FIDCE    (31U)         /*!< Bit position for MCM_ISCR_FIDCE. */
#define BM_MCM_ISCR_FIDCE    (0x80000000U) /*!< Bit mask for MCM_ISCR_FIDCE. */
#define BS_MCM_ISCR_FIDCE    (1U)          /*!< Bit field size in bits for MCM_ISCR_FIDCE. */

/*! @brief Read current value of the MCM_ISCR_FIDCE field. */
#define BR_MCM_ISCR_FIDCE(x) (HW_MCM_ISCR(x).B.FIDCE)

/*! @brief Format value for bitfield MCM_ISCR_FIDCE. */
#define BF_MCM_ISCR_FIDCE(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ISCR_FIDCE) & BM_MCM_ISCR_FIDCE)

/*! @brief Set the FIDCE field to a new value. */
#define BW_MCM_ISCR_FIDCE(x, v) (HW_MCM_ISCR_WR(x, (HW_MCM_ISCR_RD(x) & ~BM_MCM_ISCR_FIDCE) | BF_MCM_ISCR_FIDCE(v)))
/*@}*/

/*******************************************************************************
 * HW_MCM_ETBCC - ETB Counter Control register
 ******************************************************************************/

/*!
 * @brief HW_MCM_ETBCC - ETB Counter Control register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_mcm_etbcc
{
    uint32_t U;
    struct _hw_mcm_etbcc_bitfields
    {
        uint32_t CNTEN : 1;            /*!< [0] Counter Enable */
        uint32_t RSPT : 2;             /*!< [2:1] Response Type */
        uint32_t RLRQ : 1;             /*!< [3] Reload Request */
        uint32_t ETDIS : 1;            /*!< [4] ETM-To-TPIU Disable */
        uint32_t ITDIS : 1;            /*!< [5] ITM-To-TPIU Disable */
        uint32_t RESERVED0 : 26;       /*!< [31:6]  */
    } B;
} hw_mcm_etbcc_t;

/*!
 * @name Constants and macros for entire MCM_ETBCC register
 */
/*@{*/
#define HW_MCM_ETBCC_ADDR(x)     ((uint32_t)(x) + 0x14U)

#define HW_MCM_ETBCC(x)          (*(__IO hw_mcm_etbcc_t *) HW_MCM_ETBCC_ADDR(x))
#define HW_MCM_ETBCC_RD(x)       (HW_MCM_ETBCC(x).U)
#define HW_MCM_ETBCC_WR(x, v)    (HW_MCM_ETBCC(x).U = (v))
#define HW_MCM_ETBCC_SET(x, v)   (HW_MCM_ETBCC_WR(x, HW_MCM_ETBCC_RD(x) |  (v)))
#define HW_MCM_ETBCC_CLR(x, v)   (HW_MCM_ETBCC_WR(x, HW_MCM_ETBCC_RD(x) & ~(v)))
#define HW_MCM_ETBCC_TOG(x, v)   (HW_MCM_ETBCC_WR(x, HW_MCM_ETBCC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCM_ETBCC bitfields
 */

/*!
 * @name Register MCM_ETBCC, field CNTEN[0] (RW)
 *
 * Enables the ETB counter.
 *
 * Values:
 * - 0 - ETB counter disabled
 * - 1 - ETB counter enabled
 */
/*@{*/
#define BP_MCM_ETBCC_CNTEN   (0U)          /*!< Bit position for MCM_ETBCC_CNTEN. */
#define BM_MCM_ETBCC_CNTEN   (0x00000001U) /*!< Bit mask for MCM_ETBCC_CNTEN. */
#define BS_MCM_ETBCC_CNTEN   (1U)          /*!< Bit field size in bits for MCM_ETBCC_CNTEN. */

/*! @brief Read current value of the MCM_ETBCC_CNTEN field. */
#define BR_MCM_ETBCC_CNTEN(x) (HW_MCM_ETBCC(x).B.CNTEN)

/*! @brief Format value for bitfield MCM_ETBCC_CNTEN. */
#define BF_MCM_ETBCC_CNTEN(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ETBCC_CNTEN) & BM_MCM_ETBCC_CNTEN)

/*! @brief Set the CNTEN field to a new value. */
#define BW_MCM_ETBCC_CNTEN(x, v) (HW_MCM_ETBCC_WR(x, (HW_MCM_ETBCC_RD(x) & ~BM_MCM_ETBCC_CNTEN) | BF_MCM_ETBCC_CNTEN(v)))
/*@}*/

/*!
 * @name Register MCM_ETBCC, field RSPT[2:1] (RW)
 *
 * Values:
 * - 00 - No response when the ETB count expires
 * - 01 - Generate a normal interrupt when the ETB count expires
 * - 10 - Generate an NMI when the ETB count expires
 * - 11 - Generate a debug halt when the ETB count expires
 */
/*@{*/
#define BP_MCM_ETBCC_RSPT    (1U)          /*!< Bit position for MCM_ETBCC_RSPT. */
#define BM_MCM_ETBCC_RSPT    (0x00000006U) /*!< Bit mask for MCM_ETBCC_RSPT. */
#define BS_MCM_ETBCC_RSPT    (2U)          /*!< Bit field size in bits for MCM_ETBCC_RSPT. */

/*! @brief Read current value of the MCM_ETBCC_RSPT field. */
#define BR_MCM_ETBCC_RSPT(x) (HW_MCM_ETBCC(x).B.RSPT)

/*! @brief Format value for bitfield MCM_ETBCC_RSPT. */
#define BF_MCM_ETBCC_RSPT(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ETBCC_RSPT) & BM_MCM_ETBCC_RSPT)

/*! @brief Set the RSPT field to a new value. */
#define BW_MCM_ETBCC_RSPT(x, v) (HW_MCM_ETBCC_WR(x, (HW_MCM_ETBCC_RD(x) & ~BM_MCM_ETBCC_RSPT) | BF_MCM_ETBCC_RSPT(v)))
/*@}*/

/*!
 * @name Register MCM_ETBCC, field RLRQ[3] (RW)
 *
 * Reloads the ETB packet counter with the MCM_ETBRL RELOAD value. If IRQ or NMI
 * interrupts were enabled and an NMI or IRQ interrupt was generated on counter
 * expiration, setting this bit clears the pending NMI or IRQ interrupt request.
 * If debug halt was enabled and a debug halt request was asserted on counter
 * expiration, setting this bit clears the debug halt request.
 *
 * Values:
 * - 0 - No effect
 * - 1 - Clears pending debug halt, NMI, or IRQ interrupt requests
 */
/*@{*/
#define BP_MCM_ETBCC_RLRQ    (3U)          /*!< Bit position for MCM_ETBCC_RLRQ. */
#define BM_MCM_ETBCC_RLRQ    (0x00000008U) /*!< Bit mask for MCM_ETBCC_RLRQ. */
#define BS_MCM_ETBCC_RLRQ    (1U)          /*!< Bit field size in bits for MCM_ETBCC_RLRQ. */

/*! @brief Read current value of the MCM_ETBCC_RLRQ field. */
#define BR_MCM_ETBCC_RLRQ(x) (HW_MCM_ETBCC(x).B.RLRQ)

/*! @brief Format value for bitfield MCM_ETBCC_RLRQ. */
#define BF_MCM_ETBCC_RLRQ(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ETBCC_RLRQ) & BM_MCM_ETBCC_RLRQ)

/*! @brief Set the RLRQ field to a new value. */
#define BW_MCM_ETBCC_RLRQ(x, v) (HW_MCM_ETBCC_WR(x, (HW_MCM_ETBCC_RD(x) & ~BM_MCM_ETBCC_RLRQ) | BF_MCM_ETBCC_RLRQ(v)))
/*@}*/

/*!
 * @name Register MCM_ETBCC, field ETDIS[4] (RW)
 *
 * Disables the trace path from ETM to TPIU.
 *
 * Values:
 * - 0 - ETM-to-TPIU trace path enabled
 * - 1 - ETM-to-TPIU trace path disabled
 */
/*@{*/
#define BP_MCM_ETBCC_ETDIS   (4U)          /*!< Bit position for MCM_ETBCC_ETDIS. */
#define BM_MCM_ETBCC_ETDIS   (0x00000010U) /*!< Bit mask for MCM_ETBCC_ETDIS. */
#define BS_MCM_ETBCC_ETDIS   (1U)          /*!< Bit field size in bits for MCM_ETBCC_ETDIS. */

/*! @brief Read current value of the MCM_ETBCC_ETDIS field. */
#define BR_MCM_ETBCC_ETDIS(x) (HW_MCM_ETBCC(x).B.ETDIS)

/*! @brief Format value for bitfield MCM_ETBCC_ETDIS. */
#define BF_MCM_ETBCC_ETDIS(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ETBCC_ETDIS) & BM_MCM_ETBCC_ETDIS)

/*! @brief Set the ETDIS field to a new value. */
#define BW_MCM_ETBCC_ETDIS(x, v) (HW_MCM_ETBCC_WR(x, (HW_MCM_ETBCC_RD(x) & ~BM_MCM_ETBCC_ETDIS) | BF_MCM_ETBCC_ETDIS(v)))
/*@}*/

/*!
 * @name Register MCM_ETBCC, field ITDIS[5] (RW)
 *
 * Disables the trace path from ITM to TPIU.
 *
 * Values:
 * - 0 - ITM-to-TPIU trace path enabled
 * - 1 - ITM-to-TPIU trace path disabled
 */
/*@{*/
#define BP_MCM_ETBCC_ITDIS   (5U)          /*!< Bit position for MCM_ETBCC_ITDIS. */
#define BM_MCM_ETBCC_ITDIS   (0x00000020U) /*!< Bit mask for MCM_ETBCC_ITDIS. */
#define BS_MCM_ETBCC_ITDIS   (1U)          /*!< Bit field size in bits for MCM_ETBCC_ITDIS. */

/*! @brief Read current value of the MCM_ETBCC_ITDIS field. */
#define BR_MCM_ETBCC_ITDIS(x) (HW_MCM_ETBCC(x).B.ITDIS)

/*! @brief Format value for bitfield MCM_ETBCC_ITDIS. */
#define BF_MCM_ETBCC_ITDIS(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ETBCC_ITDIS) & BM_MCM_ETBCC_ITDIS)

/*! @brief Set the ITDIS field to a new value. */
#define BW_MCM_ETBCC_ITDIS(x, v) (HW_MCM_ETBCC_WR(x, (HW_MCM_ETBCC_RD(x) & ~BM_MCM_ETBCC_ITDIS) | BF_MCM_ETBCC_ITDIS(v)))
/*@}*/

/*******************************************************************************
 * HW_MCM_ETBRL - ETB Reload register
 ******************************************************************************/

/*!
 * @brief HW_MCM_ETBRL - ETB Reload register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_mcm_etbrl
{
    uint32_t U;
    struct _hw_mcm_etbrl_bitfields
    {
        uint32_t RELOAD : 11;          /*!< [10:0] Byte Count Reload Value */
        uint32_t RESERVED0 : 21;       /*!< [31:11]  */
    } B;
} hw_mcm_etbrl_t;

/*!
 * @name Constants and macros for entire MCM_ETBRL register
 */
/*@{*/
#define HW_MCM_ETBRL_ADDR(x)     ((uint32_t)(x) + 0x18U)

#define HW_MCM_ETBRL(x)          (*(__IO hw_mcm_etbrl_t *) HW_MCM_ETBRL_ADDR(x))
#define HW_MCM_ETBRL_RD(x)       (HW_MCM_ETBRL(x).U)
#define HW_MCM_ETBRL_WR(x, v)    (HW_MCM_ETBRL(x).U = (v))
#define HW_MCM_ETBRL_SET(x, v)   (HW_MCM_ETBRL_WR(x, HW_MCM_ETBRL_RD(x) |  (v)))
#define HW_MCM_ETBRL_CLR(x, v)   (HW_MCM_ETBRL_WR(x, HW_MCM_ETBRL_RD(x) & ~(v)))
#define HW_MCM_ETBRL_TOG(x, v)   (HW_MCM_ETBRL_WR(x, HW_MCM_ETBRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCM_ETBRL bitfields
 */

/*!
 * @name Register MCM_ETBRL, field RELOAD[10:0] (RW)
 *
 * Indicates the 0-mod-4 value the counter reloads to. Writing a non-0-mod-4
 * value to this field results in a bus error.
 */
/*@{*/
#define BP_MCM_ETBRL_RELOAD  (0U)          /*!< Bit position for MCM_ETBRL_RELOAD. */
#define BM_MCM_ETBRL_RELOAD  (0x000007FFU) /*!< Bit mask for MCM_ETBRL_RELOAD. */
#define BS_MCM_ETBRL_RELOAD  (11U)         /*!< Bit field size in bits for MCM_ETBRL_RELOAD. */

/*! @brief Read current value of the MCM_ETBRL_RELOAD field. */
#define BR_MCM_ETBRL_RELOAD(x) (HW_MCM_ETBRL(x).B.RELOAD)

/*! @brief Format value for bitfield MCM_ETBRL_RELOAD. */
#define BF_MCM_ETBRL_RELOAD(v) ((uint32_t)((uint32_t)(v) << BP_MCM_ETBRL_RELOAD) & BM_MCM_ETBRL_RELOAD)

/*! @brief Set the RELOAD field to a new value. */
#define BW_MCM_ETBRL_RELOAD(x, v) (HW_MCM_ETBRL_WR(x, (HW_MCM_ETBRL_RD(x) & ~BM_MCM_ETBRL_RELOAD) | BF_MCM_ETBRL_RELOAD(v)))
/*@}*/

/*******************************************************************************
 * HW_MCM_ETBCNT - ETB Counter Value register
 ******************************************************************************/

/*!
 * @brief HW_MCM_ETBCNT - ETB Counter Value register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_mcm_etbcnt
{
    uint32_t U;
    struct _hw_mcm_etbcnt_bitfields
    {
        uint32_t COUNTER : 11;         /*!< [10:0] Byte Count Counter Value */
        uint32_t RESERVED0 : 21;       /*!< [31:11]  */
    } B;
} hw_mcm_etbcnt_t;

/*!
 * @name Constants and macros for entire MCM_ETBCNT register
 */
/*@{*/
#define HW_MCM_ETBCNT_ADDR(x)    ((uint32_t)(x) + 0x1CU)

#define HW_MCM_ETBCNT(x)         (*(__I hw_mcm_etbcnt_t *) HW_MCM_ETBCNT_ADDR(x))
#define HW_MCM_ETBCNT_RD(x)      (HW_MCM_ETBCNT(x).U)
/*@}*/

/*
 * Constants & macros for individual MCM_ETBCNT bitfields
 */

/*!
 * @name Register MCM_ETBCNT, field COUNTER[10:0] (RO)
 *
 * Indicates the current 0-mod-4 value of the counter.
 */
/*@{*/
#define BP_MCM_ETBCNT_COUNTER (0U)         /*!< Bit position for MCM_ETBCNT_COUNTER. */
#define BM_MCM_ETBCNT_COUNTER (0x000007FFU) /*!< Bit mask for MCM_ETBCNT_COUNTER. */
#define BS_MCM_ETBCNT_COUNTER (11U)        /*!< Bit field size in bits for MCM_ETBCNT_COUNTER. */

/*! @brief Read current value of the MCM_ETBCNT_COUNTER field. */
#define BR_MCM_ETBCNT_COUNTER(x) (HW_MCM_ETBCNT(x).B.COUNTER)
/*@}*/

/*******************************************************************************
 * HW_MCM_PID - Process ID register
 ******************************************************************************/

/*!
 * @brief HW_MCM_PID - Process ID register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register drives the M0_PID and M1_PID values in the Memory Protection
 * Unit(MPU). System software loads this register before passing control to a given
 * user mode process. If the PID of the process does not match the value in this
 * register, a bus error occurs. See the MPU chapter for more details.
 */
typedef union _hw_mcm_pid
{
    uint32_t U;
    struct _hw_mcm_pid_bitfields
    {
        uint32_t PID : 8;              /*!< [7:0] M0_PID And M1_PID For MPU */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_mcm_pid_t;

/*!
 * @name Constants and macros for entire MCM_PID register
 */
/*@{*/
#define HW_MCM_PID_ADDR(x)       ((uint32_t)(x) + 0x30U)

#define HW_MCM_PID(x)            (*(__IO hw_mcm_pid_t *) HW_MCM_PID_ADDR(x))
#define HW_MCM_PID_RD(x)         (HW_MCM_PID(x).U)
#define HW_MCM_PID_WR(x, v)      (HW_MCM_PID(x).U = (v))
#define HW_MCM_PID_SET(x, v)     (HW_MCM_PID_WR(x, HW_MCM_PID_RD(x) |  (v)))
#define HW_MCM_PID_CLR(x, v)     (HW_MCM_PID_WR(x, HW_MCM_PID_RD(x) & ~(v)))
#define HW_MCM_PID_TOG(x, v)     (HW_MCM_PID_WR(x, HW_MCM_PID_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MCM_PID bitfields
 */

/*!
 * @name Register MCM_PID, field PID[7:0] (RW)
 *
 * Drives the M0_PID and M1_PID values in the MPU.
 */
/*@{*/
#define BP_MCM_PID_PID       (0U)          /*!< Bit position for MCM_PID_PID. */
#define BM_MCM_PID_PID       (0x000000FFU) /*!< Bit mask for MCM_PID_PID. */
#define BS_MCM_PID_PID       (8U)          /*!< Bit field size in bits for MCM_PID_PID. */

/*! @brief Read current value of the MCM_PID_PID field. */
#define BR_MCM_PID_PID(x)    (HW_MCM_PID(x).B.PID)

/*! @brief Format value for bitfield MCM_PID_PID. */
#define BF_MCM_PID_PID(v)    ((uint32_t)((uint32_t)(v) << BP_MCM_PID_PID) & BM_MCM_PID_PID)

/*! @brief Set the PID field to a new value. */
#define BW_MCM_PID_PID(x, v) (HW_MCM_PID_WR(x, (HW_MCM_PID_RD(x) & ~BM_MCM_PID_PID) | BF_MCM_PID_PID(v)))
/*@}*/

/*******************************************************************************
 * hw_mcm_t - module struct
 ******************************************************************************/
/*!
 * @brief All MCM module registers.
 */
#pragma pack(1)
typedef struct _hw_mcm
{
    uint8_t _reserved0[8];
    __I hw_mcm_plasc_t PLASC;              /*!< [0x8] Crossbar Switch (AXBS) Slave Configuration */
    __I hw_mcm_plamc_t PLAMC;              /*!< [0xA] Crossbar Switch (AXBS) Master Configuration */
    __IO hw_mcm_cr_t CR;                   /*!< [0xC] Control Register */
    __IO hw_mcm_iscr_t ISCR;               /*!< [0x10] Interrupt Status Register */
    __IO hw_mcm_etbcc_t ETBCC;             /*!< [0x14] ETB Counter Control register */
    __IO hw_mcm_etbrl_t ETBRL;             /*!< [0x18] ETB Reload register */
    __I hw_mcm_etbcnt_t ETBCNT;            /*!< [0x1C] ETB Counter Value register */
    uint8_t _reserved1[16];
    __IO hw_mcm_pid_t PID;                 /*!< [0x30] Process ID register */
} hw_mcm_t;
#pragma pack()

/*! @brief Macro to access all MCM registers. */
/*! @param x MCM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_MCM_REGS(MCM_BASE)</code>. */
#define HW_MCM_REGS(x) (*(hw_mcm_t *)(x))

/*
 * MK64F12 MPU
 *
 * Memory protection unit
 *
 * Registers defined in this header file:
 * - HW_MPU_CESR - Control/Error Status Register
 * - HW_MPU_EARn - Error Address Register, slave port n
 * - HW_MPU_EDRn - Error Detail Register, slave port n
 * - HW_MPU_RGDn_WORD0 - Region Descriptor n, Word 0
 * - HW_MPU_RGDn_WORD1 - Region Descriptor n, Word 1
 * - HW_MPU_RGDn_WORD2 - Region Descriptor n, Word 2
 * - HW_MPU_RGDn_WORD3 - Region Descriptor n, Word 3
 * - HW_MPU_RGDAACn - Region Descriptor Alternate Access Control n
 *
 * - hw_mpu_t - Struct containing all module registers.
 */

#define HW_MPU_INSTANCE_COUNT (1U) /*!< Number of instances of the MPU module. */
#define HW_MPU (0U) /*!< Instance number for MPU. */

/*******************************************************************************
 * HW_MPU_CESR - Control/Error Status Register
 ******************************************************************************/

/*!
 * @brief HW_MPU_CESR - Control/Error Status Register (RW)
 *
 * Reset value: 0x00815101U
 */
typedef union _hw_mpu_cesr
{
    uint32_t U;
    struct _hw_mpu_cesr_bitfields
    {
        uint32_t VLD : 1;              /*!< [0] Valid */
        uint32_t RESERVED0 : 7;        /*!< [7:1]  */
        uint32_t NRGD : 4;             /*!< [11:8] Number Of Region Descriptors */
        uint32_t NSP : 4;              /*!< [15:12] Number Of Slave Ports */
        uint32_t HRL : 4;              /*!< [19:16] Hardware Revision Level */
        uint32_t RESERVED1 : 7;        /*!< [26:20]  */
        uint32_t SPERR : 5;            /*!< [31:27] Slave Port n Error */
    } B;
} hw_mpu_cesr_t;

/*!
 * @name Constants and macros for entire MPU_CESR register
 */
/*@{*/
#define HW_MPU_CESR_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_MPU_CESR(x)           (*(__IO hw_mpu_cesr_t *) HW_MPU_CESR_ADDR(x))
#define HW_MPU_CESR_RD(x)        (HW_MPU_CESR(x).U)
#define HW_MPU_CESR_WR(x, v)     (HW_MPU_CESR(x).U = (v))
#define HW_MPU_CESR_SET(x, v)    (HW_MPU_CESR_WR(x, HW_MPU_CESR_RD(x) |  (v)))
#define HW_MPU_CESR_CLR(x, v)    (HW_MPU_CESR_WR(x, HW_MPU_CESR_RD(x) & ~(v)))
#define HW_MPU_CESR_TOG(x, v)    (HW_MPU_CESR_WR(x, HW_MPU_CESR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MPU_CESR bitfields
 */

/*!
 * @name Register MPU_CESR, field VLD[0] (RW)
 *
 * Global enable/disable for the MPU.
 *
 * Values:
 * - 0 - MPU is disabled. All accesses from all bus masters are allowed.
 * - 1 - MPU is enabled
 */
/*@{*/
#define BP_MPU_CESR_VLD      (0U)          /*!< Bit position for MPU_CESR_VLD. */
#define BM_MPU_CESR_VLD      (0x00000001U) /*!< Bit mask for MPU_CESR_VLD. */
#define BS_MPU_CESR_VLD      (1U)          /*!< Bit field size in bits for MPU_CESR_VLD. */

/*! @brief Read current value of the MPU_CESR_VLD field. */
#define BR_MPU_CESR_VLD(x)   (BITBAND_ACCESS32(HW_MPU_CESR_ADDR(x), BP_MPU_CESR_VLD))

/*! @brief Format value for bitfield MPU_CESR_VLD. */
#define BF_MPU_CESR_VLD(v)   ((uint32_t)((uint32_t)(v) << BP_MPU_CESR_VLD) & BM_MPU_CESR_VLD)

/*! @brief Set the VLD field to a new value. */
#define BW_MPU_CESR_VLD(x, v) (BITBAND_ACCESS32(HW_MPU_CESR_ADDR(x), BP_MPU_CESR_VLD) = (v))
/*@}*/

/*!
 * @name Register MPU_CESR, field NRGD[11:8] (RO)
 *
 * Indicates the number of region descriptors implemented in the MPU.
 *
 * Values:
 * - 0000 - 8 region descriptors
 * - 0001 - 12 region descriptors
 * - 0010 - 16 region descriptors
 */
/*@{*/
#define BP_MPU_CESR_NRGD     (8U)          /*!< Bit position for MPU_CESR_NRGD. */
#define BM_MPU_CESR_NRGD     (0x00000F00U) /*!< Bit mask for MPU_CESR_NRGD. */
#define BS_MPU_CESR_NRGD     (4U)          /*!< Bit field size in bits for MPU_CESR_NRGD. */

/*! @brief Read current value of the MPU_CESR_NRGD field. */
#define BR_MPU_CESR_NRGD(x)  (HW_MPU_CESR(x).B.NRGD)
/*@}*/

/*!
 * @name Register MPU_CESR, field NSP[15:12] (RO)
 *
 * Specifies the number of slave ports connected to the MPU.
 */
/*@{*/
#define BP_MPU_CESR_NSP      (12U)         /*!< Bit position for MPU_CESR_NSP. */
#define BM_MPU_CESR_NSP      (0x0000F000U) /*!< Bit mask for MPU_CESR_NSP. */
#define BS_MPU_CESR_NSP      (4U)          /*!< Bit field size in bits for MPU_CESR_NSP. */

/*! @brief Read current value of the MPU_CESR_NSP field. */
#define BR_MPU_CESR_NSP(x)   (HW_MPU_CESR(x).B.NSP)
/*@}*/

/*!
 * @name Register MPU_CESR, field HRL[19:16] (RO)
 *
 * Specifies the MPU's hardware and definition revision level. It can be read by
 * software to determine the functional definition of the module.
 */
/*@{*/
#define BP_MPU_CESR_HRL      (16U)         /*!< Bit position for MPU_CESR_HRL. */
#define BM_MPU_CESR_HRL      (0x000F0000U) /*!< Bit mask for MPU_CESR_HRL. */
#define BS_MPU_CESR_HRL      (4U)          /*!< Bit field size in bits for MPU_CESR_HRL. */

/*! @brief Read current value of the MPU_CESR_HRL field. */
#define BR_MPU_CESR_HRL(x)   (HW_MPU_CESR(x).B.HRL)
/*@}*/

/*!
 * @name Register MPU_CESR, field SPERR[31:27] (W1C)
 *
 * Indicates a captured error in EARn and EDRn. This bit is set when the
 * hardware detects an error and records the faulting address and attributes. It is
 * cleared by writing one to it. If another error is captured at the exact same cycle
 * as the write, the flag remains set. A find-first-one instruction or
 * equivalent can detect the presence of a captured error. The following shows the
 * correspondence between the bit number and slave port number: Bit 31 corresponds to
 * slave port 0. Bit 30 corresponds to slave port 1. Bit 29 corresponds to slave
 * port 2. Bit 28 corresponds to slave port 3. Bit 27 corresponds to slave port 4.
 *
 * Values:
 * - 0 - No error has occurred for slave port n.
 * - 1 - An error has occurred for slave port n.
 */
/*@{*/
#define BP_MPU_CESR_SPERR    (27U)         /*!< Bit position for MPU_CESR_SPERR. */
#define BM_MPU_CESR_SPERR    (0xF8000000U) /*!< Bit mask for MPU_CESR_SPERR. */
#define BS_MPU_CESR_SPERR    (5U)          /*!< Bit field size in bits for MPU_CESR_SPERR. */

/*! @brief Read current value of the MPU_CESR_SPERR field. */
#define BR_MPU_CESR_SPERR(x) (HW_MPU_CESR(x).B.SPERR)

/*! @brief Format value for bitfield MPU_CESR_SPERR. */
#define BF_MPU_CESR_SPERR(v) ((uint32_t)((uint32_t)(v) << BP_MPU_CESR_SPERR) & BM_MPU_CESR_SPERR)

/*! @brief Set the SPERR field to a new value. */
#define BW_MPU_CESR_SPERR(x, v) (HW_MPU_CESR_WR(x, (HW_MPU_CESR_RD(x) & ~BM_MPU_CESR_SPERR) | BF_MPU_CESR_SPERR(v)))
/*@}*/

/*******************************************************************************
 * HW_MPU_EARn - Error Address Register, slave port n
 ******************************************************************************/

/*!
 * @brief HW_MPU_EARn - Error Address Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, the 32-bit reference
 * address is captured in this read-only register and the corresponding bit in
 * CESR[SPERR] set. Additional information about the faulting access is captured in
 * the corresponding EDRn at the same time. This register and the corresponding
 * EDRn contain the most recent access error; there are no hardware interlocks with
 * CESR[SPERR], as the error registers are always loaded upon the occurrence of
 * each protection violation.
 */
typedef union _hw_mpu_earn
{
    uint32_t U;
    struct _hw_mpu_earn_bitfields
    {
        uint32_t EADDR : 32;           /*!< [31:0] Error Address */
    } B;
} hw_mpu_earn_t;

/*!
 * @name Constants and macros for entire MPU_EARn register
 */
/*@{*/
#define HW_MPU_EARn_COUNT (5U)

#define HW_MPU_EARn_ADDR(x, n)   ((uint32_t)(x) + 0x10U + (0x8U * (n)))

#define HW_MPU_EARn(x, n)        (*(__I hw_mpu_earn_t *) HW_MPU_EARn_ADDR(x, n))
#define HW_MPU_EARn_RD(x, n)     (HW_MPU_EARn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual MPU_EARn bitfields
 */

/*!
 * @name Register MPU_EARn, field EADDR[31:0] (RO)
 *
 * Indicates the reference address from slave port n that generated the access
 * error
 */
/*@{*/
#define BP_MPU_EARn_EADDR    (0U)          /*!< Bit position for MPU_EARn_EADDR. */
#define BM_MPU_EARn_EADDR    (0xFFFFFFFFU) /*!< Bit mask for MPU_EARn_EADDR. */
#define BS_MPU_EARn_EADDR    (32U)         /*!< Bit field size in bits for MPU_EARn_EADDR. */

/*! @brief Read current value of the MPU_EARn_EADDR field. */
#define BR_MPU_EARn_EADDR(x, n) (HW_MPU_EARn(x, n).U)
/*@}*/
/*******************************************************************************
 * HW_MPU_EDRn - Error Detail Register, slave port n
 ******************************************************************************/

/*!
 * @brief HW_MPU_EDRn - Error Detail Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, 32 bits of error detail
 * are captured in this read-only register and the corresponding bit in
 * CESR[SPERR] is set. Information on the faulting address is captured in the
 * corresponding EARn register at the same time. This register and the corresponding EARn
 * register contain the most recent access error; there are no hardware interlocks
 * with CESR[SPERR] as the error registers are always loaded upon the occurrence
 * of each protection violation.
 */
typedef union _hw_mpu_edrn
{
    uint32_t U;
    struct _hw_mpu_edrn_bitfields
    {
        uint32_t ERW : 1;              /*!< [0] Error Read/Write */
        uint32_t EATTR : 3;            /*!< [3:1] Error Attributes */
        uint32_t EMN : 4;              /*!< [7:4] Error Master Number */
        uint32_t EPID : 8;             /*!< [15:8] Error Process Identification */
        uint32_t EACD : 16;            /*!< [31:16] Error Access Control Detail */
    } B;
} hw_mpu_edrn_t;

/*!
 * @name Constants and macros for entire MPU_EDRn register
 */
/*@{*/
#define HW_MPU_EDRn_COUNT (5U)

#define HW_MPU_EDRn_ADDR(x, n)   ((uint32_t)(x) + 0x14U + (0x8U * (n)))

#define HW_MPU_EDRn(x, n)        (*(__I hw_mpu_edrn_t *) HW_MPU_EDRn_ADDR(x, n))
#define HW_MPU_EDRn_RD(x, n)     (HW_MPU_EDRn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual MPU_EDRn bitfields
 */

/*!
 * @name Register MPU_EDRn, field ERW[0] (RO)
 *
 * Indicates the access type of the faulting reference.
 *
 * Values:
 * - 0 - Read
 * - 1 - Write
 */
/*@{*/
#define BP_MPU_EDRn_ERW      (0U)          /*!< Bit position for MPU_EDRn_ERW. */
#define BM_MPU_EDRn_ERW      (0x00000001U) /*!< Bit mask for MPU_EDRn_ERW. */
#define BS_MPU_EDRn_ERW      (1U)          /*!< Bit field size in bits for MPU_EDRn_ERW. */

/*! @brief Read current value of the MPU_EDRn_ERW field. */
#define BR_MPU_EDRn_ERW(x, n) (BITBAND_ACCESS32(HW_MPU_EDRn_ADDR(x, n), BP_MPU_EDRn_ERW))
/*@}*/

/*!
 * @name Register MPU_EDRn, field EATTR[3:1] (RO)
 *
 * Indicates attribute information about the faulting reference. All other
 * encodings are reserved.
 *
 * Values:
 * - 000 - User mode, instruction access
 * - 001 - User mode, data access
 * - 010 - Supervisor mode, instruction access
 * - 011 - Supervisor mode, data access
 */
/*@{*/
#define BP_MPU_EDRn_EATTR    (1U)          /*!< Bit position for MPU_EDRn_EATTR. */
#define BM_MPU_EDRn_EATTR    (0x0000000EU) /*!< Bit mask for MPU_EDRn_EATTR. */
#define BS_MPU_EDRn_EATTR    (3U)          /*!< Bit field size in bits for MPU_EDRn_EATTR. */

/*! @brief Read current value of the MPU_EDRn_EATTR field. */
#define BR_MPU_EDRn_EATTR(x, n) (HW_MPU_EDRn(x, n).B.EATTR)
/*@}*/

/*!
 * @name Register MPU_EDRn, field EMN[7:4] (RO)
 *
 * Indicates the bus master that generated the access error.
 */
/*@{*/
#define BP_MPU_EDRn_EMN      (4U)          /*!< Bit position for MPU_EDRn_EMN. */
#define BM_MPU_EDRn_EMN      (0x000000F0U) /*!< Bit mask for MPU_EDRn_EMN. */
#define BS_MPU_EDRn_EMN      (4U)          /*!< Bit field size in bits for MPU_EDRn_EMN. */

/*! @brief Read current value of the MPU_EDRn_EMN field. */
#define BR_MPU_EDRn_EMN(x, n) (HW_MPU_EDRn(x, n).B.EMN)
/*@}*/

/*!
 * @name Register MPU_EDRn, field EPID[15:8] (RO)
 *
 * Records the process identifier of the faulting reference. The process
 * identifier is typically driven only by processor cores; for other bus masters, this
 * field is cleared.
 */
/*@{*/
#define BP_MPU_EDRn_EPID     (8U)          /*!< Bit position for MPU_EDRn_EPID. */
#define BM_MPU_EDRn_EPID     (0x0000FF00U) /*!< Bit mask for MPU_EDRn_EPID. */
#define BS_MPU_EDRn_EPID     (8U)          /*!< Bit field size in bits for MPU_EDRn_EPID. */

/*! @brief Read current value of the MPU_EDRn_EPID field. */
#define BR_MPU_EDRn_EPID(x, n) (HW_MPU_EDRn(x, n).B.EPID)
/*@}*/

/*!
 * @name Register MPU_EDRn, field EACD[31:16] (RO)
 *
 * Indicates the region descriptor with the access error. If EDRn contains a
 * captured error and EACD is cleared, an access did not hit in any region
 * descriptor. If only a single EACD bit is set, the protection error was caused by a
 * single non-overlapping region descriptor. If two or more EACD bits are set, the
 * protection error was caused by an overlapping set of region descriptors.
 */
/*@{*/
#define BP_MPU_EDRn_EACD     (16U)         /*!< Bit position for MPU_EDRn_EACD. */
#define BM_MPU_EDRn_EACD     (0xFFFF0000U) /*!< Bit mask for MPU_EDRn_EACD. */
#define BS_MPU_EDRn_EACD     (16U)         /*!< Bit field size in bits for MPU_EDRn_EACD. */

/*! @brief Read current value of the MPU_EDRn_EACD field. */
#define BR_MPU_EDRn_EACD(x, n) (HW_MPU_EDRn(x, n).B.EACD)
/*@}*/

/*******************************************************************************
 * HW_MPU_RGDn_WORD0 - Region Descriptor n, Word 0
 ******************************************************************************/

/*!
 * @brief HW_MPU_RGDn_WORD0 - Region Descriptor n, Word 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The first word of the region descriptor defines the 0-modulo-32 byte start
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
typedef union _hw_mpu_rgdn_word0
{
    uint32_t U;
    struct _hw_mpu_rgdn_word0_bitfields
    {
        uint32_t RESERVED0 : 5;        /*!< [4:0]  */
        uint32_t SRTADDR : 27;         /*!< [31:5] Start Address */
    } B;
} hw_mpu_rgdn_word0_t;

/*!
 * @name Constants and macros for entire MPU_RGDn_WORD0 register
 */
/*@{*/
#define HW_MPU_RGDn_WORD0_COUNT (12U)

#define HW_MPU_RGDn_WORD0_ADDR(x, n) ((uint32_t)(x) + 0x400U + (0x10U * (n)))

#define HW_MPU_RGDn_WORD0(x, n)  (*(__IO hw_mpu_rgdn_word0_t *) HW_MPU_RGDn_WORD0_ADDR(x, n))
#define HW_MPU_RGDn_WORD0_RD(x, n) (HW_MPU_RGDn_WORD0(x, n).U)
#define HW_MPU_RGDn_WORD0_WR(x, n, v) (HW_MPU_RGDn_WORD0(x, n).U = (v))
#define HW_MPU_RGDn_WORD0_SET(x, n, v) (HW_MPU_RGDn_WORD0_WR(x, n, HW_MPU_RGDn_WORD0_RD(x, n) |  (v)))
#define HW_MPU_RGDn_WORD0_CLR(x, n, v) (HW_MPU_RGDn_WORD0_WR(x, n, HW_MPU_RGDn_WORD0_RD(x, n) & ~(v)))
#define HW_MPU_RGDn_WORD0_TOG(x, n, v) (HW_MPU_RGDn_WORD0_WR(x, n, HW_MPU_RGDn_WORD0_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDn_WORD0 bitfields
 */

/*!
 * @name Register MPU_RGDn_WORD0, field SRTADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 0-modulo-32 byte start address of
 * the memory region.
 */
/*@{*/
#define BP_MPU_RGDn_WORD0_SRTADDR (5U)     /*!< Bit position for MPU_RGDn_WORD0_SRTADDR. */
#define BM_MPU_RGDn_WORD0_SRTADDR (0xFFFFFFE0U) /*!< Bit mask for MPU_RGDn_WORD0_SRTADDR. */
#define BS_MPU_RGDn_WORD0_SRTADDR (27U)    /*!< Bit field size in bits for MPU_RGDn_WORD0_SRTADDR. */

/*! @brief Read current value of the MPU_RGDn_WORD0_SRTADDR field. */
#define BR_MPU_RGDn_WORD0_SRTADDR(x, n) (HW_MPU_RGDn_WORD0(x, n).B.SRTADDR)

/*! @brief Format value for bitfield MPU_RGDn_WORD0_SRTADDR. */
#define BF_MPU_RGDn_WORD0_SRTADDR(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD0_SRTADDR) & BM_MPU_RGDn_WORD0_SRTADDR)

/*! @brief Set the SRTADDR field to a new value. */
#define BW_MPU_RGDn_WORD0_SRTADDR(x, n, v) (HW_MPU_RGDn_WORD0_WR(x, n, (HW_MPU_RGDn_WORD0_RD(x, n) & ~BM_MPU_RGDn_WORD0_SRTADDR) | BF_MPU_RGDn_WORD0_SRTADDR(v)))
/*@}*/
/*******************************************************************************
 * HW_MPU_RGDn_WORD1 - Region Descriptor n, Word 1
 ******************************************************************************/

/*!
 * @brief HW_MPU_RGDn_WORD1 - Region Descriptor n, Word 1 (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The second word of the region descriptor defines the 31-modulo-32 byte end
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
typedef union _hw_mpu_rgdn_word1
{
    uint32_t U;
    struct _hw_mpu_rgdn_word1_bitfields
    {
        uint32_t RESERVED0 : 5;        /*!< [4:0]  */
        uint32_t ENDADDR : 27;         /*!< [31:5] End Address */
    } B;
} hw_mpu_rgdn_word1_t;

/*!
 * @name Constants and macros for entire MPU_RGDn_WORD1 register
 */
/*@{*/
#define HW_MPU_RGDn_WORD1_COUNT (12U)

#define HW_MPU_RGDn_WORD1_ADDR(x, n) ((uint32_t)(x) + 0x404U + (0x10U * (n)))

#define HW_MPU_RGDn_WORD1(x, n)  (*(__IO hw_mpu_rgdn_word1_t *) HW_MPU_RGDn_WORD1_ADDR(x, n))
#define HW_MPU_RGDn_WORD1_RD(x, n) (HW_MPU_RGDn_WORD1(x, n).U)
#define HW_MPU_RGDn_WORD1_WR(x, n, v) (HW_MPU_RGDn_WORD1(x, n).U = (v))
#define HW_MPU_RGDn_WORD1_SET(x, n, v) (HW_MPU_RGDn_WORD1_WR(x, n, HW_MPU_RGDn_WORD1_RD(x, n) |  (v)))
#define HW_MPU_RGDn_WORD1_CLR(x, n, v) (HW_MPU_RGDn_WORD1_WR(x, n, HW_MPU_RGDn_WORD1_RD(x, n) & ~(v)))
#define HW_MPU_RGDn_WORD1_TOG(x, n, v) (HW_MPU_RGDn_WORD1_WR(x, n, HW_MPU_RGDn_WORD1_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDn_WORD1 bitfields
 */

/*!
 * @name Register MPU_RGDn_WORD1, field ENDADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 31-modulo-32 byte end address of the
 * memory region. The MPU does not verify that ENDADDR >= SRTADDR.
 */
/*@{*/
#define BP_MPU_RGDn_WORD1_ENDADDR (5U)     /*!< Bit position for MPU_RGDn_WORD1_ENDADDR. */
#define BM_MPU_RGDn_WORD1_ENDADDR (0xFFFFFFE0U) /*!< Bit mask for MPU_RGDn_WORD1_ENDADDR. */
#define BS_MPU_RGDn_WORD1_ENDADDR (27U)    /*!< Bit field size in bits for MPU_RGDn_WORD1_ENDADDR. */

/*! @brief Read current value of the MPU_RGDn_WORD1_ENDADDR field. */
#define BR_MPU_RGDn_WORD1_ENDADDR(x, n) (HW_MPU_RGDn_WORD1(x, n).B.ENDADDR)

/*! @brief Format value for bitfield MPU_RGDn_WORD1_ENDADDR. */
#define BF_MPU_RGDn_WORD1_ENDADDR(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD1_ENDADDR) & BM_MPU_RGDn_WORD1_ENDADDR)

/*! @brief Set the ENDADDR field to a new value. */
#define BW_MPU_RGDn_WORD1_ENDADDR(x, n, v) (HW_MPU_RGDn_WORD1_WR(x, n, (HW_MPU_RGDn_WORD1_RD(x, n) & ~BM_MPU_RGDn_WORD1_ENDADDR) | BF_MPU_RGDn_WORD1_ENDADDR(v)))
/*@}*/
/*******************************************************************************
 * HW_MPU_RGDn_WORD2 - Region Descriptor n, Word 2
 ******************************************************************************/

/*!
 * @brief HW_MPU_RGDn_WORD2 - Region Descriptor n, Word 2 (RW)
 *
 * Reset value: 0x0061F7DFU
 *
 * The third word of the region descriptor defines the access control rights of
 * the memory region. The access control privileges depend on two broad
 * classifications of bus masters: Bus masters 0-3 have a 5-bit field defining separate
 * privilege rights for user and supervisor mode accesses, as well as the optional
 * inclusion of a process identification field within the definition. Bus masters
 * 4-7 are limited to separate read and write permissions. For the privilege
 * rights of bus masters 0-3, there are three flags associated with this function:
 * Read (r) refers to accessing the referenced memory address using an operand
 * (data) fetch Write (w) refers to updating the referenced memory address using a
 * store (data) instruction Execute (x) refers to reading the referenced memory
 * address using an instruction fetch Writes to RGDn_WORD2 clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]). If only updating the access controls, write
 * to RGDAACn instead because stores to these locations do not affect the
 * descriptor's valid bit.
 */
typedef union _hw_mpu_rgdn_word2
{
    uint32_t U;
    struct _hw_mpu_rgdn_word2_bitfields
    {
        uint32_t M0UM : 3;             /*!< [2:0] Bus Master 0 User Mode Access Control */
        uint32_t M0SM : 2;             /*!< [4:3] Bus Master 0 Supervisor Mode Access
                                        * Control */
        uint32_t M0PE : 1;             /*!< [5] Bus Master 0 Process Identifier enable */
        uint32_t M1UM : 3;             /*!< [8:6] Bus Master 1 User Mode Access Control */
        uint32_t M1SM : 2;             /*!< [10:9] Bus Master 1 Supervisor Mode Access
                                        * Control */
        uint32_t M1PE : 1;             /*!< [11] Bus Master 1 Process Identifier enable */
        uint32_t M2UM : 3;             /*!< [14:12] Bus Master 2 User Mode Access control
                                        * */
        uint32_t M2SM : 2;             /*!< [16:15] Bus Master 2 Supervisor Mode Access
                                        * Control */
        uint32_t M2PE : 1;             /*!< [17] Bus Master 2 Process Identifier Enable */
        uint32_t M3UM : 3;             /*!< [20:18] Bus Master 3 User Mode Access Control
                                        * */
        uint32_t M3SM : 2;             /*!< [22:21] Bus Master 3 Supervisor Mode Access
                                        * Control */
        uint32_t M3PE : 1;             /*!< [23] Bus Master 3 Process Identifier Enable */
        uint32_t M4WE : 1;             /*!< [24] Bus Master 4 Write Enable */
        uint32_t M4RE : 1;             /*!< [25] Bus Master 4 Read Enable */
        uint32_t M5WE : 1;             /*!< [26] Bus Master 5 Write Enable */
        uint32_t M5RE : 1;             /*!< [27] Bus Master 5 Read Enable */
        uint32_t M6WE : 1;             /*!< [28] Bus Master 6 Write Enable */
        uint32_t M6RE : 1;             /*!< [29] Bus Master 6 Read Enable */
        uint32_t M7WE : 1;             /*!< [30] Bus Master 7 Write Enable */
        uint32_t M7RE : 1;             /*!< [31] Bus Master 7 Read Enable */
    } B;
} hw_mpu_rgdn_word2_t;

/*!
 * @name Constants and macros for entire MPU_RGDn_WORD2 register
 */
/*@{*/
#define HW_MPU_RGDn_WORD2_COUNT (12U)

#define HW_MPU_RGDn_WORD2_ADDR(x, n) ((uint32_t)(x) + 0x408U + (0x10U * (n)))

#define HW_MPU_RGDn_WORD2(x, n)  (*(__IO hw_mpu_rgdn_word2_t *) HW_MPU_RGDn_WORD2_ADDR(x, n))
#define HW_MPU_RGDn_WORD2_RD(x, n) (HW_MPU_RGDn_WORD2(x, n).U)
#define HW_MPU_RGDn_WORD2_WR(x, n, v) (HW_MPU_RGDn_WORD2(x, n).U = (v))
#define HW_MPU_RGDn_WORD2_SET(x, n, v) (HW_MPU_RGDn_WORD2_WR(x, n, HW_MPU_RGDn_WORD2_RD(x, n) |  (v)))
#define HW_MPU_RGDn_WORD2_CLR(x, n, v) (HW_MPU_RGDn_WORD2_WR(x, n, HW_MPU_RGDn_WORD2_RD(x, n) & ~(v)))
#define HW_MPU_RGDn_WORD2_TOG(x, n, v) (HW_MPU_RGDn_WORD2_WR(x, n, HW_MPU_RGDn_WORD2_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDn_WORD2 bitfields
 */

/*!
 * @name Register MPU_RGDn_WORD2, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M0UM (0U)        /*!< Bit position for MPU_RGDn_WORD2_M0UM. */
#define BM_MPU_RGDn_WORD2_M0UM (0x00000007U) /*!< Bit mask for MPU_RGDn_WORD2_M0UM. */
#define BS_MPU_RGDn_WORD2_M0UM (3U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M0UM. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M0UM field. */
#define BR_MPU_RGDn_WORD2_M0UM(x, n) (HW_MPU_RGDn_WORD2(x, n).B.M0UM)

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M0UM. */
#define BF_MPU_RGDn_WORD2_M0UM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M0UM) & BM_MPU_RGDn_WORD2_M0UM)

/*! @brief Set the M0UM field to a new value. */
#define BW_MPU_RGDn_WORD2_M0UM(x, n, v) (HW_MPU_RGDn_WORD2_WR(x, n, (HW_MPU_RGDn_WORD2_RD(x, n) & ~BM_MPU_RGDn_WORD2_M0UM) | BF_MPU_RGDn_WORD2_M0UM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M0SM (3U)        /*!< Bit position for MPU_RGDn_WORD2_M0SM. */
#define BM_MPU_RGDn_WORD2_M0SM (0x00000018U) /*!< Bit mask for MPU_RGDn_WORD2_M0SM. */
#define BS_MPU_RGDn_WORD2_M0SM (2U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M0SM. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M0SM field. */
#define BR_MPU_RGDn_WORD2_M0SM(x, n) (HW_MPU_RGDn_WORD2(x, n).B.M0SM)

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M0SM. */
#define BF_MPU_RGDn_WORD2_M0SM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M0SM) & BM_MPU_RGDn_WORD2_M0SM)

/*! @brief Set the M0SM field to a new value. */
#define BW_MPU_RGDn_WORD2_M0SM(x, n, v) (HW_MPU_RGDn_WORD2_WR(x, n, (HW_MPU_RGDn_WORD2_RD(x, n) & ~BM_MPU_RGDn_WORD2_M0SM) | BF_MPU_RGDn_WORD2_M0SM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M0PE[5] (RW)
 *
 * See M0PE description.
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M0PE (5U)        /*!< Bit position for MPU_RGDn_WORD2_M0PE. */
#define BM_MPU_RGDn_WORD2_M0PE (0x00000020U) /*!< Bit mask for MPU_RGDn_WORD2_M0PE. */
#define BS_MPU_RGDn_WORD2_M0PE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M0PE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M0PE field. */
#define BR_MPU_RGDn_WORD2_M0PE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M0PE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M0PE. */
#define BF_MPU_RGDn_WORD2_M0PE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M0PE) & BM_MPU_RGDn_WORD2_M0PE)

/*! @brief Set the M0PE field to a new value. */
#define BW_MPU_RGDn_WORD2_M0PE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M0PE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M1UM (6U)        /*!< Bit position for MPU_RGDn_WORD2_M1UM. */
#define BM_MPU_RGDn_WORD2_M1UM (0x000001C0U) /*!< Bit mask for MPU_RGDn_WORD2_M1UM. */
#define BS_MPU_RGDn_WORD2_M1UM (3U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M1UM. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M1UM field. */
#define BR_MPU_RGDn_WORD2_M1UM(x, n) (HW_MPU_RGDn_WORD2(x, n).B.M1UM)

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M1UM. */
#define BF_MPU_RGDn_WORD2_M1UM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M1UM) & BM_MPU_RGDn_WORD2_M1UM)

/*! @brief Set the M1UM field to a new value. */
#define BW_MPU_RGDn_WORD2_M1UM(x, n, v) (HW_MPU_RGDn_WORD2_WR(x, n, (HW_MPU_RGDn_WORD2_RD(x, n) & ~BM_MPU_RGDn_WORD2_M1UM) | BF_MPU_RGDn_WORD2_M1UM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M1SM (9U)        /*!< Bit position for MPU_RGDn_WORD2_M1SM. */
#define BM_MPU_RGDn_WORD2_M1SM (0x00000600U) /*!< Bit mask for MPU_RGDn_WORD2_M1SM. */
#define BS_MPU_RGDn_WORD2_M1SM (2U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M1SM. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M1SM field. */
#define BR_MPU_RGDn_WORD2_M1SM(x, n) (HW_MPU_RGDn_WORD2(x, n).B.M1SM)

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M1SM. */
#define BF_MPU_RGDn_WORD2_M1SM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M1SM) & BM_MPU_RGDn_WORD2_M1SM)

/*! @brief Set the M1SM field to a new value. */
#define BW_MPU_RGDn_WORD2_M1SM(x, n, v) (HW_MPU_RGDn_WORD2_WR(x, n, (HW_MPU_RGDn_WORD2_RD(x, n) & ~BM_MPU_RGDn_WORD2_M1SM) | BF_MPU_RGDn_WORD2_M1SM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M1PE (11U)       /*!< Bit position for MPU_RGDn_WORD2_M1PE. */
#define BM_MPU_RGDn_WORD2_M1PE (0x00000800U) /*!< Bit mask for MPU_RGDn_WORD2_M1PE. */
#define BS_MPU_RGDn_WORD2_M1PE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M1PE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M1PE field. */
#define BR_MPU_RGDn_WORD2_M1PE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M1PE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M1PE. */
#define BF_MPU_RGDn_WORD2_M1PE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M1PE) & BM_MPU_RGDn_WORD2_M1PE)

/*! @brief Set the M1PE field to a new value. */
#define BW_MPU_RGDn_WORD2_M1PE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M1PE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M2UM (12U)       /*!< Bit position for MPU_RGDn_WORD2_M2UM. */
#define BM_MPU_RGDn_WORD2_M2UM (0x00007000U) /*!< Bit mask for MPU_RGDn_WORD2_M2UM. */
#define BS_MPU_RGDn_WORD2_M2UM (3U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M2UM. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M2UM field. */
#define BR_MPU_RGDn_WORD2_M2UM(x, n) (HW_MPU_RGDn_WORD2(x, n).B.M2UM)

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M2UM. */
#define BF_MPU_RGDn_WORD2_M2UM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M2UM) & BM_MPU_RGDn_WORD2_M2UM)

/*! @brief Set the M2UM field to a new value. */
#define BW_MPU_RGDn_WORD2_M2UM(x, n, v) (HW_MPU_RGDn_WORD2_WR(x, n, (HW_MPU_RGDn_WORD2_RD(x, n) & ~BM_MPU_RGDn_WORD2_M2UM) | BF_MPU_RGDn_WORD2_M2UM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M2SM (15U)       /*!< Bit position for MPU_RGDn_WORD2_M2SM. */
#define BM_MPU_RGDn_WORD2_M2SM (0x00018000U) /*!< Bit mask for MPU_RGDn_WORD2_M2SM. */
#define BS_MPU_RGDn_WORD2_M2SM (2U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M2SM. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M2SM field. */
#define BR_MPU_RGDn_WORD2_M2SM(x, n) (HW_MPU_RGDn_WORD2(x, n).B.M2SM)

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M2SM. */
#define BF_MPU_RGDn_WORD2_M2SM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M2SM) & BM_MPU_RGDn_WORD2_M2SM)

/*! @brief Set the M2SM field to a new value. */
#define BW_MPU_RGDn_WORD2_M2SM(x, n, v) (HW_MPU_RGDn_WORD2_WR(x, n, (HW_MPU_RGDn_WORD2_RD(x, n) & ~BM_MPU_RGDn_WORD2_M2SM) | BF_MPU_RGDn_WORD2_M2SM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M2PE (17U)       /*!< Bit position for MPU_RGDn_WORD2_M2PE. */
#define BM_MPU_RGDn_WORD2_M2PE (0x00020000U) /*!< Bit mask for MPU_RGDn_WORD2_M2PE. */
#define BS_MPU_RGDn_WORD2_M2PE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M2PE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M2PE field. */
#define BR_MPU_RGDn_WORD2_M2PE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M2PE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M2PE. */
#define BF_MPU_RGDn_WORD2_M2PE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M2PE) & BM_MPU_RGDn_WORD2_M2PE)

/*! @brief Set the M2PE field to a new value. */
#define BW_MPU_RGDn_WORD2_M2PE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M2PE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in User mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0 - An attempted access of that mode may be terminated with an access error
 *     (if not allowed by another descriptor) and the access not performed.
 * - 1 - Allows the given access type to occur
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M3UM (18U)       /*!< Bit position for MPU_RGDn_WORD2_M3UM. */
#define BM_MPU_RGDn_WORD2_M3UM (0x001C0000U) /*!< Bit mask for MPU_RGDn_WORD2_M3UM. */
#define BS_MPU_RGDn_WORD2_M3UM (3U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M3UM. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M3UM field. */
#define BR_MPU_RGDn_WORD2_M3UM(x, n) (HW_MPU_RGDn_WORD2(x, n).B.M3UM)

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M3UM. */
#define BF_MPU_RGDn_WORD2_M3UM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M3UM) & BM_MPU_RGDn_WORD2_M3UM)

/*! @brief Set the M3UM field to a new value. */
#define BW_MPU_RGDn_WORD2_M3UM(x, n, v) (HW_MPU_RGDn_WORD2_WR(x, n, (HW_MPU_RGDn_WORD2_RD(x, n) & ~BM_MPU_RGDn_WORD2_M3UM) | BF_MPU_RGDn_WORD2_M3UM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 00 - r/w/x; read, write and execute allowed
 * - 01 - r/x; read and execute allowed, but no write
 * - 10 - r/w; read and write allowed, but no execute
 * - 11 - Same as User mode defined in M3UM
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M3SM (21U)       /*!< Bit position for MPU_RGDn_WORD2_M3SM. */
#define BM_MPU_RGDn_WORD2_M3SM (0x00600000U) /*!< Bit mask for MPU_RGDn_WORD2_M3SM. */
#define BS_MPU_RGDn_WORD2_M3SM (2U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M3SM. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M3SM field. */
#define BR_MPU_RGDn_WORD2_M3SM(x, n) (HW_MPU_RGDn_WORD2(x, n).B.M3SM)

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M3SM. */
#define BF_MPU_RGDn_WORD2_M3SM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M3SM) & BM_MPU_RGDn_WORD2_M3SM)

/*! @brief Set the M3SM field to a new value. */
#define BW_MPU_RGDn_WORD2_M3SM(x, n, v) (HW_MPU_RGDn_WORD2_WR(x, n, (HW_MPU_RGDn_WORD2_RD(x, n) & ~BM_MPU_RGDn_WORD2_M3SM) | BF_MPU_RGDn_WORD2_M3SM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M3PE[23] (RW)
 *
 * Values:
 * - 0 - Do not include the process identifier in the evaluation
 * - 1 - Include the process identifier and mask (RGDn_WORD3) in the region hit
 *     evaluation
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M3PE (23U)       /*!< Bit position for MPU_RGDn_WORD2_M3PE. */
#define BM_MPU_RGDn_WORD2_M3PE (0x00800000U) /*!< Bit mask for MPU_RGDn_WORD2_M3PE. */
#define BS_MPU_RGDn_WORD2_M3PE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M3PE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M3PE field. */
#define BR_MPU_RGDn_WORD2_M3PE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M3PE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M3PE. */
#define BF_MPU_RGDn_WORD2_M3PE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M3PE) & BM_MPU_RGDn_WORD2_M3PE)

/*! @brief Set the M3PE field to a new value. */
#define BW_MPU_RGDn_WORD2_M3PE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M3PE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M4WE[24] (RW)
 *
 * Values:
 * - 0 - Bus master 4 writes terminate with an access error and the write is not
 *     performed
 * - 1 - Bus master 4 writes allowed
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M4WE (24U)       /*!< Bit position for MPU_RGDn_WORD2_M4WE. */
#define BM_MPU_RGDn_WORD2_M4WE (0x01000000U) /*!< Bit mask for MPU_RGDn_WORD2_M4WE. */
#define BS_MPU_RGDn_WORD2_M4WE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M4WE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M4WE field. */
#define BR_MPU_RGDn_WORD2_M4WE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M4WE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M4WE. */
#define BF_MPU_RGDn_WORD2_M4WE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M4WE) & BM_MPU_RGDn_WORD2_M4WE)

/*! @brief Set the M4WE field to a new value. */
#define BW_MPU_RGDn_WORD2_M4WE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M4WE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M4RE[25] (RW)
 *
 * Values:
 * - 0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 1 - Bus master 4 reads allowed
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M4RE (25U)       /*!< Bit position for MPU_RGDn_WORD2_M4RE. */
#define BM_MPU_RGDn_WORD2_M4RE (0x02000000U) /*!< Bit mask for MPU_RGDn_WORD2_M4RE. */
#define BS_MPU_RGDn_WORD2_M4RE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M4RE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M4RE field. */
#define BR_MPU_RGDn_WORD2_M4RE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M4RE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M4RE. */
#define BF_MPU_RGDn_WORD2_M4RE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M4RE) & BM_MPU_RGDn_WORD2_M4RE)

/*! @brief Set the M4RE field to a new value. */
#define BW_MPU_RGDn_WORD2_M4RE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M4RE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M5WE[26] (RW)
 *
 * Values:
 * - 0 - Bus master 5 writes terminate with an access error and the write is not
 *     performed
 * - 1 - Bus master 5 writes allowed
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M5WE (26U)       /*!< Bit position for MPU_RGDn_WORD2_M5WE. */
#define BM_MPU_RGDn_WORD2_M5WE (0x04000000U) /*!< Bit mask for MPU_RGDn_WORD2_M5WE. */
#define BS_MPU_RGDn_WORD2_M5WE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M5WE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M5WE field. */
#define BR_MPU_RGDn_WORD2_M5WE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M5WE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M5WE. */
#define BF_MPU_RGDn_WORD2_M5WE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M5WE) & BM_MPU_RGDn_WORD2_M5WE)

/*! @brief Set the M5WE field to a new value. */
#define BW_MPU_RGDn_WORD2_M5WE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M5WE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M5RE[27] (RW)
 *
 * Values:
 * - 0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 1 - Bus master 5 reads allowed
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M5RE (27U)       /*!< Bit position for MPU_RGDn_WORD2_M5RE. */
#define BM_MPU_RGDn_WORD2_M5RE (0x08000000U) /*!< Bit mask for MPU_RGDn_WORD2_M5RE. */
#define BS_MPU_RGDn_WORD2_M5RE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M5RE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M5RE field. */
#define BR_MPU_RGDn_WORD2_M5RE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M5RE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M5RE. */
#define BF_MPU_RGDn_WORD2_M5RE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M5RE) & BM_MPU_RGDn_WORD2_M5RE)

/*! @brief Set the M5RE field to a new value. */
#define BW_MPU_RGDn_WORD2_M5RE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M5RE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M6WE[28] (RW)
 *
 * Values:
 * - 0 - Bus master 6 writes terminate with an access error and the write is not
 *     performed
 * - 1 - Bus master 6 writes allowed
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M6WE (28U)       /*!< Bit position for MPU_RGDn_WORD2_M6WE. */
#define BM_MPU_RGDn_WORD2_M6WE (0x10000000U) /*!< Bit mask for MPU_RGDn_WORD2_M6WE. */
#define BS_MPU_RGDn_WORD2_M6WE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M6WE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M6WE field. */
#define BR_MPU_RGDn_WORD2_M6WE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M6WE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M6WE. */
#define BF_MPU_RGDn_WORD2_M6WE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M6WE) & BM_MPU_RGDn_WORD2_M6WE)

/*! @brief Set the M6WE field to a new value. */
#define BW_MPU_RGDn_WORD2_M6WE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M6WE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M6RE[29] (RW)
 *
 * Values:
 * - 0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 1 - Bus master 6 reads allowed
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M6RE (29U)       /*!< Bit position for MPU_RGDn_WORD2_M6RE. */
#define BM_MPU_RGDn_WORD2_M6RE (0x20000000U) /*!< Bit mask for MPU_RGDn_WORD2_M6RE. */
#define BS_MPU_RGDn_WORD2_M6RE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M6RE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M6RE field. */
#define BR_MPU_RGDn_WORD2_M6RE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M6RE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M6RE. */
#define BF_MPU_RGDn_WORD2_M6RE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M6RE) & BM_MPU_RGDn_WORD2_M6RE)

/*! @brief Set the M6RE field to a new value. */
#define BW_MPU_RGDn_WORD2_M6RE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M6RE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M7WE[30] (RW)
 *
 * Values:
 * - 0 - Bus master 7 writes terminate with an access error and the write is not
 *     performed
 * - 1 - Bus master 7 writes allowed
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M7WE (30U)       /*!< Bit position for MPU_RGDn_WORD2_M7WE. */
#define BM_MPU_RGDn_WORD2_M7WE (0x40000000U) /*!< Bit mask for MPU_RGDn_WORD2_M7WE. */
#define BS_MPU_RGDn_WORD2_M7WE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M7WE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M7WE field. */
#define BR_MPU_RGDn_WORD2_M7WE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M7WE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M7WE. */
#define BF_MPU_RGDn_WORD2_M7WE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M7WE) & BM_MPU_RGDn_WORD2_M7WE)

/*! @brief Set the M7WE field to a new value. */
#define BW_MPU_RGDn_WORD2_M7WE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M7WE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD2, field M7RE[31] (RW)
 *
 * Values:
 * - 0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 1 - Bus master 7 reads allowed
 */
/*@{*/
#define BP_MPU_RGDn_WORD2_M7RE (31U)       /*!< Bit position for MPU_RGDn_WORD2_M7RE. */
#define BM_MPU_RGDn_WORD2_M7RE (0x80000000U) /*!< Bit mask for MPU_RGDn_WORD2_M7RE. */
#define BS_MPU_RGDn_WORD2_M7RE (1U)        /*!< Bit field size in bits for MPU_RGDn_WORD2_M7RE. */

/*! @brief Read current value of the MPU_RGDn_WORD2_M7RE field. */
#define BR_MPU_RGDn_WORD2_M7RE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M7RE))

/*! @brief Format value for bitfield MPU_RGDn_WORD2_M7RE. */
#define BF_MPU_RGDn_WORD2_M7RE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD2_M7RE) & BM_MPU_RGDn_WORD2_M7RE)

/*! @brief Set the M7RE field to a new value. */
#define BW_MPU_RGDn_WORD2_M7RE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD2_ADDR(x, n), BP_MPU_RGDn_WORD2_M7RE) = (v))
/*@}*/
/*******************************************************************************
 * HW_MPU_RGDn_WORD3 - Region Descriptor n, Word 3
 ******************************************************************************/

/*!
 * @brief HW_MPU_RGDn_WORD3 - Region Descriptor n, Word 3 (RW)
 *
 * Reset value: 0x00000001U
 *
 * The fourth word of the region descriptor contains the optional process
 * identifier and mask, plus the region descriptor's valid bit.
 */
typedef union _hw_mpu_rgdn_word3
{
    uint32_t U;
    struct _hw_mpu_rgdn_word3_bitfields
    {
        uint32_t VLD : 1;              /*!< [0] Valid */
        uint32_t RESERVED0 : 15;       /*!< [15:1]  */
        uint32_t PIDMASK : 8;          /*!< [23:16] Process Identifier Mask */
        uint32_t PID : 8;              /*!< [31:24] Process Identifier */
    } B;
} hw_mpu_rgdn_word3_t;

/*!
 * @name Constants and macros for entire MPU_RGDn_WORD3 register
 */
/*@{*/
#define HW_MPU_RGDn_WORD3_COUNT (12U)

#define HW_MPU_RGDn_WORD3_ADDR(x, n) ((uint32_t)(x) + 0x40CU + (0x10U * (n)))

#define HW_MPU_RGDn_WORD3(x, n)  (*(__IO hw_mpu_rgdn_word3_t *) HW_MPU_RGDn_WORD3_ADDR(x, n))
#define HW_MPU_RGDn_WORD3_RD(x, n) (HW_MPU_RGDn_WORD3(x, n).U)
#define HW_MPU_RGDn_WORD3_WR(x, n, v) (HW_MPU_RGDn_WORD3(x, n).U = (v))
#define HW_MPU_RGDn_WORD3_SET(x, n, v) (HW_MPU_RGDn_WORD3_WR(x, n, HW_MPU_RGDn_WORD3_RD(x, n) |  (v)))
#define HW_MPU_RGDn_WORD3_CLR(x, n, v) (HW_MPU_RGDn_WORD3_WR(x, n, HW_MPU_RGDn_WORD3_RD(x, n) & ~(v)))
#define HW_MPU_RGDn_WORD3_TOG(x, n, v) (HW_MPU_RGDn_WORD3_WR(x, n, HW_MPU_RGDn_WORD3_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDn_WORD3 bitfields
 */

/*!
 * @name Register MPU_RGDn_WORD3, field VLD[0] (RW)
 *
 * Signals the region descriptor is valid. Any write to RGDn_WORD0-2 clears this
 * bit.
 *
 * Values:
 * - 0 - Region descriptor is invalid
 * - 1 - Region descriptor is valid
 */
/*@{*/
#define BP_MPU_RGDn_WORD3_VLD (0U)         /*!< Bit position for MPU_RGDn_WORD3_VLD. */
#define BM_MPU_RGDn_WORD3_VLD (0x00000001U) /*!< Bit mask for MPU_RGDn_WORD3_VLD. */
#define BS_MPU_RGDn_WORD3_VLD (1U)         /*!< Bit field size in bits for MPU_RGDn_WORD3_VLD. */

/*! @brief Read current value of the MPU_RGDn_WORD3_VLD field. */
#define BR_MPU_RGDn_WORD3_VLD(x, n) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD3_ADDR(x, n), BP_MPU_RGDn_WORD3_VLD))

/*! @brief Format value for bitfield MPU_RGDn_WORD3_VLD. */
#define BF_MPU_RGDn_WORD3_VLD(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD3_VLD) & BM_MPU_RGDn_WORD3_VLD)

/*! @brief Set the VLD field to a new value. */
#define BW_MPU_RGDn_WORD3_VLD(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDn_WORD3_ADDR(x, n), BP_MPU_RGDn_WORD3_VLD) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD3, field PIDMASK[23:16] (RW)
 *
 * Provides a masking capability so that multiple process identifiers can be
 * included as part of the region hit determination. If a bit in PIDMASK is set,
 * then the corresponding PID bit is ignored in the comparison. This field and PID
 * are included in the region hit determination if RGDn_WORD2[MxPE] is set. For
 * more information on the handling of the PID and PIDMASK, see "Access Evaluation
 * - Hit Determination."
 */
/*@{*/
#define BP_MPU_RGDn_WORD3_PIDMASK (16U)    /*!< Bit position for MPU_RGDn_WORD3_PIDMASK. */
#define BM_MPU_RGDn_WORD3_PIDMASK (0x00FF0000U) /*!< Bit mask for MPU_RGDn_WORD3_PIDMASK. */
#define BS_MPU_RGDn_WORD3_PIDMASK (8U)     /*!< Bit field size in bits for MPU_RGDn_WORD3_PIDMASK. */

/*! @brief Read current value of the MPU_RGDn_WORD3_PIDMASK field. */
#define BR_MPU_RGDn_WORD3_PIDMASK(x, n) (HW_MPU_RGDn_WORD3(x, n).B.PIDMASK)

/*! @brief Format value for bitfield MPU_RGDn_WORD3_PIDMASK. */
#define BF_MPU_RGDn_WORD3_PIDMASK(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD3_PIDMASK) & BM_MPU_RGDn_WORD3_PIDMASK)

/*! @brief Set the PIDMASK field to a new value. */
#define BW_MPU_RGDn_WORD3_PIDMASK(x, n, v) (HW_MPU_RGDn_WORD3_WR(x, n, (HW_MPU_RGDn_WORD3_RD(x, n) & ~BM_MPU_RGDn_WORD3_PIDMASK) | BF_MPU_RGDn_WORD3_PIDMASK(v)))
/*@}*/

/*!
 * @name Register MPU_RGDn_WORD3, field PID[31:24] (RW)
 *
 * Specifies the process identifier that is included in the region hit
 * determination if RGDn_WORD2[MxPE] is set. PIDMASK can mask individual bits in this
 * field.
 */
/*@{*/
#define BP_MPU_RGDn_WORD3_PID (24U)        /*!< Bit position for MPU_RGDn_WORD3_PID. */
#define BM_MPU_RGDn_WORD3_PID (0xFF000000U) /*!< Bit mask for MPU_RGDn_WORD3_PID. */
#define BS_MPU_RGDn_WORD3_PID (8U)         /*!< Bit field size in bits for MPU_RGDn_WORD3_PID. */

/*! @brief Read current value of the MPU_RGDn_WORD3_PID field. */
#define BR_MPU_RGDn_WORD3_PID(x, n) (HW_MPU_RGDn_WORD3(x, n).B.PID)

/*! @brief Format value for bitfield MPU_RGDn_WORD3_PID. */
#define BF_MPU_RGDn_WORD3_PID(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDn_WORD3_PID) & BM_MPU_RGDn_WORD3_PID)

/*! @brief Set the PID field to a new value. */
#define BW_MPU_RGDn_WORD3_PID(x, n, v) (HW_MPU_RGDn_WORD3_WR(x, n, (HW_MPU_RGDn_WORD3_RD(x, n) & ~BM_MPU_RGDn_WORD3_PID) | BF_MPU_RGDn_WORD3_PID(v)))
/*@}*/

/*******************************************************************************
 * HW_MPU_RGDAACn - Region Descriptor Alternate Access Control n
 ******************************************************************************/

/*!
 * @brief HW_MPU_RGDAACn - Region Descriptor Alternate Access Control n (RW)
 *
 * Reset value: 0x0061F7DFU
 *
 * Because software may adjust only the access controls within a region
 * descriptor (RGDn_WORD2) as different tasks execute, an alternate programming view of
 * this 32-bit entity is available. Writing to this register does not affect the
 * descriptor's valid bit.
 */
typedef union _hw_mpu_rgdaacn
{
    uint32_t U;
    struct _hw_mpu_rgdaacn_bitfields
    {
        uint32_t M0UM : 3;             /*!< [2:0] Bus Master 0 User Mode Access Control */
        uint32_t M0SM : 2;             /*!< [4:3] Bus Master 0 Supervisor Mode Access
                                        * Control */
        uint32_t M0PE : 1;             /*!< [5] Bus Master 0 Process Identifier Enable */
        uint32_t M1UM : 3;             /*!< [8:6] Bus Master 1 User Mode Access Control */
        uint32_t M1SM : 2;             /*!< [10:9] Bus Master 1 Supervisor Mode Access
                                        * Control */
        uint32_t M1PE : 1;             /*!< [11] Bus Master 1 Process Identifier Enable */
        uint32_t M2UM : 3;             /*!< [14:12] Bus Master 2 User Mode Access Control
                                        * */
        uint32_t M2SM : 2;             /*!< [16:15] Bus Master 2 Supervisor Mode Access
                                        * Control */
        uint32_t M2PE : 1;             /*!< [17] Bus Master 2 Process Identifier Enable */
        uint32_t M3UM : 3;             /*!< [20:18] Bus Master 3 User Mode Access Control
                                        * */
        uint32_t M3SM : 2;             /*!< [22:21] Bus Master 3 Supervisor Mode Access
                                        * Control */
        uint32_t M3PE : 1;             /*!< [23] Bus Master 3 Process Identifier Enable */
        uint32_t M4WE : 1;             /*!< [24] Bus Master 4 Write Enable */
        uint32_t M4RE : 1;             /*!< [25] Bus Master 4 Read Enable */
        uint32_t M5WE : 1;             /*!< [26] Bus Master 5 Write Enable */
        uint32_t M5RE : 1;             /*!< [27] Bus Master 5 Read Enable */
        uint32_t M6WE : 1;             /*!< [28] Bus Master 6 Write Enable */
        uint32_t M6RE : 1;             /*!< [29] Bus Master 6 Read Enable */
        uint32_t M7WE : 1;             /*!< [30] Bus Master 7 Write Enable */
        uint32_t M7RE : 1;             /*!< [31] Bus Master 7 Read Enable */
    } B;
} hw_mpu_rgdaacn_t;

/*!
 * @name Constants and macros for entire MPU_RGDAACn register
 */
/*@{*/
#define HW_MPU_RGDAACn_COUNT (12U)

#define HW_MPU_RGDAACn_ADDR(x, n) ((uint32_t)(x) + 0x800U + (0x4U * (n)))

#define HW_MPU_RGDAACn(x, n)     (*(__IO hw_mpu_rgdaacn_t *) HW_MPU_RGDAACn_ADDR(x, n))
#define HW_MPU_RGDAACn_RD(x, n)  (HW_MPU_RGDAACn(x, n).U)
#define HW_MPU_RGDAACn_WR(x, n, v) (HW_MPU_RGDAACn(x, n).U = (v))
#define HW_MPU_RGDAACn_SET(x, n, v) (HW_MPU_RGDAACn_WR(x, n, HW_MPU_RGDAACn_RD(x, n) |  (v)))
#define HW_MPU_RGDAACn_CLR(x, n, v) (HW_MPU_RGDAACn_WR(x, n, HW_MPU_RGDAACn_RD(x, n) & ~(v)))
#define HW_MPU_RGDAACn_TOG(x, n, v) (HW_MPU_RGDAACn_WR(x, n, HW_MPU_RGDAACn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDAACn bitfields
 */

/*!
 * @name Register MPU_RGDAACn, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
#define BP_MPU_RGDAACn_M0UM  (0U)          /*!< Bit position for MPU_RGDAACn_M0UM. */
#define BM_MPU_RGDAACn_M0UM  (0x00000007U) /*!< Bit mask for MPU_RGDAACn_M0UM. */
#define BS_MPU_RGDAACn_M0UM  (3U)          /*!< Bit field size in bits for MPU_RGDAACn_M0UM. */

/*! @brief Read current value of the MPU_RGDAACn_M0UM field. */
#define BR_MPU_RGDAACn_M0UM(x, n) (HW_MPU_RGDAACn(x, n).B.M0UM)

/*! @brief Format value for bitfield MPU_RGDAACn_M0UM. */
#define BF_MPU_RGDAACn_M0UM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M0UM) & BM_MPU_RGDAACn_M0UM)

/*! @brief Set the M0UM field to a new value. */
#define BW_MPU_RGDAACn_M0UM(x, n, v) (HW_MPU_RGDAACn_WR(x, n, (HW_MPU_RGDAACn_RD(x, n) & ~BM_MPU_RGDAACn_M0UM) | BF_MPU_RGDAACn_M0UM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
#define BP_MPU_RGDAACn_M0SM  (3U)          /*!< Bit position for MPU_RGDAACn_M0SM. */
#define BM_MPU_RGDAACn_M0SM  (0x00000018U) /*!< Bit mask for MPU_RGDAACn_M0SM. */
#define BS_MPU_RGDAACn_M0SM  (2U)          /*!< Bit field size in bits for MPU_RGDAACn_M0SM. */

/*! @brief Read current value of the MPU_RGDAACn_M0SM field. */
#define BR_MPU_RGDAACn_M0SM(x, n) (HW_MPU_RGDAACn(x, n).B.M0SM)

/*! @brief Format value for bitfield MPU_RGDAACn_M0SM. */
#define BF_MPU_RGDAACn_M0SM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M0SM) & BM_MPU_RGDAACn_M0SM)

/*! @brief Set the M0SM field to a new value. */
#define BW_MPU_RGDAACn_M0SM(x, n, v) (HW_MPU_RGDAACn_WR(x, n, (HW_MPU_RGDAACn_RD(x, n) & ~BM_MPU_RGDAACn_M0SM) | BF_MPU_RGDAACn_M0SM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M0PE[5] (RW)
 *
 * See M3PE description.
 */
/*@{*/
#define BP_MPU_RGDAACn_M0PE  (5U)          /*!< Bit position for MPU_RGDAACn_M0PE. */
#define BM_MPU_RGDAACn_M0PE  (0x00000020U) /*!< Bit mask for MPU_RGDAACn_M0PE. */
#define BS_MPU_RGDAACn_M0PE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M0PE. */

/*! @brief Read current value of the MPU_RGDAACn_M0PE field. */
#define BR_MPU_RGDAACn_M0PE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M0PE))

/*! @brief Format value for bitfield MPU_RGDAACn_M0PE. */
#define BF_MPU_RGDAACn_M0PE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M0PE) & BM_MPU_RGDAACn_M0PE)

/*! @brief Set the M0PE field to a new value. */
#define BW_MPU_RGDAACn_M0PE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M0PE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
#define BP_MPU_RGDAACn_M1UM  (6U)          /*!< Bit position for MPU_RGDAACn_M1UM. */
#define BM_MPU_RGDAACn_M1UM  (0x000001C0U) /*!< Bit mask for MPU_RGDAACn_M1UM. */
#define BS_MPU_RGDAACn_M1UM  (3U)          /*!< Bit field size in bits for MPU_RGDAACn_M1UM. */

/*! @brief Read current value of the MPU_RGDAACn_M1UM field. */
#define BR_MPU_RGDAACn_M1UM(x, n) (HW_MPU_RGDAACn(x, n).B.M1UM)

/*! @brief Format value for bitfield MPU_RGDAACn_M1UM. */
#define BF_MPU_RGDAACn_M1UM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M1UM) & BM_MPU_RGDAACn_M1UM)

/*! @brief Set the M1UM field to a new value. */
#define BW_MPU_RGDAACn_M1UM(x, n, v) (HW_MPU_RGDAACn_WR(x, n, (HW_MPU_RGDAACn_RD(x, n) & ~BM_MPU_RGDAACn_M1UM) | BF_MPU_RGDAACn_M1UM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
#define BP_MPU_RGDAACn_M1SM  (9U)          /*!< Bit position for MPU_RGDAACn_M1SM. */
#define BM_MPU_RGDAACn_M1SM  (0x00000600U) /*!< Bit mask for MPU_RGDAACn_M1SM. */
#define BS_MPU_RGDAACn_M1SM  (2U)          /*!< Bit field size in bits for MPU_RGDAACn_M1SM. */

/*! @brief Read current value of the MPU_RGDAACn_M1SM field. */
#define BR_MPU_RGDAACn_M1SM(x, n) (HW_MPU_RGDAACn(x, n).B.M1SM)

/*! @brief Format value for bitfield MPU_RGDAACn_M1SM. */
#define BF_MPU_RGDAACn_M1SM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M1SM) & BM_MPU_RGDAACn_M1SM)

/*! @brief Set the M1SM field to a new value. */
#define BW_MPU_RGDAACn_M1SM(x, n, v) (HW_MPU_RGDAACn_WR(x, n, (HW_MPU_RGDAACn_RD(x, n) & ~BM_MPU_RGDAACn_M1SM) | BF_MPU_RGDAACn_M1SM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
#define BP_MPU_RGDAACn_M1PE  (11U)         /*!< Bit position for MPU_RGDAACn_M1PE. */
#define BM_MPU_RGDAACn_M1PE  (0x00000800U) /*!< Bit mask for MPU_RGDAACn_M1PE. */
#define BS_MPU_RGDAACn_M1PE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M1PE. */

/*! @brief Read current value of the MPU_RGDAACn_M1PE field. */
#define BR_MPU_RGDAACn_M1PE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M1PE))

/*! @brief Format value for bitfield MPU_RGDAACn_M1PE. */
#define BF_MPU_RGDAACn_M1PE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M1PE) & BM_MPU_RGDAACn_M1PE)

/*! @brief Set the M1PE field to a new value. */
#define BW_MPU_RGDAACn_M1PE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M1PE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
#define BP_MPU_RGDAACn_M2UM  (12U)         /*!< Bit position for MPU_RGDAACn_M2UM. */
#define BM_MPU_RGDAACn_M2UM  (0x00007000U) /*!< Bit mask for MPU_RGDAACn_M2UM. */
#define BS_MPU_RGDAACn_M2UM  (3U)          /*!< Bit field size in bits for MPU_RGDAACn_M2UM. */

/*! @brief Read current value of the MPU_RGDAACn_M2UM field. */
#define BR_MPU_RGDAACn_M2UM(x, n) (HW_MPU_RGDAACn(x, n).B.M2UM)

/*! @brief Format value for bitfield MPU_RGDAACn_M2UM. */
#define BF_MPU_RGDAACn_M2UM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M2UM) & BM_MPU_RGDAACn_M2UM)

/*! @brief Set the M2UM field to a new value. */
#define BW_MPU_RGDAACn_M2UM(x, n, v) (HW_MPU_RGDAACn_WR(x, n, (HW_MPU_RGDAACn_RD(x, n) & ~BM_MPU_RGDAACn_M2UM) | BF_MPU_RGDAACn_M2UM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
#define BP_MPU_RGDAACn_M2SM  (15U)         /*!< Bit position for MPU_RGDAACn_M2SM. */
#define BM_MPU_RGDAACn_M2SM  (0x00018000U) /*!< Bit mask for MPU_RGDAACn_M2SM. */
#define BS_MPU_RGDAACn_M2SM  (2U)          /*!< Bit field size in bits for MPU_RGDAACn_M2SM. */

/*! @brief Read current value of the MPU_RGDAACn_M2SM field. */
#define BR_MPU_RGDAACn_M2SM(x, n) (HW_MPU_RGDAACn(x, n).B.M2SM)

/*! @brief Format value for bitfield MPU_RGDAACn_M2SM. */
#define BF_MPU_RGDAACn_M2SM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M2SM) & BM_MPU_RGDAACn_M2SM)

/*! @brief Set the M2SM field to a new value. */
#define BW_MPU_RGDAACn_M2SM(x, n, v) (HW_MPU_RGDAACn_WR(x, n, (HW_MPU_RGDAACn_RD(x, n) & ~BM_MPU_RGDAACn_M2SM) | BF_MPU_RGDAACn_M2SM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
#define BP_MPU_RGDAACn_M2PE  (17U)         /*!< Bit position for MPU_RGDAACn_M2PE. */
#define BM_MPU_RGDAACn_M2PE  (0x00020000U) /*!< Bit mask for MPU_RGDAACn_M2PE. */
#define BS_MPU_RGDAACn_M2PE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M2PE. */

/*! @brief Read current value of the MPU_RGDAACn_M2PE field. */
#define BR_MPU_RGDAACn_M2PE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M2PE))

/*! @brief Format value for bitfield MPU_RGDAACn_M2PE. */
#define BF_MPU_RGDAACn_M2PE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M2PE) & BM_MPU_RGDAACn_M2PE)

/*! @brief Set the M2PE field to a new value. */
#define BW_MPU_RGDAACn_M2PE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M2PE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in user mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0 - An attempted access of that mode may be terminated with an access error
 *     (if not allowed by another descriptor) and the access not performed.
 * - 1 - Allows the given access type to occur
 */
/*@{*/
#define BP_MPU_RGDAACn_M3UM  (18U)         /*!< Bit position for MPU_RGDAACn_M3UM. */
#define BM_MPU_RGDAACn_M3UM  (0x001C0000U) /*!< Bit mask for MPU_RGDAACn_M3UM. */
#define BS_MPU_RGDAACn_M3UM  (3U)          /*!< Bit field size in bits for MPU_RGDAACn_M3UM. */

/*! @brief Read current value of the MPU_RGDAACn_M3UM field. */
#define BR_MPU_RGDAACn_M3UM(x, n) (HW_MPU_RGDAACn(x, n).B.M3UM)

/*! @brief Format value for bitfield MPU_RGDAACn_M3UM. */
#define BF_MPU_RGDAACn_M3UM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M3UM) & BM_MPU_RGDAACn_M3UM)

/*! @brief Set the M3UM field to a new value. */
#define BW_MPU_RGDAACn_M3UM(x, n, v) (HW_MPU_RGDAACn_WR(x, n, (HW_MPU_RGDAACn_RD(x, n) & ~BM_MPU_RGDAACn_M3UM) | BF_MPU_RGDAACn_M3UM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 00 - r/w/x; read, write and execute allowed
 * - 01 - r/x; read and execute allowed, but no write
 * - 10 - r/w; read and write allowed, but no execute
 * - 11 - Same as User mode defined in M3UM
 */
/*@{*/
#define BP_MPU_RGDAACn_M3SM  (21U)         /*!< Bit position for MPU_RGDAACn_M3SM. */
#define BM_MPU_RGDAACn_M3SM  (0x00600000U) /*!< Bit mask for MPU_RGDAACn_M3SM. */
#define BS_MPU_RGDAACn_M3SM  (2U)          /*!< Bit field size in bits for MPU_RGDAACn_M3SM. */

/*! @brief Read current value of the MPU_RGDAACn_M3SM field. */
#define BR_MPU_RGDAACn_M3SM(x, n) (HW_MPU_RGDAACn(x, n).B.M3SM)

/*! @brief Format value for bitfield MPU_RGDAACn_M3SM. */
#define BF_MPU_RGDAACn_M3SM(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M3SM) & BM_MPU_RGDAACn_M3SM)

/*! @brief Set the M3SM field to a new value. */
#define BW_MPU_RGDAACn_M3SM(x, n, v) (HW_MPU_RGDAACn_WR(x, n, (HW_MPU_RGDAACn_RD(x, n) & ~BM_MPU_RGDAACn_M3SM) | BF_MPU_RGDAACn_M3SM(v)))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M3PE[23] (RW)
 *
 * Values:
 * - 0 - Do not include the process identifier in the evaluation
 * - 1 - Include the process identifier and mask (RGDn.RGDAAC) in the region hit
 *     evaluation
 */
/*@{*/
#define BP_MPU_RGDAACn_M3PE  (23U)         /*!< Bit position for MPU_RGDAACn_M3PE. */
#define BM_MPU_RGDAACn_M3PE  (0x00800000U) /*!< Bit mask for MPU_RGDAACn_M3PE. */
#define BS_MPU_RGDAACn_M3PE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M3PE. */

/*! @brief Read current value of the MPU_RGDAACn_M3PE field. */
#define BR_MPU_RGDAACn_M3PE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M3PE))

/*! @brief Format value for bitfield MPU_RGDAACn_M3PE. */
#define BF_MPU_RGDAACn_M3PE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M3PE) & BM_MPU_RGDAACn_M3PE)

/*! @brief Set the M3PE field to a new value. */
#define BW_MPU_RGDAACn_M3PE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M3PE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M4WE[24] (RW)
 *
 * Values:
 * - 0 - Bus master 4 writes terminate with an access error and the write is not
 *     performed
 * - 1 - Bus master 4 writes allowed
 */
/*@{*/
#define BP_MPU_RGDAACn_M4WE  (24U)         /*!< Bit position for MPU_RGDAACn_M4WE. */
#define BM_MPU_RGDAACn_M4WE  (0x01000000U) /*!< Bit mask for MPU_RGDAACn_M4WE. */
#define BS_MPU_RGDAACn_M4WE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M4WE. */

/*! @brief Read current value of the MPU_RGDAACn_M4WE field. */
#define BR_MPU_RGDAACn_M4WE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M4WE))

/*! @brief Format value for bitfield MPU_RGDAACn_M4WE. */
#define BF_MPU_RGDAACn_M4WE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M4WE) & BM_MPU_RGDAACn_M4WE)

/*! @brief Set the M4WE field to a new value. */
#define BW_MPU_RGDAACn_M4WE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M4WE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M4RE[25] (RW)
 *
 * Values:
 * - 0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 1 - Bus master 4 reads allowed
 */
/*@{*/
#define BP_MPU_RGDAACn_M4RE  (25U)         /*!< Bit position for MPU_RGDAACn_M4RE. */
#define BM_MPU_RGDAACn_M4RE  (0x02000000U) /*!< Bit mask for MPU_RGDAACn_M4RE. */
#define BS_MPU_RGDAACn_M4RE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M4RE. */

/*! @brief Read current value of the MPU_RGDAACn_M4RE field. */
#define BR_MPU_RGDAACn_M4RE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M4RE))

/*! @brief Format value for bitfield MPU_RGDAACn_M4RE. */
#define BF_MPU_RGDAACn_M4RE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M4RE) & BM_MPU_RGDAACn_M4RE)

/*! @brief Set the M4RE field to a new value. */
#define BW_MPU_RGDAACn_M4RE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M4RE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M5WE[26] (RW)
 *
 * Values:
 * - 0 - Bus master 5 writes terminate with an access error and the write is not
 *     performed
 * - 1 - Bus master 5 writes allowed
 */
/*@{*/
#define BP_MPU_RGDAACn_M5WE  (26U)         /*!< Bit position for MPU_RGDAACn_M5WE. */
#define BM_MPU_RGDAACn_M5WE  (0x04000000U) /*!< Bit mask for MPU_RGDAACn_M5WE. */
#define BS_MPU_RGDAACn_M5WE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M5WE. */

/*! @brief Read current value of the MPU_RGDAACn_M5WE field. */
#define BR_MPU_RGDAACn_M5WE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M5WE))

/*! @brief Format value for bitfield MPU_RGDAACn_M5WE. */
#define BF_MPU_RGDAACn_M5WE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M5WE) & BM_MPU_RGDAACn_M5WE)

/*! @brief Set the M5WE field to a new value. */
#define BW_MPU_RGDAACn_M5WE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M5WE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M5RE[27] (RW)
 *
 * Values:
 * - 0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 1 - Bus master 5 reads allowed
 */
/*@{*/
#define BP_MPU_RGDAACn_M5RE  (27U)         /*!< Bit position for MPU_RGDAACn_M5RE. */
#define BM_MPU_RGDAACn_M5RE  (0x08000000U) /*!< Bit mask for MPU_RGDAACn_M5RE. */
#define BS_MPU_RGDAACn_M5RE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M5RE. */

/*! @brief Read current value of the MPU_RGDAACn_M5RE field. */
#define BR_MPU_RGDAACn_M5RE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M5RE))

/*! @brief Format value for bitfield MPU_RGDAACn_M5RE. */
#define BF_MPU_RGDAACn_M5RE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M5RE) & BM_MPU_RGDAACn_M5RE)

/*! @brief Set the M5RE field to a new value. */
#define BW_MPU_RGDAACn_M5RE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M5RE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M6WE[28] (RW)
 *
 * Values:
 * - 0 - Bus master 6 writes terminate with an access error and the write is not
 *     performed
 * - 1 - Bus master 6 writes allowed
 */
/*@{*/
#define BP_MPU_RGDAACn_M6WE  (28U)         /*!< Bit position for MPU_RGDAACn_M6WE. */
#define BM_MPU_RGDAACn_M6WE  (0x10000000U) /*!< Bit mask for MPU_RGDAACn_M6WE. */
#define BS_MPU_RGDAACn_M6WE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M6WE. */

/*! @brief Read current value of the MPU_RGDAACn_M6WE field. */
#define BR_MPU_RGDAACn_M6WE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M6WE))

/*! @brief Format value for bitfield MPU_RGDAACn_M6WE. */
#define BF_MPU_RGDAACn_M6WE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M6WE) & BM_MPU_RGDAACn_M6WE)

/*! @brief Set the M6WE field to a new value. */
#define BW_MPU_RGDAACn_M6WE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M6WE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M6RE[29] (RW)
 *
 * Values:
 * - 0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 1 - Bus master 6 reads allowed
 */
/*@{*/
#define BP_MPU_RGDAACn_M6RE  (29U)         /*!< Bit position for MPU_RGDAACn_M6RE. */
#define BM_MPU_RGDAACn_M6RE  (0x20000000U) /*!< Bit mask for MPU_RGDAACn_M6RE. */
#define BS_MPU_RGDAACn_M6RE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M6RE. */

/*! @brief Read current value of the MPU_RGDAACn_M6RE field. */
#define BR_MPU_RGDAACn_M6RE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M6RE))

/*! @brief Format value for bitfield MPU_RGDAACn_M6RE. */
#define BF_MPU_RGDAACn_M6RE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M6RE) & BM_MPU_RGDAACn_M6RE)

/*! @brief Set the M6RE field to a new value. */
#define BW_MPU_RGDAACn_M6RE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M6RE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M7WE[30] (RW)
 *
 * Values:
 * - 0 - Bus master 7 writes terminate with an access error and the write is not
 *     performed
 * - 1 - Bus master 7 writes allowed
 */
/*@{*/
#define BP_MPU_RGDAACn_M7WE  (30U)         /*!< Bit position for MPU_RGDAACn_M7WE. */
#define BM_MPU_RGDAACn_M7WE  (0x40000000U) /*!< Bit mask for MPU_RGDAACn_M7WE. */
#define BS_MPU_RGDAACn_M7WE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M7WE. */

/*! @brief Read current value of the MPU_RGDAACn_M7WE field. */
#define BR_MPU_RGDAACn_M7WE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M7WE))

/*! @brief Format value for bitfield MPU_RGDAACn_M7WE. */
#define BF_MPU_RGDAACn_M7WE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M7WE) & BM_MPU_RGDAACn_M7WE)

/*! @brief Set the M7WE field to a new value. */
#define BW_MPU_RGDAACn_M7WE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M7WE) = (v))
/*@}*/

/*!
 * @name Register MPU_RGDAACn, field M7RE[31] (RW)
 *
 * Values:
 * - 0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 1 - Bus master 7 reads allowed
 */
/*@{*/
#define BP_MPU_RGDAACn_M7RE  (31U)         /*!< Bit position for MPU_RGDAACn_M7RE. */
#define BM_MPU_RGDAACn_M7RE  (0x80000000U) /*!< Bit mask for MPU_RGDAACn_M7RE. */
#define BS_MPU_RGDAACn_M7RE  (1U)          /*!< Bit field size in bits for MPU_RGDAACn_M7RE. */

/*! @brief Read current value of the MPU_RGDAACn_M7RE field. */
#define BR_MPU_RGDAACn_M7RE(x, n) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M7RE))

/*! @brief Format value for bitfield MPU_RGDAACn_M7RE. */
#define BF_MPU_RGDAACn_M7RE(v) ((uint32_t)((uint32_t)(v) << BP_MPU_RGDAACn_M7RE) & BM_MPU_RGDAACn_M7RE)

/*! @brief Set the M7RE field to a new value. */
#define BW_MPU_RGDAACn_M7RE(x, n, v) (BITBAND_ACCESS32(HW_MPU_RGDAACn_ADDR(x, n), BP_MPU_RGDAACn_M7RE) = (v))
/*@}*/

/*******************************************************************************
 * hw_mpu_t - module struct
 ******************************************************************************/
/*!
 * @brief All MPU module registers.
 */
#pragma pack(1)
typedef struct _hw_mpu
{
    __IO hw_mpu_cesr_t CESR;               /*!< [0x0] Control/Error Status Register */
    uint8_t _reserved0[12];
    struct {
        __I hw_mpu_earn_t EARn;            /*!< [0x10] Error Address Register, slave port n */
        __I hw_mpu_edrn_t EDRn;            /*!< [0x14] Error Detail Register, slave port n */
    } SP[5];
    uint8_t _reserved1[968];
    struct {
        __IO hw_mpu_rgdn_word0_t RGDn_WORD0; /*!< [0x400] Region Descriptor n, Word 0 */
        __IO hw_mpu_rgdn_word1_t RGDn_WORD1; /*!< [0x404] Region Descriptor n, Word 1 */
        __IO hw_mpu_rgdn_word2_t RGDn_WORD2; /*!< [0x408] Region Descriptor n, Word 2 */
        __IO hw_mpu_rgdn_word3_t RGDn_WORD3; /*!< [0x40C] Region Descriptor n, Word 3 */
    } RGD[12];
    uint8_t _reserved2[832];
    __IO hw_mpu_rgdaacn_t RGDAACn[12];     /*!< [0x800] Region Descriptor Alternate Access Control n */
} hw_mpu_t;
#pragma pack()

/*! @brief Macro to access all MPU registers. */
/*! @param x MPU module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_MPU_REGS(MPU_BASE)</code>. */
#define HW_MPU_REGS(x) (*(hw_mpu_t *)(x))

/*
 * MK64F12 NV
 *
 * Flash configuration field
 *
 * Registers defined in this header file:
 * - HW_NV_BACKKEY3 - Backdoor Comparison Key 3.
 * - HW_NV_BACKKEY2 - Backdoor Comparison Key 2.
 * - HW_NV_BACKKEY1 - Backdoor Comparison Key 1.
 * - HW_NV_BACKKEY0 - Backdoor Comparison Key 0.
 * - HW_NV_BACKKEY7 - Backdoor Comparison Key 7.
 * - HW_NV_BACKKEY6 - Backdoor Comparison Key 6.
 * - HW_NV_BACKKEY5 - Backdoor Comparison Key 5.
 * - HW_NV_BACKKEY4 - Backdoor Comparison Key 4.
 * - HW_NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 * - HW_NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 * - HW_NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 * - HW_NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 * - HW_NV_FSEC - Non-volatile Flash Security Register
 * - HW_NV_FOPT - Non-volatile Flash Option Register
 * - HW_NV_FEPROT - Non-volatile EERAM Protection Register
 * - HW_NV_FDPROT - Non-volatile D-Flash Protection Register
 *
 * - hw_nv_t - Struct containing all module registers.
 */

#define HW_NV_INSTANCE_COUNT (1U) /*!< Number of instances of the NV module. */
#define HW_FTFE_FlashConfig (0U) /*!< Instance number for FTFE_FlashConfig. */

/*******************************************************************************
 * HW_NV_BACKKEY3 - Backdoor Comparison Key 3.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY3 - Backdoor Comparison Key 3. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey3
{
    uint8_t U;
    struct _hw_nv_backkey3_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey3_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY3 register
 */
/*@{*/
#define HW_NV_BACKKEY3_ADDR(x)   ((uint32_t)(x) + 0x0U)

#define HW_NV_BACKKEY3(x)        (*(__I hw_nv_backkey3_t *) HW_NV_BACKKEY3_ADDR(x))
#define HW_NV_BACKKEY3_RD(x)     (HW_NV_BACKKEY3(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY3 bitfields
 */

/*!
 * @name Register NV_BACKKEY3, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY3_KEY   (0U)          /*!< Bit position for NV_BACKKEY3_KEY. */
#define BM_NV_BACKKEY3_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY3_KEY. */
#define BS_NV_BACKKEY3_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY3_KEY. */

/*! @brief Read current value of the NV_BACKKEY3_KEY field. */
#define BR_NV_BACKKEY3_KEY(x) (HW_NV_BACKKEY3(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY2 - Backdoor Comparison Key 2.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY2 - Backdoor Comparison Key 2. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey2
{
    uint8_t U;
    struct _hw_nv_backkey2_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey2_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY2 register
 */
/*@{*/
#define HW_NV_BACKKEY2_ADDR(x)   ((uint32_t)(x) + 0x1U)

#define HW_NV_BACKKEY2(x)        (*(__I hw_nv_backkey2_t *) HW_NV_BACKKEY2_ADDR(x))
#define HW_NV_BACKKEY2_RD(x)     (HW_NV_BACKKEY2(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY2 bitfields
 */

/*!
 * @name Register NV_BACKKEY2, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY2_KEY   (0U)          /*!< Bit position for NV_BACKKEY2_KEY. */
#define BM_NV_BACKKEY2_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY2_KEY. */
#define BS_NV_BACKKEY2_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY2_KEY. */

/*! @brief Read current value of the NV_BACKKEY2_KEY field. */
#define BR_NV_BACKKEY2_KEY(x) (HW_NV_BACKKEY2(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY1 - Backdoor Comparison Key 1.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY1 - Backdoor Comparison Key 1. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey1
{
    uint8_t U;
    struct _hw_nv_backkey1_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey1_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY1 register
 */
/*@{*/
#define HW_NV_BACKKEY1_ADDR(x)   ((uint32_t)(x) + 0x2U)

#define HW_NV_BACKKEY1(x)        (*(__I hw_nv_backkey1_t *) HW_NV_BACKKEY1_ADDR(x))
#define HW_NV_BACKKEY1_RD(x)     (HW_NV_BACKKEY1(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY1 bitfields
 */

/*!
 * @name Register NV_BACKKEY1, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY1_KEY   (0U)          /*!< Bit position for NV_BACKKEY1_KEY. */
#define BM_NV_BACKKEY1_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY1_KEY. */
#define BS_NV_BACKKEY1_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY1_KEY. */

/*! @brief Read current value of the NV_BACKKEY1_KEY field. */
#define BR_NV_BACKKEY1_KEY(x) (HW_NV_BACKKEY1(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY0 - Backdoor Comparison Key 0.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY0 - Backdoor Comparison Key 0. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey0
{
    uint8_t U;
    struct _hw_nv_backkey0_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey0_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY0 register
 */
/*@{*/
#define HW_NV_BACKKEY0_ADDR(x)   ((uint32_t)(x) + 0x3U)

#define HW_NV_BACKKEY0(x)        (*(__I hw_nv_backkey0_t *) HW_NV_BACKKEY0_ADDR(x))
#define HW_NV_BACKKEY0_RD(x)     (HW_NV_BACKKEY0(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY0 bitfields
 */

/*!
 * @name Register NV_BACKKEY0, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY0_KEY   (0U)          /*!< Bit position for NV_BACKKEY0_KEY. */
#define BM_NV_BACKKEY0_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY0_KEY. */
#define BS_NV_BACKKEY0_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY0_KEY. */

/*! @brief Read current value of the NV_BACKKEY0_KEY field. */
#define BR_NV_BACKKEY0_KEY(x) (HW_NV_BACKKEY0(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY7 - Backdoor Comparison Key 7.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY7 - Backdoor Comparison Key 7. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey7
{
    uint8_t U;
    struct _hw_nv_backkey7_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey7_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY7 register
 */
/*@{*/
#define HW_NV_BACKKEY7_ADDR(x)   ((uint32_t)(x) + 0x4U)

#define HW_NV_BACKKEY7(x)        (*(__I hw_nv_backkey7_t *) HW_NV_BACKKEY7_ADDR(x))
#define HW_NV_BACKKEY7_RD(x)     (HW_NV_BACKKEY7(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY7 bitfields
 */

/*!
 * @name Register NV_BACKKEY7, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY7_KEY   (0U)          /*!< Bit position for NV_BACKKEY7_KEY. */
#define BM_NV_BACKKEY7_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY7_KEY. */
#define BS_NV_BACKKEY7_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY7_KEY. */

/*! @brief Read current value of the NV_BACKKEY7_KEY field. */
#define BR_NV_BACKKEY7_KEY(x) (HW_NV_BACKKEY7(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY6 - Backdoor Comparison Key 6.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY6 - Backdoor Comparison Key 6. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey6
{
    uint8_t U;
    struct _hw_nv_backkey6_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey6_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY6 register
 */
/*@{*/
#define HW_NV_BACKKEY6_ADDR(x)   ((uint32_t)(x) + 0x5U)

#define HW_NV_BACKKEY6(x)        (*(__I hw_nv_backkey6_t *) HW_NV_BACKKEY6_ADDR(x))
#define HW_NV_BACKKEY6_RD(x)     (HW_NV_BACKKEY6(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY6 bitfields
 */

/*!
 * @name Register NV_BACKKEY6, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY6_KEY   (0U)          /*!< Bit position for NV_BACKKEY6_KEY. */
#define BM_NV_BACKKEY6_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY6_KEY. */
#define BS_NV_BACKKEY6_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY6_KEY. */

/*! @brief Read current value of the NV_BACKKEY6_KEY field. */
#define BR_NV_BACKKEY6_KEY(x) (HW_NV_BACKKEY6(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY5 - Backdoor Comparison Key 5.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY5 - Backdoor Comparison Key 5. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey5
{
    uint8_t U;
    struct _hw_nv_backkey5_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey5_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY5 register
 */
/*@{*/
#define HW_NV_BACKKEY5_ADDR(x)   ((uint32_t)(x) + 0x6U)

#define HW_NV_BACKKEY5(x)        (*(__I hw_nv_backkey5_t *) HW_NV_BACKKEY5_ADDR(x))
#define HW_NV_BACKKEY5_RD(x)     (HW_NV_BACKKEY5(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY5 bitfields
 */

/*!
 * @name Register NV_BACKKEY5, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY5_KEY   (0U)          /*!< Bit position for NV_BACKKEY5_KEY. */
#define BM_NV_BACKKEY5_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY5_KEY. */
#define BS_NV_BACKKEY5_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY5_KEY. */

/*! @brief Read current value of the NV_BACKKEY5_KEY field. */
#define BR_NV_BACKKEY5_KEY(x) (HW_NV_BACKKEY5(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_BACKKEY4 - Backdoor Comparison Key 4.
 ******************************************************************************/

/*!
 * @brief HW_NV_BACKKEY4 - Backdoor Comparison Key 4. (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_backkey4
{
    uint8_t U;
    struct _hw_nv_backkey4_bitfields
    {
        uint8_t KEY : 8;               /*!< [7:0] Backdoor Comparison Key. */
    } B;
} hw_nv_backkey4_t;

/*!
 * @name Constants and macros for entire NV_BACKKEY4 register
 */
/*@{*/
#define HW_NV_BACKKEY4_ADDR(x)   ((uint32_t)(x) + 0x7U)

#define HW_NV_BACKKEY4(x)        (*(__I hw_nv_backkey4_t *) HW_NV_BACKKEY4_ADDR(x))
#define HW_NV_BACKKEY4_RD(x)     (HW_NV_BACKKEY4(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_BACKKEY4 bitfields
 */

/*!
 * @name Register NV_BACKKEY4, field KEY[7:0] (RO)
 */
/*@{*/
#define BP_NV_BACKKEY4_KEY   (0U)          /*!< Bit position for NV_BACKKEY4_KEY. */
#define BM_NV_BACKKEY4_KEY   (0xFFU)       /*!< Bit mask for NV_BACKKEY4_KEY. */
#define BS_NV_BACKKEY4_KEY   (8U)          /*!< Bit field size in bits for NV_BACKKEY4_KEY. */

/*! @brief Read current value of the NV_BACKKEY4_KEY field. */
#define BR_NV_BACKKEY4_KEY(x) (HW_NV_BACKKEY4(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_fprot3
{
    uint8_t U;
    struct _hw_nv_fprot3_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] P-Flash Region Protect */
    } B;
} hw_nv_fprot3_t;

/*!
 * @name Constants and macros for entire NV_FPROT3 register
 */
/*@{*/
#define HW_NV_FPROT3_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_NV_FPROT3(x)          (*(__I hw_nv_fprot3_t *) HW_NV_FPROT3_ADDR(x))
#define HW_NV_FPROT3_RD(x)       (HW_NV_FPROT3(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FPROT3 bitfields
 */

/*!
 * @name Register NV_FPROT3, field PROT[7:0] (RO)
 */
/*@{*/
#define BP_NV_FPROT3_PROT    (0U)          /*!< Bit position for NV_FPROT3_PROT. */
#define BM_NV_FPROT3_PROT    (0xFFU)       /*!< Bit mask for NV_FPROT3_PROT. */
#define BS_NV_FPROT3_PROT    (8U)          /*!< Bit field size in bits for NV_FPROT3_PROT. */

/*! @brief Read current value of the NV_FPROT3_PROT field. */
#define BR_NV_FPROT3_PROT(x) (HW_NV_FPROT3(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_fprot2
{
    uint8_t U;
    struct _hw_nv_fprot2_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] P-Flash Region Protect */
    } B;
} hw_nv_fprot2_t;

/*!
 * @name Constants and macros for entire NV_FPROT2 register
 */
/*@{*/
#define HW_NV_FPROT2_ADDR(x)     ((uint32_t)(x) + 0x9U)

#define HW_NV_FPROT2(x)          (*(__I hw_nv_fprot2_t *) HW_NV_FPROT2_ADDR(x))
#define HW_NV_FPROT2_RD(x)       (HW_NV_FPROT2(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FPROT2 bitfields
 */

/*!
 * @name Register NV_FPROT2, field PROT[7:0] (RO)
 */
/*@{*/
#define BP_NV_FPROT2_PROT    (0U)          /*!< Bit position for NV_FPROT2_PROT. */
#define BM_NV_FPROT2_PROT    (0xFFU)       /*!< Bit mask for NV_FPROT2_PROT. */
#define BS_NV_FPROT2_PROT    (8U)          /*!< Bit field size in bits for NV_FPROT2_PROT. */

/*! @brief Read current value of the NV_FPROT2_PROT field. */
#define BR_NV_FPROT2_PROT(x) (HW_NV_FPROT2(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_fprot1
{
    uint8_t U;
    struct _hw_nv_fprot1_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] P-Flash Region Protect */
    } B;
} hw_nv_fprot1_t;

/*!
 * @name Constants and macros for entire NV_FPROT1 register
 */
/*@{*/
#define HW_NV_FPROT1_ADDR(x)     ((uint32_t)(x) + 0xAU)

#define HW_NV_FPROT1(x)          (*(__I hw_nv_fprot1_t *) HW_NV_FPROT1_ADDR(x))
#define HW_NV_FPROT1_RD(x)       (HW_NV_FPROT1(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FPROT1 bitfields
 */

/*!
 * @name Register NV_FPROT1, field PROT[7:0] (RO)
 */
/*@{*/
#define BP_NV_FPROT1_PROT    (0U)          /*!< Bit position for NV_FPROT1_PROT. */
#define BM_NV_FPROT1_PROT    (0xFFU)       /*!< Bit mask for NV_FPROT1_PROT. */
#define BS_NV_FPROT1_PROT    (8U)          /*!< Bit field size in bits for NV_FPROT1_PROT. */

/*! @brief Read current value of the NV_FPROT1_PROT field. */
#define BR_NV_FPROT1_PROT(x) (HW_NV_FPROT1(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_fprot0
{
    uint8_t U;
    struct _hw_nv_fprot0_bitfields
    {
        uint8_t PROT : 8;              /*!< [7:0] P-Flash Region Protect */
    } B;
} hw_nv_fprot0_t;

/*!
 * @name Constants and macros for entire NV_FPROT0 register
 */
/*@{*/
#define HW_NV_FPROT0_ADDR(x)     ((uint32_t)(x) + 0xBU)

#define HW_NV_FPROT0(x)          (*(__I hw_nv_fprot0_t *) HW_NV_FPROT0_ADDR(x))
#define HW_NV_FPROT0_RD(x)       (HW_NV_FPROT0(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FPROT0 bitfields
 */

/*!
 * @name Register NV_FPROT0, field PROT[7:0] (RO)
 */
/*@{*/
#define BP_NV_FPROT0_PROT    (0U)          /*!< Bit position for NV_FPROT0_PROT. */
#define BM_NV_FPROT0_PROT    (0xFFU)       /*!< Bit mask for NV_FPROT0_PROT. */
#define BS_NV_FPROT0_PROT    (8U)          /*!< Bit field size in bits for NV_FPROT0_PROT. */

/*! @brief Read current value of the NV_FPROT0_PROT field. */
#define BR_NV_FPROT0_PROT(x) (HW_NV_FPROT0(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_FSEC - Non-volatile Flash Security Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FSEC - Non-volatile Flash Security Register (RO)
 *
 * Reset value: 0xFFU
 *
 * Allows the user to customize the operation of the MCU at boot time
 */
typedef union _hw_nv_fsec
{
    uint8_t U;
    struct _hw_nv_fsec_bitfields
    {
        uint8_t SEC : 2;               /*!< [1:0] Flash Security */
        uint8_t FSLACC : 2;            /*!< [3:2] Freescale Failure Analysis Access Code
                                        * */
        uint8_t MEEN : 2;              /*!< [5:4]  */
        uint8_t KEYEN : 2;             /*!< [7:6] Backdoor Key Security Enable */
    } B;
} hw_nv_fsec_t;

/*!
 * @name Constants and macros for entire NV_FSEC register
 */
/*@{*/
#define HW_NV_FSEC_ADDR(x)       ((uint32_t)(x) + 0xCU)

#define HW_NV_FSEC(x)            (*(__I hw_nv_fsec_t *) HW_NV_FSEC_ADDR(x))
#define HW_NV_FSEC_RD(x)         (HW_NV_FSEC(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FSEC bitfields
 */

/*!
 * @name Register NV_FSEC, field SEC[1:0] (RO)
 *
 * Values:
 * - 10 - MCU security status is unsecure
 * - 11 - MCU security status is secure
 */
/*@{*/
#define BP_NV_FSEC_SEC       (0U)          /*!< Bit position for NV_FSEC_SEC. */
#define BM_NV_FSEC_SEC       (0x03U)       /*!< Bit mask for NV_FSEC_SEC. */
#define BS_NV_FSEC_SEC       (2U)          /*!< Bit field size in bits for NV_FSEC_SEC. */

/*! @brief Read current value of the NV_FSEC_SEC field. */
#define BR_NV_FSEC_SEC(x)    (HW_NV_FSEC(x).B.SEC)
/*@}*/

/*!
 * @name Register NV_FSEC, field FSLACC[3:2] (RO)
 *
 * Values:
 * - 10 - Freescale factory access denied
 * - 11 - Freescale factory access granted
 */
/*@{*/
#define BP_NV_FSEC_FSLACC    (2U)          /*!< Bit position for NV_FSEC_FSLACC. */
#define BM_NV_FSEC_FSLACC    (0x0CU)       /*!< Bit mask for NV_FSEC_FSLACC. */
#define BS_NV_FSEC_FSLACC    (2U)          /*!< Bit field size in bits for NV_FSEC_FSLACC. */

/*! @brief Read current value of the NV_FSEC_FSLACC field. */
#define BR_NV_FSEC_FSLACC(x) (HW_NV_FSEC(x).B.FSLACC)
/*@}*/

/*!
 * @name Register NV_FSEC, field MEEN[5:4] (RO)
 *
 * Values:
 * - 10 - Mass erase is disabled
 * - 11 - Mass erase is enabled
 */
/*@{*/
#define BP_NV_FSEC_MEEN      (4U)          /*!< Bit position for NV_FSEC_MEEN. */
#define BM_NV_FSEC_MEEN      (0x30U)       /*!< Bit mask for NV_FSEC_MEEN. */
#define BS_NV_FSEC_MEEN      (2U)          /*!< Bit field size in bits for NV_FSEC_MEEN. */

/*! @brief Read current value of the NV_FSEC_MEEN field. */
#define BR_NV_FSEC_MEEN(x)   (HW_NV_FSEC(x).B.MEEN)
/*@}*/

/*!
 * @name Register NV_FSEC, field KEYEN[7:6] (RO)
 *
 * Values:
 * - 10 - Backdoor key access enabled
 * - 11 - Backdoor key access disabled
 */
/*@{*/
#define BP_NV_FSEC_KEYEN     (6U)          /*!< Bit position for NV_FSEC_KEYEN. */
#define BM_NV_FSEC_KEYEN     (0xC0U)       /*!< Bit mask for NV_FSEC_KEYEN. */
#define BS_NV_FSEC_KEYEN     (2U)          /*!< Bit field size in bits for NV_FSEC_KEYEN. */

/*! @brief Read current value of the NV_FSEC_KEYEN field. */
#define BR_NV_FSEC_KEYEN(x)  (HW_NV_FSEC(x).B.KEYEN)
/*@}*/

/*******************************************************************************
 * HW_NV_FOPT - Non-volatile Flash Option Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FOPT - Non-volatile Flash Option Register (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_fopt
{
    uint8_t U;
    struct _hw_nv_fopt_bitfields
    {
        uint8_t LPBOOT : 1;            /*!< [0]  */
        uint8_t EZPORT_DIS : 1;        /*!< [1]  */
        uint8_t RESERVED0 : 6;         /*!< [7:2]  */
    } B;
} hw_nv_fopt_t;

/*!
 * @name Constants and macros for entire NV_FOPT register
 */
/*@{*/
#define HW_NV_FOPT_ADDR(x)       ((uint32_t)(x) + 0xDU)

#define HW_NV_FOPT(x)            (*(__I hw_nv_fopt_t *) HW_NV_FOPT_ADDR(x))
#define HW_NV_FOPT_RD(x)         (HW_NV_FOPT(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FOPT bitfields
 */

/*!
 * @name Register NV_FOPT, field LPBOOT[0] (RO)
 *
 * Values:
 * - 00 - Low-power boot
 * - 01 - Normal boot
 */
/*@{*/
#define BP_NV_FOPT_LPBOOT    (0U)          /*!< Bit position for NV_FOPT_LPBOOT. */
#define BM_NV_FOPT_LPBOOT    (0x01U)       /*!< Bit mask for NV_FOPT_LPBOOT. */
#define BS_NV_FOPT_LPBOOT    (1U)          /*!< Bit field size in bits for NV_FOPT_LPBOOT. */

/*! @brief Read current value of the NV_FOPT_LPBOOT field. */
#define BR_NV_FOPT_LPBOOT(x) (BITBAND_ACCESS8(HW_NV_FOPT_ADDR(x), BP_NV_FOPT_LPBOOT))
/*@}*/

/*!
 * @name Register NV_FOPT, field EZPORT_DIS[1] (RO)
 */
/*@{*/
#define BP_NV_FOPT_EZPORT_DIS (1U)         /*!< Bit position for NV_FOPT_EZPORT_DIS. */
#define BM_NV_FOPT_EZPORT_DIS (0x02U)      /*!< Bit mask for NV_FOPT_EZPORT_DIS. */
#define BS_NV_FOPT_EZPORT_DIS (1U)         /*!< Bit field size in bits for NV_FOPT_EZPORT_DIS. */

/*! @brief Read current value of the NV_FOPT_EZPORT_DIS field. */
#define BR_NV_FOPT_EZPORT_DIS(x) (BITBAND_ACCESS8(HW_NV_FOPT_ADDR(x), BP_NV_FOPT_EZPORT_DIS))
/*@}*/

/*******************************************************************************
 * HW_NV_FEPROT - Non-volatile EERAM Protection Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FEPROT - Non-volatile EERAM Protection Register (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_feprot
{
    uint8_t U;
    struct _hw_nv_feprot_bitfields
    {
        uint8_t EPROT : 8;             /*!< [7:0]  */
    } B;
} hw_nv_feprot_t;

/*!
 * @name Constants and macros for entire NV_FEPROT register
 */
/*@{*/
#define HW_NV_FEPROT_ADDR(x)     ((uint32_t)(x) + 0xEU)

#define HW_NV_FEPROT(x)          (*(__I hw_nv_feprot_t *) HW_NV_FEPROT_ADDR(x))
#define HW_NV_FEPROT_RD(x)       (HW_NV_FEPROT(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FEPROT bitfields
 */

/*!
 * @name Register NV_FEPROT, field EPROT[7:0] (RO)
 */
/*@{*/
#define BP_NV_FEPROT_EPROT   (0U)          /*!< Bit position for NV_FEPROT_EPROT. */
#define BM_NV_FEPROT_EPROT   (0xFFU)       /*!< Bit mask for NV_FEPROT_EPROT. */
#define BS_NV_FEPROT_EPROT   (8U)          /*!< Bit field size in bits for NV_FEPROT_EPROT. */

/*! @brief Read current value of the NV_FEPROT_EPROT field. */
#define BR_NV_FEPROT_EPROT(x) (HW_NV_FEPROT(x).U)
/*@}*/

/*******************************************************************************
 * HW_NV_FDPROT - Non-volatile D-Flash Protection Register
 ******************************************************************************/

/*!
 * @brief HW_NV_FDPROT - Non-volatile D-Flash Protection Register (RO)
 *
 * Reset value: 0xFFU
 */
typedef union _hw_nv_fdprot
{
    uint8_t U;
    struct _hw_nv_fdprot_bitfields
    {
        uint8_t DPROT : 8;             /*!< [7:0] D-Flash Region Protect */
    } B;
} hw_nv_fdprot_t;

/*!
 * @name Constants and macros for entire NV_FDPROT register
 */
/*@{*/
#define HW_NV_FDPROT_ADDR(x)     ((uint32_t)(x) + 0xFU)

#define HW_NV_FDPROT(x)          (*(__I hw_nv_fdprot_t *) HW_NV_FDPROT_ADDR(x))
#define HW_NV_FDPROT_RD(x)       (HW_NV_FDPROT(x).U)
/*@}*/

/*
 * Constants & macros for individual NV_FDPROT bitfields
 */

/*!
 * @name Register NV_FDPROT, field DPROT[7:0] (RO)
 */
/*@{*/
#define BP_NV_FDPROT_DPROT   (0U)          /*!< Bit position for NV_FDPROT_DPROT. */
#define BM_NV_FDPROT_DPROT   (0xFFU)       /*!< Bit mask for NV_FDPROT_DPROT. */
#define BS_NV_FDPROT_DPROT   (8U)          /*!< Bit field size in bits for NV_FDPROT_DPROT. */

/*! @brief Read current value of the NV_FDPROT_DPROT field. */
#define BR_NV_FDPROT_DPROT(x) (HW_NV_FDPROT(x).U)
/*@}*/

/*******************************************************************************
 * hw_nv_t - module struct
 ******************************************************************************/
/*!
 * @brief All NV module registers.
 */
#pragma pack(1)
typedef struct _hw_nv
{
    __I hw_nv_backkey3_t BACKKEY3;         /*!< [0x0] Backdoor Comparison Key 3. */
    __I hw_nv_backkey2_t BACKKEY2;         /*!< [0x1] Backdoor Comparison Key 2. */
    __I hw_nv_backkey1_t BACKKEY1;         /*!< [0x2] Backdoor Comparison Key 1. */
    __I hw_nv_backkey0_t BACKKEY0;         /*!< [0x3] Backdoor Comparison Key 0. */
    __I hw_nv_backkey7_t BACKKEY7;         /*!< [0x4] Backdoor Comparison Key 7. */
    __I hw_nv_backkey6_t BACKKEY6;         /*!< [0x5] Backdoor Comparison Key 6. */
    __I hw_nv_backkey5_t BACKKEY5;         /*!< [0x6] Backdoor Comparison Key 5. */
    __I hw_nv_backkey4_t BACKKEY4;         /*!< [0x7] Backdoor Comparison Key 4. */
    __I hw_nv_fprot3_t FPROT3;             /*!< [0x8] Non-volatile P-Flash Protection 1 - Low Register */
    __I hw_nv_fprot2_t FPROT2;             /*!< [0x9] Non-volatile P-Flash Protection 1 - High Register */
    __I hw_nv_fprot1_t FPROT1;             /*!< [0xA] Non-volatile P-Flash Protection 0 - Low Register */
    __I hw_nv_fprot0_t FPROT0;             /*!< [0xB] Non-volatile P-Flash Protection 0 - High Register */
    __I hw_nv_fsec_t FSEC;                 /*!< [0xC] Non-volatile Flash Security Register */
    __I hw_nv_fopt_t FOPT;                 /*!< [0xD] Non-volatile Flash Option Register */
    __I hw_nv_feprot_t FEPROT;             /*!< [0xE] Non-volatile EERAM Protection Register */
    __I hw_nv_fdprot_t FDPROT;             /*!< [0xF] Non-volatile D-Flash Protection Register */
} hw_nv_t;
#pragma pack()

/*! @brief Macro to access all NV registers. */
/*! @param x NV module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_NV_REGS(FTFE_FlashConfig_BASE)</code>. */
#define HW_NV_REGS(x)  (*(hw_nv_t *)(x))

/*
 * MK64F12 OSC
 *
 * Oscillator
 *
 * Registers defined in this header file:
 * - HW_OSC_CR - OSC Control Register
 *
 * - hw_osc_t - Struct containing all module registers.
 */

#define HW_OSC_INSTANCE_COUNT (1U) /*!< Number of instances of the OSC module. */
#define HW_OSC (0U) /*!< Instance number for OSC. */

/*******************************************************************************
 * HW_OSC_CR - OSC Control Register
 ******************************************************************************/

/*!
 * @brief HW_OSC_CR - OSC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * After OSC is enabled and starts generating the clocks, the configurations
 * such as low power and frequency range, must not be changed.
 */
typedef union _hw_osc_cr
{
    uint8_t U;
    struct _hw_osc_cr_bitfields
    {
        uint8_t SC16P : 1;             /*!< [0] Oscillator 16 pF Capacitor Load Configure
                                        * */
        uint8_t SC8P : 1;              /*!< [1] Oscillator 8 pF Capacitor Load Configure */
        uint8_t SC4P : 1;              /*!< [2] Oscillator 4 pF Capacitor Load Configure */
        uint8_t SC2P : 1;              /*!< [3] Oscillator 2 pF Capacitor Load Configure */
        uint8_t RESERVED0 : 1;         /*!< [4]  */
        uint8_t EREFSTEN : 1;          /*!< [5] External Reference Stop Enable */
        uint8_t RESERVED1 : 1;         /*!< [6]  */
        uint8_t ERCLKEN : 1;           /*!< [7] External Reference Enable */
    } B;
} hw_osc_cr_t;

/*!
 * @name Constants and macros for entire OSC_CR register
 */
/*@{*/
#define HW_OSC_CR_ADDR(x)        ((uint32_t)(x) + 0x0U)

#define HW_OSC_CR(x)             (*(__IO hw_osc_cr_t *) HW_OSC_CR_ADDR(x))
#define HW_OSC_CR_RD(x)          (HW_OSC_CR(x).U)
#define HW_OSC_CR_WR(x, v)       (HW_OSC_CR(x).U = (v))
#define HW_OSC_CR_SET(x, v)      (HW_OSC_CR_WR(x, HW_OSC_CR_RD(x) |  (v)))
#define HW_OSC_CR_CLR(x, v)      (HW_OSC_CR_WR(x, HW_OSC_CR_RD(x) & ~(v)))
#define HW_OSC_CR_TOG(x, v)      (HW_OSC_CR_WR(x, HW_OSC_CR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual OSC_CR bitfields
 */

/*!
 * @name Register OSC_CR, field SC16P[0] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 16 pF capacitor to the oscillator load.
 */
/*@{*/
#define BP_OSC_CR_SC16P      (0U)          /*!< Bit position for OSC_CR_SC16P. */
#define BM_OSC_CR_SC16P      (0x01U)       /*!< Bit mask for OSC_CR_SC16P. */
#define BS_OSC_CR_SC16P      (1U)          /*!< Bit field size in bits for OSC_CR_SC16P. */

/*! @brief Read current value of the OSC_CR_SC16P field. */
#define BR_OSC_CR_SC16P(x)   (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC16P))

/*! @brief Format value for bitfield OSC_CR_SC16P. */
#define BF_OSC_CR_SC16P(v)   ((uint8_t)((uint8_t)(v) << BP_OSC_CR_SC16P) & BM_OSC_CR_SC16P)

/*! @brief Set the SC16P field to a new value. */
#define BW_OSC_CR_SC16P(x, v) (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC16P) = (v))
/*@}*/

/*!
 * @name Register OSC_CR, field SC8P[1] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 8 pF capacitor to the oscillator load.
 */
/*@{*/
#define BP_OSC_CR_SC8P       (1U)          /*!< Bit position for OSC_CR_SC8P. */
#define BM_OSC_CR_SC8P       (0x02U)       /*!< Bit mask for OSC_CR_SC8P. */
#define BS_OSC_CR_SC8P       (1U)          /*!< Bit field size in bits for OSC_CR_SC8P. */

/*! @brief Read current value of the OSC_CR_SC8P field. */
#define BR_OSC_CR_SC8P(x)    (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC8P))

/*! @brief Format value for bitfield OSC_CR_SC8P. */
#define BF_OSC_CR_SC8P(v)    ((uint8_t)((uint8_t)(v) << BP_OSC_CR_SC8P) & BM_OSC_CR_SC8P)

/*! @brief Set the SC8P field to a new value. */
#define BW_OSC_CR_SC8P(x, v) (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC8P) = (v))
/*@}*/

/*!
 * @name Register OSC_CR, field SC4P[2] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 4 pF capacitor to the oscillator load.
 */
/*@{*/
#define BP_OSC_CR_SC4P       (2U)          /*!< Bit position for OSC_CR_SC4P. */
#define BM_OSC_CR_SC4P       (0x04U)       /*!< Bit mask for OSC_CR_SC4P. */
#define BS_OSC_CR_SC4P       (1U)          /*!< Bit field size in bits for OSC_CR_SC4P. */

/*! @brief Read current value of the OSC_CR_SC4P field. */
#define BR_OSC_CR_SC4P(x)    (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC4P))

/*! @brief Format value for bitfield OSC_CR_SC4P. */
#define BF_OSC_CR_SC4P(v)    ((uint8_t)((uint8_t)(v) << BP_OSC_CR_SC4P) & BM_OSC_CR_SC4P)

/*! @brief Set the SC4P field to a new value. */
#define BW_OSC_CR_SC4P(x, v) (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC4P) = (v))
/*@}*/

/*!
 * @name Register OSC_CR, field SC2P[3] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 2 pF capacitor to the oscillator load.
 */
/*@{*/
#define BP_OSC_CR_SC2P       (3U)          /*!< Bit position for OSC_CR_SC2P. */
#define BM_OSC_CR_SC2P       (0x08U)       /*!< Bit mask for OSC_CR_SC2P. */
#define BS_OSC_CR_SC2P       (1U)          /*!< Bit field size in bits for OSC_CR_SC2P. */

/*! @brief Read current value of the OSC_CR_SC2P field. */
#define BR_OSC_CR_SC2P(x)    (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC2P))

/*! @brief Format value for bitfield OSC_CR_SC2P. */
#define BF_OSC_CR_SC2P(v)    ((uint8_t)((uint8_t)(v) << BP_OSC_CR_SC2P) & BM_OSC_CR_SC2P)

/*! @brief Set the SC2P field to a new value. */
#define BW_OSC_CR_SC2P(x, v) (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_SC2P) = (v))
/*@}*/

/*!
 * @name Register OSC_CR, field EREFSTEN[5] (RW)
 *
 * Controls whether or not the external reference clock (OSCERCLK) remains
 * enabled when MCU enters Stop mode.
 *
 * Values:
 * - 0 - External reference clock is disabled in Stop mode.
 * - 1 - External reference clock stays enabled in Stop mode if ERCLKEN is set
 *     before entering Stop mode.
 */
/*@{*/
#define BP_OSC_CR_EREFSTEN   (5U)          /*!< Bit position for OSC_CR_EREFSTEN. */
#define BM_OSC_CR_EREFSTEN   (0x20U)       /*!< Bit mask for OSC_CR_EREFSTEN. */
#define BS_OSC_CR_EREFSTEN   (1U)          /*!< Bit field size in bits for OSC_CR_EREFSTEN. */

/*! @brief Read current value of the OSC_CR_EREFSTEN field. */
#define BR_OSC_CR_EREFSTEN(x) (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_EREFSTEN))

/*! @brief Format value for bitfield OSC_CR_EREFSTEN. */
#define BF_OSC_CR_EREFSTEN(v) ((uint8_t)((uint8_t)(v) << BP_OSC_CR_EREFSTEN) & BM_OSC_CR_EREFSTEN)

/*! @brief Set the EREFSTEN field to a new value. */
#define BW_OSC_CR_EREFSTEN(x, v) (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_EREFSTEN) = (v))
/*@}*/

/*!
 * @name Register OSC_CR, field ERCLKEN[7] (RW)
 *
 * Enables external reference clock (OSCERCLK).
 *
 * Values:
 * - 0 - External reference clock is inactive.
 * - 1 - External reference clock is enabled.
 */
/*@{*/
#define BP_OSC_CR_ERCLKEN    (7U)          /*!< Bit position for OSC_CR_ERCLKEN. */
#define BM_OSC_CR_ERCLKEN    (0x80U)       /*!< Bit mask for OSC_CR_ERCLKEN. */
#define BS_OSC_CR_ERCLKEN    (1U)          /*!< Bit field size in bits for OSC_CR_ERCLKEN. */

/*! @brief Read current value of the OSC_CR_ERCLKEN field. */
#define BR_OSC_CR_ERCLKEN(x) (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_ERCLKEN))

/*! @brief Format value for bitfield OSC_CR_ERCLKEN. */
#define BF_OSC_CR_ERCLKEN(v) ((uint8_t)((uint8_t)(v) << BP_OSC_CR_ERCLKEN) & BM_OSC_CR_ERCLKEN)

/*! @brief Set the ERCLKEN field to a new value. */
#define BW_OSC_CR_ERCLKEN(x, v) (BITBAND_ACCESS8(HW_OSC_CR_ADDR(x), BP_OSC_CR_ERCLKEN) = (v))
/*@}*/

/*******************************************************************************
 * hw_osc_t - module struct
 ******************************************************************************/
/*!
 * @brief All OSC module registers.
 */
#pragma pack(1)
typedef struct _hw_osc
{
    __IO hw_osc_cr_t CR;                   /*!< [0x0] OSC Control Register */
} hw_osc_t;
#pragma pack()

/*! @brief Macro to access all OSC registers. */
/*! @param x OSC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_OSC_REGS(OSC_BASE)</code>. */
#define HW_OSC_REGS(x) (*(hw_osc_t *)(x))

/*
 * MK64F12 PDB
 *
 * Programmable Delay Block
 *
 * Registers defined in this header file:
 * - HW_PDB_SC - Status and Control register
 * - HW_PDB_MOD - Modulus register
 * - HW_PDB_CNT - Counter register
 * - HW_PDB_IDLY - Interrupt Delay register
 * - HW_PDB_CHnC1 - Channel n Control register 1
 * - HW_PDB_CHnS - Channel n Status register
 * - HW_PDB_CHnDLY0 - Channel n Delay 0 register
 * - HW_PDB_CHnDLY1 - Channel n Delay 1 register
 * - HW_PDB_DACINTCn - DAC Interval Trigger n Control register
 * - HW_PDB_DACINTn - DAC Interval n register
 * - HW_PDB_POEN - Pulse-Out n Enable register
 * - HW_PDB_POnDLY - Pulse-Out n Delay register
 *
 * - hw_pdb_t - Struct containing all module registers.
 */

#define HW_PDB_INSTANCE_COUNT (1U) /*!< Number of instances of the PDB module. */
#define HW_PDB0 (0U) /*!< Instance number for PDB0. */

/*******************************************************************************
 * HW_PDB_SC - Status and Control register
 ******************************************************************************/

/*!
 * @brief HW_PDB_SC - Status and Control register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_sc
{
    uint32_t U;
    struct _hw_pdb_sc_bitfields
    {
        uint32_t LDOK : 1;             /*!< [0] Load OK */
        uint32_t CONT : 1;             /*!< [1] Continuous Mode Enable */
        uint32_t MULT : 2;             /*!< [3:2] Multiplication Factor Select for
                                        * Prescaler */
        uint32_t RESERVED0 : 1;        /*!< [4]  */
        uint32_t PDBIE : 1;            /*!< [5] PDB Interrupt Enable */
        uint32_t PDBIF : 1;            /*!< [6] PDB Interrupt Flag */
        uint32_t PDBEN : 1;            /*!< [7] PDB Enable */
        uint32_t TRGSEL : 4;           /*!< [11:8] Trigger Input Source Select */
        uint32_t PRESCALER : 3;        /*!< [14:12] Prescaler Divider Select */
        uint32_t DMAEN : 1;            /*!< [15] DMA Enable */
        uint32_t SWTRIG : 1;           /*!< [16] Software Trigger */
        uint32_t PDBEIE : 1;           /*!< [17] PDB Sequence Error Interrupt Enable */
        uint32_t LDMOD : 2;            /*!< [19:18] Load Mode Select */
        uint32_t RESERVED1 : 12;       /*!< [31:20]  */
    } B;
} hw_pdb_sc_t;

/*!
 * @name Constants and macros for entire PDB_SC register
 */
/*@{*/
#define HW_PDB_SC_ADDR(x)        ((uint32_t)(x) + 0x0U)

#define HW_PDB_SC(x)             (*(__IO hw_pdb_sc_t *) HW_PDB_SC_ADDR(x))
#define HW_PDB_SC_RD(x)          (HW_PDB_SC(x).U)
#define HW_PDB_SC_WR(x, v)       (HW_PDB_SC(x).U = (v))
#define HW_PDB_SC_SET(x, v)      (HW_PDB_SC_WR(x, HW_PDB_SC_RD(x) |  (v)))
#define HW_PDB_SC_CLR(x, v)      (HW_PDB_SC_WR(x, HW_PDB_SC_RD(x) & ~(v)))
#define HW_PDB_SC_TOG(x, v)      (HW_PDB_SC_WR(x, HW_PDB_SC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PDB_SC bitfields
 */

/*!
 * @name Register PDB_SC, field LDOK[0] (RW)
 *
 * Writing 1 to this bit updates the internal registers of MOD, IDLY, CHnDLYm,
 * DACINTx,and POyDLY with the values written to their buffers. The MOD, IDLY,
 * CHnDLYm, DACINTx, and POyDLY will take effect according to the LDMOD. After 1 is
 * written to the LDOK field, the values in the buffers of above registers are
 * not effective and the buffers cannot be written until the values in buffers are
 * loaded into their internal registers. LDOK can be written only when PDBEN is
 * set or it can be written at the same time with PDBEN being written to 1. It is
 * automatically cleared when the values in buffers are loaded into the internal
 * registers or the PDBEN is cleared. Writing 0 to it has no effect.
 */
/*@{*/
#define BP_PDB_SC_LDOK       (0U)          /*!< Bit position for PDB_SC_LDOK. */
#define BM_PDB_SC_LDOK       (0x00000001U) /*!< Bit mask for PDB_SC_LDOK. */
#define BS_PDB_SC_LDOK       (1U)          /*!< Bit field size in bits for PDB_SC_LDOK. */

/*! @brief Read current value of the PDB_SC_LDOK field. */
#define BR_PDB_SC_LDOK(x)    (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_LDOK))

/*! @brief Format value for bitfield PDB_SC_LDOK. */
#define BF_PDB_SC_LDOK(v)    ((uint32_t)((uint32_t)(v) << BP_PDB_SC_LDOK) & BM_PDB_SC_LDOK)

/*! @brief Set the LDOK field to a new value. */
#define BW_PDB_SC_LDOK(x, v) (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_LDOK) = (v))
/*@}*/

/*!
 * @name Register PDB_SC, field CONT[1] (RW)
 *
 * Enables the PDB operation in Continuous mode.
 *
 * Values:
 * - 0 - PDB operation in One-Shot mode
 * - 1 - PDB operation in Continuous mode
 */
/*@{*/
#define BP_PDB_SC_CONT       (1U)          /*!< Bit position for PDB_SC_CONT. */
#define BM_PDB_SC_CONT       (0x00000002U) /*!< Bit mask for PDB_SC_CONT. */
#define BS_PDB_SC_CONT       (1U)          /*!< Bit field size in bits for PDB_SC_CONT. */

/*! @brief Read current value of the PDB_SC_CONT field. */
#define BR_PDB_SC_CONT(x)    (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_CONT))

/*! @brief Format value for bitfield PDB_SC_CONT. */
#define BF_PDB_SC_CONT(v)    ((uint32_t)((uint32_t)(v) << BP_PDB_SC_CONT) & BM_PDB_SC_CONT)

/*! @brief Set the CONT field to a new value. */
#define BW_PDB_SC_CONT(x, v) (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_CONT) = (v))
/*@}*/

/*!
 * @name Register PDB_SC, field MULT[3:2] (RW)
 *
 * Selects the multiplication factor of the prescaler divider for the counter
 * clock.
 *
 * Values:
 * - 00 - Multiplication factor is 1.
 * - 01 - Multiplication factor is 10.
 * - 10 - Multiplication factor is 20.
 * - 11 - Multiplication factor is 40.
 */
/*@{*/
#define BP_PDB_SC_MULT       (2U)          /*!< Bit position for PDB_SC_MULT. */
#define BM_PDB_SC_MULT       (0x0000000CU) /*!< Bit mask for PDB_SC_MULT. */
#define BS_PDB_SC_MULT       (2U)          /*!< Bit field size in bits for PDB_SC_MULT. */

/*! @brief Read current value of the PDB_SC_MULT field. */
#define BR_PDB_SC_MULT(x)    (HW_PDB_SC(x).B.MULT)

/*! @brief Format value for bitfield PDB_SC_MULT. */
#define BF_PDB_SC_MULT(v)    ((uint32_t)((uint32_t)(v) << BP_PDB_SC_MULT) & BM_PDB_SC_MULT)

/*! @brief Set the MULT field to a new value. */
#define BW_PDB_SC_MULT(x, v) (HW_PDB_SC_WR(x, (HW_PDB_SC_RD(x) & ~BM_PDB_SC_MULT) | BF_PDB_SC_MULT(v)))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIE[5] (RW)
 *
 * Enables the PDB interrupt. When this field is set and DMAEN is cleared, PDBIF
 * generates a PDB interrupt.
 *
 * Values:
 * - 0 - PDB interrupt disabled.
 * - 1 - PDB interrupt enabled.
 */
/*@{*/
#define BP_PDB_SC_PDBIE      (5U)          /*!< Bit position for PDB_SC_PDBIE. */
#define BM_PDB_SC_PDBIE      (0x00000020U) /*!< Bit mask for PDB_SC_PDBIE. */
#define BS_PDB_SC_PDBIE      (1U)          /*!< Bit field size in bits for PDB_SC_PDBIE. */

/*! @brief Read current value of the PDB_SC_PDBIE field. */
#define BR_PDB_SC_PDBIE(x)   (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_PDBIE))

/*! @brief Format value for bitfield PDB_SC_PDBIE. */
#define BF_PDB_SC_PDBIE(v)   ((uint32_t)((uint32_t)(v) << BP_PDB_SC_PDBIE) & BM_PDB_SC_PDBIE)

/*! @brief Set the PDBIE field to a new value. */
#define BW_PDB_SC_PDBIE(x, v) (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_PDBIE) = (v))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIF[6] (RW)
 *
 * This field is set when the counter value is equal to the IDLY register.
 * Writing zero clears this field.
 */
/*@{*/
#define BP_PDB_SC_PDBIF      (6U)          /*!< Bit position for PDB_SC_PDBIF. */
#define BM_PDB_SC_PDBIF      (0x00000040U) /*!< Bit mask for PDB_SC_PDBIF. */
#define BS_PDB_SC_PDBIF      (1U)          /*!< Bit field size in bits for PDB_SC_PDBIF. */

/*! @brief Read current value of the PDB_SC_PDBIF field. */
#define BR_PDB_SC_PDBIF(x)   (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_PDBIF))

/*! @brief Format value for bitfield PDB_SC_PDBIF. */
#define BF_PDB_SC_PDBIF(v)   ((uint32_t)((uint32_t)(v) << BP_PDB_SC_PDBIF) & BM_PDB_SC_PDBIF)

/*! @brief Set the PDBIF field to a new value. */
#define BW_PDB_SC_PDBIF(x, v) (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_PDBIF) = (v))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEN[7] (RW)
 *
 * Values:
 * - 0 - PDB disabled. Counter is off.
 * - 1 - PDB enabled.
 */
/*@{*/
#define BP_PDB_SC_PDBEN      (7U)          /*!< Bit position for PDB_SC_PDBEN. */
#define BM_PDB_SC_PDBEN      (0x00000080U) /*!< Bit mask for PDB_SC_PDBEN. */
#define BS_PDB_SC_PDBEN      (1U)          /*!< Bit field size in bits for PDB_SC_PDBEN. */

/*! @brief Read current value of the PDB_SC_PDBEN field. */
#define BR_PDB_SC_PDBEN(x)   (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_PDBEN))

/*! @brief Format value for bitfield PDB_SC_PDBEN. */
#define BF_PDB_SC_PDBEN(v)   ((uint32_t)((uint32_t)(v) << BP_PDB_SC_PDBEN) & BM_PDB_SC_PDBEN)

/*! @brief Set the PDBEN field to a new value. */
#define BW_PDB_SC_PDBEN(x, v) (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_PDBEN) = (v))
/*@}*/

/*!
 * @name Register PDB_SC, field TRGSEL[11:8] (RW)
 *
 * Selects the trigger input source for the PDB. The trigger input source can be
 * internal or external (EXTRG pin), or the software trigger. Refer to chip
 * configuration details for the actual PDB input trigger connections.
 *
 * Values:
 * - 0000 - Trigger-In 0 is selected.
 * - 0001 - Trigger-In 1 is selected.
 * - 0010 - Trigger-In 2 is selected.
 * - 0011 - Trigger-In 3 is selected.
 * - 0100 - Trigger-In 4 is selected.
 * - 0101 - Trigger-In 5 is selected.
 * - 0110 - Trigger-In 6 is selected.
 * - 0111 - Trigger-In 7 is selected.
 * - 1000 - Trigger-In 8 is selected.
 * - 1001 - Trigger-In 9 is selected.
 * - 1010 - Trigger-In 10 is selected.
 * - 1011 - Trigger-In 11 is selected.
 * - 1100 - Trigger-In 12 is selected.
 * - 1101 - Trigger-In 13 is selected.
 * - 1110 - Trigger-In 14 is selected.
 * - 1111 - Software trigger is selected.
 */
/*@{*/
#define BP_PDB_SC_TRGSEL     (8U)          /*!< Bit position for PDB_SC_TRGSEL. */
#define BM_PDB_SC_TRGSEL     (0x00000F00U) /*!< Bit mask for PDB_SC_TRGSEL. */
#define BS_PDB_SC_TRGSEL     (4U)          /*!< Bit field size in bits for PDB_SC_TRGSEL. */

/*! @brief Read current value of the PDB_SC_TRGSEL field. */
#define BR_PDB_SC_TRGSEL(x)  (HW_PDB_SC(x).B.TRGSEL)

/*! @brief Format value for bitfield PDB_SC_TRGSEL. */
#define BF_PDB_SC_TRGSEL(v)  ((uint32_t)((uint32_t)(v) << BP_PDB_SC_TRGSEL) & BM_PDB_SC_TRGSEL)

/*! @brief Set the TRGSEL field to a new value. */
#define BW_PDB_SC_TRGSEL(x, v) (HW_PDB_SC_WR(x, (HW_PDB_SC_RD(x) & ~BM_PDB_SC_TRGSEL) | BF_PDB_SC_TRGSEL(v)))
/*@}*/

/*!
 * @name Register PDB_SC, field PRESCALER[14:12] (RW)
 *
 * Values:
 * - 000 - Counting uses the peripheral clock divided by multiplication factor
 *     selected by MULT.
 * - 001 - Counting uses the peripheral clock divided by twice of the
 *     multiplication factor selected by MULT.
 * - 010 - Counting uses the peripheral clock divided by four times of the
 *     multiplication factor selected by MULT.
 * - 011 - Counting uses the peripheral clock divided by eight times of the
 *     multiplication factor selected by MULT.
 * - 100 - Counting uses the peripheral clock divided by 16 times of the
 *     multiplication factor selected by MULT.
 * - 101 - Counting uses the peripheral clock divided by 32 times of the
 *     multiplication factor selected by MULT.
 * - 110 - Counting uses the peripheral clock divided by 64 times of the
 *     multiplication factor selected by MULT.
 * - 111 - Counting uses the peripheral clock divided by 128 times of the
 *     multiplication factor selected by MULT.
 */
/*@{*/
#define BP_PDB_SC_PRESCALER  (12U)         /*!< Bit position for PDB_SC_PRESCALER. */
#define BM_PDB_SC_PRESCALER  (0x00007000U) /*!< Bit mask for PDB_SC_PRESCALER. */
#define BS_PDB_SC_PRESCALER  (3U)          /*!< Bit field size in bits for PDB_SC_PRESCALER. */

/*! @brief Read current value of the PDB_SC_PRESCALER field. */
#define BR_PDB_SC_PRESCALER(x) (HW_PDB_SC(x).B.PRESCALER)

/*! @brief Format value for bitfield PDB_SC_PRESCALER. */
#define BF_PDB_SC_PRESCALER(v) ((uint32_t)((uint32_t)(v) << BP_PDB_SC_PRESCALER) & BM_PDB_SC_PRESCALER)

/*! @brief Set the PRESCALER field to a new value. */
#define BW_PDB_SC_PRESCALER(x, v) (HW_PDB_SC_WR(x, (HW_PDB_SC_RD(x) & ~BM_PDB_SC_PRESCALER) | BF_PDB_SC_PRESCALER(v)))
/*@}*/

/*!
 * @name Register PDB_SC, field DMAEN[15] (RW)
 *
 * When DMA is enabled, the PDBIF flag generates a DMA request instead of an
 * interrupt.
 *
 * Values:
 * - 0 - DMA disabled.
 * - 1 - DMA enabled.
 */
/*@{*/
#define BP_PDB_SC_DMAEN      (15U)         /*!< Bit position for PDB_SC_DMAEN. */
#define BM_PDB_SC_DMAEN      (0x00008000U) /*!< Bit mask for PDB_SC_DMAEN. */
#define BS_PDB_SC_DMAEN      (1U)          /*!< Bit field size in bits for PDB_SC_DMAEN. */

/*! @brief Read current value of the PDB_SC_DMAEN field. */
#define BR_PDB_SC_DMAEN(x)   (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_DMAEN))

/*! @brief Format value for bitfield PDB_SC_DMAEN. */
#define BF_PDB_SC_DMAEN(v)   ((uint32_t)((uint32_t)(v) << BP_PDB_SC_DMAEN) & BM_PDB_SC_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_PDB_SC_DMAEN(x, v) (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_DMAEN) = (v))
/*@}*/

/*!
 * @name Register PDB_SC, field SWTRIG[16] (WORZ)
 *
 * When PDB is enabled and the software trigger is selected as the trigger input
 * source, writing 1 to this field resets and restarts the counter. Writing 0 to
 * this field has no effect. Reading this field results 0.
 */
/*@{*/
#define BP_PDB_SC_SWTRIG     (16U)         /*!< Bit position for PDB_SC_SWTRIG. */
#define BM_PDB_SC_SWTRIG     (0x00010000U) /*!< Bit mask for PDB_SC_SWTRIG. */
#define BS_PDB_SC_SWTRIG     (1U)          /*!< Bit field size in bits for PDB_SC_SWTRIG. */

/*! @brief Format value for bitfield PDB_SC_SWTRIG. */
#define BF_PDB_SC_SWTRIG(v)  ((uint32_t)((uint32_t)(v) << BP_PDB_SC_SWTRIG) & BM_PDB_SC_SWTRIG)

/*! @brief Set the SWTRIG field to a new value. */
#define BW_PDB_SC_SWTRIG(x, v) (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_SWTRIG) = (v))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEIE[17] (RW)
 *
 * Enables the PDB sequence error interrupt. When this field is set, any of the
 * PDB channel sequence error flags generates a PDB sequence error interrupt.
 *
 * Values:
 * - 0 - PDB sequence error interrupt disabled.
 * - 1 - PDB sequence error interrupt enabled.
 */
/*@{*/
#define BP_PDB_SC_PDBEIE     (17U)         /*!< Bit position for PDB_SC_PDBEIE. */
#define BM_PDB_SC_PDBEIE     (0x00020000U) /*!< Bit mask for PDB_SC_PDBEIE. */
#define BS_PDB_SC_PDBEIE     (1U)          /*!< Bit field size in bits for PDB_SC_PDBEIE. */

/*! @brief Read current value of the PDB_SC_PDBEIE field. */
#define BR_PDB_SC_PDBEIE(x)  (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_PDBEIE))

/*! @brief Format value for bitfield PDB_SC_PDBEIE. */
#define BF_PDB_SC_PDBEIE(v)  ((uint32_t)((uint32_t)(v) << BP_PDB_SC_PDBEIE) & BM_PDB_SC_PDBEIE)

/*! @brief Set the PDBEIE field to a new value. */
#define BW_PDB_SC_PDBEIE(x, v) (BITBAND_ACCESS32(HW_PDB_SC_ADDR(x), BP_PDB_SC_PDBEIE) = (v))
/*@}*/

/*!
 * @name Register PDB_SC, field LDMOD[19:18] (RW)
 *
 * Selects the mode to load the MOD, IDLY, CHnDLYm, INTx, and POyDLY registers,
 * after 1 is written to LDOK.
 *
 * Values:
 * - 00 - The internal registers are loaded with the values from their buffers
 *     immediately after 1 is written to LDOK.
 * - 01 - The internal registers are loaded with the values from their buffers
 *     when the PDB counter reaches the MOD register value after 1 is written to
 *     LDOK.
 * - 10 - The internal registers are loaded with the values from their buffers
 *     when a trigger input event is detected after 1 is written to LDOK.
 * - 11 - The internal registers are loaded with the values from their buffers
 *     when either the PDB counter reaches the MOD register value or a trigger
 *     input event is detected, after 1 is written to LDOK.
 */
/*@{*/
#define BP_PDB_SC_LDMOD      (18U)         /*!< Bit position for PDB_SC_LDMOD. */
#define BM_PDB_SC_LDMOD      (0x000C0000U) /*!< Bit mask for PDB_SC_LDMOD. */
#define BS_PDB_SC_LDMOD      (2U)          /*!< Bit field size in bits for PDB_SC_LDMOD. */

/*! @brief Read current value of the PDB_SC_LDMOD field. */
#define BR_PDB_SC_LDMOD(x)   (HW_PDB_SC(x).B.LDMOD)

/*! @brief Format value for bitfield PDB_SC_LDMOD. */
#define BF_PDB_SC_LDMOD(v)   ((uint32_t)((uint32_t)(v) << BP_PDB_SC_LDMOD) & BM_PDB_SC_LDMOD)

/*! @brief Set the LDMOD field to a new value. */
#define BW_PDB_SC_LDMOD(x, v) (HW_PDB_SC_WR(x, (HW_PDB_SC_RD(x) & ~BM_PDB_SC_LDMOD) | BF_PDB_SC_LDMOD(v)))
/*@}*/

/*******************************************************************************
 * HW_PDB_MOD - Modulus register
 ******************************************************************************/

/*!
 * @brief HW_PDB_MOD - Modulus register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
typedef union _hw_pdb_mod
{
    uint32_t U;
    struct _hw_pdb_mod_bitfields
    {
        uint32_t MOD : 16;             /*!< [15:0] PDB Modulus */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_pdb_mod_t;

/*!
 * @name Constants and macros for entire PDB_MOD register
 */
/*@{*/
#define HW_PDB_MOD_ADDR(x)       ((uint32_t)(x) + 0x4U)

#define HW_PDB_MOD(x)            (*(__IO hw_pdb_mod_t *) HW_PDB_MOD_ADDR(x))
#define HW_PDB_MOD_RD(x)         (HW_PDB_MOD(x).U)
#define HW_PDB_MOD_WR(x, v)      (HW_PDB_MOD(x).U = (v))
#define HW_PDB_MOD_SET(x, v)     (HW_PDB_MOD_WR(x, HW_PDB_MOD_RD(x) |  (v)))
#define HW_PDB_MOD_CLR(x, v)     (HW_PDB_MOD_WR(x, HW_PDB_MOD_RD(x) & ~(v)))
#define HW_PDB_MOD_TOG(x, v)     (HW_PDB_MOD_WR(x, HW_PDB_MOD_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PDB_MOD bitfields
 */

/*!
 * @name Register PDB_MOD, field MOD[15:0] (RW)
 *
 * Specifies the period of the counter. When the counter reaches this value, it
 * will be reset back to zero. If the PDB is in Continuous mode, the count begins
 * anew. Reading this field returns the value of the internal register that is
 * effective for the current cycle of PDB.
 */
/*@{*/
#define BP_PDB_MOD_MOD       (0U)          /*!< Bit position for PDB_MOD_MOD. */
#define BM_PDB_MOD_MOD       (0x0000FFFFU) /*!< Bit mask for PDB_MOD_MOD. */
#define BS_PDB_MOD_MOD       (16U)         /*!< Bit field size in bits for PDB_MOD_MOD. */

/*! @brief Read current value of the PDB_MOD_MOD field. */
#define BR_PDB_MOD_MOD(x)    (HW_PDB_MOD(x).B.MOD)

/*! @brief Format value for bitfield PDB_MOD_MOD. */
#define BF_PDB_MOD_MOD(v)    ((uint32_t)((uint32_t)(v) << BP_PDB_MOD_MOD) & BM_PDB_MOD_MOD)

/*! @brief Set the MOD field to a new value. */
#define BW_PDB_MOD_MOD(x, v) (HW_PDB_MOD_WR(x, (HW_PDB_MOD_RD(x) & ~BM_PDB_MOD_MOD) | BF_PDB_MOD_MOD(v)))
/*@}*/

/*******************************************************************************
 * HW_PDB_CNT - Counter register
 ******************************************************************************/

/*!
 * @brief HW_PDB_CNT - Counter register (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_cnt
{
    uint32_t U;
    struct _hw_pdb_cnt_bitfields
    {
        uint32_t CNT : 16;             /*!< [15:0] PDB Counter */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_pdb_cnt_t;

/*!
 * @name Constants and macros for entire PDB_CNT register
 */
/*@{*/
#define HW_PDB_CNT_ADDR(x)       ((uint32_t)(x) + 0x8U)

#define HW_PDB_CNT(x)            (*(__I hw_pdb_cnt_t *) HW_PDB_CNT_ADDR(x))
#define HW_PDB_CNT_RD(x)         (HW_PDB_CNT(x).U)
/*@}*/

/*
 * Constants & macros for individual PDB_CNT bitfields
 */

/*!
 * @name Register PDB_CNT, field CNT[15:0] (RO)
 *
 * Contains the current value of the counter.
 */
/*@{*/
#define BP_PDB_CNT_CNT       (0U)          /*!< Bit position for PDB_CNT_CNT. */
#define BM_PDB_CNT_CNT       (0x0000FFFFU) /*!< Bit mask for PDB_CNT_CNT. */
#define BS_PDB_CNT_CNT       (16U)         /*!< Bit field size in bits for PDB_CNT_CNT. */

/*! @brief Read current value of the PDB_CNT_CNT field. */
#define BR_PDB_CNT_CNT(x)    (HW_PDB_CNT(x).B.CNT)
/*@}*/

/*******************************************************************************
 * HW_PDB_IDLY - Interrupt Delay register
 ******************************************************************************/

/*!
 * @brief HW_PDB_IDLY - Interrupt Delay register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
typedef union _hw_pdb_idly
{
    uint32_t U;
    struct _hw_pdb_idly_bitfields
    {
        uint32_t IDLY : 16;            /*!< [15:0] PDB Interrupt Delay */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_pdb_idly_t;

/*!
 * @name Constants and macros for entire PDB_IDLY register
 */
/*@{*/
#define HW_PDB_IDLY_ADDR(x)      ((uint32_t)(x) + 0xCU)

#define HW_PDB_IDLY(x)           (*(__IO hw_pdb_idly_t *) HW_PDB_IDLY_ADDR(x))
#define HW_PDB_IDLY_RD(x)        (HW_PDB_IDLY(x).U)
#define HW_PDB_IDLY_WR(x, v)     (HW_PDB_IDLY(x).U = (v))
#define HW_PDB_IDLY_SET(x, v)    (HW_PDB_IDLY_WR(x, HW_PDB_IDLY_RD(x) |  (v)))
#define HW_PDB_IDLY_CLR(x, v)    (HW_PDB_IDLY_WR(x, HW_PDB_IDLY_RD(x) & ~(v)))
#define HW_PDB_IDLY_TOG(x, v)    (HW_PDB_IDLY_WR(x, HW_PDB_IDLY_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PDB_IDLY bitfields
 */

/*!
 * @name Register PDB_IDLY, field IDLY[15:0] (RW)
 *
 * Specifies the delay value to schedule the PDB interrupt. It can be used to
 * schedule an independent interrupt at some point in the PDB cycle. If enabled, a
 * PDB interrupt is generated, when the counter is equal to the IDLY. Reading
 * this field returns the value of internal register that is effective for the
 * current cycle of the PDB.
 */
/*@{*/
#define BP_PDB_IDLY_IDLY     (0U)          /*!< Bit position for PDB_IDLY_IDLY. */
#define BM_PDB_IDLY_IDLY     (0x0000FFFFU) /*!< Bit mask for PDB_IDLY_IDLY. */
#define BS_PDB_IDLY_IDLY     (16U)         /*!< Bit field size in bits for PDB_IDLY_IDLY. */

/*! @brief Read current value of the PDB_IDLY_IDLY field. */
#define BR_PDB_IDLY_IDLY(x)  (HW_PDB_IDLY(x).B.IDLY)

/*! @brief Format value for bitfield PDB_IDLY_IDLY. */
#define BF_PDB_IDLY_IDLY(v)  ((uint32_t)((uint32_t)(v) << BP_PDB_IDLY_IDLY) & BM_PDB_IDLY_IDLY)

/*! @brief Set the IDLY field to a new value. */
#define BW_PDB_IDLY_IDLY(x, v) (HW_PDB_IDLY_WR(x, (HW_PDB_IDLY_RD(x) & ~BM_PDB_IDLY_IDLY) | BF_PDB_IDLY_IDLY(v)))
/*@}*/

/*******************************************************************************
 * HW_PDB_CHnC1 - Channel n Control register 1
 ******************************************************************************/

/*!
 * @brief HW_PDB_CHnC1 - Channel n Control register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one control register, CHnC1. The bits in this register
 * control the functionality of each PDB channel operation.
 */
typedef union _hw_pdb_chnc1
{
    uint32_t U;
    struct _hw_pdb_chnc1_bitfields
    {
        uint32_t EN : 8;               /*!< [7:0] PDB Channel Pre-Trigger Enable */
        uint32_t TOS : 8;              /*!< [15:8] PDB Channel Pre-Trigger Output Select */
        uint32_t BB : 8;               /*!< [23:16] PDB Channel Pre-Trigger Back-to-Back
                                        * Operation Enable */
        uint32_t RESERVED0 : 8;        /*!< [31:24]  */
    } B;
} hw_pdb_chnc1_t;

/*!
 * @name Constants and macros for entire PDB_CHnC1 register
 */
/*@{*/
#define HW_PDB_CHnC1_COUNT (2U)

#define HW_PDB_CHnC1_ADDR(x, n)  ((uint32_t)(x) + 0x10U + (0x28U * (n)))

#define HW_PDB_CHnC1(x, n)       (*(__IO hw_pdb_chnc1_t *) HW_PDB_CHnC1_ADDR(x, n))
#define HW_PDB_CHnC1_RD(x, n)    (HW_PDB_CHnC1(x, n).U)
#define HW_PDB_CHnC1_WR(x, n, v) (HW_PDB_CHnC1(x, n).U = (v))
#define HW_PDB_CHnC1_SET(x, n, v) (HW_PDB_CHnC1_WR(x, n, HW_PDB_CHnC1_RD(x, n) |  (v)))
#define HW_PDB_CHnC1_CLR(x, n, v) (HW_PDB_CHnC1_WR(x, n, HW_PDB_CHnC1_RD(x, n) & ~(v)))
#define HW_PDB_CHnC1_TOG(x, n, v) (HW_PDB_CHnC1_WR(x, n, HW_PDB_CHnC1_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PDB_CHnC1 bitfields
 */

/*!
 * @name Register PDB_CHnC1, field EN[7:0] (RW)
 *
 * These bits enable the PDB ADC pre-trigger outputs. Only lower M pre-trigger
 * bits are implemented in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger disabled.
 * - 1 - PDB channel's corresponding pre-trigger enabled.
 */
/*@{*/
#define BP_PDB_CHnC1_EN      (0U)          /*!< Bit position for PDB_CHnC1_EN. */
#define BM_PDB_CHnC1_EN      (0x000000FFU) /*!< Bit mask for PDB_CHnC1_EN. */
#define BS_PDB_CHnC1_EN      (8U)          /*!< Bit field size in bits for PDB_CHnC1_EN. */

/*! @brief Read current value of the PDB_CHnC1_EN field. */
#define BR_PDB_CHnC1_EN(x, n) (HW_PDB_CHnC1(x, n).B.EN)

/*! @brief Format value for bitfield PDB_CHnC1_EN. */
#define BF_PDB_CHnC1_EN(v)   ((uint32_t)((uint32_t)(v) << BP_PDB_CHnC1_EN) & BM_PDB_CHnC1_EN)

/*! @brief Set the EN field to a new value. */
#define BW_PDB_CHnC1_EN(x, n, v) (HW_PDB_CHnC1_WR(x, n, (HW_PDB_CHnC1_RD(x, n) & ~BM_PDB_CHnC1_EN) | BF_PDB_CHnC1_EN(v)))
/*@}*/

/*!
 * @name Register PDB_CHnC1, field TOS[15:8] (RW)
 *
 * Selects the PDB ADC pre-trigger outputs. Only lower M pre-trigger fields are
 * implemented in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger is in bypassed mode. The
 *     pre-trigger asserts one peripheral clock cycle after a rising edge is detected
 *     on selected trigger input source or software trigger is selected and SWTRIG
 *     is written with 1.
 * - 1 - PDB channel's corresponding pre-trigger asserts when the counter
 *     reaches the channel delay register and one peripheral clock cycle after a rising
 *     edge is detected on selected trigger input source or software trigger is
 *     selected and SETRIG is written with 1.
 */
/*@{*/
#define BP_PDB_CHnC1_TOS     (8U)          /*!< Bit position for PDB_CHnC1_TOS. */
#define BM_PDB_CHnC1_TOS     (0x0000FF00U) /*!< Bit mask for PDB_CHnC1_TOS. */
#define BS_PDB_CHnC1_TOS     (8U)          /*!< Bit field size in bits for PDB_CHnC1_TOS. */

/*! @brief Read current value of the PDB_CHnC1_TOS field. */
#define BR_PDB_CHnC1_TOS(x, n) (HW_PDB_CHnC1(x, n).B.TOS)

/*! @brief Format value for bitfield PDB_CHnC1_TOS. */
#define BF_PDB_CHnC1_TOS(v)  ((uint32_t)((uint32_t)(v) << BP_PDB_CHnC1_TOS) & BM_PDB_CHnC1_TOS)

/*! @brief Set the TOS field to a new value. */
#define BW_PDB_CHnC1_TOS(x, n, v) (HW_PDB_CHnC1_WR(x, n, (HW_PDB_CHnC1_RD(x, n) & ~BM_PDB_CHnC1_TOS) | BF_PDB_CHnC1_TOS(v)))
/*@}*/

/*!
 * @name Register PDB_CHnC1, field BB[23:16] (RW)
 *
 * These bits enable the PDB ADC pre-trigger operation as back-to-back mode.
 * Only lower M pre-trigger bits are implemented in this MCU. Back-to-back operation
 * enables the ADC conversions complete to trigger the next PDB channel
 * pre-trigger and trigger output, so that the ADC conversions can be triggered on next
 * set of configuration and results registers. Application code must only enable
 * the back-to-back operation of the PDB pre-triggers at the leading of the
 * back-to-back connection chain.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger back-to-back operation disabled.
 * - 1 - PDB channel's corresponding pre-trigger back-to-back operation enabled.
 */
/*@{*/
#define BP_PDB_CHnC1_BB      (16U)         /*!< Bit position for PDB_CHnC1_BB. */
#define BM_PDB_CHnC1_BB      (0x00FF0000U) /*!< Bit mask for PDB_CHnC1_BB. */
#define BS_PDB_CHnC1_BB      (8U)          /*!< Bit field size in bits for PDB_CHnC1_BB. */

/*! @brief Read current value of the PDB_CHnC1_BB field. */
#define BR_PDB_CHnC1_BB(x, n) (HW_PDB_CHnC1(x, n).B.BB)

/*! @brief Format value for bitfield PDB_CHnC1_BB. */
#define BF_PDB_CHnC1_BB(v)   ((uint32_t)((uint32_t)(v) << BP_PDB_CHnC1_BB) & BM_PDB_CHnC1_BB)

/*! @brief Set the BB field to a new value. */
#define BW_PDB_CHnC1_BB(x, n, v) (HW_PDB_CHnC1_WR(x, n, (HW_PDB_CHnC1_RD(x, n) & ~BM_PDB_CHnC1_BB) | BF_PDB_CHnC1_BB(v)))
/*@}*/
/*******************************************************************************
 * HW_PDB_CHnS - Channel n Status register
 ******************************************************************************/

/*!
 * @brief HW_PDB_CHnS - Channel n Status register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_chns
{
    uint32_t U;
    struct _hw_pdb_chns_bitfields
    {
        uint32_t ERR : 8;              /*!< [7:0] PDB Channel Sequence Error Flags */
        uint32_t RESERVED0 : 8;        /*!< [15:8]  */
        uint32_t CF : 8;               /*!< [23:16] PDB Channel Flags */
        uint32_t RESERVED1 : 8;        /*!< [31:24]  */
    } B;
} hw_pdb_chns_t;

/*!
 * @name Constants and macros for entire PDB_CHnS register
 */
/*@{*/
#define HW_PDB_CHnS_COUNT (2U)

#define HW_PDB_CHnS_ADDR(x, n)   ((uint32_t)(x) + 0x14U + (0x28U * (n)))

#define HW_PDB_CHnS(x, n)        (*(__IO hw_pdb_chns_t *) HW_PDB_CHnS_ADDR(x, n))
#define HW_PDB_CHnS_RD(x, n)     (HW_PDB_CHnS(x, n).U)
#define HW_PDB_CHnS_WR(x, n, v)  (HW_PDB_CHnS(x, n).U = (v))
#define HW_PDB_CHnS_SET(x, n, v) (HW_PDB_CHnS_WR(x, n, HW_PDB_CHnS_RD(x, n) |  (v)))
#define HW_PDB_CHnS_CLR(x, n, v) (HW_PDB_CHnS_WR(x, n, HW_PDB_CHnS_RD(x, n) & ~(v)))
#define HW_PDB_CHnS_TOG(x, n, v) (HW_PDB_CHnS_WR(x, n, HW_PDB_CHnS_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PDB_CHnS bitfields
 */

/*!
 * @name Register PDB_CHnS, field ERR[7:0] (RW)
 *
 * Only the lower M bits are implemented in this MCU.
 *
 * Values:
 * - 0 - Sequence error not detected on PDB channel's corresponding pre-trigger.
 * - 1 - Sequence error detected on PDB channel's corresponding pre-trigger.
 *     ADCn block can be triggered for a conversion by one pre-trigger from PDB
 *     channel n. When one conversion, which is triggered by one of the pre-triggers
 *     from PDB channel n, is in progress, new trigger from PDB channel's
 *     corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set.
 *     Writing 0's to clear the sequence error flags.
 */
/*@{*/
#define BP_PDB_CHnS_ERR      (0U)          /*!< Bit position for PDB_CHnS_ERR. */
#define BM_PDB_CHnS_ERR      (0x000000FFU) /*!< Bit mask for PDB_CHnS_ERR. */
#define BS_PDB_CHnS_ERR      (8U)          /*!< Bit field size in bits for PDB_CHnS_ERR. */

/*! @brief Read current value of the PDB_CHnS_ERR field. */
#define BR_PDB_CHnS_ERR(x, n) (HW_PDB_CHnS(x, n).B.ERR)

/*! @brief Format value for bitfield PDB_CHnS_ERR. */
#define BF_PDB_CHnS_ERR(v)   ((uint32_t)((uint32_t)(v) << BP_PDB_CHnS_ERR) & BM_PDB_CHnS_ERR)

/*! @brief Set the ERR field to a new value. */
#define BW_PDB_CHnS_ERR(x, n, v) (HW_PDB_CHnS_WR(x, n, (HW_PDB_CHnS_RD(x, n) & ~BM_PDB_CHnS_ERR) | BF_PDB_CHnS_ERR(v)))
/*@}*/

/*!
 * @name Register PDB_CHnS, field CF[23:16] (RW)
 *
 * The CF[m] bit is set when the PDB counter matches the CHnDLYm. Write 0 to
 * clear these bits.
 */
/*@{*/
#define BP_PDB_CHnS_CF       (16U)         /*!< Bit position for PDB_CHnS_CF. */
#define BM_PDB_CHnS_CF       (0x00FF0000U) /*!< Bit mask for PDB_CHnS_CF. */
#define BS_PDB_CHnS_CF       (8U)          /*!< Bit field size in bits for PDB_CHnS_CF. */

/*! @brief Read current value of the PDB_CHnS_CF field. */
#define BR_PDB_CHnS_CF(x, n) (HW_PDB_CHnS(x, n).B.CF)

/*! @brief Format value for bitfield PDB_CHnS_CF. */
#define BF_PDB_CHnS_CF(v)    ((uint32_t)((uint32_t)(v) << BP_PDB_CHnS_CF) & BM_PDB_CHnS_CF)

/*! @brief Set the CF field to a new value. */
#define BW_PDB_CHnS_CF(x, n, v) (HW_PDB_CHnS_WR(x, n, (HW_PDB_CHnS_RD(x, n) & ~BM_PDB_CHnS_CF) | BF_PDB_CHnS_CF(v)))
/*@}*/
/*******************************************************************************
 * HW_PDB_CHnDLY0 - Channel n Delay 0 register
 ******************************************************************************/

/*!
 * @brief HW_PDB_CHnDLY0 - Channel n Delay 0 register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_chndly0
{
    uint32_t U;
    struct _hw_pdb_chndly0_bitfields
    {
        uint32_t DLY : 16;             /*!< [15:0] PDB Channel Delay */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_pdb_chndly0_t;

/*!
 * @name Constants and macros for entire PDB_CHnDLY0 register
 */
/*@{*/
#define HW_PDB_CHnDLY0_COUNT (2U)

#define HW_PDB_CHnDLY0_ADDR(x, n) ((uint32_t)(x) + 0x18U + (0x28U * (n)))

#define HW_PDB_CHnDLY0(x, n)     (*(__IO hw_pdb_chndly0_t *) HW_PDB_CHnDLY0_ADDR(x, n))
#define HW_PDB_CHnDLY0_RD(x, n)  (HW_PDB_CHnDLY0(x, n).U)
#define HW_PDB_CHnDLY0_WR(x, n, v) (HW_PDB_CHnDLY0(x, n).U = (v))
#define HW_PDB_CHnDLY0_SET(x, n, v) (HW_PDB_CHnDLY0_WR(x, n, HW_PDB_CHnDLY0_RD(x, n) |  (v)))
#define HW_PDB_CHnDLY0_CLR(x, n, v) (HW_PDB_CHnDLY0_WR(x, n, HW_PDB_CHnDLY0_RD(x, n) & ~(v)))
#define HW_PDB_CHnDLY0_TOG(x, n, v) (HW_PDB_CHnDLY0_WR(x, n, HW_PDB_CHnDLY0_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PDB_CHnDLY0 bitfields
 */

/*!
 * @name Register PDB_CHnDLY0, field DLY[15:0] (RW)
 *
 * Specifies the delay value for the channel's corresponding pre-trigger. The
 * pre-trigger asserts when the counter is equal to DLY. Reading this field returns
 * the value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
#define BP_PDB_CHnDLY0_DLY   (0U)          /*!< Bit position for PDB_CHnDLY0_DLY. */
#define BM_PDB_CHnDLY0_DLY   (0x0000FFFFU) /*!< Bit mask for PDB_CHnDLY0_DLY. */
#define BS_PDB_CHnDLY0_DLY   (16U)         /*!< Bit field size in bits for PDB_CHnDLY0_DLY. */

/*! @brief Read current value of the PDB_CHnDLY0_DLY field. */
#define BR_PDB_CHnDLY0_DLY(x, n) (HW_PDB_CHnDLY0(x, n).B.DLY)

/*! @brief Format value for bitfield PDB_CHnDLY0_DLY. */
#define BF_PDB_CHnDLY0_DLY(v) ((uint32_t)((uint32_t)(v) << BP_PDB_CHnDLY0_DLY) & BM_PDB_CHnDLY0_DLY)

/*! @brief Set the DLY field to a new value. */
#define BW_PDB_CHnDLY0_DLY(x, n, v) (HW_PDB_CHnDLY0_WR(x, n, (HW_PDB_CHnDLY0_RD(x, n) & ~BM_PDB_CHnDLY0_DLY) | BF_PDB_CHnDLY0_DLY(v)))
/*@}*/
/*******************************************************************************
 * HW_PDB_CHnDLY1 - Channel n Delay 1 register
 ******************************************************************************/

/*!
 * @brief HW_PDB_CHnDLY1 - Channel n Delay 1 register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_chndly1
{
    uint32_t U;
    struct _hw_pdb_chndly1_bitfields
    {
        uint32_t DLY : 16;             /*!< [15:0] PDB Channel Delay */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_pdb_chndly1_t;

/*!
 * @name Constants and macros for entire PDB_CHnDLY1 register
 */
/*@{*/
#define HW_PDB_CHnDLY1_COUNT (2U)

#define HW_PDB_CHnDLY1_ADDR(x, n) ((uint32_t)(x) + 0x1CU + (0x28U * (n)))

#define HW_PDB_CHnDLY1(x, n)     (*(__IO hw_pdb_chndly1_t *) HW_PDB_CHnDLY1_ADDR(x, n))
#define HW_PDB_CHnDLY1_RD(x, n)  (HW_PDB_CHnDLY1(x, n).U)
#define HW_PDB_CHnDLY1_WR(x, n, v) (HW_PDB_CHnDLY1(x, n).U = (v))
#define HW_PDB_CHnDLY1_SET(x, n, v) (HW_PDB_CHnDLY1_WR(x, n, HW_PDB_CHnDLY1_RD(x, n) |  (v)))
#define HW_PDB_CHnDLY1_CLR(x, n, v) (HW_PDB_CHnDLY1_WR(x, n, HW_PDB_CHnDLY1_RD(x, n) & ~(v)))
#define HW_PDB_CHnDLY1_TOG(x, n, v) (HW_PDB_CHnDLY1_WR(x, n, HW_PDB_CHnDLY1_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PDB_CHnDLY1 bitfields
 */

/*!
 * @name Register PDB_CHnDLY1, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
#define BP_PDB_CHnDLY1_DLY   (0U)          /*!< Bit position for PDB_CHnDLY1_DLY. */
#define BM_PDB_CHnDLY1_DLY   (0x0000FFFFU) /*!< Bit mask for PDB_CHnDLY1_DLY. */
#define BS_PDB_CHnDLY1_DLY   (16U)         /*!< Bit field size in bits for PDB_CHnDLY1_DLY. */

/*! @brief Read current value of the PDB_CHnDLY1_DLY field. */
#define BR_PDB_CHnDLY1_DLY(x, n) (HW_PDB_CHnDLY1(x, n).B.DLY)

/*! @brief Format value for bitfield PDB_CHnDLY1_DLY. */
#define BF_PDB_CHnDLY1_DLY(v) ((uint32_t)((uint32_t)(v) << BP_PDB_CHnDLY1_DLY) & BM_PDB_CHnDLY1_DLY)

/*! @brief Set the DLY field to a new value. */
#define BW_PDB_CHnDLY1_DLY(x, n, v) (HW_PDB_CHnDLY1_WR(x, n, (HW_PDB_CHnDLY1_RD(x, n) & ~BM_PDB_CHnDLY1_DLY) | BF_PDB_CHnDLY1_DLY(v)))
/*@}*/

/*******************************************************************************
 * HW_PDB_DACINTCn - DAC Interval Trigger n Control register
 ******************************************************************************/

/*!
 * @brief HW_PDB_DACINTCn - DAC Interval Trigger n Control register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_dacintcn
{
    uint32_t U;
    struct _hw_pdb_dacintcn_bitfields
    {
        uint32_t TOE : 1;              /*!< [0] DAC Interval Trigger Enable */
        uint32_t EXT : 1;              /*!< [1] DAC External Trigger Input Enable */
        uint32_t RESERVED0 : 30;       /*!< [31:2]  */
    } B;
} hw_pdb_dacintcn_t;

/*!
 * @name Constants and macros for entire PDB_DACINTCn register
 */
/*@{*/
#define HW_PDB_DACINTCn_COUNT (2U)

#define HW_PDB_DACINTCn_ADDR(x, n) ((uint32_t)(x) + 0x150U + (0x8U * (n)))

#define HW_PDB_DACINTCn(x, n)    (*(__IO hw_pdb_dacintcn_t *) HW_PDB_DACINTCn_ADDR(x, n))
#define HW_PDB_DACINTCn_RD(x, n) (HW_PDB_DACINTCn(x, n).U)
#define HW_PDB_DACINTCn_WR(x, n, v) (HW_PDB_DACINTCn(x, n).U = (v))
#define HW_PDB_DACINTCn_SET(x, n, v) (HW_PDB_DACINTCn_WR(x, n, HW_PDB_DACINTCn_RD(x, n) |  (v)))
#define HW_PDB_DACINTCn_CLR(x, n, v) (HW_PDB_DACINTCn_WR(x, n, HW_PDB_DACINTCn_RD(x, n) & ~(v)))
#define HW_PDB_DACINTCn_TOG(x, n, v) (HW_PDB_DACINTCn_WR(x, n, HW_PDB_DACINTCn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PDB_DACINTCn bitfields
 */

/*!
 * @name Register PDB_DACINTCn, field TOE[0] (RW)
 *
 * This bit enables the DAC interval trigger.
 *
 * Values:
 * - 0 - DAC interval trigger disabled.
 * - 1 - DAC interval trigger enabled.
 */
/*@{*/
#define BP_PDB_DACINTCn_TOE  (0U)          /*!< Bit position for PDB_DACINTCn_TOE. */
#define BM_PDB_DACINTCn_TOE  (0x00000001U) /*!< Bit mask for PDB_DACINTCn_TOE. */
#define BS_PDB_DACINTCn_TOE  (1U)          /*!< Bit field size in bits for PDB_DACINTCn_TOE. */

/*! @brief Read current value of the PDB_DACINTCn_TOE field. */
#define BR_PDB_DACINTCn_TOE(x, n) (BITBAND_ACCESS32(HW_PDB_DACINTCn_ADDR(x, n), BP_PDB_DACINTCn_TOE))

/*! @brief Format value for bitfield PDB_DACINTCn_TOE. */
#define BF_PDB_DACINTCn_TOE(v) ((uint32_t)((uint32_t)(v) << BP_PDB_DACINTCn_TOE) & BM_PDB_DACINTCn_TOE)

/*! @brief Set the TOE field to a new value. */
#define BW_PDB_DACINTCn_TOE(x, n, v) (BITBAND_ACCESS32(HW_PDB_DACINTCn_ADDR(x, n), BP_PDB_DACINTCn_TOE) = (v))
/*@}*/

/*!
 * @name Register PDB_DACINTCn, field EXT[1] (RW)
 *
 * Enables the external trigger for DAC interval counter.
 *
 * Values:
 * - 0 - DAC external trigger input disabled. DAC interval counter is reset and
 *     counting starts when a rising edge is detected on selected trigger input
 *     source or software trigger is selected and SWTRIG is written with 1.
 * - 1 - DAC external trigger input enabled. DAC interval counter is bypassed
 *     and DAC external trigger input triggers the DAC interval trigger.
 */
/*@{*/
#define BP_PDB_DACINTCn_EXT  (1U)          /*!< Bit position for PDB_DACINTCn_EXT. */
#define BM_PDB_DACINTCn_EXT  (0x00000002U) /*!< Bit mask for PDB_DACINTCn_EXT. */
#define BS_PDB_DACINTCn_EXT  (1U)          /*!< Bit field size in bits for PDB_DACINTCn_EXT. */

/*! @brief Read current value of the PDB_DACINTCn_EXT field. */
#define BR_PDB_DACINTCn_EXT(x, n) (BITBAND_ACCESS32(HW_PDB_DACINTCn_ADDR(x, n), BP_PDB_DACINTCn_EXT))

/*! @brief Format value for bitfield PDB_DACINTCn_EXT. */
#define BF_PDB_DACINTCn_EXT(v) ((uint32_t)((uint32_t)(v) << BP_PDB_DACINTCn_EXT) & BM_PDB_DACINTCn_EXT)

/*! @brief Set the EXT field to a new value. */
#define BW_PDB_DACINTCn_EXT(x, n, v) (BITBAND_ACCESS32(HW_PDB_DACINTCn_ADDR(x, n), BP_PDB_DACINTCn_EXT) = (v))
/*@}*/
/*******************************************************************************
 * HW_PDB_DACINTn - DAC Interval n register
 ******************************************************************************/

/*!
 * @brief HW_PDB_DACINTn - DAC Interval n register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_dacintn
{
    uint32_t U;
    struct _hw_pdb_dacintn_bitfields
    {
        uint32_t INT : 16;             /*!< [15:0] DAC Interval */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_pdb_dacintn_t;

/*!
 * @name Constants and macros for entire PDB_DACINTn register
 */
/*@{*/
#define HW_PDB_DACINTn_COUNT (2U)

#define HW_PDB_DACINTn_ADDR(x, n) ((uint32_t)(x) + 0x154U + (0x8U * (n)))

#define HW_PDB_DACINTn(x, n)     (*(__IO hw_pdb_dacintn_t *) HW_PDB_DACINTn_ADDR(x, n))
#define HW_PDB_DACINTn_RD(x, n)  (HW_PDB_DACINTn(x, n).U)
#define HW_PDB_DACINTn_WR(x, n, v) (HW_PDB_DACINTn(x, n).U = (v))
#define HW_PDB_DACINTn_SET(x, n, v) (HW_PDB_DACINTn_WR(x, n, HW_PDB_DACINTn_RD(x, n) |  (v)))
#define HW_PDB_DACINTn_CLR(x, n, v) (HW_PDB_DACINTn_WR(x, n, HW_PDB_DACINTn_RD(x, n) & ~(v)))
#define HW_PDB_DACINTn_TOG(x, n, v) (HW_PDB_DACINTn_WR(x, n, HW_PDB_DACINTn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PDB_DACINTn bitfields
 */

/*!
 * @name Register PDB_DACINTn, field INT[15:0] (RW)
 *
 * Specifies the interval value for DAC interval trigger. DAC interval trigger
 * triggers DAC[1:0] update when the DAC interval counter is equal to the DACINT.
 * Reading this field returns the value of internal register that is effective
 * for the current PDB cycle.
 */
/*@{*/
#define BP_PDB_DACINTn_INT   (0U)          /*!< Bit position for PDB_DACINTn_INT. */
#define BM_PDB_DACINTn_INT   (0x0000FFFFU) /*!< Bit mask for PDB_DACINTn_INT. */
#define BS_PDB_DACINTn_INT   (16U)         /*!< Bit field size in bits for PDB_DACINTn_INT. */

/*! @brief Read current value of the PDB_DACINTn_INT field. */
#define BR_PDB_DACINTn_INT(x, n) (HW_PDB_DACINTn(x, n).B.INT)

/*! @brief Format value for bitfield PDB_DACINTn_INT. */
#define BF_PDB_DACINTn_INT(v) ((uint32_t)((uint32_t)(v) << BP_PDB_DACINTn_INT) & BM_PDB_DACINTn_INT)

/*! @brief Set the INT field to a new value. */
#define BW_PDB_DACINTn_INT(x, n, v) (HW_PDB_DACINTn_WR(x, n, (HW_PDB_DACINTn_RD(x, n) & ~BM_PDB_DACINTn_INT) | BF_PDB_DACINTn_INT(v)))
/*@}*/

/*******************************************************************************
 * HW_PDB_POEN - Pulse-Out n Enable register
 ******************************************************************************/

/*!
 * @brief HW_PDB_POEN - Pulse-Out n Enable register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_poen
{
    uint32_t U;
    struct _hw_pdb_poen_bitfields
    {
        uint32_t POEN : 8;             /*!< [7:0] PDB Pulse-Out Enable */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_pdb_poen_t;

/*!
 * @name Constants and macros for entire PDB_POEN register
 */
/*@{*/
#define HW_PDB_POEN_ADDR(x)      ((uint32_t)(x) + 0x190U)

#define HW_PDB_POEN(x)           (*(__IO hw_pdb_poen_t *) HW_PDB_POEN_ADDR(x))
#define HW_PDB_POEN_RD(x)        (HW_PDB_POEN(x).U)
#define HW_PDB_POEN_WR(x, v)     (HW_PDB_POEN(x).U = (v))
#define HW_PDB_POEN_SET(x, v)    (HW_PDB_POEN_WR(x, HW_PDB_POEN_RD(x) |  (v)))
#define HW_PDB_POEN_CLR(x, v)    (HW_PDB_POEN_WR(x, HW_PDB_POEN_RD(x) & ~(v)))
#define HW_PDB_POEN_TOG(x, v)    (HW_PDB_POEN_WR(x, HW_PDB_POEN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PDB_POEN bitfields
 */

/*!
 * @name Register PDB_POEN, field POEN[7:0] (RW)
 *
 * Enables the pulse output. Only lower Y bits are implemented in this MCU.
 *
 * Values:
 * - 0 - PDB Pulse-Out disabled
 * - 1 - PDB Pulse-Out enabled
 */
/*@{*/
#define BP_PDB_POEN_POEN     (0U)          /*!< Bit position for PDB_POEN_POEN. */
#define BM_PDB_POEN_POEN     (0x000000FFU) /*!< Bit mask for PDB_POEN_POEN. */
#define BS_PDB_POEN_POEN     (8U)          /*!< Bit field size in bits for PDB_POEN_POEN. */

/*! @brief Read current value of the PDB_POEN_POEN field. */
#define BR_PDB_POEN_POEN(x)  (HW_PDB_POEN(x).B.POEN)

/*! @brief Format value for bitfield PDB_POEN_POEN. */
#define BF_PDB_POEN_POEN(v)  ((uint32_t)((uint32_t)(v) << BP_PDB_POEN_POEN) & BM_PDB_POEN_POEN)

/*! @brief Set the POEN field to a new value. */
#define BW_PDB_POEN_POEN(x, v) (HW_PDB_POEN_WR(x, (HW_PDB_POEN_RD(x) & ~BM_PDB_POEN_POEN) | BF_PDB_POEN_POEN(v)))
/*@}*/

/*******************************************************************************
 * HW_PDB_POnDLY - Pulse-Out n Delay register
 ******************************************************************************/

/*!
 * @brief HW_PDB_POnDLY - Pulse-Out n Delay register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_pdb_pondly
{
    uint32_t U;
    struct _hw_pdb_pondly_bitfields
    {
        uint32_t DLY2 : 16;            /*!< [15:0] PDB Pulse-Out Delay 2 */
        uint32_t DLY1 : 16;            /*!< [31:16] PDB Pulse-Out Delay 1 */
    } B;
} hw_pdb_pondly_t;

/*!
 * @name Constants and macros for entire PDB_POnDLY register
 */
/*@{*/
#define HW_PDB_POnDLY_COUNT (3U)

#define HW_PDB_POnDLY_ADDR(x, n) ((uint32_t)(x) + 0x194U + (0x4U * (n)))

#define HW_PDB_POnDLY(x, n)      (*(__IO hw_pdb_pondly_t *) HW_PDB_POnDLY_ADDR(x, n))
#define HW_PDB_POnDLY_RD(x, n)   (HW_PDB_POnDLY(x, n).U)
#define HW_PDB_POnDLY_WR(x, n, v) (HW_PDB_POnDLY(x, n).U = (v))
#define HW_PDB_POnDLY_SET(x, n, v) (HW_PDB_POnDLY_WR(x, n, HW_PDB_POnDLY_RD(x, n) |  (v)))
#define HW_PDB_POnDLY_CLR(x, n, v) (HW_PDB_POnDLY_WR(x, n, HW_PDB_POnDLY_RD(x, n) & ~(v)))
#define HW_PDB_POnDLY_TOG(x, n, v) (HW_PDB_POnDLY_WR(x, n, HW_PDB_POnDLY_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PDB_POnDLY bitfields
 */

/*!
 * @name Register PDB_POnDLY, field DLY2[15:0] (RW)
 *
 * These bits specify the delay 2 value for the PDB Pulse-Out. Pulse-Out goes
 * low when the PDB counter is equal to the DLY2. Reading these bits returns the
 * value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
#define BP_PDB_POnDLY_DLY2   (0U)          /*!< Bit position for PDB_POnDLY_DLY2. */
#define BM_PDB_POnDLY_DLY2   (0x0000FFFFU) /*!< Bit mask for PDB_POnDLY_DLY2. */
#define BS_PDB_POnDLY_DLY2   (16U)         /*!< Bit field size in bits for PDB_POnDLY_DLY2. */

/*! @brief Read current value of the PDB_POnDLY_DLY2 field. */
#define BR_PDB_POnDLY_DLY2(x, n) (HW_PDB_POnDLY(x, n).B.DLY2)

/*! @brief Format value for bitfield PDB_POnDLY_DLY2. */
#define BF_PDB_POnDLY_DLY2(v) ((uint32_t)((uint32_t)(v) << BP_PDB_POnDLY_DLY2) & BM_PDB_POnDLY_DLY2)

/*! @brief Set the DLY2 field to a new value. */
#define BW_PDB_POnDLY_DLY2(x, n, v) (HW_PDB_POnDLY_WR(x, n, (HW_PDB_POnDLY_RD(x, n) & ~BM_PDB_POnDLY_DLY2) | BF_PDB_POnDLY_DLY2(v)))
/*@}*/

/*!
 * @name Register PDB_POnDLY, field DLY1[31:16] (RW)
 *
 * These bits specify the delay 1 value for the PDB Pulse-Out. Pulse-Out goes
 * high when the PDB counter is equal to the DLY1. Reading these bits returns the
 * value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
#define BP_PDB_POnDLY_DLY1   (16U)         /*!< Bit position for PDB_POnDLY_DLY1. */
#define BM_PDB_POnDLY_DLY1   (0xFFFF0000U) /*!< Bit mask for PDB_POnDLY_DLY1. */
#define BS_PDB_POnDLY_DLY1   (16U)         /*!< Bit field size in bits for PDB_POnDLY_DLY1. */

/*! @brief Read current value of the PDB_POnDLY_DLY1 field. */
#define BR_PDB_POnDLY_DLY1(x, n) (HW_PDB_POnDLY(x, n).B.DLY1)

/*! @brief Format value for bitfield PDB_POnDLY_DLY1. */
#define BF_PDB_POnDLY_DLY1(v) ((uint32_t)((uint32_t)(v) << BP_PDB_POnDLY_DLY1) & BM_PDB_POnDLY_DLY1)

/*! @brief Set the DLY1 field to a new value. */
#define BW_PDB_POnDLY_DLY1(x, n, v) (HW_PDB_POnDLY_WR(x, n, (HW_PDB_POnDLY_RD(x, n) & ~BM_PDB_POnDLY_DLY1) | BF_PDB_POnDLY_DLY1(v)))
/*@}*/

/*******************************************************************************
 * hw_pdb_t - module struct
 ******************************************************************************/
/*!
 * @brief All PDB module registers.
 */
#pragma pack(1)
typedef struct _hw_pdb
{
    __IO hw_pdb_sc_t SC;                   /*!< [0x0] Status and Control register */
    __IO hw_pdb_mod_t MOD;                 /*!< [0x4] Modulus register */
    __I hw_pdb_cnt_t CNT;                  /*!< [0x8] Counter register */
    __IO hw_pdb_idly_t IDLY;               /*!< [0xC] Interrupt Delay register */
    struct {
        __IO hw_pdb_chnc1_t CHnC1;         /*!< [0x10] Channel n Control register 1 */
        __IO hw_pdb_chns_t CHnS;           /*!< [0x14] Channel n Status register */
        __IO hw_pdb_chndly0_t CHnDLY0;     /*!< [0x18] Channel n Delay 0 register */
        __IO hw_pdb_chndly1_t CHnDLY1;     /*!< [0x1C] Channel n Delay 1 register */
        uint8_t _reserved0[24];
    } CH[2];
    uint8_t _reserved0[240];
    struct {
        __IO hw_pdb_dacintcn_t DACINTCn;   /*!< [0x150] DAC Interval Trigger n Control register */
        __IO hw_pdb_dacintn_t DACINTn;     /*!< [0x154] DAC Interval n register */
    } DAC[2];
    uint8_t _reserved1[48];
    __IO hw_pdb_poen_t POEN;               /*!< [0x190] Pulse-Out n Enable register */
    __IO hw_pdb_pondly_t POnDLY[3];        /*!< [0x194] Pulse-Out n Delay register */
} hw_pdb_t;
#pragma pack()

/*! @brief Macro to access all PDB registers. */
/*! @param x PDB module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_PDB_REGS(PDB0_BASE)</code>. */
#define HW_PDB_REGS(x) (*(hw_pdb_t *)(x))

/*
 * MK64F12 PIT
 *
 * Periodic Interrupt Timer
 *
 * Registers defined in this header file:
 * - HW_PIT_MCR - PIT Module Control Register
 * - HW_PIT_LDVALn - Timer Load Value Register
 * - HW_PIT_CVALn - Current Timer Value Register
 * - HW_PIT_TCTRLn - Timer Control Register
 * - HW_PIT_TFLGn - Timer Flag Register
 *
 * - hw_pit_t - Struct containing all module registers.
 */

#define HW_PIT_INSTANCE_COUNT (1U) /*!< Number of instances of the PIT module. */
#define HW_PIT (0U) /*!< Instance number for PIT. */

/*******************************************************************************
 * HW_PIT_MCR - PIT Module Control Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_MCR - PIT Module Control Register (RW)
 *
 * Reset value: 0x00000006U
 *
 * This register enables or disables the PIT timer clocks and controls the
 * timers when the PIT enters the Debug mode.
 */
typedef union _hw_pit_mcr
{
    uint32_t U;
    struct _hw_pit_mcr_bitfields
    {
        uint32_t FRZ : 1;              /*!< [0] Freeze */
        uint32_t MDIS : 1;             /*!< [1] Module Disable - (PIT section) */
        uint32_t RESERVED0 : 30;       /*!< [31:2]  */
    } B;
} hw_pit_mcr_t;

/*!
 * @name Constants and macros for entire PIT_MCR register
 */
/*@{*/
#define HW_PIT_MCR_ADDR(x)       ((uint32_t)(x) + 0x0U)

#define HW_PIT_MCR(x)            (*(__IO hw_pit_mcr_t *) HW_PIT_MCR_ADDR(x))
#define HW_PIT_MCR_RD(x)         (HW_PIT_MCR(x).U)
#define HW_PIT_MCR_WR(x, v)      (HW_PIT_MCR(x).U = (v))
#define HW_PIT_MCR_SET(x, v)     (HW_PIT_MCR_WR(x, HW_PIT_MCR_RD(x) |  (v)))
#define HW_PIT_MCR_CLR(x, v)     (HW_PIT_MCR_WR(x, HW_PIT_MCR_RD(x) & ~(v)))
#define HW_PIT_MCR_TOG(x, v)     (HW_PIT_MCR_WR(x, HW_PIT_MCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PIT_MCR bitfields
 */

/*!
 * @name Register PIT_MCR, field FRZ[0] (RW)
 *
 * Allows the timers to be stopped when the device enters the Debug mode.
 *
 * Values:
 * - 0 - Timers continue to run in Debug mode.
 * - 1 - Timers are stopped in Debug mode.
 */
/*@{*/
#define BP_PIT_MCR_FRZ       (0U)          /*!< Bit position for PIT_MCR_FRZ. */
#define BM_PIT_MCR_FRZ       (0x00000001U) /*!< Bit mask for PIT_MCR_FRZ. */
#define BS_PIT_MCR_FRZ       (1U)          /*!< Bit field size in bits for PIT_MCR_FRZ. */

/*! @brief Read current value of the PIT_MCR_FRZ field. */
#define BR_PIT_MCR_FRZ(x)    (BITBAND_ACCESS32(HW_PIT_MCR_ADDR(x), BP_PIT_MCR_FRZ))

/*! @brief Format value for bitfield PIT_MCR_FRZ. */
#define BF_PIT_MCR_FRZ(v)    ((uint32_t)((uint32_t)(v) << BP_PIT_MCR_FRZ) & BM_PIT_MCR_FRZ)

/*! @brief Set the FRZ field to a new value. */
#define BW_PIT_MCR_FRZ(x, v) (BITBAND_ACCESS32(HW_PIT_MCR_ADDR(x), BP_PIT_MCR_FRZ) = (v))
/*@}*/

/*!
 * @name Register PIT_MCR, field MDIS[1] (RW)
 *
 * Disables the standard timers. This field must be enabled before any other
 * setup is done.
 *
 * Values:
 * - 0 - Clock for standard PIT timers is enabled.
 * - 1 - Clock for standard PIT timers is disabled.
 */
/*@{*/
#define BP_PIT_MCR_MDIS      (1U)          /*!< Bit position for PIT_MCR_MDIS. */
#define BM_PIT_MCR_MDIS      (0x00000002U) /*!< Bit mask for PIT_MCR_MDIS. */
#define BS_PIT_MCR_MDIS      (1U)          /*!< Bit field size in bits for PIT_MCR_MDIS. */

/*! @brief Read current value of the PIT_MCR_MDIS field. */
#define BR_PIT_MCR_MDIS(x)   (BITBAND_ACCESS32(HW_PIT_MCR_ADDR(x), BP_PIT_MCR_MDIS))

/*! @brief Format value for bitfield PIT_MCR_MDIS. */
#define BF_PIT_MCR_MDIS(v)   ((uint32_t)((uint32_t)(v) << BP_PIT_MCR_MDIS) & BM_PIT_MCR_MDIS)

/*! @brief Set the MDIS field to a new value. */
#define BW_PIT_MCR_MDIS(x, v) (BITBAND_ACCESS32(HW_PIT_MCR_ADDR(x), BP_PIT_MCR_MDIS) = (v))
/*@}*/

/*******************************************************************************
 * HW_PIT_LDVALn - Timer Load Value Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_LDVALn - Timer Load Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers select the timeout period for the timer interrupts.
 */
typedef union _hw_pit_ldvaln
{
    uint32_t U;
    struct _hw_pit_ldvaln_bitfields
    {
        uint32_t TSV : 32;             /*!< [31:0] Timer Start Value */
    } B;
} hw_pit_ldvaln_t;

/*!
 * @name Constants and macros for entire PIT_LDVALn register
 */
/*@{*/
#define HW_PIT_LDVALn_COUNT (4U)

#define HW_PIT_LDVALn_ADDR(x, n) ((uint32_t)(x) + 0x100U + (0x10U * (n)))

#define HW_PIT_LDVALn(x, n)      (*(__IO hw_pit_ldvaln_t *) HW_PIT_LDVALn_ADDR(x, n))
#define HW_PIT_LDVALn_RD(x, n)   (HW_PIT_LDVALn(x, n).U)
#define HW_PIT_LDVALn_WR(x, n, v) (HW_PIT_LDVALn(x, n).U = (v))
#define HW_PIT_LDVALn_SET(x, n, v) (HW_PIT_LDVALn_WR(x, n, HW_PIT_LDVALn_RD(x, n) |  (v)))
#define HW_PIT_LDVALn_CLR(x, n, v) (HW_PIT_LDVALn_WR(x, n, HW_PIT_LDVALn_RD(x, n) & ~(v)))
#define HW_PIT_LDVALn_TOG(x, n, v) (HW_PIT_LDVALn_WR(x, n, HW_PIT_LDVALn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PIT_LDVALn bitfields
 */

/*!
 * @name Register PIT_LDVALn, field TSV[31:0] (RW)
 *
 * Sets the timer start value. The timer will count down until it reaches 0,
 * then it will generate an interrupt and load this register value again. Writing a
 * new value to this register will not restart the timer; instead the value will
 * be loaded after the timer expires. To abort the current cycle and start a
 * timer period with the new value, the timer must be disabled and enabled again.
 */
/*@{*/
#define BP_PIT_LDVALn_TSV    (0U)          /*!< Bit position for PIT_LDVALn_TSV. */
#define BM_PIT_LDVALn_TSV    (0xFFFFFFFFU) /*!< Bit mask for PIT_LDVALn_TSV. */
#define BS_PIT_LDVALn_TSV    (32U)         /*!< Bit field size in bits for PIT_LDVALn_TSV. */

/*! @brief Read current value of the PIT_LDVALn_TSV field. */
#define BR_PIT_LDVALn_TSV(x, n) (HW_PIT_LDVALn(x, n).U)

/*! @brief Format value for bitfield PIT_LDVALn_TSV. */
#define BF_PIT_LDVALn_TSV(v) ((uint32_t)((uint32_t)(v) << BP_PIT_LDVALn_TSV) & BM_PIT_LDVALn_TSV)

/*! @brief Set the TSV field to a new value. */
#define BW_PIT_LDVALn_TSV(x, n, v) (HW_PIT_LDVALn_WR(x, n, v))
/*@}*/
/*******************************************************************************
 * HW_PIT_CVALn - Current Timer Value Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_CVALn - Current Timer Value Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the current timer position.
 */
typedef union _hw_pit_cvaln
{
    uint32_t U;
    struct _hw_pit_cvaln_bitfields
    {
        uint32_t TVL : 32;             /*!< [31:0] Current Timer Value */
    } B;
} hw_pit_cvaln_t;

/*!
 * @name Constants and macros for entire PIT_CVALn register
 */
/*@{*/
#define HW_PIT_CVALn_COUNT (4U)

#define HW_PIT_CVALn_ADDR(x, n)  ((uint32_t)(x) + 0x104U + (0x10U * (n)))

#define HW_PIT_CVALn(x, n)       (*(__I hw_pit_cvaln_t *) HW_PIT_CVALn_ADDR(x, n))
#define HW_PIT_CVALn_RD(x, n)    (HW_PIT_CVALn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual PIT_CVALn bitfields
 */

/*!
 * @name Register PIT_CVALn, field TVL[31:0] (RO)
 *
 * Represents the current timer value, if the timer is enabled. If the timer is
 * disabled, do not use this field as its value is unreliable. The timer uses a
 * downcounter. The timer values are frozen in Debug mode if MCR[FRZ] is set.
 */
/*@{*/
#define BP_PIT_CVALn_TVL     (0U)          /*!< Bit position for PIT_CVALn_TVL. */
#define BM_PIT_CVALn_TVL     (0xFFFFFFFFU) /*!< Bit mask for PIT_CVALn_TVL. */
#define BS_PIT_CVALn_TVL     (32U)         /*!< Bit field size in bits for PIT_CVALn_TVL. */

/*! @brief Read current value of the PIT_CVALn_TVL field. */
#define BR_PIT_CVALn_TVL(x, n) (HW_PIT_CVALn(x, n).U)
/*@}*/
/*******************************************************************************
 * HW_PIT_TCTRLn - Timer Control Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_TCTRLn - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the control bits for each timer.
 */
typedef union _hw_pit_tctrln
{
    uint32_t U;
    struct _hw_pit_tctrln_bitfields
    {
        uint32_t TEN : 1;              /*!< [0] Timer Enable */
        uint32_t TIE : 1;              /*!< [1] Timer Interrupt Enable */
        uint32_t CHN : 1;              /*!< [2] Chain Mode */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_pit_tctrln_t;

/*!
 * @name Constants and macros for entire PIT_TCTRLn register
 */
/*@{*/
#define HW_PIT_TCTRLn_COUNT (4U)

#define HW_PIT_TCTRLn_ADDR(x, n) ((uint32_t)(x) + 0x108U + (0x10U * (n)))

#define HW_PIT_TCTRLn(x, n)      (*(__IO hw_pit_tctrln_t *) HW_PIT_TCTRLn_ADDR(x, n))
#define HW_PIT_TCTRLn_RD(x, n)   (HW_PIT_TCTRLn(x, n).U)
#define HW_PIT_TCTRLn_WR(x, n, v) (HW_PIT_TCTRLn(x, n).U = (v))
#define HW_PIT_TCTRLn_SET(x, n, v) (HW_PIT_TCTRLn_WR(x, n, HW_PIT_TCTRLn_RD(x, n) |  (v)))
#define HW_PIT_TCTRLn_CLR(x, n, v) (HW_PIT_TCTRLn_WR(x, n, HW_PIT_TCTRLn_RD(x, n) & ~(v)))
#define HW_PIT_TCTRLn_TOG(x, n, v) (HW_PIT_TCTRLn_WR(x, n, HW_PIT_TCTRLn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PIT_TCTRLn bitfields
 */

/*!
 * @name Register PIT_TCTRLn, field TEN[0] (RW)
 *
 * Enables or disables the timer.
 *
 * Values:
 * - 0 - Timer n is disabled.
 * - 1 - Timer n is enabled.
 */
/*@{*/
#define BP_PIT_TCTRLn_TEN    (0U)          /*!< Bit position for PIT_TCTRLn_TEN. */
#define BM_PIT_TCTRLn_TEN    (0x00000001U) /*!< Bit mask for PIT_TCTRLn_TEN. */
#define BS_PIT_TCTRLn_TEN    (1U)          /*!< Bit field size in bits for PIT_TCTRLn_TEN. */

/*! @brief Read current value of the PIT_TCTRLn_TEN field. */
#define BR_PIT_TCTRLn_TEN(x, n) (BITBAND_ACCESS32(HW_PIT_TCTRLn_ADDR(x, n), BP_PIT_TCTRLn_TEN))

/*! @brief Format value for bitfield PIT_TCTRLn_TEN. */
#define BF_PIT_TCTRLn_TEN(v) ((uint32_t)((uint32_t)(v) << BP_PIT_TCTRLn_TEN) & BM_PIT_TCTRLn_TEN)

/*! @brief Set the TEN field to a new value. */
#define BW_PIT_TCTRLn_TEN(x, n, v) (BITBAND_ACCESS32(HW_PIT_TCTRLn_ADDR(x, n), BP_PIT_TCTRLn_TEN) = (v))
/*@}*/

/*!
 * @name Register PIT_TCTRLn, field TIE[1] (RW)
 *
 * When an interrupt is pending, or, TFLGn[TIF] is set, enabling the interrupt
 * will immediately cause an interrupt event. To avoid this, the associated
 * TFLGn[TIF] must be cleared first.
 *
 * Values:
 * - 0 - Interrupt requests from Timer n are disabled.
 * - 1 - Interrupt will be requested whenever TIF is set.
 */
/*@{*/
#define BP_PIT_TCTRLn_TIE    (1U)          /*!< Bit position for PIT_TCTRLn_TIE. */
#define BM_PIT_TCTRLn_TIE    (0x00000002U) /*!< Bit mask for PIT_TCTRLn_TIE. */
#define BS_PIT_TCTRLn_TIE    (1U)          /*!< Bit field size in bits for PIT_TCTRLn_TIE. */

/*! @brief Read current value of the PIT_TCTRLn_TIE field. */
#define BR_PIT_TCTRLn_TIE(x, n) (BITBAND_ACCESS32(HW_PIT_TCTRLn_ADDR(x, n), BP_PIT_TCTRLn_TIE))

/*! @brief Format value for bitfield PIT_TCTRLn_TIE. */
#define BF_PIT_TCTRLn_TIE(v) ((uint32_t)((uint32_t)(v) << BP_PIT_TCTRLn_TIE) & BM_PIT_TCTRLn_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_PIT_TCTRLn_TIE(x, n, v) (BITBAND_ACCESS32(HW_PIT_TCTRLn_ADDR(x, n), BP_PIT_TCTRLn_TIE) = (v))
/*@}*/

/*!
 * @name Register PIT_TCTRLn, field CHN[2] (RW)
 *
 * When activated, Timer n-1 needs to expire before timer n can decrement by 1.
 * Timer 0 cannot be chained.
 *
 * Values:
 * - 0 - Timer is not chained.
 * - 1 - Timer is chained to previous timer. For example, for Channel 2, if this
 *     field is set, Timer 2 is chained to Timer 1.
 */
/*@{*/
#define BP_PIT_TCTRLn_CHN    (2U)          /*!< Bit position for PIT_TCTRLn_CHN. */
#define BM_PIT_TCTRLn_CHN    (0x00000004U) /*!< Bit mask for PIT_TCTRLn_CHN. */
#define BS_PIT_TCTRLn_CHN    (1U)          /*!< Bit field size in bits for PIT_TCTRLn_CHN. */

/*! @brief Read current value of the PIT_TCTRLn_CHN field. */
#define BR_PIT_TCTRLn_CHN(x, n) (BITBAND_ACCESS32(HW_PIT_TCTRLn_ADDR(x, n), BP_PIT_TCTRLn_CHN))

/*! @brief Format value for bitfield PIT_TCTRLn_CHN. */
#define BF_PIT_TCTRLn_CHN(v) ((uint32_t)((uint32_t)(v) << BP_PIT_TCTRLn_CHN) & BM_PIT_TCTRLn_CHN)

/*! @brief Set the CHN field to a new value. */
#define BW_PIT_TCTRLn_CHN(x, n, v) (BITBAND_ACCESS32(HW_PIT_TCTRLn_ADDR(x, n), BP_PIT_TCTRLn_CHN) = (v))
/*@}*/
/*******************************************************************************
 * HW_PIT_TFLGn - Timer Flag Register
 ******************************************************************************/

/*!
 * @brief HW_PIT_TFLGn - Timer Flag Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers hold the PIT interrupt flags.
 */
typedef union _hw_pit_tflgn
{
    uint32_t U;
    struct _hw_pit_tflgn_bitfields
    {
        uint32_t TIF : 1;              /*!< [0] Timer Interrupt Flag */
        uint32_t RESERVED0 : 31;       /*!< [31:1]  */
    } B;
} hw_pit_tflgn_t;

/*!
 * @name Constants and macros for entire PIT_TFLGn register
 */
/*@{*/
#define HW_PIT_TFLGn_COUNT (4U)

#define HW_PIT_TFLGn_ADDR(x, n)  ((uint32_t)(x) + 0x10CU + (0x10U * (n)))

#define HW_PIT_TFLGn(x, n)       (*(__IO hw_pit_tflgn_t *) HW_PIT_TFLGn_ADDR(x, n))
#define HW_PIT_TFLGn_RD(x, n)    (HW_PIT_TFLGn(x, n).U)
#define HW_PIT_TFLGn_WR(x, n, v) (HW_PIT_TFLGn(x, n).U = (v))
#define HW_PIT_TFLGn_SET(x, n, v) (HW_PIT_TFLGn_WR(x, n, HW_PIT_TFLGn_RD(x, n) |  (v)))
#define HW_PIT_TFLGn_CLR(x, n, v) (HW_PIT_TFLGn_WR(x, n, HW_PIT_TFLGn_RD(x, n) & ~(v)))
#define HW_PIT_TFLGn_TOG(x, n, v) (HW_PIT_TFLGn_WR(x, n, HW_PIT_TFLGn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PIT_TFLGn bitfields
 */

/*!
 * @name Register PIT_TFLGn, field TIF[0] (W1C)
 *
 * Sets to 1 at the end of the timer period. Writing 1 to this flag clears it.
 * Writing 0 has no effect. If enabled, or, when TCTRLn[TIE] = 1, TIF causes an
 * interrupt request.
 *
 * Values:
 * - 0 - Timeout has not yet occurred.
 * - 1 - Timeout has occurred.
 */
/*@{*/
#define BP_PIT_TFLGn_TIF     (0U)          /*!< Bit position for PIT_TFLGn_TIF. */
#define BM_PIT_TFLGn_TIF     (0x00000001U) /*!< Bit mask for PIT_TFLGn_TIF. */
#define BS_PIT_TFLGn_TIF     (1U)          /*!< Bit field size in bits for PIT_TFLGn_TIF. */

/*! @brief Read current value of the PIT_TFLGn_TIF field. */
#define BR_PIT_TFLGn_TIF(x, n) (BITBAND_ACCESS32(HW_PIT_TFLGn_ADDR(x, n), BP_PIT_TFLGn_TIF))

/*! @brief Format value for bitfield PIT_TFLGn_TIF. */
#define BF_PIT_TFLGn_TIF(v)  ((uint32_t)((uint32_t)(v) << BP_PIT_TFLGn_TIF) & BM_PIT_TFLGn_TIF)

/*! @brief Set the TIF field to a new value. */
#define BW_PIT_TFLGn_TIF(x, n, v) (BITBAND_ACCESS32(HW_PIT_TFLGn_ADDR(x, n), BP_PIT_TFLGn_TIF) = (v))
/*@}*/

/*******************************************************************************
 * hw_pit_t - module struct
 ******************************************************************************/
/*!
 * @brief All PIT module registers.
 */
#pragma pack(1)
typedef struct _hw_pit
{
    __IO hw_pit_mcr_t MCR;                 /*!< [0x0] PIT Module Control Register */
    uint8_t _reserved0[252];
    struct {
        __IO hw_pit_ldvaln_t LDVALn;       /*!< [0x100] Timer Load Value Register */
        __I hw_pit_cvaln_t CVALn;          /*!< [0x104] Current Timer Value Register */
        __IO hw_pit_tctrln_t TCTRLn;       /*!< [0x108] Timer Control Register */
        __IO hw_pit_tflgn_t TFLGn;         /*!< [0x10C] Timer Flag Register */
    } CHANNEL[4];
} hw_pit_t;
#pragma pack()

/*! @brief Macro to access all PIT registers. */
/*! @param x PIT module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_PIT_REGS(PIT_BASE)</code>. */
#define HW_PIT_REGS(x) (*(hw_pit_t *)(x))

/*
 * MK64F12 PMC
 *
 * Power Management Controller
 *
 * Registers defined in this header file:
 * - HW_PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 * - HW_PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 * - HW_PMC_REGSC - Regulator Status And Control register
 *
 * - hw_pmc_t - Struct containing all module registers.
 */

#define HW_PMC_INSTANCE_COUNT (1U) /*!< Number of instances of the PMC module. */
#define HW_PMC (0U) /*!< Instance number for PMC. */

/*******************************************************************************
 * HW_PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 ******************************************************************************/

/*!
 * @brief HW_PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register (RW)
 *
 * Reset value: 0x10U
 *
 * This register contains status and control bits to support the low voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the LVD system is disabled regardless of LVDSC1 settings. To protect
 * systems that must have LVD always on, configure the Power Mode Protection
 * (PMPROT) register of the SMC module (SMC_PMPROT) to disallow any very low power or
 * low leakage modes from being enabled. See the device's data sheet for the
 * exact LVD trip voltages. The LVDV bits are reset solely on a POR Only event. The
 * register's other bits are reset on Chip Reset Not VLLS. For more information
 * about these reset types, refer to the Reset section details.
 */
typedef union _hw_pmc_lvdsc1
{
    uint8_t U;
    struct _hw_pmc_lvdsc1_bitfields
    {
        uint8_t LVDV : 2;              /*!< [1:0] Low-Voltage Detect Voltage Select */
        uint8_t RESERVED0 : 2;         /*!< [3:2]  */
        uint8_t LVDRE : 1;             /*!< [4] Low-Voltage Detect Reset Enable */
        uint8_t LVDIE : 1;             /*!< [5] Low-Voltage Detect Interrupt Enable */
        uint8_t LVDACK : 1;            /*!< [6] Low-Voltage Detect Acknowledge */
        uint8_t LVDF : 1;              /*!< [7] Low-Voltage Detect Flag */
    } B;
} hw_pmc_lvdsc1_t;

/*!
 * @name Constants and macros for entire PMC_LVDSC1 register
 */
/*@{*/
#define HW_PMC_LVDSC1_ADDR(x)    ((uint32_t)(x) + 0x0U)

#define HW_PMC_LVDSC1(x)         (*(__IO hw_pmc_lvdsc1_t *) HW_PMC_LVDSC1_ADDR(x))
#define HW_PMC_LVDSC1_RD(x)      (HW_PMC_LVDSC1(x).U)
#define HW_PMC_LVDSC1_WR(x, v)   (HW_PMC_LVDSC1(x).U = (v))
#define HW_PMC_LVDSC1_SET(x, v)  (HW_PMC_LVDSC1_WR(x, HW_PMC_LVDSC1_RD(x) |  (v)))
#define HW_PMC_LVDSC1_CLR(x, v)  (HW_PMC_LVDSC1_WR(x, HW_PMC_LVDSC1_RD(x) & ~(v)))
#define HW_PMC_LVDSC1_TOG(x, v)  (HW_PMC_LVDSC1_WR(x, HW_PMC_LVDSC1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC1 bitfields
 */

/*!
 * @name Register PMC_LVDSC1, field LVDV[1:0] (RW)
 *
 * Selects the LVD trip point voltage (V LVD ).
 *
 * Values:
 * - 00 - Low trip point selected (V LVD = V LVDL )
 * - 01 - High trip point selected (V LVD = V LVDH )
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
#define BP_PMC_LVDSC1_LVDV   (0U)          /*!< Bit position for PMC_LVDSC1_LVDV. */
#define BM_PMC_LVDSC1_LVDV   (0x03U)       /*!< Bit mask for PMC_LVDSC1_LVDV. */
#define BS_PMC_LVDSC1_LVDV   (2U)          /*!< Bit field size in bits for PMC_LVDSC1_LVDV. */

/*! @brief Read current value of the PMC_LVDSC1_LVDV field. */
#define BR_PMC_LVDSC1_LVDV(x) (HW_PMC_LVDSC1(x).B.LVDV)

/*! @brief Format value for bitfield PMC_LVDSC1_LVDV. */
#define BF_PMC_LVDSC1_LVDV(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC1_LVDV) & BM_PMC_LVDSC1_LVDV)

/*! @brief Set the LVDV field to a new value. */
#define BW_PMC_LVDSC1_LVDV(x, v) (HW_PMC_LVDSC1_WR(x, (HW_PMC_LVDSC1_RD(x) & ~BM_PMC_LVDSC1_LVDV) | BF_PMC_LVDSC1_LVDV(v)))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDRE[4] (RW)
 *
 * This write-once bit enables LVDF events to generate a hardware reset.
 * Additional writes are ignored.
 *
 * Values:
 * - 0 - LVDF does not generate hardware resets
 * - 1 - Force an MCU reset when LVDF = 1
 */
/*@{*/
#define BP_PMC_LVDSC1_LVDRE  (4U)          /*!< Bit position for PMC_LVDSC1_LVDRE. */
#define BM_PMC_LVDSC1_LVDRE  (0x10U)       /*!< Bit mask for PMC_LVDSC1_LVDRE. */
#define BS_PMC_LVDSC1_LVDRE  (1U)          /*!< Bit field size in bits for PMC_LVDSC1_LVDRE. */

/*! @brief Read current value of the PMC_LVDSC1_LVDRE field. */
#define BR_PMC_LVDSC1_LVDRE(x) (BITBAND_ACCESS8(HW_PMC_LVDSC1_ADDR(x), BP_PMC_LVDSC1_LVDRE))

/*! @brief Format value for bitfield PMC_LVDSC1_LVDRE. */
#define BF_PMC_LVDSC1_LVDRE(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC1_LVDRE) & BM_PMC_LVDSC1_LVDRE)

/*! @brief Set the LVDRE field to a new value. */
#define BW_PMC_LVDSC1_LVDRE(x, v) (BITBAND_ACCESS8(HW_PMC_LVDSC1_ADDR(x), BP_PMC_LVDSC1_LVDRE) = (v))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVDF.
 *
 * Values:
 * - 0 - Hardware interrupt disabled (use polling)
 * - 1 - Request a hardware interrupt when LVDF = 1
 */
/*@{*/
#define BP_PMC_LVDSC1_LVDIE  (5U)          /*!< Bit position for PMC_LVDSC1_LVDIE. */
#define BM_PMC_LVDSC1_LVDIE  (0x20U)       /*!< Bit mask for PMC_LVDSC1_LVDIE. */
#define BS_PMC_LVDSC1_LVDIE  (1U)          /*!< Bit field size in bits for PMC_LVDSC1_LVDIE. */

/*! @brief Read current value of the PMC_LVDSC1_LVDIE field. */
#define BR_PMC_LVDSC1_LVDIE(x) (BITBAND_ACCESS8(HW_PMC_LVDSC1_ADDR(x), BP_PMC_LVDSC1_LVDIE))

/*! @brief Format value for bitfield PMC_LVDSC1_LVDIE. */
#define BF_PMC_LVDSC1_LVDIE(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC1_LVDIE) & BM_PMC_LVDSC1_LVDIE)

/*! @brief Set the LVDIE field to a new value. */
#define BW_PMC_LVDSC1_LVDIE(x, v) (BITBAND_ACCESS8(HW_PMC_LVDSC1_ADDR(x), BP_PMC_LVDSC1_LVDIE) = (v))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage detection errors.
 * Write 1 to clear LVDF. Reads always return 0.
 */
/*@{*/
#define BP_PMC_LVDSC1_LVDACK (6U)          /*!< Bit position for PMC_LVDSC1_LVDACK. */
#define BM_PMC_LVDSC1_LVDACK (0x40U)       /*!< Bit mask for PMC_LVDSC1_LVDACK. */
#define BS_PMC_LVDSC1_LVDACK (1U)          /*!< Bit field size in bits for PMC_LVDSC1_LVDACK. */

/*! @brief Format value for bitfield PMC_LVDSC1_LVDACK. */
#define BF_PMC_LVDSC1_LVDACK(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC1_LVDACK) & BM_PMC_LVDSC1_LVDACK)

/*! @brief Set the LVDACK field to a new value. */
#define BW_PMC_LVDSC1_LVDACK(x, v) (BITBAND_ACCESS8(HW_PMC_LVDSC1_ADDR(x), BP_PMC_LVDSC1_LVDACK) = (v))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDF[7] (RO)
 *
 * This read-only status field indicates a low-voltage detect event.
 *
 * Values:
 * - 0 - Low-voltage event not detected
 * - 1 - Low-voltage event detected
 */
/*@{*/
#define BP_PMC_LVDSC1_LVDF   (7U)          /*!< Bit position for PMC_LVDSC1_LVDF. */
#define BM_PMC_LVDSC1_LVDF   (0x80U)       /*!< Bit mask for PMC_LVDSC1_LVDF. */
#define BS_PMC_LVDSC1_LVDF   (1U)          /*!< Bit field size in bits for PMC_LVDSC1_LVDF. */

/*! @brief Read current value of the PMC_LVDSC1_LVDF field. */
#define BR_PMC_LVDSC1_LVDF(x) (BITBAND_ACCESS8(HW_PMC_LVDSC1_ADDR(x), BP_PMC_LVDSC1_LVDF))
/*@}*/

/*******************************************************************************
 * HW_PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 ******************************************************************************/

/*!
 * @brief HW_PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains status and control bits to support the low voltage
 * warning function. While the device is in the very low power or low leakage modes,
 * the LVD system is disabled regardless of LVDSC2 settings. See the device's
 * data sheet for the exact LVD trip voltages. The LVW trip voltages depend on LVWV
 * and LVDV. LVWV is reset solely on a POR Only event. The other fields of the
 * register are reset on Chip Reset Not VLLS. For more information about these
 * reset types, refer to the Reset section details.
 */
typedef union _hw_pmc_lvdsc2
{
    uint8_t U;
    struct _hw_pmc_lvdsc2_bitfields
    {
        uint8_t LVWV : 2;              /*!< [1:0] Low-Voltage Warning Voltage Select */
        uint8_t RESERVED0 : 3;         /*!< [4:2]  */
        uint8_t LVWIE : 1;             /*!< [5] Low-Voltage Warning Interrupt Enable */
        uint8_t LVWACK : 1;            /*!< [6] Low-Voltage Warning Acknowledge */
        uint8_t LVWF : 1;              /*!< [7] Low-Voltage Warning Flag */
    } B;
} hw_pmc_lvdsc2_t;

/*!
 * @name Constants and macros for entire PMC_LVDSC2 register
 */
/*@{*/
#define HW_PMC_LVDSC2_ADDR(x)    ((uint32_t)(x) + 0x1U)

#define HW_PMC_LVDSC2(x)         (*(__IO hw_pmc_lvdsc2_t *) HW_PMC_LVDSC2_ADDR(x))
#define HW_PMC_LVDSC2_RD(x)      (HW_PMC_LVDSC2(x).U)
#define HW_PMC_LVDSC2_WR(x, v)   (HW_PMC_LVDSC2(x).U = (v))
#define HW_PMC_LVDSC2_SET(x, v)  (HW_PMC_LVDSC2_WR(x, HW_PMC_LVDSC2_RD(x) |  (v)))
#define HW_PMC_LVDSC2_CLR(x, v)  (HW_PMC_LVDSC2_WR(x, HW_PMC_LVDSC2_RD(x) & ~(v)))
#define HW_PMC_LVDSC2_TOG(x, v)  (HW_PMC_LVDSC2_WR(x, HW_PMC_LVDSC2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC2 bitfields
 */

/*!
 * @name Register PMC_LVDSC2, field LVWV[1:0] (RW)
 *
 * Selects the LVW trip point voltage (VLVW). The actual voltage for the warning
 * depends on LVDSC1[LVDV].
 *
 * Values:
 * - 00 - Low trip point selected (VLVW = VLVW1)
 * - 01 - Mid 1 trip point selected (VLVW = VLVW2)
 * - 10 - Mid 2 trip point selected (VLVW = VLVW3)
 * - 11 - High trip point selected (VLVW = VLVW4)
 */
/*@{*/
#define BP_PMC_LVDSC2_LVWV   (0U)          /*!< Bit position for PMC_LVDSC2_LVWV. */
#define BM_PMC_LVDSC2_LVWV   (0x03U)       /*!< Bit mask for PMC_LVDSC2_LVWV. */
#define BS_PMC_LVDSC2_LVWV   (2U)          /*!< Bit field size in bits for PMC_LVDSC2_LVWV. */

/*! @brief Read current value of the PMC_LVDSC2_LVWV field. */
#define BR_PMC_LVDSC2_LVWV(x) (HW_PMC_LVDSC2(x).B.LVWV)

/*! @brief Format value for bitfield PMC_LVDSC2_LVWV. */
#define BF_PMC_LVDSC2_LVWV(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC2_LVWV) & BM_PMC_LVDSC2_LVWV)

/*! @brief Set the LVWV field to a new value. */
#define BW_PMC_LVDSC2_LVWV(x, v) (HW_PMC_LVDSC2_WR(x, (HW_PMC_LVDSC2_RD(x) & ~BM_PMC_LVDSC2_LVWV) | BF_PMC_LVDSC2_LVWV(v)))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVWF.
 *
 * Values:
 * - 0 - Hardware interrupt disabled (use polling)
 * - 1 - Request a hardware interrupt when LVWF = 1
 */
/*@{*/
#define BP_PMC_LVDSC2_LVWIE  (5U)          /*!< Bit position for PMC_LVDSC2_LVWIE. */
#define BM_PMC_LVDSC2_LVWIE  (0x20U)       /*!< Bit mask for PMC_LVDSC2_LVWIE. */
#define BS_PMC_LVDSC2_LVWIE  (1U)          /*!< Bit field size in bits for PMC_LVDSC2_LVWIE. */

/*! @brief Read current value of the PMC_LVDSC2_LVWIE field. */
#define BR_PMC_LVDSC2_LVWIE(x) (BITBAND_ACCESS8(HW_PMC_LVDSC2_ADDR(x), BP_PMC_LVDSC2_LVWIE))

/*! @brief Format value for bitfield PMC_LVDSC2_LVWIE. */
#define BF_PMC_LVDSC2_LVWIE(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC2_LVWIE) & BM_PMC_LVDSC2_LVWIE)

/*! @brief Set the LVWIE field to a new value. */
#define BW_PMC_LVDSC2_LVWIE(x, v) (BITBAND_ACCESS8(HW_PMC_LVDSC2_ADDR(x), BP_PMC_LVDSC2_LVWIE) = (v))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage warning errors.
 * Write 1 to clear LVWF. Reads always return 0.
 */
/*@{*/
#define BP_PMC_LVDSC2_LVWACK (6U)          /*!< Bit position for PMC_LVDSC2_LVWACK. */
#define BM_PMC_LVDSC2_LVWACK (0x40U)       /*!< Bit mask for PMC_LVDSC2_LVWACK. */
#define BS_PMC_LVDSC2_LVWACK (1U)          /*!< Bit field size in bits for PMC_LVDSC2_LVWACK. */

/*! @brief Format value for bitfield PMC_LVDSC2_LVWACK. */
#define BF_PMC_LVDSC2_LVWACK(v) ((uint8_t)((uint8_t)(v) << BP_PMC_LVDSC2_LVWACK) & BM_PMC_LVDSC2_LVWACK)

/*! @brief Set the LVWACK field to a new value. */
#define BW_PMC_LVDSC2_LVWACK(x, v) (BITBAND_ACCESS8(HW_PMC_LVDSC2_ADDR(x), BP_PMC_LVDSC2_LVWACK) = (v))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWF[7] (RO)
 *
 * This read-only status field indicates a low-voltage warning event. LVWF is
 * set when VSupply transitions below the trip point, or after reset and VSupply is
 * already below VLVW. LVWF may be 1 after power-on reset, therefore, to use LVW
 * interrupt function, before enabling LVWIE, LVWF must be cleared by writing
 * LVWACK first.
 *
 * Values:
 * - 0 - Low-voltage warning event not detected
 * - 1 - Low-voltage warning event detected
 */
/*@{*/
#define BP_PMC_LVDSC2_LVWF   (7U)          /*!< Bit position for PMC_LVDSC2_LVWF. */
#define BM_PMC_LVDSC2_LVWF   (0x80U)       /*!< Bit mask for PMC_LVDSC2_LVWF. */
#define BS_PMC_LVDSC2_LVWF   (1U)          /*!< Bit field size in bits for PMC_LVDSC2_LVWF. */

/*! @brief Read current value of the PMC_LVDSC2_LVWF field. */
#define BR_PMC_LVDSC2_LVWF(x) (BITBAND_ACCESS8(HW_PMC_LVDSC2_ADDR(x), BP_PMC_LVDSC2_LVWF))
/*@}*/

/*******************************************************************************
 * HW_PMC_REGSC - Regulator Status And Control register
 ******************************************************************************/

/*!
 * @brief HW_PMC_REGSC - Regulator Status And Control register (RW)
 *
 * Reset value: 0x04U
 *
 * The PMC contains an internal voltage regulator. The voltage regulator design
 * uses a bandgap reference that is also available through a buffer as input to
 * certain internal peripherals, such as the CMP and ADC. The internal regulator
 * provides a status bit (REGONS) indicating the regulator is in run regulation.
 * This register is reset on Chip Reset Not VLLS and by reset types that trigger
 * Chip Reset not VLLS. See the Reset section details for more information.
 */
typedef union _hw_pmc_regsc
{
    uint8_t U;
    struct _hw_pmc_regsc_bitfields
    {
        uint8_t BGBE : 1;              /*!< [0] Bandgap Buffer Enable */
        uint8_t RESERVED0 : 1;         /*!< [1]  */
        uint8_t REGONS : 1;            /*!< [2] Regulator In Run Regulation Status */
        uint8_t ACKISO : 1;            /*!< [3] Acknowledge Isolation */
        uint8_t BGEN : 1;              /*!< [4] Bandgap Enable In VLPx Operation */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_pmc_regsc_t;

/*!
 * @name Constants and macros for entire PMC_REGSC register
 */
/*@{*/
#define HW_PMC_REGSC_ADDR(x)     ((uint32_t)(x) + 0x2U)

#define HW_PMC_REGSC(x)          (*(__IO hw_pmc_regsc_t *) HW_PMC_REGSC_ADDR(x))
#define HW_PMC_REGSC_RD(x)       (HW_PMC_REGSC(x).U)
#define HW_PMC_REGSC_WR(x, v)    (HW_PMC_REGSC(x).U = (v))
#define HW_PMC_REGSC_SET(x, v)   (HW_PMC_REGSC_WR(x, HW_PMC_REGSC_RD(x) |  (v)))
#define HW_PMC_REGSC_CLR(x, v)   (HW_PMC_REGSC_WR(x, HW_PMC_REGSC_RD(x) & ~(v)))
#define HW_PMC_REGSC_TOG(x, v)   (HW_PMC_REGSC_WR(x, HW_PMC_REGSC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PMC_REGSC bitfields
 */

/*!
 * @name Register PMC_REGSC, field BGBE[0] (RW)
 *
 * Enables the bandgap buffer.
 *
 * Values:
 * - 0 - Bandgap buffer not enabled
 * - 1 - Bandgap buffer enabled
 */
/*@{*/
#define BP_PMC_REGSC_BGBE    (0U)          /*!< Bit position for PMC_REGSC_BGBE. */
#define BM_PMC_REGSC_BGBE    (0x01U)       /*!< Bit mask for PMC_REGSC_BGBE. */
#define BS_PMC_REGSC_BGBE    (1U)          /*!< Bit field size in bits for PMC_REGSC_BGBE. */

/*! @brief Read current value of the PMC_REGSC_BGBE field. */
#define BR_PMC_REGSC_BGBE(x) (BITBAND_ACCESS8(HW_PMC_REGSC_ADDR(x), BP_PMC_REGSC_BGBE))

/*! @brief Format value for bitfield PMC_REGSC_BGBE. */
#define BF_PMC_REGSC_BGBE(v) ((uint8_t)((uint8_t)(v) << BP_PMC_REGSC_BGBE) & BM_PMC_REGSC_BGBE)

/*! @brief Set the BGBE field to a new value. */
#define BW_PMC_REGSC_BGBE(x, v) (BITBAND_ACCESS8(HW_PMC_REGSC_ADDR(x), BP_PMC_REGSC_BGBE) = (v))
/*@}*/

/*!
 * @name Register PMC_REGSC, field REGONS[2] (RO)
 *
 * This read-only field provides the current status of the internal voltage
 * regulator.
 *
 * Values:
 * - 0 - Regulator is in stop regulation or in transition to/from it
 * - 1 - Regulator is in run regulation
 */
/*@{*/
#define BP_PMC_REGSC_REGONS  (2U)          /*!< Bit position for PMC_REGSC_REGONS. */
#define BM_PMC_REGSC_REGONS  (0x04U)       /*!< Bit mask for PMC_REGSC_REGONS. */
#define BS_PMC_REGSC_REGONS  (1U)          /*!< Bit field size in bits for PMC_REGSC_REGONS. */

/*! @brief Read current value of the PMC_REGSC_REGONS field. */
#define BR_PMC_REGSC_REGONS(x) (BITBAND_ACCESS8(HW_PMC_REGSC_ADDR(x), BP_PMC_REGSC_REGONS))
/*@}*/

/*!
 * @name Register PMC_REGSC, field ACKISO[3] (W1C)
 *
 * Reading this field indicates whether certain peripherals and the I/O pads are
 * in a latched state as a result of having been in a VLLS mode. Writing 1 to
 * this field when it is set releases the I/O pads and certain peripherals to their
 * normal run mode state. After recovering from a VLLS mode, user should restore
 * chip configuration before clearing ACKISO. In particular, pin configuration
 * for enabled LLWU wakeup pins should be restored to avoid any LLWU flag from
 * being falsely set when ACKISO is cleared.
 *
 * Values:
 * - 0 - Peripherals and I/O pads are in normal run state.
 * - 1 - Certain peripherals and I/O pads are in an isolated and latched state.
 */
/*@{*/
#define BP_PMC_REGSC_ACKISO  (3U)          /*!< Bit position for PMC_REGSC_ACKISO. */
#define BM_PMC_REGSC_ACKISO  (0x08U)       /*!< Bit mask for PMC_REGSC_ACKISO. */
#define BS_PMC_REGSC_ACKISO  (1U)          /*!< Bit field size in bits for PMC_REGSC_ACKISO. */

/*! @brief Read current value of the PMC_REGSC_ACKISO field. */
#define BR_PMC_REGSC_ACKISO(x) (BITBAND_ACCESS8(HW_PMC_REGSC_ADDR(x), BP_PMC_REGSC_ACKISO))

/*! @brief Format value for bitfield PMC_REGSC_ACKISO. */
#define BF_PMC_REGSC_ACKISO(v) ((uint8_t)((uint8_t)(v) << BP_PMC_REGSC_ACKISO) & BM_PMC_REGSC_ACKISO)

/*! @brief Set the ACKISO field to a new value. */
#define BW_PMC_REGSC_ACKISO(x, v) (BITBAND_ACCESS8(HW_PMC_REGSC_ADDR(x), BP_PMC_REGSC_ACKISO) = (v))
/*@}*/

/*!
 * @name Register PMC_REGSC, field BGEN[4] (RW)
 *
 * BGEN controls whether the bandgap is enabled in lower power modes of
 * operation (VLPx, LLS, and VLLSx). When on-chip peripherals require the bandgap voltage
 * reference in low power modes of operation, set BGEN to continue to enable the
 * bandgap operation. When the bandgap voltage reference is not needed in low
 * power modes, clear BGEN to avoid excess power consumption.
 *
 * Values:
 * - 0 - Bandgap voltage reference is disabled in VLPx , LLS , and VLLSx modes.
 * - 1 - Bandgap voltage reference is enabled in VLPx , LLS , and VLLSx modes.
 */
/*@{*/
#define BP_PMC_REGSC_BGEN    (4U)          /*!< Bit position for PMC_REGSC_BGEN. */
#define BM_PMC_REGSC_BGEN    (0x10U)       /*!< Bit mask for PMC_REGSC_BGEN. */
#define BS_PMC_REGSC_BGEN    (1U)          /*!< Bit field size in bits for PMC_REGSC_BGEN. */

/*! @brief Read current value of the PMC_REGSC_BGEN field. */
#define BR_PMC_REGSC_BGEN(x) (BITBAND_ACCESS8(HW_PMC_REGSC_ADDR(x), BP_PMC_REGSC_BGEN))

/*! @brief Format value for bitfield PMC_REGSC_BGEN. */
#define BF_PMC_REGSC_BGEN(v) ((uint8_t)((uint8_t)(v) << BP_PMC_REGSC_BGEN) & BM_PMC_REGSC_BGEN)

/*! @brief Set the BGEN field to a new value. */
#define BW_PMC_REGSC_BGEN(x, v) (BITBAND_ACCESS8(HW_PMC_REGSC_ADDR(x), BP_PMC_REGSC_BGEN) = (v))
/*@}*/

/*******************************************************************************
 * hw_pmc_t - module struct
 ******************************************************************************/
/*!
 * @brief All PMC module registers.
 */
#pragma pack(1)
typedef struct _hw_pmc
{
    __IO hw_pmc_lvdsc1_t LVDSC1;           /*!< [0x0] Low Voltage Detect Status And Control 1 register */
    __IO hw_pmc_lvdsc2_t LVDSC2;           /*!< [0x1] Low Voltage Detect Status And Control 2 register */
    __IO hw_pmc_regsc_t REGSC;             /*!< [0x2] Regulator Status And Control register */
} hw_pmc_t;
#pragma pack()

/*! @brief Macro to access all PMC registers. */
/*! @param x PMC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_PMC_REGS(PMC_BASE)</code>. */
#define HW_PMC_REGS(x) (*(hw_pmc_t *)(x))

/*
 * MK64F12 PORT
 *
 * Pin Control and Interrupts
 *
 * Registers defined in this header file:
 * - HW_PORT_PCRn - Pin Control Register n
 * - HW_PORT_GPCLR - Global Pin Control Low Register
 * - HW_PORT_GPCHR - Global Pin Control High Register
 * - HW_PORT_ISFR - Interrupt Status Flag Register
 * - HW_PORT_DFER - Digital Filter Enable Register
 * - HW_PORT_DFCR - Digital Filter Clock Register
 * - HW_PORT_DFWR - Digital Filter Width Register
 *
 * - hw_port_t - Struct containing all module registers.
 */

#define HW_PORT_INSTANCE_COUNT (5U) /*!< Number of instances of the PORT module. */
#define HW_PORTA (0U) /*!< Instance number for PORTA. */
#define HW_PORTB (1U) /*!< Instance number for PORTB. */
#define HW_PORTC (2U) /*!< Instance number for PORTC. */
#define HW_PORTD (3U) /*!< Instance number for PORTD. */
#define HW_PORTE (4U) /*!< Instance number for PORTE. */

/*******************************************************************************
 * HW_PORT_PCRn - Pin Control Register n
 ******************************************************************************/

/*!
 * @brief HW_PORT_PCRn - Pin Control Register n (RW)
 *
 * Reset value: 0x00000746U
 *
 * See the Signal Multiplexing and Pin Assignment chapter for the reset value of
 * this device. See the GPIO Configuration section for details on the available
 * functions for each pin. Do not modify pin configuration registers associated
 * with pins not available in your selected package. All unbonded pins not
 * available in your package will default to DISABLE state for lowest power consumption.
 */
typedef union _hw_port_pcrn
{
    uint32_t U;
    struct _hw_port_pcrn_bitfields
    {
        uint32_t PS : 1;               /*!< [0] Pull Select */
        uint32_t PE : 1;               /*!< [1] Pull Enable */
        uint32_t SRE : 1;              /*!< [2] Slew Rate Enable */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t PFE : 1;              /*!< [4] Passive Filter Enable */
        uint32_t ODE : 1;              /*!< [5] Open Drain Enable */
        uint32_t DSE : 1;              /*!< [6] Drive Strength Enable */
        uint32_t RESERVED1 : 1;        /*!< [7]  */
        uint32_t MUX : 3;              /*!< [10:8] Pin Mux Control */
        uint32_t RESERVED2 : 4;        /*!< [14:11]  */
        uint32_t LK : 1;               /*!< [15] Lock Register */
        uint32_t IRQC : 4;             /*!< [19:16] Interrupt Configuration */
        uint32_t RESERVED3 : 4;        /*!< [23:20]  */
        uint32_t ISF : 1;              /*!< [24] Interrupt Status Flag */
        uint32_t RESERVED4 : 7;        /*!< [31:25]  */
    } B;
} hw_port_pcrn_t;

/*!
 * @name Constants and macros for entire PORT_PCRn register
 */
/*@{*/
#define HW_PORT_PCRn_COUNT (32U)

#define HW_PORT_PCRn_ADDR(x, n)  ((uint32_t)(x) + 0x0U + (0x4U * (n)))

#define HW_PORT_PCRn(x, n)       (*(__IO hw_port_pcrn_t *) HW_PORT_PCRn_ADDR(x, n))
#define HW_PORT_PCRn_RD(x, n)    (HW_PORT_PCRn(x, n).U)
#define HW_PORT_PCRn_WR(x, n, v) (HW_PORT_PCRn(x, n).U = (v))
#define HW_PORT_PCRn_SET(x, n, v) (HW_PORT_PCRn_WR(x, n, HW_PORT_PCRn_RD(x, n) |  (v)))
#define HW_PORT_PCRn_CLR(x, n, v) (HW_PORT_PCRn_WR(x, n, HW_PORT_PCRn_RD(x, n) & ~(v)))
#define HW_PORT_PCRn_TOG(x, n, v) (HW_PORT_PCRn_WR(x, n, HW_PORT_PCRn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PORT_PCRn bitfields
 */

/*!
 * @name Register PORT_PCRn, field PS[0] (RW)
 *
 * Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Internal pulldown resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 * - 1 - Internal pullup resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 */
/*@{*/
#define BP_PORT_PCRn_PS      (0U)          /*!< Bit position for PORT_PCRn_PS. */
#define BM_PORT_PCRn_PS      (0x00000001U) /*!< Bit mask for PORT_PCRn_PS. */
#define BS_PORT_PCRn_PS      (1U)          /*!< Bit field size in bits for PORT_PCRn_PS. */

/*! @brief Read current value of the PORT_PCRn_PS field. */
#define BR_PORT_PCRn_PS(x, n) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_PS))

/*! @brief Format value for bitfield PORT_PCRn_PS. */
#define BF_PORT_PCRn_PS(v)   ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_PS) & BM_PORT_PCRn_PS)

/*! @brief Set the PS field to a new value. */
#define BW_PORT_PCRn_PS(x, n, v) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_PS) = (v))
/*@}*/

/*!
 * @name Register PORT_PCRn, field PE[1] (RW)
 *
 * Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Internal pullup or pulldown resistor is not enabled on the
 *     corresponding pin.
 * - 1 - Internal pullup or pulldown resistor is enabled on the corresponding
 *     pin, if the pin is configured as a digital input.
 */
/*@{*/
#define BP_PORT_PCRn_PE      (1U)          /*!< Bit position for PORT_PCRn_PE. */
#define BM_PORT_PCRn_PE      (0x00000002U) /*!< Bit mask for PORT_PCRn_PE. */
#define BS_PORT_PCRn_PE      (1U)          /*!< Bit field size in bits for PORT_PCRn_PE. */

/*! @brief Read current value of the PORT_PCRn_PE field. */
#define BR_PORT_PCRn_PE(x, n) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_PE))

/*! @brief Format value for bitfield PORT_PCRn_PE. */
#define BF_PORT_PCRn_PE(v)   ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_PE) & BM_PORT_PCRn_PE)

/*! @brief Set the PE field to a new value. */
#define BW_PORT_PCRn_PE(x, n, v) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_PE) = (v))
/*@}*/

/*!
 * @name Register PORT_PCRn, field SRE[2] (RW)
 *
 * Slew rate configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Fast slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 * - 1 - Slow slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
#define BP_PORT_PCRn_SRE     (2U)          /*!< Bit position for PORT_PCRn_SRE. */
#define BM_PORT_PCRn_SRE     (0x00000004U) /*!< Bit mask for PORT_PCRn_SRE. */
#define BS_PORT_PCRn_SRE     (1U)          /*!< Bit field size in bits for PORT_PCRn_SRE. */

/*! @brief Read current value of the PORT_PCRn_SRE field. */
#define BR_PORT_PCRn_SRE(x, n) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_SRE))

/*! @brief Format value for bitfield PORT_PCRn_SRE. */
#define BF_PORT_PCRn_SRE(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_SRE) & BM_PORT_PCRn_SRE)

/*! @brief Set the SRE field to a new value. */
#define BW_PORT_PCRn_SRE(x, n, v) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_SRE) = (v))
/*@}*/

/*!
 * @name Register PORT_PCRn, field PFE[4] (RW)
 *
 * Passive filter configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Passive input filter is disabled on the corresponding pin.
 * - 1 - Passive input filter is enabled on the corresponding pin, if the pin is
 *     configured as a digital input. Refer to the device data sheet for filter
 *     characteristics.
 */
/*@{*/
#define BP_PORT_PCRn_PFE     (4U)          /*!< Bit position for PORT_PCRn_PFE. */
#define BM_PORT_PCRn_PFE     (0x00000010U) /*!< Bit mask for PORT_PCRn_PFE. */
#define BS_PORT_PCRn_PFE     (1U)          /*!< Bit field size in bits for PORT_PCRn_PFE. */

/*! @brief Read current value of the PORT_PCRn_PFE field. */
#define BR_PORT_PCRn_PFE(x, n) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_PFE))

/*! @brief Format value for bitfield PORT_PCRn_PFE. */
#define BF_PORT_PCRn_PFE(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_PFE) & BM_PORT_PCRn_PFE)

/*! @brief Set the PFE field to a new value. */
#define BW_PORT_PCRn_PFE(x, n, v) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_PFE) = (v))
/*@}*/

/*!
 * @name Register PORT_PCRn, field ODE[5] (RW)
 *
 * Open drain configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Open drain output is disabled on the corresponding pin.
 * - 1 - Open drain output is enabled on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
#define BP_PORT_PCRn_ODE     (5U)          /*!< Bit position for PORT_PCRn_ODE. */
#define BM_PORT_PCRn_ODE     (0x00000020U) /*!< Bit mask for PORT_PCRn_ODE. */
#define BS_PORT_PCRn_ODE     (1U)          /*!< Bit field size in bits for PORT_PCRn_ODE. */

/*! @brief Read current value of the PORT_PCRn_ODE field. */
#define BR_PORT_PCRn_ODE(x, n) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_ODE))

/*! @brief Format value for bitfield PORT_PCRn_ODE. */
#define BF_PORT_PCRn_ODE(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_ODE) & BM_PORT_PCRn_ODE)

/*! @brief Set the ODE field to a new value. */
#define BW_PORT_PCRn_ODE(x, n, v) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_ODE) = (v))
/*@}*/

/*!
 * @name Register PORT_PCRn, field DSE[6] (RW)
 *
 * Drive strength configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Low drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 * - 1 - High drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 */
/*@{*/
#define BP_PORT_PCRn_DSE     (6U)          /*!< Bit position for PORT_PCRn_DSE. */
#define BM_PORT_PCRn_DSE     (0x00000040U) /*!< Bit mask for PORT_PCRn_DSE. */
#define BS_PORT_PCRn_DSE     (1U)          /*!< Bit field size in bits for PORT_PCRn_DSE. */

/*! @brief Read current value of the PORT_PCRn_DSE field. */
#define BR_PORT_PCRn_DSE(x, n) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_DSE))

/*! @brief Format value for bitfield PORT_PCRn_DSE. */
#define BF_PORT_PCRn_DSE(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_DSE) & BM_PORT_PCRn_DSE)

/*! @brief Set the DSE field to a new value. */
#define BW_PORT_PCRn_DSE(x, n, v) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_DSE) = (v))
/*@}*/

/*!
 * @name Register PORT_PCRn, field MUX[10:8] (RW)
 *
 * Not all pins support all pin muxing slots. Unimplemented pin muxing slots are
 * reserved and may result in configuring the pin for a different pin muxing
 * slot. The corresponding pin is configured in the following pin muxing slot as
 * follows:
 *
 * Values:
 * - 000 - Pin disabled (analog).
 * - 001 - Alternative 1 (GPIO).
 * - 010 - Alternative 2 (chip-specific).
 * - 011 - Alternative 3 (chip-specific).
 * - 100 - Alternative 4 (chip-specific).
 * - 101 - Alternative 5 (chip-specific).
 * - 110 - Alternative 6 (chip-specific).
 * - 111 - Alternative 7 (chip-specific).
 */
/*@{*/
#define BP_PORT_PCRn_MUX     (8U)          /*!< Bit position for PORT_PCRn_MUX. */
#define BM_PORT_PCRn_MUX     (0x00000700U) /*!< Bit mask for PORT_PCRn_MUX. */
#define BS_PORT_PCRn_MUX     (3U)          /*!< Bit field size in bits for PORT_PCRn_MUX. */

/*! @brief Read current value of the PORT_PCRn_MUX field. */
#define BR_PORT_PCRn_MUX(x, n) (HW_PORT_PCRn(x, n).B.MUX)

/*! @brief Format value for bitfield PORT_PCRn_MUX. */
#define BF_PORT_PCRn_MUX(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_MUX) & BM_PORT_PCRn_MUX)

/*! @brief Set the MUX field to a new value. */
#define BW_PORT_PCRn_MUX(x, n, v) (HW_PORT_PCRn_WR(x, n, (HW_PORT_PCRn_RD(x, n) & ~BM_PORT_PCRn_MUX) | BF_PORT_PCRn_MUX(v)))
/*@}*/

/*!
 * @name Register PORT_PCRn, field LK[15] (RW)
 *
 * Values:
 * - 0 - Pin Control Register fields [15:0] are not locked.
 * - 1 - Pin Control Register fields [15:0] are locked and cannot be updated
 *     until the next system reset.
 */
/*@{*/
#define BP_PORT_PCRn_LK      (15U)         /*!< Bit position for PORT_PCRn_LK. */
#define BM_PORT_PCRn_LK      (0x00008000U) /*!< Bit mask for PORT_PCRn_LK. */
#define BS_PORT_PCRn_LK      (1U)          /*!< Bit field size in bits for PORT_PCRn_LK. */

/*! @brief Read current value of the PORT_PCRn_LK field. */
#define BR_PORT_PCRn_LK(x, n) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_LK))

/*! @brief Format value for bitfield PORT_PCRn_LK. */
#define BF_PORT_PCRn_LK(v)   ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_LK) & BM_PORT_PCRn_LK)

/*! @brief Set the LK field to a new value. */
#define BW_PORT_PCRn_LK(x, n, v) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_LK) = (v))
/*@}*/

/*!
 * @name Register PORT_PCRn, field IRQC[19:16] (RW)
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * corresponding pin is configured to generate interrupt/DMA request as follows:
 *
 * Values:
 * - 0000 - Interrupt/DMA request disabled.
 * - 0001 - DMA request on rising edge.
 * - 0010 - DMA request on falling edge.
 * - 0011 - DMA request on either edge.
 * - 1000 - Interrupt when logic 0.
 * - 1001 - Interrupt on rising-edge.
 * - 1010 - Interrupt on falling-edge.
 * - 1011 - Interrupt on either edge.
 * - 1100 - Interrupt when logic 1.
 */
/*@{*/
#define BP_PORT_PCRn_IRQC    (16U)         /*!< Bit position for PORT_PCRn_IRQC. */
#define BM_PORT_PCRn_IRQC    (0x000F0000U) /*!< Bit mask for PORT_PCRn_IRQC. */
#define BS_PORT_PCRn_IRQC    (4U)          /*!< Bit field size in bits for PORT_PCRn_IRQC. */

/*! @brief Read current value of the PORT_PCRn_IRQC field. */
#define BR_PORT_PCRn_IRQC(x, n) (HW_PORT_PCRn(x, n).B.IRQC)

/*! @brief Format value for bitfield PORT_PCRn_IRQC. */
#define BF_PORT_PCRn_IRQC(v) ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_IRQC) & BM_PORT_PCRn_IRQC)

/*! @brief Set the IRQC field to a new value. */
#define BW_PORT_PCRn_IRQC(x, n, v) (HW_PORT_PCRn_WR(x, n, (HW_PORT_PCRn_RD(x, n) & ~BM_PORT_PCRn_IRQC) | BF_PORT_PCRn_IRQC(v)))
/*@}*/

/*!
 * @name Register PORT_PCRn, field ISF[24] (W1C)
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Configured interrupt is not detected.
 * - 1 - Configured interrupt is detected. If the pin is configured to generate
 *     a DMA request, then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer. Otherwise, the flag
 *     remains set until a logic 1 is written to the flag. If the pin is configured for
 *     a level sensitive interrupt and the pin remains asserted, then the flag
 *     is set again immediately after it is cleared.
 */
/*@{*/
#define BP_PORT_PCRn_ISF     (24U)         /*!< Bit position for PORT_PCRn_ISF. */
#define BM_PORT_PCRn_ISF     (0x01000000U) /*!< Bit mask for PORT_PCRn_ISF. */
#define BS_PORT_PCRn_ISF     (1U)          /*!< Bit field size in bits for PORT_PCRn_ISF. */

/*! @brief Read current value of the PORT_PCRn_ISF field. */
#define BR_PORT_PCRn_ISF(x, n) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_ISF))

/*! @brief Format value for bitfield PORT_PCRn_ISF. */
#define BF_PORT_PCRn_ISF(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_PCRn_ISF) & BM_PORT_PCRn_ISF)

/*! @brief Set the ISF field to a new value. */
#define BW_PORT_PCRn_ISF(x, n, v) (BITBAND_ACCESS32(HW_PORT_PCRn_ADDR(x, n), BP_PORT_PCRn_ISF) = (v))
/*@}*/

/*******************************************************************************
 * HW_PORT_GPCLR - Global Pin Control Low Register
 ******************************************************************************/

/*!
 * @brief HW_PORT_GPCLR - Global Pin Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
typedef union _hw_port_gpclr
{
    uint32_t U;
    struct _hw_port_gpclr_bitfields
    {
        uint32_t GPWD : 16;            /*!< [15:0] Global Pin Write Data */
        uint32_t GPWE : 16;            /*!< [31:16] Global Pin Write Enable */
    } B;
} hw_port_gpclr_t;

/*!
 * @name Constants and macros for entire PORT_GPCLR register
 */
/*@{*/
#define HW_PORT_GPCLR_ADDR(x)    ((uint32_t)(x) + 0x80U)

#define HW_PORT_GPCLR(x)         (*(__O hw_port_gpclr_t *) HW_PORT_GPCLR_ADDR(x))
#define HW_PORT_GPCLR_RD(x)      (HW_PORT_GPCLR(x).U)
#define HW_PORT_GPCLR_WR(x, v)   (HW_PORT_GPCLR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCLR bitfields
 */

/*!
 * @name Register PORT_GPCLR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
#define BP_PORT_GPCLR_GPWD   (0U)          /*!< Bit position for PORT_GPCLR_GPWD. */
#define BM_PORT_GPCLR_GPWD   (0x0000FFFFU) /*!< Bit mask for PORT_GPCLR_GPWD. */
#define BS_PORT_GPCLR_GPWD   (16U)         /*!< Bit field size in bits for PORT_GPCLR_GPWD. */

/*! @brief Format value for bitfield PORT_GPCLR_GPWD. */
#define BF_PORT_GPCLR_GPWD(v) ((uint32_t)((uint32_t)(v) << BP_PORT_GPCLR_GPWD) & BM_PORT_GPCLR_GPWD)

/*! @brief Set the GPWD field to a new value. */
#define BW_PORT_GPCLR_GPWD(x, v) (HW_PORT_GPCLR_WR(x, (HW_PORT_GPCLR_RD(x) & ~BM_PORT_GPCLR_GPWD) | BF_PORT_GPCLR_GPWD(v)))
/*@}*/

/*!
 * @name Register PORT_GPCLR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (15 through 0) bits [15:0] update with
 * the value in GPWD. If a selected Pin Control Register is locked then the write
 * to that register is ignored.
 *
 * Values:
 * - 0 - Corresponding Pin Control Register is not updated with the value in
 *     GPWD.
 * - 1 - Corresponding Pin Control Register is updated with the value in GPWD.
 */
/*@{*/
#define BP_PORT_GPCLR_GPWE   (16U)         /*!< Bit position for PORT_GPCLR_GPWE. */
#define BM_PORT_GPCLR_GPWE   (0xFFFF0000U) /*!< Bit mask for PORT_GPCLR_GPWE. */
#define BS_PORT_GPCLR_GPWE   (16U)         /*!< Bit field size in bits for PORT_GPCLR_GPWE. */

/*! @brief Format value for bitfield PORT_GPCLR_GPWE. */
#define BF_PORT_GPCLR_GPWE(v) ((uint32_t)((uint32_t)(v) << BP_PORT_GPCLR_GPWE) & BM_PORT_GPCLR_GPWE)

/*! @brief Set the GPWE field to a new value. */
#define BW_PORT_GPCLR_GPWE(x, v) (HW_PORT_GPCLR_WR(x, (HW_PORT_GPCLR_RD(x) & ~BM_PORT_GPCLR_GPWE) | BF_PORT_GPCLR_GPWE(v)))
/*@}*/

/*******************************************************************************
 * HW_PORT_GPCHR - Global Pin Control High Register
 ******************************************************************************/

/*!
 * @brief HW_PORT_GPCHR - Global Pin Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
typedef union _hw_port_gpchr
{
    uint32_t U;
    struct _hw_port_gpchr_bitfields
    {
        uint32_t GPWD : 16;            /*!< [15:0] Global Pin Write Data */
        uint32_t GPWE : 16;            /*!< [31:16] Global Pin Write Enable */
    } B;
} hw_port_gpchr_t;

/*!
 * @name Constants and macros for entire PORT_GPCHR register
 */
/*@{*/
#define HW_PORT_GPCHR_ADDR(x)    ((uint32_t)(x) + 0x84U)

#define HW_PORT_GPCHR(x)         (*(__O hw_port_gpchr_t *) HW_PORT_GPCHR_ADDR(x))
#define HW_PORT_GPCHR_RD(x)      (HW_PORT_GPCHR(x).U)
#define HW_PORT_GPCHR_WR(x, v)   (HW_PORT_GPCHR(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCHR bitfields
 */

/*!
 * @name Register PORT_GPCHR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
#define BP_PORT_GPCHR_GPWD   (0U)          /*!< Bit position for PORT_GPCHR_GPWD. */
#define BM_PORT_GPCHR_GPWD   (0x0000FFFFU) /*!< Bit mask for PORT_GPCHR_GPWD. */
#define BS_PORT_GPCHR_GPWD   (16U)         /*!< Bit field size in bits for PORT_GPCHR_GPWD. */

/*! @brief Format value for bitfield PORT_GPCHR_GPWD. */
#define BF_PORT_GPCHR_GPWD(v) ((uint32_t)((uint32_t)(v) << BP_PORT_GPCHR_GPWD) & BM_PORT_GPCHR_GPWD)

/*! @brief Set the GPWD field to a new value. */
#define BW_PORT_GPCHR_GPWD(x, v) (HW_PORT_GPCHR_WR(x, (HW_PORT_GPCHR_RD(x) & ~BM_PORT_GPCHR_GPWD) | BF_PORT_GPCHR_GPWD(v)))
/*@}*/

/*!
 * @name Register PORT_GPCHR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (31 through 16) bits [15:0] update with
 * the value in GPWD. If a selected Pin Control Register is locked then the write
 * to that register is ignored.
 *
 * Values:
 * - 0 - Corresponding Pin Control Register is not updated with the value in
 *     GPWD.
 * - 1 - Corresponding Pin Control Register is updated with the value in GPWD.
 */
/*@{*/
#define BP_PORT_GPCHR_GPWE   (16U)         /*!< Bit position for PORT_GPCHR_GPWE. */
#define BM_PORT_GPCHR_GPWE   (0xFFFF0000U) /*!< Bit mask for PORT_GPCHR_GPWE. */
#define BS_PORT_GPCHR_GPWE   (16U)         /*!< Bit field size in bits for PORT_GPCHR_GPWE. */

/*! @brief Format value for bitfield PORT_GPCHR_GPWE. */
#define BF_PORT_GPCHR_GPWE(v) ((uint32_t)((uint32_t)(v) << BP_PORT_GPCHR_GPWE) & BM_PORT_GPCHR_GPWE)

/*! @brief Set the GPWE field to a new value. */
#define BW_PORT_GPCHR_GPWE(x, v) (HW_PORT_GPCHR_WR(x, (HW_PORT_GPCHR_RD(x) & ~BM_PORT_GPCHR_GPWE) | BF_PORT_GPCHR_GPWE(v)))
/*@}*/

/*******************************************************************************
 * HW_PORT_ISFR - Interrupt Status Flag Register
 ******************************************************************************/

/*!
 * @brief HW_PORT_ISFR - Interrupt Status Flag Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * Interrupt Status Flag for each pin is also visible in the corresponding Pin
 * Control Register, and each flag can be cleared in either location.
 */
typedef union _hw_port_isfr
{
    uint32_t U;
    struct _hw_port_isfr_bitfields
    {
        uint32_t ISF : 32;             /*!< [31:0] Interrupt Status Flag */
    } B;
} hw_port_isfr_t;

/*!
 * @name Constants and macros for entire PORT_ISFR register
 */
/*@{*/
#define HW_PORT_ISFR_ADDR(x)     ((uint32_t)(x) + 0xA0U)

#define HW_PORT_ISFR(x)          (*(__IO hw_port_isfr_t *) HW_PORT_ISFR_ADDR(x))
#define HW_PORT_ISFR_RD(x)       (HW_PORT_ISFR(x).U)
#define HW_PORT_ISFR_WR(x, v)    (HW_PORT_ISFR(x).U = (v))
#define HW_PORT_ISFR_SET(x, v)   (HW_PORT_ISFR_WR(x, HW_PORT_ISFR_RD(x) |  (v)))
#define HW_PORT_ISFR_CLR(x, v)   (HW_PORT_ISFR_WR(x, HW_PORT_ISFR_RD(x) & ~(v)))
#define HW_PORT_ISFR_TOG(x, v)   (HW_PORT_ISFR_WR(x, HW_PORT_ISFR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PORT_ISFR bitfields
 */

/*!
 * @name Register PORT_ISFR, field ISF[31:0] (W1C)
 *
 * Each bit in the field indicates the detection of the configured interrupt of
 * the same number as the field.
 *
 * Values:
 * - 0 - Configured interrupt is not detected.
 * - 1 - Configured interrupt is detected. If the pin is configured to generate
 *     a DMA request, then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer. Otherwise, the flag
 *     remains set until a logic 1 is written to the flag. If the pin is configured for
 *     a level sensitive interrupt and the pin remains asserted, then the flag
 *     is set again immediately after it is cleared.
 */
/*@{*/
#define BP_PORT_ISFR_ISF     (0U)          /*!< Bit position for PORT_ISFR_ISF. */
#define BM_PORT_ISFR_ISF     (0xFFFFFFFFU) /*!< Bit mask for PORT_ISFR_ISF. */
#define BS_PORT_ISFR_ISF     (32U)         /*!< Bit field size in bits for PORT_ISFR_ISF. */

/*! @brief Read current value of the PORT_ISFR_ISF field. */
#define BR_PORT_ISFR_ISF(x)  (HW_PORT_ISFR(x).U)

/*! @brief Format value for bitfield PORT_ISFR_ISF. */
#define BF_PORT_ISFR_ISF(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_ISFR_ISF) & BM_PORT_ISFR_ISF)

/*! @brief Set the ISF field to a new value. */
#define BW_PORT_ISFR_ISF(x, v) (HW_PORT_ISFR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_PORT_DFER - Digital Filter Enable Register
 ******************************************************************************/

/*!
 * @brief HW_PORT_DFER - Digital Filter Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The corresponding bit is read only for pins that do not support a digital
 * filter. Refer to the Chapter of Signal Multiplexing and Signal Descriptions for
 * the pins that support digital filter. The digital filter configuration is valid
 * in all digital pin muxing modes.
 */
typedef union _hw_port_dfer
{
    uint32_t U;
    struct _hw_port_dfer_bitfields
    {
        uint32_t DFE : 32;             /*!< [31:0] Digital Filter Enable */
    } B;
} hw_port_dfer_t;

/*!
 * @name Constants and macros for entire PORT_DFER register
 */
/*@{*/
#define HW_PORT_DFER_ADDR(x)     ((uint32_t)(x) + 0xC0U)

#define HW_PORT_DFER(x)          (*(__IO hw_port_dfer_t *) HW_PORT_DFER_ADDR(x))
#define HW_PORT_DFER_RD(x)       (HW_PORT_DFER(x).U)
#define HW_PORT_DFER_WR(x, v)    (HW_PORT_DFER(x).U = (v))
#define HW_PORT_DFER_SET(x, v)   (HW_PORT_DFER_WR(x, HW_PORT_DFER_RD(x) |  (v)))
#define HW_PORT_DFER_CLR(x, v)   (HW_PORT_DFER_WR(x, HW_PORT_DFER_RD(x) & ~(v)))
#define HW_PORT_DFER_TOG(x, v)   (HW_PORT_DFER_WR(x, HW_PORT_DFER_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFER bitfields
 */

/*!
 * @name Register PORT_DFER, field DFE[31:0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * The output of each digital filter is reset to zero at system reset and whenever
 * the digital filter is disabled. Each bit in the field enables the digital
 * filter of the same number as the field.
 *
 * Values:
 * - 0 - Digital filter is disabled on the corresponding pin and output of the
 *     digital filter is reset to zero.
 * - 1 - Digital filter is enabled on the corresponding pin, if the pin is
 *     configured as a digital input.
 */
/*@{*/
#define BP_PORT_DFER_DFE     (0U)          /*!< Bit position for PORT_DFER_DFE. */
#define BM_PORT_DFER_DFE     (0xFFFFFFFFU) /*!< Bit mask for PORT_DFER_DFE. */
#define BS_PORT_DFER_DFE     (32U)         /*!< Bit field size in bits for PORT_DFER_DFE. */

/*! @brief Read current value of the PORT_DFER_DFE field. */
#define BR_PORT_DFER_DFE(x)  (HW_PORT_DFER(x).U)

/*! @brief Format value for bitfield PORT_DFER_DFE. */
#define BF_PORT_DFER_DFE(v)  ((uint32_t)((uint32_t)(v) << BP_PORT_DFER_DFE) & BM_PORT_DFER_DFE)

/*! @brief Set the DFE field to a new value. */
#define BW_PORT_DFER_DFE(x, v) (HW_PORT_DFER_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_PORT_DFCR - Digital Filter Clock Register
 ******************************************************************************/

/*!
 * @brief HW_PORT_DFCR - Digital Filter Clock Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is read only for ports that do not support a digital filter.
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
typedef union _hw_port_dfcr
{
    uint32_t U;
    struct _hw_port_dfcr_bitfields
    {
        uint32_t CS : 1;               /*!< [0] Clock Source */
        uint32_t RESERVED0 : 31;       /*!< [31:1]  */
    } B;
} hw_port_dfcr_t;

/*!
 * @name Constants and macros for entire PORT_DFCR register
 */
/*@{*/
#define HW_PORT_DFCR_ADDR(x)     ((uint32_t)(x) + 0xC4U)

#define HW_PORT_DFCR(x)          (*(__IO hw_port_dfcr_t *) HW_PORT_DFCR_ADDR(x))
#define HW_PORT_DFCR_RD(x)       (HW_PORT_DFCR(x).U)
#define HW_PORT_DFCR_WR(x, v)    (HW_PORT_DFCR(x).U = (v))
#define HW_PORT_DFCR_SET(x, v)   (HW_PORT_DFCR_WR(x, HW_PORT_DFCR_RD(x) |  (v)))
#define HW_PORT_DFCR_CLR(x, v)   (HW_PORT_DFCR_WR(x, HW_PORT_DFCR_RD(x) & ~(v)))
#define HW_PORT_DFCR_TOG(x, v)   (HW_PORT_DFCR_WR(x, HW_PORT_DFCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFCR bitfields
 */

/*!
 * @name Register PORT_DFCR, field CS[0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the clock source for the digital input filters. Changing the filter
 * clock source must be done only when all digital filters are disabled.
 *
 * Values:
 * - 0 - Digital filters are clocked by the bus clock.
 * - 1 - Digital filters are clocked by the 1 kHz LPO clock.
 */
/*@{*/
#define BP_PORT_DFCR_CS      (0U)          /*!< Bit position for PORT_DFCR_CS. */
#define BM_PORT_DFCR_CS      (0x00000001U) /*!< Bit mask for PORT_DFCR_CS. */
#define BS_PORT_DFCR_CS      (1U)          /*!< Bit field size in bits for PORT_DFCR_CS. */

/*! @brief Read current value of the PORT_DFCR_CS field. */
#define BR_PORT_DFCR_CS(x)   (BITBAND_ACCESS32(HW_PORT_DFCR_ADDR(x), BP_PORT_DFCR_CS))

/*! @brief Format value for bitfield PORT_DFCR_CS. */
#define BF_PORT_DFCR_CS(v)   ((uint32_t)((uint32_t)(v) << BP_PORT_DFCR_CS) & BM_PORT_DFCR_CS)

/*! @brief Set the CS field to a new value. */
#define BW_PORT_DFCR_CS(x, v) (BITBAND_ACCESS32(HW_PORT_DFCR_ADDR(x), BP_PORT_DFCR_CS) = (v))
/*@}*/

/*******************************************************************************
 * HW_PORT_DFWR - Digital Filter Width Register
 ******************************************************************************/

/*!
 * @brief HW_PORT_DFWR - Digital Filter Width Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is read only for ports that do not support a digital filter.
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
typedef union _hw_port_dfwr
{
    uint32_t U;
    struct _hw_port_dfwr_bitfields
    {
        uint32_t FILT : 5;             /*!< [4:0] Filter Length */
        uint32_t RESERVED0 : 27;       /*!< [31:5]  */
    } B;
} hw_port_dfwr_t;

/*!
 * @name Constants and macros for entire PORT_DFWR register
 */
/*@{*/
#define HW_PORT_DFWR_ADDR(x)     ((uint32_t)(x) + 0xC8U)

#define HW_PORT_DFWR(x)          (*(__IO hw_port_dfwr_t *) HW_PORT_DFWR_ADDR(x))
#define HW_PORT_DFWR_RD(x)       (HW_PORT_DFWR(x).U)
#define HW_PORT_DFWR_WR(x, v)    (HW_PORT_DFWR(x).U = (v))
#define HW_PORT_DFWR_SET(x, v)   (HW_PORT_DFWR_WR(x, HW_PORT_DFWR_RD(x) |  (v)))
#define HW_PORT_DFWR_CLR(x, v)   (HW_PORT_DFWR_WR(x, HW_PORT_DFWR_RD(x) & ~(v)))
#define HW_PORT_DFWR_TOG(x, v)   (HW_PORT_DFWR_WR(x, HW_PORT_DFWR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFWR bitfields
 */

/*!
 * @name Register PORT_DFWR, field FILT[4:0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the maximum size of the glitches, in clock cycles, that the digital
 * filter absorbs for the enabled digital filters. Glitches that are longer than
 * this register setting will pass through the digital filter, and glitches that
 * are equal to or less than this register setting are filtered. Changing the
 * filter length must be done only after all filters are disabled.
 */
/*@{*/
#define BP_PORT_DFWR_FILT    (0U)          /*!< Bit position for PORT_DFWR_FILT. */
#define BM_PORT_DFWR_FILT    (0x0000001FU) /*!< Bit mask for PORT_DFWR_FILT. */
#define BS_PORT_DFWR_FILT    (5U)          /*!< Bit field size in bits for PORT_DFWR_FILT. */

/*! @brief Read current value of the PORT_DFWR_FILT field. */
#define BR_PORT_DFWR_FILT(x) (HW_PORT_DFWR(x).B.FILT)

/*! @brief Format value for bitfield PORT_DFWR_FILT. */
#define BF_PORT_DFWR_FILT(v) ((uint32_t)((uint32_t)(v) << BP_PORT_DFWR_FILT) & BM_PORT_DFWR_FILT)

/*! @brief Set the FILT field to a new value. */
#define BW_PORT_DFWR_FILT(x, v) (HW_PORT_DFWR_WR(x, (HW_PORT_DFWR_RD(x) & ~BM_PORT_DFWR_FILT) | BF_PORT_DFWR_FILT(v)))
/*@}*/

/*******************************************************************************
 * hw_port_t - module struct
 ******************************************************************************/
/*!
 * @brief All PORT module registers.
 */
#pragma pack(1)
typedef struct _hw_port
{
    __IO hw_port_pcrn_t PCRn[32];          /*!< [0x0] Pin Control Register n */
    __O hw_port_gpclr_t GPCLR;             /*!< [0x80] Global Pin Control Low Register */
    __O hw_port_gpchr_t GPCHR;             /*!< [0x84] Global Pin Control High Register */
    uint8_t _reserved0[24];
    __IO hw_port_isfr_t ISFR;              /*!< [0xA0] Interrupt Status Flag Register */
    uint8_t _reserved1[28];
    __IO hw_port_dfer_t DFER;              /*!< [0xC0] Digital Filter Enable Register */
    __IO hw_port_dfcr_t DFCR;              /*!< [0xC4] Digital Filter Clock Register */
    __IO hw_port_dfwr_t DFWR;              /*!< [0xC8] Digital Filter Width Register */
} hw_port_t;
#pragma pack()

/*! @brief Macro to access all PORT registers. */
/*! @param x PORT module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_PORT_REGS(PORTA_BASE)</code>. */
#define HW_PORT_REGS(x) (*(hw_port_t *)(x))

/*
 * MK64F12 RCM
 *
 * Reset Control Module
 *
 * Registers defined in this header file:
 * - HW_RCM_SRS0 - System Reset Status Register 0
 * - HW_RCM_SRS1 - System Reset Status Register 1
 * - HW_RCM_RPFC - Reset Pin Filter Control register
 * - HW_RCM_RPFW - Reset Pin Filter Width register
 * - HW_RCM_MR - Mode Register
 *
 * - hw_rcm_t - Struct containing all module registers.
 */

#define HW_RCM_INSTANCE_COUNT (1U) /*!< Number of instances of the RCM module. */
#define HW_RCM (0U) /*!< Instance number for RCM. */

/*******************************************************************************
 * HW_RCM_SRS0 - System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief HW_RCM_SRS0 - System Reset Status Register 0 (RO)
 *
 * Reset value: 0x82U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x82 LVD (without POR) - 0x02 VLLS mode wakeup due to RESET
 * pin assertion - 0x41 VLLS mode wakeup due to other wakeup sources - 0x01 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
typedef union _hw_rcm_srs0
{
    uint8_t U;
    struct _hw_rcm_srs0_bitfields
    {
        uint8_t WAKEUP : 1;            /*!< [0] Low Leakage Wakeup Reset */
        uint8_t LVD : 1;               /*!< [1] Low-Voltage Detect Reset */
        uint8_t LOC : 1;               /*!< [2] Loss-of-Clock Reset */
        uint8_t LOL : 1;               /*!< [3] Loss-of-Lock Reset */
        uint8_t RESERVED0 : 1;         /*!< [4]  */
        uint8_t WDOGb : 1;             /*!< [5] Watchdog */
        uint8_t PIN : 1;               /*!< [6] External Reset Pin */
        uint8_t POR : 1;               /*!< [7] Power-On Reset */
    } B;
} hw_rcm_srs0_t;

/*!
 * @name Constants and macros for entire RCM_SRS0 register
 */
/*@{*/
#define HW_RCM_SRS0_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_RCM_SRS0(x)           (*(__I hw_rcm_srs0_t *) HW_RCM_SRS0_ADDR(x))
#define HW_RCM_SRS0_RD(x)        (HW_RCM_SRS0(x).U)
/*@}*/

/*
 * Constants & macros for individual RCM_SRS0 bitfields
 */

/*!
 * @name Register RCM_SRS0, field WAKEUP[0] (RO)
 *
 * Indicates a reset has been caused by an enabled LLWU module wakeup source
 * while the chip was in a low leakage mode. In LLS mode, the RESET pin is the only
 * wakeup source that can cause this reset. Any enabled wakeup source in a VLLSx
 * mode causes a reset. This bit is cleared by any reset except WAKEUP.
 *
 * Values:
 * - 0 - Reset not caused by LLWU module wakeup source
 * - 1 - Reset caused by LLWU module wakeup source
 */
/*@{*/
#define BP_RCM_SRS0_WAKEUP   (0U)          /*!< Bit position for RCM_SRS0_WAKEUP. */
#define BM_RCM_SRS0_WAKEUP   (0x01U)       /*!< Bit mask for RCM_SRS0_WAKEUP. */
#define BS_RCM_SRS0_WAKEUP   (1U)          /*!< Bit field size in bits for RCM_SRS0_WAKEUP. */

/*! @brief Read current value of the RCM_SRS0_WAKEUP field. */
#define BR_RCM_SRS0_WAKEUP(x) (BITBAND_ACCESS8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_WAKEUP))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LVD[1] (RO)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0 - Reset not caused by LVD trip or POR
 * - 1 - Reset caused by LVD trip or POR
 */
/*@{*/
#define BP_RCM_SRS0_LVD      (1U)          /*!< Bit position for RCM_SRS0_LVD. */
#define BM_RCM_SRS0_LVD      (0x02U)       /*!< Bit mask for RCM_SRS0_LVD. */
#define BS_RCM_SRS0_LVD      (1U)          /*!< Bit field size in bits for RCM_SRS0_LVD. */

/*! @brief Read current value of the RCM_SRS0_LVD field. */
#define BR_RCM_SRS0_LVD(x)   (BITBAND_ACCESS8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_LVD))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOC[2] (RO)
 *
 * Indicates a reset has been caused by a loss of external clock. The MCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed MCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0 - Reset not caused by a loss of external clock.
 * - 1 - Reset caused by a loss of external clock.
 */
/*@{*/
#define BP_RCM_SRS0_LOC      (2U)          /*!< Bit position for RCM_SRS0_LOC. */
#define BM_RCM_SRS0_LOC      (0x04U)       /*!< Bit mask for RCM_SRS0_LOC. */
#define BS_RCM_SRS0_LOC      (1U)          /*!< Bit field size in bits for RCM_SRS0_LOC. */

/*! @brief Read current value of the RCM_SRS0_LOC field. */
#define BR_RCM_SRS0_LOC(x)   (BITBAND_ACCESS8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_LOC))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOL[3] (RO)
 *
 * Indicates a reset has been caused by a loss of lock in the MCG PLL. See the
 * MCG description for information on the loss-of-clock event.
 *
 * Values:
 * - 0 - Reset not caused by a loss of lock in the PLL
 * - 1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
#define BP_RCM_SRS0_LOL      (3U)          /*!< Bit position for RCM_SRS0_LOL. */
#define BM_RCM_SRS0_LOL      (0x08U)       /*!< Bit mask for RCM_SRS0_LOL. */
#define BS_RCM_SRS0_LOL      (1U)          /*!< Bit field size in bits for RCM_SRS0_LOL. */

/*! @brief Read current value of the RCM_SRS0_LOL field. */
#define BR_RCM_SRS0_LOL(x)   (BITBAND_ACCESS8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_LOL))
/*@}*/

/*!
 * @name Register RCM_SRS0, field WDOG[5] (RO)
 *
 * Indicates a reset has been caused by the watchdog timer Computer Operating
 * Properly (COP) timing out. This reset source can be blocked by disabling the COP
 * watchdog: write 00 to SIM_COPCTRL[COPT].
 *
 * Values:
 * - 0 - Reset not caused by watchdog timeout
 * - 1 - Reset caused by watchdog timeout
 */
/*@{*/
#define BP_RCM_SRS0_WDOG     (5U)          /*!< Bit position for RCM_SRS0_WDOG. */
#define BM_RCM_SRS0_WDOG     (0x20U)       /*!< Bit mask for RCM_SRS0_WDOG. */
#define BS_RCM_SRS0_WDOG     (1U)          /*!< Bit field size in bits for RCM_SRS0_WDOG. */

/*! @brief Read current value of the RCM_SRS0_WDOG field. */
#define BR_RCM_SRS0_WDOG(x)  (BITBAND_ACCESS8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_WDOG))
/*@}*/

/*!
 * @name Register RCM_SRS0, field PIN[6] (RO)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET pin.
 *
 * Values:
 * - 0 - Reset not caused by external reset pin
 * - 1 - Reset caused by external reset pin
 */
/*@{*/
#define BP_RCM_SRS0_PIN      (6U)          /*!< Bit position for RCM_SRS0_PIN. */
#define BM_RCM_SRS0_PIN      (0x40U)       /*!< Bit mask for RCM_SRS0_PIN. */
#define BS_RCM_SRS0_PIN      (1U)          /*!< Bit field size in bits for RCM_SRS0_PIN. */

/*! @brief Read current value of the RCM_SRS0_PIN field. */
#define BR_RCM_SRS0_PIN(x)   (BITBAND_ACCESS8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_PIN))
/*@}*/

/*!
 * @name Register RCM_SRS0, field POR[7] (RO)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0 - Reset not caused by POR
 * - 1 - Reset caused by POR
 */
/*@{*/
#define BP_RCM_SRS0_POR      (7U)          /*!< Bit position for RCM_SRS0_POR. */
#define BM_RCM_SRS0_POR      (0x80U)       /*!< Bit mask for RCM_SRS0_POR. */
#define BS_RCM_SRS0_POR      (1U)          /*!< Bit field size in bits for RCM_SRS0_POR. */

/*! @brief Read current value of the RCM_SRS0_POR field. */
#define BR_RCM_SRS0_POR(x)   (BITBAND_ACCESS8(HW_RCM_SRS0_ADDR(x), BP_RCM_SRS0_POR))
/*@}*/

/*******************************************************************************
 * HW_RCM_SRS1 - System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief HW_RCM_SRS1 - System Reset Status Register 1 (RO)
 *
 * Reset value: 0x00U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x00 LVD (without POR) - 0x00 VLLS mode wakeup - 0x00 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
typedef union _hw_rcm_srs1
{
    uint8_t U;
    struct _hw_rcm_srs1_bitfields
    {
        uint8_t JTAG : 1;              /*!< [0] JTAG Generated Reset */
        uint8_t LOCKUP : 1;            /*!< [1] Core Lockup */
        uint8_t SW : 1;                /*!< [2] Software */
        uint8_t MDM_AP : 1;            /*!< [3] MDM-AP System Reset Request */
        uint8_t EZPT : 1;              /*!< [4] EzPort Reset */
        uint8_t SACKERR : 1;           /*!< [5] Stop Mode Acknowledge Error Reset */
        uint8_t RESERVED0 : 2;         /*!< [7:6]  */
    } B;
} hw_rcm_srs1_t;

/*!
 * @name Constants and macros for entire RCM_SRS1 register
 */
/*@{*/
#define HW_RCM_SRS1_ADDR(x)      ((uint32_t)(x) + 0x1U)

#define HW_RCM_SRS1(x)           (*(__I hw_rcm_srs1_t *) HW_RCM_SRS1_ADDR(x))
#define HW_RCM_SRS1_RD(x)        (HW_RCM_SRS1(x).U)
/*@}*/

/*
 * Constants & macros for individual RCM_SRS1 bitfields
 */

/*!
 * @name Register RCM_SRS1, field JTAG[0] (RO)
 *
 * Indicates a reset has been caused by JTAG selection of certain IR codes:
 * EZPORT, EXTEST, HIGHZ, and CLAMP.
 *
 * Values:
 * - 0 - Reset not caused by JTAG
 * - 1 - Reset caused by JTAG
 */
/*@{*/
#define BP_RCM_SRS1_JTAG     (0U)          /*!< Bit position for RCM_SRS1_JTAG. */
#define BM_RCM_SRS1_JTAG     (0x01U)       /*!< Bit mask for RCM_SRS1_JTAG. */
#define BS_RCM_SRS1_JTAG     (1U)          /*!< Bit field size in bits for RCM_SRS1_JTAG. */

/*! @brief Read current value of the RCM_SRS1_JTAG field. */
#define BR_RCM_SRS1_JTAG(x)  (BITBAND_ACCESS8(HW_RCM_SRS1_ADDR(x), BP_RCM_SRS1_JTAG))
/*@}*/

/*!
 * @name Register RCM_SRS1, field LOCKUP[1] (RO)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0 - Reset not caused by core LOCKUP event
 * - 1 - Reset caused by core LOCKUP event
 */
/*@{*/
#define BP_RCM_SRS1_LOCKUP   (1U)          /*!< Bit position for RCM_SRS1_LOCKUP. */
#define BM_RCM_SRS1_LOCKUP   (0x02U)       /*!< Bit mask for RCM_SRS1_LOCKUP. */
#define BS_RCM_SRS1_LOCKUP   (1U)          /*!< Bit field size in bits for RCM_SRS1_LOCKUP. */

/*! @brief Read current value of the RCM_SRS1_LOCKUP field. */
#define BR_RCM_SRS1_LOCKUP(x) (BITBAND_ACCESS8(HW_RCM_SRS1_ADDR(x), BP_RCM_SRS1_LOCKUP))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SW[2] (RO)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
#define BP_RCM_SRS1_SW       (2U)          /*!< Bit position for RCM_SRS1_SW. */
#define BM_RCM_SRS1_SW       (0x04U)       /*!< Bit mask for RCM_SRS1_SW. */
#define BS_RCM_SRS1_SW       (1U)          /*!< Bit field size in bits for RCM_SRS1_SW. */

/*! @brief Read current value of the RCM_SRS1_SW field. */
#define BR_RCM_SRS1_SW(x)    (BITBAND_ACCESS8(HW_RCM_SRS1_ADDR(x), BP_RCM_SRS1_SW))
/*@}*/

/*!
 * @name Register RCM_SRS1, field MDM_AP[3] (RO)
 *
 * Indicates a reset has been caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
#define BP_RCM_SRS1_MDM_AP   (3U)          /*!< Bit position for RCM_SRS1_MDM_AP. */
#define BM_RCM_SRS1_MDM_AP   (0x08U)       /*!< Bit mask for RCM_SRS1_MDM_AP. */
#define BS_RCM_SRS1_MDM_AP   (1U)          /*!< Bit field size in bits for RCM_SRS1_MDM_AP. */

/*! @brief Read current value of the RCM_SRS1_MDM_AP field. */
#define BR_RCM_SRS1_MDM_AP(x) (BITBAND_ACCESS8(HW_RCM_SRS1_ADDR(x), BP_RCM_SRS1_MDM_AP))
/*@}*/

/*!
 * @name Register RCM_SRS1, field EZPT[4] (RO)
 *
 * Indicates a reset has been caused by EzPort receiving the RESET command while
 * the device is in EzPort mode.
 *
 * Values:
 * - 0 - Reset not caused by EzPort receiving the RESET command while the device
 *     is in EzPort mode
 * - 1 - Reset caused by EzPort receiving the RESET command while the device is
 *     in EzPort mode
 */
/*@{*/
#define BP_RCM_SRS1_EZPT     (4U)          /*!< Bit position for RCM_SRS1_EZPT. */
#define BM_RCM_SRS1_EZPT     (0x10U)       /*!< Bit mask for RCM_SRS1_EZPT. */
#define BS_RCM_SRS1_EZPT     (1U)          /*!< Bit field size in bits for RCM_SRS1_EZPT. */

/*! @brief Read current value of the RCM_SRS1_EZPT field. */
#define BR_RCM_SRS1_EZPT(x)  (BITBAND_ACCESS8(HW_RCM_SRS1_ADDR(x), BP_RCM_SRS1_EZPT))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SACKERR[5] (RO)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0 - Reset not caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 * - 1 - Reset caused by peripheral failure to acknowledge attempt to enter stop
 *     mode
 */
/*@{*/
#define BP_RCM_SRS1_SACKERR  (5U)          /*!< Bit position for RCM_SRS1_SACKERR. */
#define BM_RCM_SRS1_SACKERR  (0x20U)       /*!< Bit mask for RCM_SRS1_SACKERR. */
#define BS_RCM_SRS1_SACKERR  (1U)          /*!< Bit field size in bits for RCM_SRS1_SACKERR. */

/*! @brief Read current value of the RCM_SRS1_SACKERR field. */
#define BR_RCM_SRS1_SACKERR(x) (BITBAND_ACCESS8(HW_RCM_SRS1_ADDR(x), BP_RCM_SRS1_SACKERR))
/*@}*/

/*******************************************************************************
 * HW_RCM_RPFC - Reset Pin Filter Control register
 ******************************************************************************/

/*!
 * @brief HW_RCM_RPFC - Reset Pin Filter Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of bits 2-0 are for Chip POR only. They are unaffected by
 * other reset types. The bus clock filter is reset when disabled or when entering
 * stop mode. The LPO filter is reset when disabled or when entering any low
 * leakage stop mode .
 */
typedef union _hw_rcm_rpfc
{
    uint8_t U;
    struct _hw_rcm_rpfc_bitfields
    {
        uint8_t RSTFLTSRW : 2;         /*!< [1:0] Reset Pin Filter Select in Run and
                                        * Wait Modes */
        uint8_t RSTFLTSS : 1;          /*!< [2] Reset Pin Filter Select in Stop Mode */
        uint8_t RESERVED0 : 5;         /*!< [7:3]  */
    } B;
} hw_rcm_rpfc_t;

/*!
 * @name Constants and macros for entire RCM_RPFC register
 */
/*@{*/
#define HW_RCM_RPFC_ADDR(x)      ((uint32_t)(x) + 0x4U)

#define HW_RCM_RPFC(x)           (*(__IO hw_rcm_rpfc_t *) HW_RCM_RPFC_ADDR(x))
#define HW_RCM_RPFC_RD(x)        (HW_RCM_RPFC(x).U)
#define HW_RCM_RPFC_WR(x, v)     (HW_RCM_RPFC(x).U = (v))
#define HW_RCM_RPFC_SET(x, v)    (HW_RCM_RPFC_WR(x, HW_RCM_RPFC_RD(x) |  (v)))
#define HW_RCM_RPFC_CLR(x, v)    (HW_RCM_RPFC_WR(x, HW_RCM_RPFC_RD(x) & ~(v)))
#define HW_RCM_RPFC_TOG(x, v)    (HW_RCM_RPFC_WR(x, HW_RCM_RPFC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFC bitfields
 */

/*!
 * @name Register RCM_RPFC, field RSTFLTSRW[1:0] (RW)
 *
 * Selects how the reset pin filter is enabled in run and wait modes.
 *
 * Values:
 * - 00 - All filtering disabled
 * - 01 - Bus clock filter enabled for normal operation
 * - 10 - LPO clock filter enabled for normal operation
 * - 11 - Reserved
 */
/*@{*/
#define BP_RCM_RPFC_RSTFLTSRW (0U)         /*!< Bit position for RCM_RPFC_RSTFLTSRW. */
#define BM_RCM_RPFC_RSTFLTSRW (0x03U)      /*!< Bit mask for RCM_RPFC_RSTFLTSRW. */
#define BS_RCM_RPFC_RSTFLTSRW (2U)         /*!< Bit field size in bits for RCM_RPFC_RSTFLTSRW. */

/*! @brief Read current value of the RCM_RPFC_RSTFLTSRW field. */
#define BR_RCM_RPFC_RSTFLTSRW(x) (HW_RCM_RPFC(x).B.RSTFLTSRW)

/*! @brief Format value for bitfield RCM_RPFC_RSTFLTSRW. */
#define BF_RCM_RPFC_RSTFLTSRW(v) ((uint8_t)((uint8_t)(v) << BP_RCM_RPFC_RSTFLTSRW) & BM_RCM_RPFC_RSTFLTSRW)

/*! @brief Set the RSTFLTSRW field to a new value. */
#define BW_RCM_RPFC_RSTFLTSRW(x, v) (HW_RCM_RPFC_WR(x, (HW_RCM_RPFC_RD(x) & ~BM_RCM_RPFC_RSTFLTSRW) | BF_RCM_RPFC_RSTFLTSRW(v)))
/*@}*/

/*!
 * @name Register RCM_RPFC, field RSTFLTSS[2] (RW)
 *
 * Selects how the reset pin filter is enabled in Stop and VLPS modes
 *
 * Values:
 * - 0 - All filtering disabled
 * - 1 - LPO clock filter enabled
 */
/*@{*/
#define BP_RCM_RPFC_RSTFLTSS (2U)          /*!< Bit position for RCM_RPFC_RSTFLTSS. */
#define BM_RCM_RPFC_RSTFLTSS (0x04U)       /*!< Bit mask for RCM_RPFC_RSTFLTSS. */
#define BS_RCM_RPFC_RSTFLTSS (1U)          /*!< Bit field size in bits for RCM_RPFC_RSTFLTSS. */

/*! @brief Read current value of the RCM_RPFC_RSTFLTSS field. */
#define BR_RCM_RPFC_RSTFLTSS(x) (BITBAND_ACCESS8(HW_RCM_RPFC_ADDR(x), BP_RCM_RPFC_RSTFLTSS))

/*! @brief Format value for bitfield RCM_RPFC_RSTFLTSS. */
#define BF_RCM_RPFC_RSTFLTSS(v) ((uint8_t)((uint8_t)(v) << BP_RCM_RPFC_RSTFLTSS) & BM_RCM_RPFC_RSTFLTSS)

/*! @brief Set the RSTFLTSS field to a new value. */
#define BW_RCM_RPFC_RSTFLTSS(x, v) (BITBAND_ACCESS8(HW_RCM_RPFC_ADDR(x), BP_RCM_RPFC_RSTFLTSS) = (v))
/*@}*/

/*******************************************************************************
 * HW_RCM_RPFW - Reset Pin Filter Width register
 ******************************************************************************/

/*!
 * @brief HW_RCM_RPFW - Reset Pin Filter Width register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of the bits in the RSTFLTSEL field are for Chip POR only.
 * They are unaffected by other reset types.
 */
typedef union _hw_rcm_rpfw
{
    uint8_t U;
    struct _hw_rcm_rpfw_bitfields
    {
        uint8_t RSTFLTSEL : 5;         /*!< [4:0] Reset Pin Filter Bus Clock Select */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_rcm_rpfw_t;

/*!
 * @name Constants and macros for entire RCM_RPFW register
 */
/*@{*/
#define HW_RCM_RPFW_ADDR(x)      ((uint32_t)(x) + 0x5U)

#define HW_RCM_RPFW(x)           (*(__IO hw_rcm_rpfw_t *) HW_RCM_RPFW_ADDR(x))
#define HW_RCM_RPFW_RD(x)        (HW_RCM_RPFW(x).U)
#define HW_RCM_RPFW_WR(x, v)     (HW_RCM_RPFW(x).U = (v))
#define HW_RCM_RPFW_SET(x, v)    (HW_RCM_RPFW_WR(x, HW_RCM_RPFW_RD(x) |  (v)))
#define HW_RCM_RPFW_CLR(x, v)    (HW_RCM_RPFW_WR(x, HW_RCM_RPFW_RD(x) & ~(v)))
#define HW_RCM_RPFW_TOG(x, v)    (HW_RCM_RPFW_WR(x, HW_RCM_RPFW_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFW bitfields
 */

/*!
 * @name Register RCM_RPFW, field RSTFLTSEL[4:0] (RW)
 *
 * Selects the reset pin bus clock filter width.
 *
 * Values:
 * - 00000 - Bus clock filter count is 1
 * - 00001 - Bus clock filter count is 2
 * - 00010 - Bus clock filter count is 3
 * - 00011 - Bus clock filter count is 4
 * - 00100 - Bus clock filter count is 5
 * - 00101 - Bus clock filter count is 6
 * - 00110 - Bus clock filter count is 7
 * - 00111 - Bus clock filter count is 8
 * - 01000 - Bus clock filter count is 9
 * - 01001 - Bus clock filter count is 10
 * - 01010 - Bus clock filter count is 11
 * - 01011 - Bus clock filter count is 12
 * - 01100 - Bus clock filter count is 13
 * - 01101 - Bus clock filter count is 14
 * - 01110 - Bus clock filter count is 15
 * - 01111 - Bus clock filter count is 16
 * - 10000 - Bus clock filter count is 17
 * - 10001 - Bus clock filter count is 18
 * - 10010 - Bus clock filter count is 19
 * - 10011 - Bus clock filter count is 20
 * - 10100 - Bus clock filter count is 21
 * - 10101 - Bus clock filter count is 22
 * - 10110 - Bus clock filter count is 23
 * - 10111 - Bus clock filter count is 24
 * - 11000 - Bus clock filter count is 25
 * - 11001 - Bus clock filter count is 26
 * - 11010 - Bus clock filter count is 27
 * - 11011 - Bus clock filter count is 28
 * - 11100 - Bus clock filter count is 29
 * - 11101 - Bus clock filter count is 30
 * - 11110 - Bus clock filter count is 31
 * - 11111 - Bus clock filter count is 32
 */
/*@{*/
#define BP_RCM_RPFW_RSTFLTSEL (0U)         /*!< Bit position for RCM_RPFW_RSTFLTSEL. */
#define BM_RCM_RPFW_RSTFLTSEL (0x1FU)      /*!< Bit mask for RCM_RPFW_RSTFLTSEL. */
#define BS_RCM_RPFW_RSTFLTSEL (5U)         /*!< Bit field size in bits for RCM_RPFW_RSTFLTSEL. */

/*! @brief Read current value of the RCM_RPFW_RSTFLTSEL field. */
#define BR_RCM_RPFW_RSTFLTSEL(x) (HW_RCM_RPFW(x).B.RSTFLTSEL)

/*! @brief Format value for bitfield RCM_RPFW_RSTFLTSEL. */
#define BF_RCM_RPFW_RSTFLTSEL(v) ((uint8_t)((uint8_t)(v) << BP_RCM_RPFW_RSTFLTSEL) & BM_RCM_RPFW_RSTFLTSEL)

/*! @brief Set the RSTFLTSEL field to a new value. */
#define BW_RCM_RPFW_RSTFLTSEL(x, v) (HW_RCM_RPFW_WR(x, (HW_RCM_RPFW_RD(x) & ~BM_RCM_RPFW_RSTFLTSEL) | BF_RCM_RPFW_RSTFLTSEL(v)))
/*@}*/

/*******************************************************************************
 * HW_RCM_MR - Mode Register
 ******************************************************************************/

/*!
 * @brief HW_RCM_MR - Mode Register (RO)
 *
 * Reset value: 0x00U
 *
 * This register includes read-only status flags to indicate the state of the
 * mode pins during the last Chip Reset.
 */
typedef union _hw_rcm_mr
{
    uint8_t U;
    struct _hw_rcm_mr_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t EZP_MS : 1;            /*!< [1] EZP_MS_B pin state */
        uint8_t RESERVED1 : 6;         /*!< [7:2]  */
    } B;
} hw_rcm_mr_t;

/*!
 * @name Constants and macros for entire RCM_MR register
 */
/*@{*/
#define HW_RCM_MR_ADDR(x)        ((uint32_t)(x) + 0x7U)

#define HW_RCM_MR(x)             (*(__I hw_rcm_mr_t *) HW_RCM_MR_ADDR(x))
#define HW_RCM_MR_RD(x)          (HW_RCM_MR(x).U)
/*@}*/

/*
 * Constants & macros for individual RCM_MR bitfields
 */

/*!
 * @name Register RCM_MR, field EZP_MS[1] (RO)
 *
 * Reflects the state of the EZP_MS pin during the last Chip Reset
 *
 * Values:
 * - 0 - Pin deasserted (logic 1)
 * - 1 - Pin asserted (logic 0)
 */
/*@{*/
#define BP_RCM_MR_EZP_MS     (1U)          /*!< Bit position for RCM_MR_EZP_MS. */
#define BM_RCM_MR_EZP_MS     (0x02U)       /*!< Bit mask for RCM_MR_EZP_MS. */
#define BS_RCM_MR_EZP_MS     (1U)          /*!< Bit field size in bits for RCM_MR_EZP_MS. */

/*! @brief Read current value of the RCM_MR_EZP_MS field. */
#define BR_RCM_MR_EZP_MS(x)  (BITBAND_ACCESS8(HW_RCM_MR_ADDR(x), BP_RCM_MR_EZP_MS))
/*@}*/

/*******************************************************************************
 * hw_rcm_t - module struct
 ******************************************************************************/
/*!
 * @brief All RCM module registers.
 */
#pragma pack(1)
typedef struct _hw_rcm
{
    __I hw_rcm_srs0_t SRS0;                /*!< [0x0] System Reset Status Register 0 */
    __I hw_rcm_srs1_t SRS1;                /*!< [0x1] System Reset Status Register 1 */
    uint8_t _reserved0[2];
    __IO hw_rcm_rpfc_t RPFC;               /*!< [0x4] Reset Pin Filter Control register */
    __IO hw_rcm_rpfw_t RPFW;               /*!< [0x5] Reset Pin Filter Width register */
    uint8_t _reserved1[1];
    __I hw_rcm_mr_t MR;                    /*!< [0x7] Mode Register */
} hw_rcm_t;
#pragma pack()

/*! @brief Macro to access all RCM registers. */
/*! @param x RCM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_RCM_REGS(RCM_BASE)</code>. */
#define HW_RCM_REGS(x) (*(hw_rcm_t *)(x))

/*
 * MK64F12 RFSYS
 *
 * System register file
 *
 * Registers defined in this header file:
 * - HW_RFSYS_REGn - Register file register
 *
 * - hw_rfsys_t - Struct containing all module registers.
 */

#define HW_RFSYS_INSTANCE_COUNT (1U) /*!< Number of instances of the RFSYS module. */
#define HW_RFSYS (0U) /*!< Instance number for RFSYS. */

/*******************************************************************************
 * HW_RFSYS_REGn - Register file register
 ******************************************************************************/

/*!
 * @brief HW_RFSYS_REGn - Register file register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each register can be accessed as 8-, 16-, or 32-bits.
 */
typedef union _hw_rfsys_regn
{
    uint32_t U;
    struct _hw_rfsys_regn_bitfields
    {
        uint32_t LL : 8;               /*!< [7:0]  */
        uint32_t LH : 8;               /*!< [15:8]  */
        uint32_t HL : 8;               /*!< [23:16]  */
        uint32_t HH : 8;               /*!< [31:24]  */
    } B;
} hw_rfsys_regn_t;

/*!
 * @name Constants and macros for entire RFSYS_REGn register
 */
/*@{*/
#define HW_RFSYS_REGn_COUNT (8U)

#define HW_RFSYS_REGn_ADDR(x, n) ((uint32_t)(x) + 0x0U + (0x4U * (n)))

#define HW_RFSYS_REGn(x, n)      (*(__IO hw_rfsys_regn_t *) HW_RFSYS_REGn_ADDR(x, n))
#define HW_RFSYS_REGn_RD(x, n)   (HW_RFSYS_REGn(x, n).U)
#define HW_RFSYS_REGn_WR(x, n, v) (HW_RFSYS_REGn(x, n).U = (v))
#define HW_RFSYS_REGn_SET(x, n, v) (HW_RFSYS_REGn_WR(x, n, HW_RFSYS_REGn_RD(x, n) |  (v)))
#define HW_RFSYS_REGn_CLR(x, n, v) (HW_RFSYS_REGn_WR(x, n, HW_RFSYS_REGn_RD(x, n) & ~(v)))
#define HW_RFSYS_REGn_TOG(x, n, v) (HW_RFSYS_REGn_WR(x, n, HW_RFSYS_REGn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RFSYS_REGn bitfields
 */

/*!
 * @name Register RFSYS_REGn, field LL[7:0] (RW)
 *
 * Low lower byte
 */
/*@{*/
#define BP_RFSYS_REGn_LL     (0U)          /*!< Bit position for RFSYS_REGn_LL. */
#define BM_RFSYS_REGn_LL     (0x000000FFU) /*!< Bit mask for RFSYS_REGn_LL. */
#define BS_RFSYS_REGn_LL     (8U)          /*!< Bit field size in bits for RFSYS_REGn_LL. */

/*! @brief Read current value of the RFSYS_REGn_LL field. */
#define BR_RFSYS_REGn_LL(x, n) (HW_RFSYS_REGn(x, n).B.LL)

/*! @brief Format value for bitfield RFSYS_REGn_LL. */
#define BF_RFSYS_REGn_LL(v)  ((uint32_t)((uint32_t)(v) << BP_RFSYS_REGn_LL) & BM_RFSYS_REGn_LL)

/*! @brief Set the LL field to a new value. */
#define BW_RFSYS_REGn_LL(x, n, v) (HW_RFSYS_REGn_WR(x, n, (HW_RFSYS_REGn_RD(x, n) & ~BM_RFSYS_REGn_LL) | BF_RFSYS_REGn_LL(v)))
/*@}*/

/*!
 * @name Register RFSYS_REGn, field LH[15:8] (RW)
 *
 * Low higher byte
 */
/*@{*/
#define BP_RFSYS_REGn_LH     (8U)          /*!< Bit position for RFSYS_REGn_LH. */
#define BM_RFSYS_REGn_LH     (0x0000FF00U) /*!< Bit mask for RFSYS_REGn_LH. */
#define BS_RFSYS_REGn_LH     (8U)          /*!< Bit field size in bits for RFSYS_REGn_LH. */

/*! @brief Read current value of the RFSYS_REGn_LH field. */
#define BR_RFSYS_REGn_LH(x, n) (HW_RFSYS_REGn(x, n).B.LH)

/*! @brief Format value for bitfield RFSYS_REGn_LH. */
#define BF_RFSYS_REGn_LH(v)  ((uint32_t)((uint32_t)(v) << BP_RFSYS_REGn_LH) & BM_RFSYS_REGn_LH)

/*! @brief Set the LH field to a new value. */
#define BW_RFSYS_REGn_LH(x, n, v) (HW_RFSYS_REGn_WR(x, n, (HW_RFSYS_REGn_RD(x, n) & ~BM_RFSYS_REGn_LH) | BF_RFSYS_REGn_LH(v)))
/*@}*/

/*!
 * @name Register RFSYS_REGn, field HL[23:16] (RW)
 *
 * High lower byte
 */
/*@{*/
#define BP_RFSYS_REGn_HL     (16U)         /*!< Bit position for RFSYS_REGn_HL. */
#define BM_RFSYS_REGn_HL     (0x00FF0000U) /*!< Bit mask for RFSYS_REGn_HL. */
#define BS_RFSYS_REGn_HL     (8U)          /*!< Bit field size in bits for RFSYS_REGn_HL. */

/*! @brief Read current value of the RFSYS_REGn_HL field. */
#define BR_RFSYS_REGn_HL(x, n) (HW_RFSYS_REGn(x, n).B.HL)

/*! @brief Format value for bitfield RFSYS_REGn_HL. */
#define BF_RFSYS_REGn_HL(v)  ((uint32_t)((uint32_t)(v) << BP_RFSYS_REGn_HL) & BM_RFSYS_REGn_HL)

/*! @brief Set the HL field to a new value. */
#define BW_RFSYS_REGn_HL(x, n, v) (HW_RFSYS_REGn_WR(x, n, (HW_RFSYS_REGn_RD(x, n) & ~BM_RFSYS_REGn_HL) | BF_RFSYS_REGn_HL(v)))
/*@}*/

/*!
 * @name Register RFSYS_REGn, field HH[31:24] (RW)
 *
 * High higher byte
 */
/*@{*/
#define BP_RFSYS_REGn_HH     (24U)         /*!< Bit position for RFSYS_REGn_HH. */
#define BM_RFSYS_REGn_HH     (0xFF000000U) /*!< Bit mask for RFSYS_REGn_HH. */
#define BS_RFSYS_REGn_HH     (8U)          /*!< Bit field size in bits for RFSYS_REGn_HH. */

/*! @brief Read current value of the RFSYS_REGn_HH field. */
#define BR_RFSYS_REGn_HH(x, n) (HW_RFSYS_REGn(x, n).B.HH)

/*! @brief Format value for bitfield RFSYS_REGn_HH. */
#define BF_RFSYS_REGn_HH(v)  ((uint32_t)((uint32_t)(v) << BP_RFSYS_REGn_HH) & BM_RFSYS_REGn_HH)

/*! @brief Set the HH field to a new value. */
#define BW_RFSYS_REGn_HH(x, n, v) (HW_RFSYS_REGn_WR(x, n, (HW_RFSYS_REGn_RD(x, n) & ~BM_RFSYS_REGn_HH) | BF_RFSYS_REGn_HH(v)))
/*@}*/

/*******************************************************************************
 * hw_rfsys_t - module struct
 ******************************************************************************/
/*!
 * @brief All RFSYS module registers.
 */
#pragma pack(1)
typedef struct _hw_rfsys
{
    __IO hw_rfsys_regn_t REGn[8];          /*!< [0x0] Register file register */
} hw_rfsys_t;
#pragma pack()

/*! @brief Macro to access all RFSYS registers. */
/*! @param x RFSYS module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_RFSYS_REGS(RFSYS_BASE)</code>. */
#define HW_RFSYS_REGS(x) (*(hw_rfsys_t *)(x))

/*
 * MK64F12 RFVBAT
 *
 * VBAT register file
 *
 * Registers defined in this header file:
 * - HW_RFVBAT_REGn - VBAT register file register
 *
 * - hw_rfvbat_t - Struct containing all module registers.
 */

#define HW_RFVBAT_INSTANCE_COUNT (1U) /*!< Number of instances of the RFVBAT module. */
#define HW_RFVBAT (0U) /*!< Instance number for RFVBAT. */

/*******************************************************************************
 * HW_RFVBAT_REGn - VBAT register file register
 ******************************************************************************/

/*!
 * @brief HW_RFVBAT_REGn - VBAT register file register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each register can be accessed as 8-, 16-, or 32-bits.
 */
typedef union _hw_rfvbat_regn
{
    uint32_t U;
    struct _hw_rfvbat_regn_bitfields
    {
        uint32_t LL : 8;               /*!< [7:0]  */
        uint32_t LH : 8;               /*!< [15:8]  */
        uint32_t HL : 8;               /*!< [23:16]  */
        uint32_t HH : 8;               /*!< [31:24]  */
    } B;
} hw_rfvbat_regn_t;

/*!
 * @name Constants and macros for entire RFVBAT_REGn register
 */
/*@{*/
#define HW_RFVBAT_REGn_COUNT (8U)

#define HW_RFVBAT_REGn_ADDR(x, n) ((uint32_t)(x) + 0x0U + (0x4U * (n)))

#define HW_RFVBAT_REGn(x, n)     (*(__IO hw_rfvbat_regn_t *) HW_RFVBAT_REGn_ADDR(x, n))
#define HW_RFVBAT_REGn_RD(x, n)  (HW_RFVBAT_REGn(x, n).U)
#define HW_RFVBAT_REGn_WR(x, n, v) (HW_RFVBAT_REGn(x, n).U = (v))
#define HW_RFVBAT_REGn_SET(x, n, v) (HW_RFVBAT_REGn_WR(x, n, HW_RFVBAT_REGn_RD(x, n) |  (v)))
#define HW_RFVBAT_REGn_CLR(x, n, v) (HW_RFVBAT_REGn_WR(x, n, HW_RFVBAT_REGn_RD(x, n) & ~(v)))
#define HW_RFVBAT_REGn_TOG(x, n, v) (HW_RFVBAT_REGn_WR(x, n, HW_RFVBAT_REGn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RFVBAT_REGn bitfields
 */

/*!
 * @name Register RFVBAT_REGn, field LL[7:0] (RW)
 *
 * Low lower byte
 */
/*@{*/
#define BP_RFVBAT_REGn_LL    (0U)          /*!< Bit position for RFVBAT_REGn_LL. */
#define BM_RFVBAT_REGn_LL    (0x000000FFU) /*!< Bit mask for RFVBAT_REGn_LL. */
#define BS_RFVBAT_REGn_LL    (8U)          /*!< Bit field size in bits for RFVBAT_REGn_LL. */

/*! @brief Read current value of the RFVBAT_REGn_LL field. */
#define BR_RFVBAT_REGn_LL(x, n) (HW_RFVBAT_REGn(x, n).B.LL)

/*! @brief Format value for bitfield RFVBAT_REGn_LL. */
#define BF_RFVBAT_REGn_LL(v) ((uint32_t)((uint32_t)(v) << BP_RFVBAT_REGn_LL) & BM_RFVBAT_REGn_LL)

/*! @brief Set the LL field to a new value. */
#define BW_RFVBAT_REGn_LL(x, n, v) (HW_RFVBAT_REGn_WR(x, n, (HW_RFVBAT_REGn_RD(x, n) & ~BM_RFVBAT_REGn_LL) | BF_RFVBAT_REGn_LL(v)))
/*@}*/

/*!
 * @name Register RFVBAT_REGn, field LH[15:8] (RW)
 *
 * Low higher byte
 */
/*@{*/
#define BP_RFVBAT_REGn_LH    (8U)          /*!< Bit position for RFVBAT_REGn_LH. */
#define BM_RFVBAT_REGn_LH    (0x0000FF00U) /*!< Bit mask for RFVBAT_REGn_LH. */
#define BS_RFVBAT_REGn_LH    (8U)          /*!< Bit field size in bits for RFVBAT_REGn_LH. */

/*! @brief Read current value of the RFVBAT_REGn_LH field. */
#define BR_RFVBAT_REGn_LH(x, n) (HW_RFVBAT_REGn(x, n).B.LH)

/*! @brief Format value for bitfield RFVBAT_REGn_LH. */
#define BF_RFVBAT_REGn_LH(v) ((uint32_t)((uint32_t)(v) << BP_RFVBAT_REGn_LH) & BM_RFVBAT_REGn_LH)

/*! @brief Set the LH field to a new value. */
#define BW_RFVBAT_REGn_LH(x, n, v) (HW_RFVBAT_REGn_WR(x, n, (HW_RFVBAT_REGn_RD(x, n) & ~BM_RFVBAT_REGn_LH) | BF_RFVBAT_REGn_LH(v)))
/*@}*/

/*!
 * @name Register RFVBAT_REGn, field HL[23:16] (RW)
 *
 * High lower byte
 */
/*@{*/
#define BP_RFVBAT_REGn_HL    (16U)         /*!< Bit position for RFVBAT_REGn_HL. */
#define BM_RFVBAT_REGn_HL    (0x00FF0000U) /*!< Bit mask for RFVBAT_REGn_HL. */
#define BS_RFVBAT_REGn_HL    (8U)          /*!< Bit field size in bits for RFVBAT_REGn_HL. */

/*! @brief Read current value of the RFVBAT_REGn_HL field. */
#define BR_RFVBAT_REGn_HL(x, n) (HW_RFVBAT_REGn(x, n).B.HL)

/*! @brief Format value for bitfield RFVBAT_REGn_HL. */
#define BF_RFVBAT_REGn_HL(v) ((uint32_t)((uint32_t)(v) << BP_RFVBAT_REGn_HL) & BM_RFVBAT_REGn_HL)

/*! @brief Set the HL field to a new value. */
#define BW_RFVBAT_REGn_HL(x, n, v) (HW_RFVBAT_REGn_WR(x, n, (HW_RFVBAT_REGn_RD(x, n) & ~BM_RFVBAT_REGn_HL) | BF_RFVBAT_REGn_HL(v)))
/*@}*/

/*!
 * @name Register RFVBAT_REGn, field HH[31:24] (RW)
 *
 * High higher byte
 */
/*@{*/
#define BP_RFVBAT_REGn_HH    (24U)         /*!< Bit position for RFVBAT_REGn_HH. */
#define BM_RFVBAT_REGn_HH    (0xFF000000U) /*!< Bit mask for RFVBAT_REGn_HH. */
#define BS_RFVBAT_REGn_HH    (8U)          /*!< Bit field size in bits for RFVBAT_REGn_HH. */

/*! @brief Read current value of the RFVBAT_REGn_HH field. */
#define BR_RFVBAT_REGn_HH(x, n) (HW_RFVBAT_REGn(x, n).B.HH)

/*! @brief Format value for bitfield RFVBAT_REGn_HH. */
#define BF_RFVBAT_REGn_HH(v) ((uint32_t)((uint32_t)(v) << BP_RFVBAT_REGn_HH) & BM_RFVBAT_REGn_HH)

/*! @brief Set the HH field to a new value. */
#define BW_RFVBAT_REGn_HH(x, n, v) (HW_RFVBAT_REGn_WR(x, n, (HW_RFVBAT_REGn_RD(x, n) & ~BM_RFVBAT_REGn_HH) | BF_RFVBAT_REGn_HH(v)))
/*@}*/

/*******************************************************************************
 * hw_rfvbat_t - module struct
 ******************************************************************************/
/*!
 * @brief All RFVBAT module registers.
 */
#pragma pack(1)
typedef struct _hw_rfvbat
{
    __IO hw_rfvbat_regn_t REGn[8];         /*!< [0x0] VBAT register file register */
} hw_rfvbat_t;
#pragma pack()

/*! @brief Macro to access all RFVBAT registers. */
/*! @param x RFVBAT module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_RFVBAT_REGS(RFVBAT_BASE)</code>. */
#define HW_RFVBAT_REGS(x) (*(hw_rfvbat_t *)(x))

/*
 * MK64F12 RNG
 *
 * Random Number Generator Accelerator
 *
 * Registers defined in this header file:
 * - HW_RNG_CR - RNGA Control Register
 * - HW_RNG_SR - RNGA Status Register
 * - HW_RNG_ER - RNGA Entropy Register
 * - HW_RNG_OR - RNGA Output Register
 *
 * - hw_rng_t - Struct containing all module registers.
 */

#define HW_RNG_INSTANCE_COUNT (1U) /*!< Number of instances of the RNG module. */
#define HW_RNG (0U) /*!< Instance number for RNG. */

/*******************************************************************************
 * HW_RNG_CR - RNGA Control Register
 ******************************************************************************/

/*!
 * @brief HW_RNG_CR - RNGA Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Controls the operation of RNGA.
 */
typedef union _hw_rng_cr
{
    uint32_t U;
    struct _hw_rng_cr_bitfields
    {
        uint32_t GO : 1;               /*!< [0] Go */
        uint32_t HA : 1;               /*!< [1] High Assurance */
        uint32_t INTM : 1;             /*!< [2] Interrupt Mask */
        uint32_t CLRI : 1;             /*!< [3] Clear Interrupt */
        uint32_t SLP : 1;              /*!< [4] Sleep */
        uint32_t RESERVED0 : 27;       /*!< [31:5]  */
    } B;
} hw_rng_cr_t;

/*!
 * @name Constants and macros for entire RNG_CR register
 */
/*@{*/
#define HW_RNG_CR_ADDR(x)        ((uint32_t)(x) + 0x0U)

#define HW_RNG_CR(x)             (*(__IO hw_rng_cr_t *) HW_RNG_CR_ADDR(x))
#define HW_RNG_CR_RD(x)          (HW_RNG_CR(x).U)
#define HW_RNG_CR_WR(x, v)       (HW_RNG_CR(x).U = (v))
#define HW_RNG_CR_SET(x, v)      (HW_RNG_CR_WR(x, HW_RNG_CR_RD(x) |  (v)))
#define HW_RNG_CR_CLR(x, v)      (HW_RNG_CR_WR(x, HW_RNG_CR_RD(x) & ~(v)))
#define HW_RNG_CR_TOG(x, v)      (HW_RNG_CR_WR(x, HW_RNG_CR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RNG_CR bitfields
 */

/*!
 * @name Register RNG_CR, field GO[0] (RW)
 *
 * Specifies whether random-data generation and loading (into OR[RANDOUT]) is
 * enabled.This field is sticky. You must reset RNGA to stop RNGA from loading
 * OR[RANDOUT] with data.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_RNG_CR_GO         (0U)          /*!< Bit position for RNG_CR_GO. */
#define BM_RNG_CR_GO         (0x00000001U) /*!< Bit mask for RNG_CR_GO. */
#define BS_RNG_CR_GO         (1U)          /*!< Bit field size in bits for RNG_CR_GO. */

/*! @brief Read current value of the RNG_CR_GO field. */
#define BR_RNG_CR_GO(x)      (BITBAND_ACCESS32(HW_RNG_CR_ADDR(x), BP_RNG_CR_GO))

/*! @brief Format value for bitfield RNG_CR_GO. */
#define BF_RNG_CR_GO(v)      ((uint32_t)((uint32_t)(v) << BP_RNG_CR_GO) & BM_RNG_CR_GO)

/*! @brief Set the GO field to a new value. */
#define BW_RNG_CR_GO(x, v)   (BITBAND_ACCESS32(HW_RNG_CR_ADDR(x), BP_RNG_CR_GO) = (v))
/*@}*/

/*!
 * @name Register RNG_CR, field HA[1] (RW)
 *
 * Enables notification of security violations (via SR[SECV]). A security
 * violation occurs when you read OR[RANDOUT] and SR[OREG_LVL]=0. This field is sticky.
 * After enabling notification of security violations, you must reset RNGA to
 * disable them again.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_RNG_CR_HA         (1U)          /*!< Bit position for RNG_CR_HA. */
#define BM_RNG_CR_HA         (0x00000002U) /*!< Bit mask for RNG_CR_HA. */
#define BS_RNG_CR_HA         (1U)          /*!< Bit field size in bits for RNG_CR_HA. */

/*! @brief Read current value of the RNG_CR_HA field. */
#define BR_RNG_CR_HA(x)      (BITBAND_ACCESS32(HW_RNG_CR_ADDR(x), BP_RNG_CR_HA))

/*! @brief Format value for bitfield RNG_CR_HA. */
#define BF_RNG_CR_HA(v)      ((uint32_t)((uint32_t)(v) << BP_RNG_CR_HA) & BM_RNG_CR_HA)

/*! @brief Set the HA field to a new value. */
#define BW_RNG_CR_HA(x, v)   (BITBAND_ACCESS32(HW_RNG_CR_ADDR(x), BP_RNG_CR_HA) = (v))
/*@}*/

/*!
 * @name Register RNG_CR, field INTM[2] (RW)
 *
 * Masks the triggering of an error interrupt to the interrupt controller when
 * an OR underflow condition occurs. An OR underflow condition occurs when you
 * read OR[RANDOUT] and SR[OREG_LVL]=0. See the Output Register (OR) description.
 *
 * Values:
 * - 0 - Not masked
 * - 1 - Masked
 */
/*@{*/
#define BP_RNG_CR_INTM       (2U)          /*!< Bit position for RNG_CR_INTM. */
#define BM_RNG_CR_INTM       (0x00000004U) /*!< Bit mask for RNG_CR_INTM. */
#define BS_RNG_CR_INTM       (1U)          /*!< Bit field size in bits for RNG_CR_INTM. */

/*! @brief Read current value of the RNG_CR_INTM field. */
#define BR_RNG_CR_INTM(x)    (BITBAND_ACCESS32(HW_RNG_CR_ADDR(x), BP_RNG_CR_INTM))

/*! @brief Format value for bitfield RNG_CR_INTM. */
#define BF_RNG_CR_INTM(v)    ((uint32_t)((uint32_t)(v) << BP_RNG_CR_INTM) & BM_RNG_CR_INTM)

/*! @brief Set the INTM field to a new value. */
#define BW_RNG_CR_INTM(x, v) (BITBAND_ACCESS32(HW_RNG_CR_ADDR(x), BP_RNG_CR_INTM) = (v))
/*@}*/

/*!
 * @name Register RNG_CR, field CLRI[3] (WORZ)
 *
 * Clears the interrupt by resetting the error-interrupt indicator (SR[ERRI]).
 *
 * Values:
 * - 0 - Do not clear the interrupt.
 * - 1 - Clear the interrupt. When you write 1 to this field, RNGA then resets
 *     the error-interrupt indicator (SR[ERRI]). This bit always reads as 0.
 */
/*@{*/
#define BP_RNG_CR_CLRI       (3U)          /*!< Bit position for RNG_CR_CLRI. */
#define BM_RNG_CR_CLRI       (0x00000008U) /*!< Bit mask for RNG_CR_CLRI. */
#define BS_RNG_CR_CLRI       (1U)          /*!< Bit field size in bits for RNG_CR_CLRI. */

/*! @brief Format value for bitfield RNG_CR_CLRI. */
#define BF_RNG_CR_CLRI(v)    ((uint32_t)((uint32_t)(v) << BP_RNG_CR_CLRI) & BM_RNG_CR_CLRI)

/*! @brief Set the CLRI field to a new value. */
#define BW_RNG_CR_CLRI(x, v) (BITBAND_ACCESS32(HW_RNG_CR_ADDR(x), BP_RNG_CR_CLRI) = (v))
/*@}*/

/*!
 * @name Register RNG_CR, field SLP[4] (RW)
 *
 * Specifies whether RNGA is in Sleep or Normal mode. You can also enter Sleep
 * mode by asserting the DOZE signal.
 *
 * Values:
 * - 0 - Normal mode
 * - 1 - Sleep (low-power) mode
 */
/*@{*/
#define BP_RNG_CR_SLP        (4U)          /*!< Bit position for RNG_CR_SLP. */
#define BM_RNG_CR_SLP        (0x00000010U) /*!< Bit mask for RNG_CR_SLP. */
#define BS_RNG_CR_SLP        (1U)          /*!< Bit field size in bits for RNG_CR_SLP. */

/*! @brief Read current value of the RNG_CR_SLP field. */
#define BR_RNG_CR_SLP(x)     (BITBAND_ACCESS32(HW_RNG_CR_ADDR(x), BP_RNG_CR_SLP))

/*! @brief Format value for bitfield RNG_CR_SLP. */
#define BF_RNG_CR_SLP(v)     ((uint32_t)((uint32_t)(v) << BP_RNG_CR_SLP) & BM_RNG_CR_SLP)

/*! @brief Set the SLP field to a new value. */
#define BW_RNG_CR_SLP(x, v)  (BITBAND_ACCESS32(HW_RNG_CR_ADDR(x), BP_RNG_CR_SLP) = (v))
/*@}*/

/*******************************************************************************
 * HW_RNG_SR - RNGA Status Register
 ******************************************************************************/

/*!
 * @brief HW_RNG_SR - RNGA Status Register (RO)
 *
 * Reset value: 0x00010000U
 *
 * Indicates the status of RNGA. This register is read-only.
 */
typedef union _hw_rng_sr
{
    uint32_t U;
    struct _hw_rng_sr_bitfields
    {
        uint32_t SECV : 1;             /*!< [0] Security Violation */
        uint32_t LRS : 1;              /*!< [1] Last Read Status */
        uint32_t ORU : 1;              /*!< [2] Output Register Underflow */
        uint32_t ERRI : 1;             /*!< [3] Error Interrupt */
        uint32_t SLP : 1;              /*!< [4] Sleep */
        uint32_t RESERVED0 : 3;        /*!< [7:5]  */
        uint32_t OREG_LVL : 8;         /*!< [15:8] Output Register Level */
        uint32_t OREG_SIZE : 8;        /*!< [23:16] Output Register Size */
        uint32_t RESERVED1 : 8;        /*!< [31:24]  */
    } B;
} hw_rng_sr_t;

/*!
 * @name Constants and macros for entire RNG_SR register
 */
/*@{*/
#define HW_RNG_SR_ADDR(x)        ((uint32_t)(x) + 0x4U)

#define HW_RNG_SR(x)             (*(__I hw_rng_sr_t *) HW_RNG_SR_ADDR(x))
#define HW_RNG_SR_RD(x)          (HW_RNG_SR(x).U)
/*@}*/

/*
 * Constants & macros for individual RNG_SR bitfields
 */

/*!
 * @name Register RNG_SR, field SECV[0] (RO)
 *
 * Used only when high assurance is enabled (CR[HA]). Indicates that a security
 * violation has occurred.This field is sticky. To clear SR[SECV], you must reset
 * RNGA.
 *
 * Values:
 * - 0 - No security violation
 * - 1 - Security violation
 */
/*@{*/
#define BP_RNG_SR_SECV       (0U)          /*!< Bit position for RNG_SR_SECV. */
#define BM_RNG_SR_SECV       (0x00000001U) /*!< Bit mask for RNG_SR_SECV. */
#define BS_RNG_SR_SECV       (1U)          /*!< Bit field size in bits for RNG_SR_SECV. */

/*! @brief Read current value of the RNG_SR_SECV field. */
#define BR_RNG_SR_SECV(x)    (BITBAND_ACCESS32(HW_RNG_SR_ADDR(x), BP_RNG_SR_SECV))
/*@}*/

/*!
 * @name Register RNG_SR, field LRS[1] (RO)
 *
 * Indicates whether the most recent read of OR[RANDOUT] caused an OR underflow
 * condition, regardless of whether the error interrupt is masked (CR[INTM]). An
 * OR underflow condition occurs when you read OR[RANDOUT] and SR[OREG_LVL]=0.
 * After you read this register, RNGA writes 0 to this field.
 *
 * Values:
 * - 0 - No underflow
 * - 1 - Underflow
 */
/*@{*/
#define BP_RNG_SR_LRS        (1U)          /*!< Bit position for RNG_SR_LRS. */
#define BM_RNG_SR_LRS        (0x00000002U) /*!< Bit mask for RNG_SR_LRS. */
#define BS_RNG_SR_LRS        (1U)          /*!< Bit field size in bits for RNG_SR_LRS. */

/*! @brief Read current value of the RNG_SR_LRS field. */
#define BR_RNG_SR_LRS(x)     (BITBAND_ACCESS32(HW_RNG_SR_ADDR(x), BP_RNG_SR_LRS))
/*@}*/

/*!
 * @name Register RNG_SR, field ORU[2] (RO)
 *
 * Indicates whether an OR underflow condition has occurred since you last read
 * this register (SR) or RNGA was reset, regardless of whether the error
 * interrupt is masked (CR[INTM]). An OR underflow condition occurs when you read
 * OR[RANDOUT] and SR[OREG_LVL]=0. After you read this register, RNGA writes 0 to this
 * field.
 *
 * Values:
 * - 0 - No underflow
 * - 1 - Underflow
 */
/*@{*/
#define BP_RNG_SR_ORU        (2U)          /*!< Bit position for RNG_SR_ORU. */
#define BM_RNG_SR_ORU        (0x00000004U) /*!< Bit mask for RNG_SR_ORU. */
#define BS_RNG_SR_ORU        (1U)          /*!< Bit field size in bits for RNG_SR_ORU. */

/*! @brief Read current value of the RNG_SR_ORU field. */
#define BR_RNG_SR_ORU(x)     (BITBAND_ACCESS32(HW_RNG_SR_ADDR(x), BP_RNG_SR_ORU))
/*@}*/

/*!
 * @name Register RNG_SR, field ERRI[3] (RO)
 *
 * Indicates whether an OR underflow condition has occurred since you last
 * cleared the error interrupt (CR[CLRI]) or RNGA was reset, regardless of whether the
 * error interrupt is masked (CR[INTM]). An OR underflow condition occurs when
 * you read OR[RANDOUT] and SR[OREG_LVL]=0. After you reset the error-interrupt
 * indicator (via CR[CLRI]), RNGA writes 0 to this field.
 *
 * Values:
 * - 0 - No underflow
 * - 1 - Underflow
 */
/*@{*/
#define BP_RNG_SR_ERRI       (3U)          /*!< Bit position for RNG_SR_ERRI. */
#define BM_RNG_SR_ERRI       (0x00000008U) /*!< Bit mask for RNG_SR_ERRI. */
#define BS_RNG_SR_ERRI       (1U)          /*!< Bit field size in bits for RNG_SR_ERRI. */

/*! @brief Read current value of the RNG_SR_ERRI field. */
#define BR_RNG_SR_ERRI(x)    (BITBAND_ACCESS32(HW_RNG_SR_ADDR(x), BP_RNG_SR_ERRI))
/*@}*/

/*!
 * @name Register RNG_SR, field SLP[4] (RO)
 *
 * Specifies whether RNGA is in Sleep or Normal mode. You can also enter Sleep
 * mode by asserting the DOZE signal.
 *
 * Values:
 * - 0 - Normal mode
 * - 1 - Sleep (low-power) mode
 */
/*@{*/
#define BP_RNG_SR_SLP        (4U)          /*!< Bit position for RNG_SR_SLP. */
#define BM_RNG_SR_SLP        (0x00000010U) /*!< Bit mask for RNG_SR_SLP. */
#define BS_RNG_SR_SLP        (1U)          /*!< Bit field size in bits for RNG_SR_SLP. */

/*! @brief Read current value of the RNG_SR_SLP field. */
#define BR_RNG_SR_SLP(x)     (BITBAND_ACCESS32(HW_RNG_SR_ADDR(x), BP_RNG_SR_SLP))
/*@}*/

/*!
 * @name Register RNG_SR, field OREG_LVL[15:8] (RO)
 *
 * Indicates the number of random-data words that are in OR[RANDOUT], which
 * indicates whether OR[RANDOUT] is valid.If you read OR[RANDOUT] when SR[OREG_LVL]
 * is not 0, then the contents of a random number contained in OR[RANDOUT] are
 * returned, and RNGA writes 0 to both OR[RANDOUT] and SR[OREG_LVL].
 *
 * Values:
 * - 0 - No words (empty)
 * - 1 - One word (valid)
 */
/*@{*/
#define BP_RNG_SR_OREG_LVL   (8U)          /*!< Bit position for RNG_SR_OREG_LVL. */
#define BM_RNG_SR_OREG_LVL   (0x0000FF00U) /*!< Bit mask for RNG_SR_OREG_LVL. */
#define BS_RNG_SR_OREG_LVL   (8U)          /*!< Bit field size in bits for RNG_SR_OREG_LVL. */

/*! @brief Read current value of the RNG_SR_OREG_LVL field. */
#define BR_RNG_SR_OREG_LVL(x) (HW_RNG_SR(x).B.OREG_LVL)
/*@}*/

/*!
 * @name Register RNG_SR, field OREG_SIZE[23:16] (RO)
 *
 * Indicates the size of the Output (OR) register in terms of the number of
 * 32-bit random-data words it can hold.
 *
 * Values:
 * - 1 - One word (this value is fixed)
 */
/*@{*/
#define BP_RNG_SR_OREG_SIZE  (16U)         /*!< Bit position for RNG_SR_OREG_SIZE. */
#define BM_RNG_SR_OREG_SIZE  (0x00FF0000U) /*!< Bit mask for RNG_SR_OREG_SIZE. */
#define BS_RNG_SR_OREG_SIZE  (8U)          /*!< Bit field size in bits for RNG_SR_OREG_SIZE. */

/*! @brief Read current value of the RNG_SR_OREG_SIZE field. */
#define BR_RNG_SR_OREG_SIZE(x) (HW_RNG_SR(x).B.OREG_SIZE)
/*@}*/

/*******************************************************************************
 * HW_RNG_ER - RNGA Entropy Register
 ******************************************************************************/

/*!
 * @brief HW_RNG_ER - RNGA Entropy Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Specifies an entropy value that RNGA uses in addition to its ring oscillators
 * to seed its pseudorandom algorithm. This is a write-only register; reads
 * return all zeros.
 */
typedef union _hw_rng_er
{
    uint32_t U;
    struct _hw_rng_er_bitfields
    {
        uint32_t EXT_ENT : 32;         /*!< [31:0] External Entropy */
    } B;
} hw_rng_er_t;

/*!
 * @name Constants and macros for entire RNG_ER register
 */
/*@{*/
#define HW_RNG_ER_ADDR(x)        ((uint32_t)(x) + 0x8U)

#define HW_RNG_ER(x)             (*(__O hw_rng_er_t *) HW_RNG_ER_ADDR(x))
#define HW_RNG_ER_RD(x)          (HW_RNG_ER(x).U)
#define HW_RNG_ER_WR(x, v)       (HW_RNG_ER(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual RNG_ER bitfields
 */

/*!
 * @name Register RNG_ER, field EXT_ENT[31:0] (WORZ)
 *
 * Specifies an entropy value that RNGA uses in addition to its ring oscillators
 * to seed its pseudorandom algorithm.Specifying a value for this field is
 * optional but recommended. You can write to this field at any time during operation.
 */
/*@{*/
#define BP_RNG_ER_EXT_ENT    (0U)          /*!< Bit position for RNG_ER_EXT_ENT. */
#define BM_RNG_ER_EXT_ENT    (0xFFFFFFFFU) /*!< Bit mask for RNG_ER_EXT_ENT. */
#define BS_RNG_ER_EXT_ENT    (32U)         /*!< Bit field size in bits for RNG_ER_EXT_ENT. */

/*! @brief Format value for bitfield RNG_ER_EXT_ENT. */
#define BF_RNG_ER_EXT_ENT(v) ((uint32_t)((uint32_t)(v) << BP_RNG_ER_EXT_ENT) & BM_RNG_ER_EXT_ENT)

/*! @brief Set the EXT_ENT field to a new value. */
#define BW_RNG_ER_EXT_ENT(x, v) (HW_RNG_ER_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_RNG_OR - RNGA Output Register
 ******************************************************************************/

/*!
 * @brief HW_RNG_OR - RNGA Output Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Stores a random-data word generated by RNGA.
 */
typedef union _hw_rng_or
{
    uint32_t U;
    struct _hw_rng_or_bitfields
    {
        uint32_t RANDOUT : 32;         /*!< [31:0] Random Output */
    } B;
} hw_rng_or_t;

/*!
 * @name Constants and macros for entire RNG_OR register
 */
/*@{*/
#define HW_RNG_OR_ADDR(x)        ((uint32_t)(x) + 0xCU)

#define HW_RNG_OR(x)             (*(__I hw_rng_or_t *) HW_RNG_OR_ADDR(x))
#define HW_RNG_OR_RD(x)          (HW_RNG_OR(x).U)
/*@}*/

/*
 * Constants & macros for individual RNG_OR bitfields
 */

/*!
 * @name Register RNG_OR, field RANDOUT[31:0] (RO)
 *
 * Stores a random-data word generated by RNGA. This is a read-only field.Before
 * reading RANDOUT, be sure it is valid (SR[OREG_LVL]=1).
 *
 * Values:
 * - 0 - Invalid data (if you read this field when it is 0 and SR[OREG_LVL] is
 *     0, RNGA then writes 1 to SR[ERRI], SR[ORU], and SR[LRS]; when the error
 *     interrupt is not masked (CR[INTM]=0), RNGA also asserts an error interrupt
 *     request to the interrupt controller).
 */
/*@{*/
#define BP_RNG_OR_RANDOUT    (0U)          /*!< Bit position for RNG_OR_RANDOUT. */
#define BM_RNG_OR_RANDOUT    (0xFFFFFFFFU) /*!< Bit mask for RNG_OR_RANDOUT. */
#define BS_RNG_OR_RANDOUT    (32U)         /*!< Bit field size in bits for RNG_OR_RANDOUT. */

/*! @brief Read current value of the RNG_OR_RANDOUT field. */
#define BR_RNG_OR_RANDOUT(x) (HW_RNG_OR(x).U)
/*@}*/

/*******************************************************************************
 * hw_rng_t - module struct
 ******************************************************************************/
/*!
 * @brief All RNG module registers.
 */
#pragma pack(1)
typedef struct _hw_rng
{
    __IO hw_rng_cr_t CR;                   /*!< [0x0] RNGA Control Register */
    __I hw_rng_sr_t SR;                    /*!< [0x4] RNGA Status Register */
    __O hw_rng_er_t ER;                    /*!< [0x8] RNGA Entropy Register */
    __I hw_rng_or_t OR;                    /*!< [0xC] RNGA Output Register */
} hw_rng_t;
#pragma pack()

/*! @brief Macro to access all RNG registers. */
/*! @param x RNG module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_RNG_REGS(RNG_BASE)</code>. */
#define HW_RNG_REGS(x) (*(hw_rng_t *)(x))

/*
 * MK64F12 RTC
 *
 * Secure Real Time Clock
 *
 * Registers defined in this header file:
 * - HW_RTC_TSR - RTC Time Seconds Register
 * - HW_RTC_TPR - RTC Time Prescaler Register
 * - HW_RTC_TAR - RTC Time Alarm Register
 * - HW_RTC_TCR - RTC Time Compensation Register
 * - HW_RTC_CR - RTC Control Register
 * - HW_RTC_SR - RTC Status Register
 * - HW_RTC_LR - RTC Lock Register
 * - HW_RTC_IER - RTC Interrupt Enable Register
 * - HW_RTC_WAR - RTC Write Access Register
 * - HW_RTC_RAR - RTC Read Access Register
 *
 * - hw_rtc_t - Struct containing all module registers.
 */

#define HW_RTC_INSTANCE_COUNT (1U) /*!< Number of instances of the RTC module. */
#define HW_RTC (0U) /*!< Instance number for RTC. */

/*******************************************************************************
 * HW_RTC_TSR - RTC Time Seconds Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_TSR - RTC Time Seconds Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tsr
{
    uint32_t U;
    struct _hw_rtc_tsr_bitfields
    {
        uint32_t TSR : 32;             /*!< [31:0] Time Seconds Register */
    } B;
} hw_rtc_tsr_t;

/*!
 * @name Constants and macros for entire RTC_TSR register
 */
/*@{*/
#define HW_RTC_TSR_ADDR(x)       ((uint32_t)(x) + 0x0U)

#define HW_RTC_TSR(x)            (*(__IO hw_rtc_tsr_t *) HW_RTC_TSR_ADDR(x))
#define HW_RTC_TSR_RD(x)         (HW_RTC_TSR(x).U)
#define HW_RTC_TSR_WR(x, v)      (HW_RTC_TSR(x).U = (v))
#define HW_RTC_TSR_SET(x, v)     (HW_RTC_TSR_WR(x, HW_RTC_TSR_RD(x) |  (v)))
#define HW_RTC_TSR_CLR(x, v)     (HW_RTC_TSR_WR(x, HW_RTC_TSR_RD(x) & ~(v)))
#define HW_RTC_TSR_TOG(x, v)     (HW_RTC_TSR_WR(x, HW_RTC_TSR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RTC_TSR bitfields
 */

/*!
 * @name Register RTC_TSR, field TSR[31:0] (RW)
 *
 * When the time counter is enabled, the TSR is read only and increments once a
 * second provided SR[TOF] or SR[TIF] are not set. The time counter will read as
 * zero when SR[TOF] or SR[TIF] are set. When the time counter is disabled, the
 * TSR can be read or written. Writing to the TSR when the time counter is
 * disabled will clear the SR[TOF] and/or the SR[TIF]. Writing to TSR with zero is
 * supported, but not recommended because TSR will read as zero when SR[TIF] or
 * SR[TOF] are set (indicating the time is invalid).
 */
/*@{*/
#define BP_RTC_TSR_TSR       (0U)          /*!< Bit position for RTC_TSR_TSR. */
#define BM_RTC_TSR_TSR       (0xFFFFFFFFU) /*!< Bit mask for RTC_TSR_TSR. */
#define BS_RTC_TSR_TSR       (32U)         /*!< Bit field size in bits for RTC_TSR_TSR. */

/*! @brief Read current value of the RTC_TSR_TSR field. */
#define BR_RTC_TSR_TSR(x)    (HW_RTC_TSR(x).U)

/*! @brief Format value for bitfield RTC_TSR_TSR. */
#define BF_RTC_TSR_TSR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_TSR_TSR) & BM_RTC_TSR_TSR)

/*! @brief Set the TSR field to a new value. */
#define BW_RTC_TSR_TSR(x, v) (HW_RTC_TSR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_RTC_TPR - RTC Time Prescaler Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_TPR - RTC Time Prescaler Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tpr
{
    uint32_t U;
    struct _hw_rtc_tpr_bitfields
    {
        uint32_t TPR : 16;             /*!< [15:0] Time Prescaler Register */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_rtc_tpr_t;

/*!
 * @name Constants and macros for entire RTC_TPR register
 */
/*@{*/
#define HW_RTC_TPR_ADDR(x)       ((uint32_t)(x) + 0x4U)

#define HW_RTC_TPR(x)            (*(__IO hw_rtc_tpr_t *) HW_RTC_TPR_ADDR(x))
#define HW_RTC_TPR_RD(x)         (HW_RTC_TPR(x).U)
#define HW_RTC_TPR_WR(x, v)      (HW_RTC_TPR(x).U = (v))
#define HW_RTC_TPR_SET(x, v)     (HW_RTC_TPR_WR(x, HW_RTC_TPR_RD(x) |  (v)))
#define HW_RTC_TPR_CLR(x, v)     (HW_RTC_TPR_WR(x, HW_RTC_TPR_RD(x) & ~(v)))
#define HW_RTC_TPR_TOG(x, v)     (HW_RTC_TPR_WR(x, HW_RTC_TPR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RTC_TPR bitfields
 */

/*!
 * @name Register RTC_TPR, field TPR[15:0] (RW)
 *
 * When the time counter is enabled, the TPR is read only and increments every
 * 32.768 kHz clock cycle. The time counter will read as zero when SR[TOF] or
 * SR[TIF] are set. When the time counter is disabled, the TPR can be read or
 * written. The TSR[TSR] increments when bit 14 of the TPR transitions from a logic one
 * to a logic zero.
 */
/*@{*/
#define BP_RTC_TPR_TPR       (0U)          /*!< Bit position for RTC_TPR_TPR. */
#define BM_RTC_TPR_TPR       (0x0000FFFFU) /*!< Bit mask for RTC_TPR_TPR. */
#define BS_RTC_TPR_TPR       (16U)         /*!< Bit field size in bits for RTC_TPR_TPR. */

/*! @brief Read current value of the RTC_TPR_TPR field. */
#define BR_RTC_TPR_TPR(x)    (HW_RTC_TPR(x).B.TPR)

/*! @brief Format value for bitfield RTC_TPR_TPR. */
#define BF_RTC_TPR_TPR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_TPR_TPR) & BM_RTC_TPR_TPR)

/*! @brief Set the TPR field to a new value. */
#define BW_RTC_TPR_TPR(x, v) (HW_RTC_TPR_WR(x, (HW_RTC_TPR_RD(x) & ~BM_RTC_TPR_TPR) | BF_RTC_TPR_TPR(v)))
/*@}*/

/*******************************************************************************
 * HW_RTC_TAR - RTC Time Alarm Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_TAR - RTC Time Alarm Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tar
{
    uint32_t U;
    struct _hw_rtc_tar_bitfields
    {
        uint32_t TAR : 32;             /*!< [31:0] Time Alarm Register */
    } B;
} hw_rtc_tar_t;

/*!
 * @name Constants and macros for entire RTC_TAR register
 */
/*@{*/
#define HW_RTC_TAR_ADDR(x)       ((uint32_t)(x) + 0x8U)

#define HW_RTC_TAR(x)            (*(__IO hw_rtc_tar_t *) HW_RTC_TAR_ADDR(x))
#define HW_RTC_TAR_RD(x)         (HW_RTC_TAR(x).U)
#define HW_RTC_TAR_WR(x, v)      (HW_RTC_TAR(x).U = (v))
#define HW_RTC_TAR_SET(x, v)     (HW_RTC_TAR_WR(x, HW_RTC_TAR_RD(x) |  (v)))
#define HW_RTC_TAR_CLR(x, v)     (HW_RTC_TAR_WR(x, HW_RTC_TAR_RD(x) & ~(v)))
#define HW_RTC_TAR_TOG(x, v)     (HW_RTC_TAR_WR(x, HW_RTC_TAR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RTC_TAR bitfields
 */

/*!
 * @name Register RTC_TAR, field TAR[31:0] (RW)
 *
 * When the time counter is enabled, the SR[TAF] is set whenever the TAR[TAR]
 * equals the TSR[TSR] and the TSR[TSR] increments. Writing to the TAR clears the
 * SR[TAF].
 */
/*@{*/
#define BP_RTC_TAR_TAR       (0U)          /*!< Bit position for RTC_TAR_TAR. */
#define BM_RTC_TAR_TAR       (0xFFFFFFFFU) /*!< Bit mask for RTC_TAR_TAR. */
#define BS_RTC_TAR_TAR       (32U)         /*!< Bit field size in bits for RTC_TAR_TAR. */

/*! @brief Read current value of the RTC_TAR_TAR field. */
#define BR_RTC_TAR_TAR(x)    (HW_RTC_TAR(x).U)

/*! @brief Format value for bitfield RTC_TAR_TAR. */
#define BF_RTC_TAR_TAR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_TAR_TAR) & BM_RTC_TAR_TAR)

/*! @brief Set the TAR field to a new value. */
#define BW_RTC_TAR_TAR(x, v) (HW_RTC_TAR_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_RTC_TCR - RTC Time Compensation Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_TCR - RTC Time Compensation Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_tcr
{
    uint32_t U;
    struct _hw_rtc_tcr_bitfields
    {
        uint32_t TCR : 8;              /*!< [7:0] Time Compensation Register */
        uint32_t CIR : 8;              /*!< [15:8] Compensation Interval Register */
        uint32_t TCV : 8;              /*!< [23:16] Time Compensation Value */
        uint32_t CIC : 8;              /*!< [31:24] Compensation Interval Counter */
    } B;
} hw_rtc_tcr_t;

/*!
 * @name Constants and macros for entire RTC_TCR register
 */
/*@{*/
#define HW_RTC_TCR_ADDR(x)       ((uint32_t)(x) + 0xCU)

#define HW_RTC_TCR(x)            (*(__IO hw_rtc_tcr_t *) HW_RTC_TCR_ADDR(x))
#define HW_RTC_TCR_RD(x)         (HW_RTC_TCR(x).U)
#define HW_RTC_TCR_WR(x, v)      (HW_RTC_TCR(x).U = (v))
#define HW_RTC_TCR_SET(x, v)     (HW_RTC_TCR_WR(x, HW_RTC_TCR_RD(x) |  (v)))
#define HW_RTC_TCR_CLR(x, v)     (HW_RTC_TCR_WR(x, HW_RTC_TCR_RD(x) & ~(v)))
#define HW_RTC_TCR_TOG(x, v)     (HW_RTC_TCR_WR(x, HW_RTC_TCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RTC_TCR bitfields
 */

/*!
 * @name Register RTC_TCR, field TCR[7:0] (RW)
 *
 * Configures the number of 32.768 kHz clock cycles in each second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 *
 * Values:
 * - 10000000 - Time Prescaler Register overflows every 32896 clock cycles.
 * - 11111111 - Time Prescaler Register overflows every 32769 clock cycles.
 * - 0 - Time Prescaler Register overflows every 32768 clock cycles.
 * - 1 - Time Prescaler Register overflows every 32767 clock cycles.
 * - 1111111 - Time Prescaler Register overflows every 32641 clock cycles.
 */
/*@{*/
#define BP_RTC_TCR_TCR       (0U)          /*!< Bit position for RTC_TCR_TCR. */
#define BM_RTC_TCR_TCR       (0x000000FFU) /*!< Bit mask for RTC_TCR_TCR. */
#define BS_RTC_TCR_TCR       (8U)          /*!< Bit field size in bits for RTC_TCR_TCR. */

/*! @brief Read current value of the RTC_TCR_TCR field. */
#define BR_RTC_TCR_TCR(x)    (HW_RTC_TCR(x).B.TCR)

/*! @brief Format value for bitfield RTC_TCR_TCR. */
#define BF_RTC_TCR_TCR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_TCR_TCR) & BM_RTC_TCR_TCR)

/*! @brief Set the TCR field to a new value. */
#define BW_RTC_TCR_TCR(x, v) (HW_RTC_TCR_WR(x, (HW_RTC_TCR_RD(x) & ~BM_RTC_TCR_TCR) | BF_RTC_TCR_TCR(v)))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIR[15:8] (RW)
 *
 * Configures the compensation interval in seconds from 1 to 256 to control how
 * frequently the TCR should adjust the number of 32.768 kHz cycles in each
 * second. The value written should be one less than the number of seconds. For
 * example, write zero to configure for a compensation interval of one second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 */
/*@{*/
#define BP_RTC_TCR_CIR       (8U)          /*!< Bit position for RTC_TCR_CIR. */
#define BM_RTC_TCR_CIR       (0x0000FF00U) /*!< Bit mask for RTC_TCR_CIR. */
#define BS_RTC_TCR_CIR       (8U)          /*!< Bit field size in bits for RTC_TCR_CIR. */

/*! @brief Read current value of the RTC_TCR_CIR field. */
#define BR_RTC_TCR_CIR(x)    (HW_RTC_TCR(x).B.CIR)

/*! @brief Format value for bitfield RTC_TCR_CIR. */
#define BF_RTC_TCR_CIR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_TCR_CIR) & BM_RTC_TCR_CIR)

/*! @brief Set the CIR field to a new value. */
#define BW_RTC_TCR_CIR(x, v) (HW_RTC_TCR_WR(x, (HW_RTC_TCR_RD(x) & ~BM_RTC_TCR_CIR) | BF_RTC_TCR_CIR(v)))
/*@}*/

/*!
 * @name Register RTC_TCR, field TCV[23:16] (RO)
 *
 * Current value used by the compensation logic for the present second interval.
 * Updated once a second if the CIC equals 0 with the contents of the TCR field.
 * If the CIC does not equal zero then it is loaded with zero (compensation is
 * not enabled for that second increment).
 */
/*@{*/
#define BP_RTC_TCR_TCV       (16U)         /*!< Bit position for RTC_TCR_TCV. */
#define BM_RTC_TCR_TCV       (0x00FF0000U) /*!< Bit mask for RTC_TCR_TCV. */
#define BS_RTC_TCR_TCV       (8U)          /*!< Bit field size in bits for RTC_TCR_TCV. */

/*! @brief Read current value of the RTC_TCR_TCV field. */
#define BR_RTC_TCR_TCV(x)    (HW_RTC_TCR(x).B.TCV)
/*@}*/

/*!
 * @name Register RTC_TCR, field CIC[31:24] (RO)
 *
 * Current value of the compensation interval counter. If the compensation
 * interval counter equals zero then it is loaded with the contents of the CIR. If the
 * CIC does not equal zero then it is decremented once a second.
 */
/*@{*/
#define BP_RTC_TCR_CIC       (24U)         /*!< Bit position for RTC_TCR_CIC. */
#define BM_RTC_TCR_CIC       (0xFF000000U) /*!< Bit mask for RTC_TCR_CIC. */
#define BS_RTC_TCR_CIC       (8U)          /*!< Bit field size in bits for RTC_TCR_CIC. */

/*! @brief Read current value of the RTC_TCR_CIC field. */
#define BR_RTC_TCR_CIC(x)    (HW_RTC_TCR(x).B.CIC)
/*@}*/

/*******************************************************************************
 * HW_RTC_CR - RTC Control Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_CR - RTC Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_rtc_cr
{
    uint32_t U;
    struct _hw_rtc_cr_bitfields
    {
        uint32_t SWR : 1;              /*!< [0] Software Reset */
        uint32_t WPE : 1;              /*!< [1] Wakeup Pin Enable */
        uint32_t SUP : 1;              /*!< [2] Supervisor Access */
        uint32_t UM : 1;               /*!< [3] Update Mode */
        uint32_t WPS : 1;              /*!< [4] Wakeup Pin Select */
        uint32_t RESERVED0 : 3;        /*!< [7:5]  */
        uint32_t OSCE : 1;             /*!< [8] Oscillator Enable */
        uint32_t CLKO : 1;             /*!< [9] Clock Output */
        uint32_t SC16P : 1;            /*!< [10] Oscillator 16pF Load Configure */
        uint32_t SC8P : 1;             /*!< [11] Oscillator 8pF Load Configure */
        uint32_t SC4P : 1;             /*!< [12] Oscillator 4pF Load Configure */
        uint32_t SC2P : 1;             /*!< [13] Oscillator 2pF Load Configure */
        uint32_t RESERVED1 : 18;       /*!< [31:14]  */
    } B;
} hw_rtc_cr_t;

/*!
 * @name Constants and macros for entire RTC_CR register
 */
/*@{*/
#define HW_RTC_CR_ADDR(x)        ((uint32_t)(x) + 0x10U)

#define HW_RTC_CR(x)             (*(__IO hw_rtc_cr_t *) HW_RTC_CR_ADDR(x))
#define HW_RTC_CR_RD(x)          (HW_RTC_CR(x).U)
#define HW_RTC_CR_WR(x, v)       (HW_RTC_CR(x).U = (v))
#define HW_RTC_CR_SET(x, v)      (HW_RTC_CR_WR(x, HW_RTC_CR_RD(x) |  (v)))
#define HW_RTC_CR_CLR(x, v)      (HW_RTC_CR_WR(x, HW_RTC_CR_RD(x) & ~(v)))
#define HW_RTC_CR_TOG(x, v)      (HW_RTC_CR_WR(x, HW_RTC_CR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RTC_CR bitfields
 */

/*!
 * @name Register RTC_CR, field SWR[0] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Resets all RTC registers except for the SWR bit and the RTC_WAR and
 *     RTC_RAR registers . The SWR bit is cleared by VBAT POR and by software
 *     explicitly clearing it.
 */
/*@{*/
#define BP_RTC_CR_SWR        (0U)          /*!< Bit position for RTC_CR_SWR. */
#define BM_RTC_CR_SWR        (0x00000001U) /*!< Bit mask for RTC_CR_SWR. */
#define BS_RTC_CR_SWR        (1U)          /*!< Bit field size in bits for RTC_CR_SWR. */

/*! @brief Read current value of the RTC_CR_SWR field. */
#define BR_RTC_CR_SWR(x)     (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SWR))

/*! @brief Format value for bitfield RTC_CR_SWR. */
#define BF_RTC_CR_SWR(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SWR) & BM_RTC_CR_SWR)

/*! @brief Set the SWR field to a new value. */
#define BW_RTC_CR_SWR(x, v)  (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SWR) = (v))
/*@}*/

/*!
 * @name Register RTC_CR, field WPE[1] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0 - Wakeup pin is disabled.
 * - 1 - Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 */
/*@{*/
#define BP_RTC_CR_WPE        (1U)          /*!< Bit position for RTC_CR_WPE. */
#define BM_RTC_CR_WPE        (0x00000002U) /*!< Bit mask for RTC_CR_WPE. */
#define BS_RTC_CR_WPE        (1U)          /*!< Bit field size in bits for RTC_CR_WPE. */

/*! @brief Read current value of the RTC_CR_WPE field. */
#define BR_RTC_CR_WPE(x)     (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_WPE))

/*! @brief Format value for bitfield RTC_CR_WPE. */
#define BF_RTC_CR_WPE(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_CR_WPE) & BM_RTC_CR_WPE)

/*! @brief Set the WPE field to a new value. */
#define BW_RTC_CR_WPE(x, v)  (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_WPE) = (v))
/*@}*/

/*!
 * @name Register RTC_CR, field SUP[2] (RW)
 *
 * Values:
 * - 0 - Non-supervisor mode write accesses are not supported and generate a bus
 *     error.
 * - 1 - Non-supervisor mode write accesses are supported.
 */
/*@{*/
#define BP_RTC_CR_SUP        (2U)          /*!< Bit position for RTC_CR_SUP. */
#define BM_RTC_CR_SUP        (0x00000004U) /*!< Bit mask for RTC_CR_SUP. */
#define BS_RTC_CR_SUP        (1U)          /*!< Bit field size in bits for RTC_CR_SUP. */

/*! @brief Read current value of the RTC_CR_SUP field. */
#define BR_RTC_CR_SUP(x)     (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SUP))

/*! @brief Format value for bitfield RTC_CR_SUP. */
#define BF_RTC_CR_SUP(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SUP) & BM_RTC_CR_SUP)

/*! @brief Set the SUP field to a new value. */
#define BW_RTC_CR_SUP(x, v)  (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SUP) = (v))
/*@}*/

/*!
 * @name Register RTC_CR, field UM[3] (RW)
 *
 * Allows SR[TCE] to be written even when the Status Register is locked. When
 * set, the SR[TCE] can always be written if the SR[TIF] or SR[TOF] are set or if
 * the SR[TCE] is clear.
 *
 * Values:
 * - 0 - Registers cannot be written when locked.
 * - 1 - Registers can be written when locked under limited conditions.
 */
/*@{*/
#define BP_RTC_CR_UM         (3U)          /*!< Bit position for RTC_CR_UM. */
#define BM_RTC_CR_UM         (0x00000008U) /*!< Bit mask for RTC_CR_UM. */
#define BS_RTC_CR_UM         (1U)          /*!< Bit field size in bits for RTC_CR_UM. */

/*! @brief Read current value of the RTC_CR_UM field. */
#define BR_RTC_CR_UM(x)      (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_UM))

/*! @brief Format value for bitfield RTC_CR_UM. */
#define BF_RTC_CR_UM(v)      ((uint32_t)((uint32_t)(v) << BP_RTC_CR_UM) & BM_RTC_CR_UM)

/*! @brief Set the UM field to a new value. */
#define BW_RTC_CR_UM(x, v)   (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_UM) = (v))
/*@}*/

/*!
 * @name Register RTC_CR, field WPS[4] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0 - Wakeup pin asserts (active low, open drain) if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 * - 1 - Wakeup pin instead outputs the RTC 32kHz clock, provided the wakeup pin
 *     is turned on and the 32kHz clock is output to other peripherals.
 */
/*@{*/
#define BP_RTC_CR_WPS        (4U)          /*!< Bit position for RTC_CR_WPS. */
#define BM_RTC_CR_WPS        (0x00000010U) /*!< Bit mask for RTC_CR_WPS. */
#define BS_RTC_CR_WPS        (1U)          /*!< Bit field size in bits for RTC_CR_WPS. */

/*! @brief Read current value of the RTC_CR_WPS field. */
#define BR_RTC_CR_WPS(x)     (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_WPS))

/*! @brief Format value for bitfield RTC_CR_WPS. */
#define BF_RTC_CR_WPS(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_CR_WPS) & BM_RTC_CR_WPS)

/*! @brief Set the WPS field to a new value. */
#define BW_RTC_CR_WPS(x, v)  (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_WPS) = (v))
/*@}*/

/*!
 * @name Register RTC_CR, field OSCE[8] (RW)
 *
 * Values:
 * - 0 - 32.768 kHz oscillator is disabled.
 * - 1 - 32.768 kHz oscillator is enabled. After setting this bit, wait the
 *     oscillator startup time before enabling the time counter to allow the 32.768
 *     kHz clock time to stabilize.
 */
/*@{*/
#define BP_RTC_CR_OSCE       (8U)          /*!< Bit position for RTC_CR_OSCE. */
#define BM_RTC_CR_OSCE       (0x00000100U) /*!< Bit mask for RTC_CR_OSCE. */
#define BS_RTC_CR_OSCE       (1U)          /*!< Bit field size in bits for RTC_CR_OSCE. */

/*! @brief Read current value of the RTC_CR_OSCE field. */
#define BR_RTC_CR_OSCE(x)    (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_OSCE))

/*! @brief Format value for bitfield RTC_CR_OSCE. */
#define BF_RTC_CR_OSCE(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_CR_OSCE) & BM_RTC_CR_OSCE)

/*! @brief Set the OSCE field to a new value. */
#define BW_RTC_CR_OSCE(x, v) (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_OSCE) = (v))
/*@}*/

/*!
 * @name Register RTC_CR, field CLKO[9] (RW)
 *
 * Values:
 * - 0 - The 32 kHz clock is output to other peripherals.
 * - 1 - The 32 kHz clock is not output to other peripherals.
 */
/*@{*/
#define BP_RTC_CR_CLKO       (9U)          /*!< Bit position for RTC_CR_CLKO. */
#define BM_RTC_CR_CLKO       (0x00000200U) /*!< Bit mask for RTC_CR_CLKO. */
#define BS_RTC_CR_CLKO       (1U)          /*!< Bit field size in bits for RTC_CR_CLKO. */

/*! @brief Read current value of the RTC_CR_CLKO field. */
#define BR_RTC_CR_CLKO(x)    (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_CLKO))

/*! @brief Format value for bitfield RTC_CR_CLKO. */
#define BF_RTC_CR_CLKO(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_CR_CLKO) & BM_RTC_CR_CLKO)

/*! @brief Set the CLKO field to a new value. */
#define BW_RTC_CR_CLKO(x, v) (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_CLKO) = (v))
/*@}*/

/*!
 * @name Register RTC_CR, field SC16P[10] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
#define BP_RTC_CR_SC16P      (10U)         /*!< Bit position for RTC_CR_SC16P. */
#define BM_RTC_CR_SC16P      (0x00000400U) /*!< Bit mask for RTC_CR_SC16P. */
#define BS_RTC_CR_SC16P      (1U)          /*!< Bit field size in bits for RTC_CR_SC16P. */

/*! @brief Read current value of the RTC_CR_SC16P field. */
#define BR_RTC_CR_SC16P(x)   (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC16P))

/*! @brief Format value for bitfield RTC_CR_SC16P. */
#define BF_RTC_CR_SC16P(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SC16P) & BM_RTC_CR_SC16P)

/*! @brief Set the SC16P field to a new value. */
#define BW_RTC_CR_SC16P(x, v) (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC16P) = (v))
/*@}*/

/*!
 * @name Register RTC_CR, field SC8P[11] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
#define BP_RTC_CR_SC8P       (11U)         /*!< Bit position for RTC_CR_SC8P. */
#define BM_RTC_CR_SC8P       (0x00000800U) /*!< Bit mask for RTC_CR_SC8P. */
#define BS_RTC_CR_SC8P       (1U)          /*!< Bit field size in bits for RTC_CR_SC8P. */

/*! @brief Read current value of the RTC_CR_SC8P field. */
#define BR_RTC_CR_SC8P(x)    (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC8P))

/*! @brief Format value for bitfield RTC_CR_SC8P. */
#define BF_RTC_CR_SC8P(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SC8P) & BM_RTC_CR_SC8P)

/*! @brief Set the SC8P field to a new value. */
#define BW_RTC_CR_SC8P(x, v) (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC8P) = (v))
/*@}*/

/*!
 * @name Register RTC_CR, field SC4P[12] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
#define BP_RTC_CR_SC4P       (12U)         /*!< Bit position for RTC_CR_SC4P. */
#define BM_RTC_CR_SC4P       (0x00001000U) /*!< Bit mask for RTC_CR_SC4P. */
#define BS_RTC_CR_SC4P       (1U)          /*!< Bit field size in bits for RTC_CR_SC4P. */

/*! @brief Read current value of the RTC_CR_SC4P field. */
#define BR_RTC_CR_SC4P(x)    (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC4P))

/*! @brief Format value for bitfield RTC_CR_SC4P. */
#define BF_RTC_CR_SC4P(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SC4P) & BM_RTC_CR_SC4P)

/*! @brief Set the SC4P field to a new value. */
#define BW_RTC_CR_SC4P(x, v) (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC4P) = (v))
/*@}*/

/*!
 * @name Register RTC_CR, field SC2P[13] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
#define BP_RTC_CR_SC2P       (13U)         /*!< Bit position for RTC_CR_SC2P. */
#define BM_RTC_CR_SC2P       (0x00002000U) /*!< Bit mask for RTC_CR_SC2P. */
#define BS_RTC_CR_SC2P       (1U)          /*!< Bit field size in bits for RTC_CR_SC2P. */

/*! @brief Read current value of the RTC_CR_SC2P field. */
#define BR_RTC_CR_SC2P(x)    (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC2P))

/*! @brief Format value for bitfield RTC_CR_SC2P. */
#define BF_RTC_CR_SC2P(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_CR_SC2P) & BM_RTC_CR_SC2P)

/*! @brief Set the SC2P field to a new value. */
#define BW_RTC_CR_SC2P(x, v) (BITBAND_ACCESS32(HW_RTC_CR_ADDR(x), BP_RTC_CR_SC2P) = (v))
/*@}*/

/*******************************************************************************
 * HW_RTC_SR - RTC Status Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_SR - RTC Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
typedef union _hw_rtc_sr
{
    uint32_t U;
    struct _hw_rtc_sr_bitfields
    {
        uint32_t TIF : 1;              /*!< [0] Time Invalid Flag */
        uint32_t TOF : 1;              /*!< [1] Time Overflow Flag */
        uint32_t TAF : 1;              /*!< [2] Time Alarm Flag */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TCE : 1;              /*!< [4] Time Counter Enable */
        uint32_t RESERVED1 : 27;       /*!< [31:5]  */
    } B;
} hw_rtc_sr_t;

/*!
 * @name Constants and macros for entire RTC_SR register
 */
/*@{*/
#define HW_RTC_SR_ADDR(x)        ((uint32_t)(x) + 0x14U)

#define HW_RTC_SR(x)             (*(__IO hw_rtc_sr_t *) HW_RTC_SR_ADDR(x))
#define HW_RTC_SR_RD(x)          (HW_RTC_SR(x).U)
#define HW_RTC_SR_WR(x, v)       (HW_RTC_SR(x).U = (v))
#define HW_RTC_SR_SET(x, v)      (HW_RTC_SR_WR(x, HW_RTC_SR_RD(x) |  (v)))
#define HW_RTC_SR_CLR(x, v)      (HW_RTC_SR_WR(x, HW_RTC_SR_RD(x) & ~(v)))
#define HW_RTC_SR_TOG(x, v)      (HW_RTC_SR_WR(x, HW_RTC_SR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RTC_SR bitfields
 */

/*!
 * @name Register RTC_SR, field TIF[0] (RO)
 *
 * The time invalid flag is set on VBAT POR or software reset. The TSR and TPR
 * do not increment and read as zero when this bit is set. This bit is cleared by
 * writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0 - Time is valid.
 * - 1 - Time is invalid and time counter is read as zero.
 */
/*@{*/
#define BP_RTC_SR_TIF        (0U)          /*!< Bit position for RTC_SR_TIF. */
#define BM_RTC_SR_TIF        (0x00000001U) /*!< Bit mask for RTC_SR_TIF. */
#define BS_RTC_SR_TIF        (1U)          /*!< Bit field size in bits for RTC_SR_TIF. */

/*! @brief Read current value of the RTC_SR_TIF field. */
#define BR_RTC_SR_TIF(x)     (BITBAND_ACCESS32(HW_RTC_SR_ADDR(x), BP_RTC_SR_TIF))
/*@}*/

/*!
 * @name Register RTC_SR, field TOF[1] (RO)
 *
 * Time overflow flag is set when the time counter is enabled and overflows. The
 * TSR and TPR do not increment and read as zero when this bit is set. This bit
 * is cleared by writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0 - Time overflow has not occurred.
 * - 1 - Time overflow has occurred and time counter is read as zero.
 */
/*@{*/
#define BP_RTC_SR_TOF        (1U)          /*!< Bit position for RTC_SR_TOF. */
#define BM_RTC_SR_TOF        (0x00000002U) /*!< Bit mask for RTC_SR_TOF. */
#define BS_RTC_SR_TOF        (1U)          /*!< Bit field size in bits for RTC_SR_TOF. */

/*! @brief Read current value of the RTC_SR_TOF field. */
#define BR_RTC_SR_TOF(x)     (BITBAND_ACCESS32(HW_RTC_SR_ADDR(x), BP_RTC_SR_TOF))
/*@}*/

/*!
 * @name Register RTC_SR, field TAF[2] (RO)
 *
 * Time alarm flag is set when the TAR[TAR] equals the TSR[TSR] and the TSR[TSR]
 * increments. This bit is cleared by writing the TAR register.
 *
 * Values:
 * - 0 - Time alarm has not occurred.
 * - 1 - Time alarm has occurred.
 */
/*@{*/
#define BP_RTC_SR_TAF        (2U)          /*!< Bit position for RTC_SR_TAF. */
#define BM_RTC_SR_TAF        (0x00000004U) /*!< Bit mask for RTC_SR_TAF. */
#define BS_RTC_SR_TAF        (1U)          /*!< Bit field size in bits for RTC_SR_TAF. */

/*! @brief Read current value of the RTC_SR_TAF field. */
#define BR_RTC_SR_TAF(x)     (BITBAND_ACCESS32(HW_RTC_SR_ADDR(x), BP_RTC_SR_TAF))
/*@}*/

/*!
 * @name Register RTC_SR, field TCE[4] (RW)
 *
 * When time counter is disabled the TSR register and TPR register are
 * writeable, but do not increment. When time counter is enabled the TSR register and TPR
 * register are not writeable, but increment.
 *
 * Values:
 * - 0 - Time counter is disabled.
 * - 1 - Time counter is enabled.
 */
/*@{*/
#define BP_RTC_SR_TCE        (4U)          /*!< Bit position for RTC_SR_TCE. */
#define BM_RTC_SR_TCE        (0x00000010U) /*!< Bit mask for RTC_SR_TCE. */
#define BS_RTC_SR_TCE        (1U)          /*!< Bit field size in bits for RTC_SR_TCE. */

/*! @brief Read current value of the RTC_SR_TCE field. */
#define BR_RTC_SR_TCE(x)     (BITBAND_ACCESS32(HW_RTC_SR_ADDR(x), BP_RTC_SR_TCE))

/*! @brief Format value for bitfield RTC_SR_TCE. */
#define BF_RTC_SR_TCE(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_SR_TCE) & BM_RTC_SR_TCE)

/*! @brief Set the TCE field to a new value. */
#define BW_RTC_SR_TCE(x, v)  (BITBAND_ACCESS32(HW_RTC_SR_ADDR(x), BP_RTC_SR_TCE) = (v))
/*@}*/

/*******************************************************************************
 * HW_RTC_LR - RTC Lock Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_LR - RTC Lock Register (RW)
 *
 * Reset value: 0x000000FFU
 */
typedef union _hw_rtc_lr
{
    uint32_t U;
    struct _hw_rtc_lr_bitfields
    {
        uint32_t RESERVED0 : 3;        /*!< [2:0]  */
        uint32_t TCL : 1;              /*!< [3] Time Compensation Lock */
        uint32_t CRL : 1;              /*!< [4] Control Register Lock */
        uint32_t SRL : 1;              /*!< [5] Status Register Lock */
        uint32_t LRL : 1;              /*!< [6] Lock Register Lock */
        uint32_t RESERVED1 : 25;       /*!< [31:7]  */
    } B;
} hw_rtc_lr_t;

/*!
 * @name Constants and macros for entire RTC_LR register
 */
/*@{*/
#define HW_RTC_LR_ADDR(x)        ((uint32_t)(x) + 0x18U)

#define HW_RTC_LR(x)             (*(__IO hw_rtc_lr_t *) HW_RTC_LR_ADDR(x))
#define HW_RTC_LR_RD(x)          (HW_RTC_LR(x).U)
#define HW_RTC_LR_WR(x, v)       (HW_RTC_LR(x).U = (v))
#define HW_RTC_LR_SET(x, v)      (HW_RTC_LR_WR(x, HW_RTC_LR_RD(x) |  (v)))
#define HW_RTC_LR_CLR(x, v)      (HW_RTC_LR_WR(x, HW_RTC_LR_RD(x) & ~(v)))
#define HW_RTC_LR_TOG(x, v)      (HW_RTC_LR_WR(x, HW_RTC_LR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RTC_LR bitfields
 */

/*!
 * @name Register RTC_LR, field TCL[3] (RW)
 *
 * After being cleared, this bit can be set only by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Time Compensation Register is locked and writes are ignored.
 * - 1 - Time Compensation Register is not locked and writes complete as normal.
 */
/*@{*/
#define BP_RTC_LR_TCL        (3U)          /*!< Bit position for RTC_LR_TCL. */
#define BM_RTC_LR_TCL        (0x00000008U) /*!< Bit mask for RTC_LR_TCL. */
#define BS_RTC_LR_TCL        (1U)          /*!< Bit field size in bits for RTC_LR_TCL. */

/*! @brief Read current value of the RTC_LR_TCL field. */
#define BR_RTC_LR_TCL(x)     (BITBAND_ACCESS32(HW_RTC_LR_ADDR(x), BP_RTC_LR_TCL))

/*! @brief Format value for bitfield RTC_LR_TCL. */
#define BF_RTC_LR_TCL(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_LR_TCL) & BM_RTC_LR_TCL)

/*! @brief Set the TCL field to a new value. */
#define BW_RTC_LR_TCL(x, v)  (BITBAND_ACCESS32(HW_RTC_LR_ADDR(x), BP_RTC_LR_TCL) = (v))
/*@}*/

/*!
 * @name Register RTC_LR, field CRL[4] (RW)
 *
 * After being cleared, this bit can only be set by VBAT POR.
 *
 * Values:
 * - 0 - Control Register is locked and writes are ignored.
 * - 1 - Control Register is not locked and writes complete as normal.
 */
/*@{*/
#define BP_RTC_LR_CRL        (4U)          /*!< Bit position for RTC_LR_CRL. */
#define BM_RTC_LR_CRL        (0x00000010U) /*!< Bit mask for RTC_LR_CRL. */
#define BS_RTC_LR_CRL        (1U)          /*!< Bit field size in bits for RTC_LR_CRL. */

/*! @brief Read current value of the RTC_LR_CRL field. */
#define BR_RTC_LR_CRL(x)     (BITBAND_ACCESS32(HW_RTC_LR_ADDR(x), BP_RTC_LR_CRL))

/*! @brief Format value for bitfield RTC_LR_CRL. */
#define BF_RTC_LR_CRL(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_LR_CRL) & BM_RTC_LR_CRL)

/*! @brief Set the CRL field to a new value. */
#define BW_RTC_LR_CRL(x, v)  (BITBAND_ACCESS32(HW_RTC_LR_ADDR(x), BP_RTC_LR_CRL) = (v))
/*@}*/

/*!
 * @name Register RTC_LR, field SRL[5] (RW)
 *
 * After being cleared, this bit can be set only by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Status Register is locked and writes are ignored.
 * - 1 - Status Register is not locked and writes complete as normal.
 */
/*@{*/
#define BP_RTC_LR_SRL        (5U)          /*!< Bit position for RTC_LR_SRL. */
#define BM_RTC_LR_SRL        (0x00000020U) /*!< Bit mask for RTC_LR_SRL. */
#define BS_RTC_LR_SRL        (1U)          /*!< Bit field size in bits for RTC_LR_SRL. */

/*! @brief Read current value of the RTC_LR_SRL field. */
#define BR_RTC_LR_SRL(x)     (BITBAND_ACCESS32(HW_RTC_LR_ADDR(x), BP_RTC_LR_SRL))

/*! @brief Format value for bitfield RTC_LR_SRL. */
#define BF_RTC_LR_SRL(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_LR_SRL) & BM_RTC_LR_SRL)

/*! @brief Set the SRL field to a new value. */
#define BW_RTC_LR_SRL(x, v)  (BITBAND_ACCESS32(HW_RTC_LR_ADDR(x), BP_RTC_LR_SRL) = (v))
/*@}*/

/*!
 * @name Register RTC_LR, field LRL[6] (RW)
 *
 * After being cleared, this bit can be set only by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Lock Register is locked and writes are ignored.
 * - 1 - Lock Register is not locked and writes complete as normal.
 */
/*@{*/
#define BP_RTC_LR_LRL        (6U)          /*!< Bit position for RTC_LR_LRL. */
#define BM_RTC_LR_LRL        (0x00000040U) /*!< Bit mask for RTC_LR_LRL. */
#define BS_RTC_LR_LRL        (1U)          /*!< Bit field size in bits for RTC_LR_LRL. */

/*! @brief Read current value of the RTC_LR_LRL field. */
#define BR_RTC_LR_LRL(x)     (BITBAND_ACCESS32(HW_RTC_LR_ADDR(x), BP_RTC_LR_LRL))

/*! @brief Format value for bitfield RTC_LR_LRL. */
#define BF_RTC_LR_LRL(v)     ((uint32_t)((uint32_t)(v) << BP_RTC_LR_LRL) & BM_RTC_LR_LRL)

/*! @brief Set the LRL field to a new value. */
#define BW_RTC_LR_LRL(x, v)  (BITBAND_ACCESS32(HW_RTC_LR_ADDR(x), BP_RTC_LR_LRL) = (v))
/*@}*/

/*******************************************************************************
 * HW_RTC_IER - RTC Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_IER - RTC Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000007U
 */
typedef union _hw_rtc_ier
{
    uint32_t U;
    struct _hw_rtc_ier_bitfields
    {
        uint32_t TIIE : 1;             /*!< [0] Time Invalid Interrupt Enable */
        uint32_t TOIE : 1;             /*!< [1] Time Overflow Interrupt Enable */
        uint32_t TAIE : 1;             /*!< [2] Time Alarm Interrupt Enable */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t TSIE : 1;             /*!< [4] Time Seconds Interrupt Enable */
        uint32_t RESERVED1 : 2;        /*!< [6:5]  */
        uint32_t WPON : 1;             /*!< [7] Wakeup Pin On */
        uint32_t RESERVED2 : 24;       /*!< [31:8]  */
    } B;
} hw_rtc_ier_t;

/*!
 * @name Constants and macros for entire RTC_IER register
 */
/*@{*/
#define HW_RTC_IER_ADDR(x)       ((uint32_t)(x) + 0x1CU)

#define HW_RTC_IER(x)            (*(__IO hw_rtc_ier_t *) HW_RTC_IER_ADDR(x))
#define HW_RTC_IER_RD(x)         (HW_RTC_IER(x).U)
#define HW_RTC_IER_WR(x, v)      (HW_RTC_IER(x).U = (v))
#define HW_RTC_IER_SET(x, v)     (HW_RTC_IER_WR(x, HW_RTC_IER_RD(x) |  (v)))
#define HW_RTC_IER_CLR(x, v)     (HW_RTC_IER_WR(x, HW_RTC_IER_RD(x) & ~(v)))
#define HW_RTC_IER_TOG(x, v)     (HW_RTC_IER_WR(x, HW_RTC_IER_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RTC_IER bitfields
 */

/*!
 * @name Register RTC_IER, field TIIE[0] (RW)
 *
 * Values:
 * - 0 - Time invalid flag does not generate an interrupt.
 * - 1 - Time invalid flag does generate an interrupt.
 */
/*@{*/
#define BP_RTC_IER_TIIE      (0U)          /*!< Bit position for RTC_IER_TIIE. */
#define BM_RTC_IER_TIIE      (0x00000001U) /*!< Bit mask for RTC_IER_TIIE. */
#define BS_RTC_IER_TIIE      (1U)          /*!< Bit field size in bits for RTC_IER_TIIE. */

/*! @brief Read current value of the RTC_IER_TIIE field. */
#define BR_RTC_IER_TIIE(x)   (BITBAND_ACCESS32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TIIE))

/*! @brief Format value for bitfield RTC_IER_TIIE. */
#define BF_RTC_IER_TIIE(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_IER_TIIE) & BM_RTC_IER_TIIE)

/*! @brief Set the TIIE field to a new value. */
#define BW_RTC_IER_TIIE(x, v) (BITBAND_ACCESS32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TIIE) = (v))
/*@}*/

/*!
 * @name Register RTC_IER, field TOIE[1] (RW)
 *
 * Values:
 * - 0 - Time overflow flag does not generate an interrupt.
 * - 1 - Time overflow flag does generate an interrupt.
 */
/*@{*/
#define BP_RTC_IER_TOIE      (1U)          /*!< Bit position for RTC_IER_TOIE. */
#define BM_RTC_IER_TOIE      (0x00000002U) /*!< Bit mask for RTC_IER_TOIE. */
#define BS_RTC_IER_TOIE      (1U)          /*!< Bit field size in bits for RTC_IER_TOIE. */

/*! @brief Read current value of the RTC_IER_TOIE field. */
#define BR_RTC_IER_TOIE(x)   (BITBAND_ACCESS32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TOIE))

/*! @brief Format value for bitfield RTC_IER_TOIE. */
#define BF_RTC_IER_TOIE(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_IER_TOIE) & BM_RTC_IER_TOIE)

/*! @brief Set the TOIE field to a new value. */
#define BW_RTC_IER_TOIE(x, v) (BITBAND_ACCESS32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TOIE) = (v))
/*@}*/

/*!
 * @name Register RTC_IER, field TAIE[2] (RW)
 *
 * Values:
 * - 0 - Time alarm flag does not generate an interrupt.
 * - 1 - Time alarm flag does generate an interrupt.
 */
/*@{*/
#define BP_RTC_IER_TAIE      (2U)          /*!< Bit position for RTC_IER_TAIE. */
#define BM_RTC_IER_TAIE      (0x00000004U) /*!< Bit mask for RTC_IER_TAIE. */
#define BS_RTC_IER_TAIE      (1U)          /*!< Bit field size in bits for RTC_IER_TAIE. */

/*! @brief Read current value of the RTC_IER_TAIE field. */
#define BR_RTC_IER_TAIE(x)   (BITBAND_ACCESS32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TAIE))

/*! @brief Format value for bitfield RTC_IER_TAIE. */
#define BF_RTC_IER_TAIE(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_IER_TAIE) & BM_RTC_IER_TAIE)

/*! @brief Set the TAIE field to a new value. */
#define BW_RTC_IER_TAIE(x, v) (BITBAND_ACCESS32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TAIE) = (v))
/*@}*/

/*!
 * @name Register RTC_IER, field TSIE[4] (RW)
 *
 * The seconds interrupt is an edge-sensitive interrupt with a dedicated
 * interrupt vector. It is generated once a second and requires no software overhead
 * (there is no corresponding status flag to clear).
 *
 * Values:
 * - 0 - Seconds interrupt is disabled.
 * - 1 - Seconds interrupt is enabled.
 */
/*@{*/
#define BP_RTC_IER_TSIE      (4U)          /*!< Bit position for RTC_IER_TSIE. */
#define BM_RTC_IER_TSIE      (0x00000010U) /*!< Bit mask for RTC_IER_TSIE. */
#define BS_RTC_IER_TSIE      (1U)          /*!< Bit field size in bits for RTC_IER_TSIE. */

/*! @brief Read current value of the RTC_IER_TSIE field. */
#define BR_RTC_IER_TSIE(x)   (BITBAND_ACCESS32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TSIE))

/*! @brief Format value for bitfield RTC_IER_TSIE. */
#define BF_RTC_IER_TSIE(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_IER_TSIE) & BM_RTC_IER_TSIE)

/*! @brief Set the TSIE field to a new value. */
#define BW_RTC_IER_TSIE(x, v) (BITBAND_ACCESS32(HW_RTC_IER_ADDR(x), BP_RTC_IER_TSIE) = (v))
/*@}*/

/*!
 * @name Register RTC_IER, field WPON[7] (RW)
 *
 * The wakeup pin is optional and not available on all devices. Whenever the
 * wakeup pin is enabled and this bit is set, the wakeup pin will assert.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - If the wakeup pin is enabled, then the wakeup pin will assert.
 */
/*@{*/
#define BP_RTC_IER_WPON      (7U)          /*!< Bit position for RTC_IER_WPON. */
#define BM_RTC_IER_WPON      (0x00000080U) /*!< Bit mask for RTC_IER_WPON. */
#define BS_RTC_IER_WPON      (1U)          /*!< Bit field size in bits for RTC_IER_WPON. */

/*! @brief Read current value of the RTC_IER_WPON field. */
#define BR_RTC_IER_WPON(x)   (BITBAND_ACCESS32(HW_RTC_IER_ADDR(x), BP_RTC_IER_WPON))

/*! @brief Format value for bitfield RTC_IER_WPON. */
#define BF_RTC_IER_WPON(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_IER_WPON) & BM_RTC_IER_WPON)

/*! @brief Set the WPON field to a new value. */
#define BW_RTC_IER_WPON(x, v) (BITBAND_ACCESS32(HW_RTC_IER_ADDR(x), BP_RTC_IER_WPON) = (v))
/*@}*/

/*******************************************************************************
 * HW_RTC_WAR - RTC Write Access Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_WAR - RTC Write Access Register (RW)
 *
 * Reset value: 0x000000FFU
 */
typedef union _hw_rtc_war
{
    uint32_t U;
    struct _hw_rtc_war_bitfields
    {
        uint32_t TSRW : 1;             /*!< [0] Time Seconds Register Write */
        uint32_t TPRW : 1;             /*!< [1] Time Prescaler Register Write */
        uint32_t TARW : 1;             /*!< [2] Time Alarm Register Write */
        uint32_t TCRW : 1;             /*!< [3] Time Compensation Register Write */
        uint32_t CRW : 1;              /*!< [4] Control Register Write */
        uint32_t SRW : 1;              /*!< [5] Status Register Write */
        uint32_t LRW : 1;              /*!< [6] Lock Register Write */
        uint32_t IERW : 1;             /*!< [7] Interrupt Enable Register Write */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_rtc_war_t;

/*!
 * @name Constants and macros for entire RTC_WAR register
 */
/*@{*/
#define HW_RTC_WAR_ADDR(x)       ((uint32_t)(x) + 0x800U)

#define HW_RTC_WAR(x)            (*(__IO hw_rtc_war_t *) HW_RTC_WAR_ADDR(x))
#define HW_RTC_WAR_RD(x)         (HW_RTC_WAR(x).U)
#define HW_RTC_WAR_WR(x, v)      (HW_RTC_WAR(x).U = (v))
#define HW_RTC_WAR_SET(x, v)     (HW_RTC_WAR_WR(x, HW_RTC_WAR_RD(x) |  (v)))
#define HW_RTC_WAR_CLR(x, v)     (HW_RTC_WAR_WR(x, HW_RTC_WAR_RD(x) & ~(v)))
#define HW_RTC_WAR_TOG(x, v)     (HW_RTC_WAR_WR(x, HW_RTC_WAR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RTC_WAR bitfields
 */

/*!
 * @name Register RTC_WAR, field TSRW[0] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Time Seconds Register are ignored.
 * - 1 - Writes to the Time Seconds Register complete as normal.
 */
/*@{*/
#define BP_RTC_WAR_TSRW      (0U)          /*!< Bit position for RTC_WAR_TSRW. */
#define BM_RTC_WAR_TSRW      (0x00000001U) /*!< Bit mask for RTC_WAR_TSRW. */
#define BS_RTC_WAR_TSRW      (1U)          /*!< Bit field size in bits for RTC_WAR_TSRW. */

/*! @brief Read current value of the RTC_WAR_TSRW field. */
#define BR_RTC_WAR_TSRW(x)   (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_TSRW))

/*! @brief Format value for bitfield RTC_WAR_TSRW. */
#define BF_RTC_WAR_TSRW(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_WAR_TSRW) & BM_RTC_WAR_TSRW)

/*! @brief Set the TSRW field to a new value. */
#define BW_RTC_WAR_TSRW(x, v) (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_TSRW) = (v))
/*@}*/

/*!
 * @name Register RTC_WAR, field TPRW[1] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Time Prescaler Register are ignored.
 * - 1 - Writes to the Time Prescaler Register complete as normal.
 */
/*@{*/
#define BP_RTC_WAR_TPRW      (1U)          /*!< Bit position for RTC_WAR_TPRW. */
#define BM_RTC_WAR_TPRW      (0x00000002U) /*!< Bit mask for RTC_WAR_TPRW. */
#define BS_RTC_WAR_TPRW      (1U)          /*!< Bit field size in bits for RTC_WAR_TPRW. */

/*! @brief Read current value of the RTC_WAR_TPRW field. */
#define BR_RTC_WAR_TPRW(x)   (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_TPRW))

/*! @brief Format value for bitfield RTC_WAR_TPRW. */
#define BF_RTC_WAR_TPRW(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_WAR_TPRW) & BM_RTC_WAR_TPRW)

/*! @brief Set the TPRW field to a new value. */
#define BW_RTC_WAR_TPRW(x, v) (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_TPRW) = (v))
/*@}*/

/*!
 * @name Register RTC_WAR, field TARW[2] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Time Alarm Register are ignored.
 * - 1 - Writes to the Time Alarm Register complete as normal.
 */
/*@{*/
#define BP_RTC_WAR_TARW      (2U)          /*!< Bit position for RTC_WAR_TARW. */
#define BM_RTC_WAR_TARW      (0x00000004U) /*!< Bit mask for RTC_WAR_TARW. */
#define BS_RTC_WAR_TARW      (1U)          /*!< Bit field size in bits for RTC_WAR_TARW. */

/*! @brief Read current value of the RTC_WAR_TARW field. */
#define BR_RTC_WAR_TARW(x)   (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_TARW))

/*! @brief Format value for bitfield RTC_WAR_TARW. */
#define BF_RTC_WAR_TARW(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_WAR_TARW) & BM_RTC_WAR_TARW)

/*! @brief Set the TARW field to a new value. */
#define BW_RTC_WAR_TARW(x, v) (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_TARW) = (v))
/*@}*/

/*!
 * @name Register RTC_WAR, field TCRW[3] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Time Compensation Register are ignored.
 * - 1 - Writes to the Time Compensation Register complete as normal.
 */
/*@{*/
#define BP_RTC_WAR_TCRW      (3U)          /*!< Bit position for RTC_WAR_TCRW. */
#define BM_RTC_WAR_TCRW      (0x00000008U) /*!< Bit mask for RTC_WAR_TCRW. */
#define BS_RTC_WAR_TCRW      (1U)          /*!< Bit field size in bits for RTC_WAR_TCRW. */

/*! @brief Read current value of the RTC_WAR_TCRW field. */
#define BR_RTC_WAR_TCRW(x)   (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_TCRW))

/*! @brief Format value for bitfield RTC_WAR_TCRW. */
#define BF_RTC_WAR_TCRW(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_WAR_TCRW) & BM_RTC_WAR_TCRW)

/*! @brief Set the TCRW field to a new value. */
#define BW_RTC_WAR_TCRW(x, v) (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_TCRW) = (v))
/*@}*/

/*!
 * @name Register RTC_WAR, field CRW[4] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Control Register are ignored.
 * - 1 - Writes to the Control Register complete as normal.
 */
/*@{*/
#define BP_RTC_WAR_CRW       (4U)          /*!< Bit position for RTC_WAR_CRW. */
#define BM_RTC_WAR_CRW       (0x00000010U) /*!< Bit mask for RTC_WAR_CRW. */
#define BS_RTC_WAR_CRW       (1U)          /*!< Bit field size in bits for RTC_WAR_CRW. */

/*! @brief Read current value of the RTC_WAR_CRW field. */
#define BR_RTC_WAR_CRW(x)    (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_CRW))

/*! @brief Format value for bitfield RTC_WAR_CRW. */
#define BF_RTC_WAR_CRW(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_WAR_CRW) & BM_RTC_WAR_CRW)

/*! @brief Set the CRW field to a new value. */
#define BW_RTC_WAR_CRW(x, v) (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_CRW) = (v))
/*@}*/

/*!
 * @name Register RTC_WAR, field SRW[5] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Status Register are ignored.
 * - 1 - Writes to the Status Register complete as normal.
 */
/*@{*/
#define BP_RTC_WAR_SRW       (5U)          /*!< Bit position for RTC_WAR_SRW. */
#define BM_RTC_WAR_SRW       (0x00000020U) /*!< Bit mask for RTC_WAR_SRW. */
#define BS_RTC_WAR_SRW       (1U)          /*!< Bit field size in bits for RTC_WAR_SRW. */

/*! @brief Read current value of the RTC_WAR_SRW field. */
#define BR_RTC_WAR_SRW(x)    (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_SRW))

/*! @brief Format value for bitfield RTC_WAR_SRW. */
#define BF_RTC_WAR_SRW(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_WAR_SRW) & BM_RTC_WAR_SRW)

/*! @brief Set the SRW field to a new value. */
#define BW_RTC_WAR_SRW(x, v) (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_SRW) = (v))
/*@}*/

/*!
 * @name Register RTC_WAR, field LRW[6] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Lock Register are ignored.
 * - 1 - Writes to the Lock Register complete as normal.
 */
/*@{*/
#define BP_RTC_WAR_LRW       (6U)          /*!< Bit position for RTC_WAR_LRW. */
#define BM_RTC_WAR_LRW       (0x00000040U) /*!< Bit mask for RTC_WAR_LRW. */
#define BS_RTC_WAR_LRW       (1U)          /*!< Bit field size in bits for RTC_WAR_LRW. */

/*! @brief Read current value of the RTC_WAR_LRW field. */
#define BR_RTC_WAR_LRW(x)    (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_LRW))

/*! @brief Format value for bitfield RTC_WAR_LRW. */
#define BF_RTC_WAR_LRW(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_WAR_LRW) & BM_RTC_WAR_LRW)

/*! @brief Set the LRW field to a new value. */
#define BW_RTC_WAR_LRW(x, v) (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_LRW) = (v))
/*@}*/

/*!
 * @name Register RTC_WAR, field IERW[7] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Interupt Enable Register are ignored.
 * - 1 - Writes to the Interrupt Enable Register complete as normal.
 */
/*@{*/
#define BP_RTC_WAR_IERW      (7U)          /*!< Bit position for RTC_WAR_IERW. */
#define BM_RTC_WAR_IERW      (0x00000080U) /*!< Bit mask for RTC_WAR_IERW. */
#define BS_RTC_WAR_IERW      (1U)          /*!< Bit field size in bits for RTC_WAR_IERW. */

/*! @brief Read current value of the RTC_WAR_IERW field. */
#define BR_RTC_WAR_IERW(x)   (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_IERW))

/*! @brief Format value for bitfield RTC_WAR_IERW. */
#define BF_RTC_WAR_IERW(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_WAR_IERW) & BM_RTC_WAR_IERW)

/*! @brief Set the IERW field to a new value. */
#define BW_RTC_WAR_IERW(x, v) (BITBAND_ACCESS32(HW_RTC_WAR_ADDR(x), BP_RTC_WAR_IERW) = (v))
/*@}*/

/*******************************************************************************
 * HW_RTC_RAR - RTC Read Access Register
 ******************************************************************************/

/*!
 * @brief HW_RTC_RAR - RTC Read Access Register (RW)
 *
 * Reset value: 0x000000FFU
 */
typedef union _hw_rtc_rar
{
    uint32_t U;
    struct _hw_rtc_rar_bitfields
    {
        uint32_t TSRR : 1;             /*!< [0] Time Seconds Register Read */
        uint32_t TPRR : 1;             /*!< [1] Time Prescaler Register Read */
        uint32_t TARR : 1;             /*!< [2] Time Alarm Register Read */
        uint32_t TCRR : 1;             /*!< [3] Time Compensation Register Read */
        uint32_t CRR : 1;              /*!< [4] Control Register Read */
        uint32_t SRR : 1;              /*!< [5] Status Register Read */
        uint32_t LRR : 1;              /*!< [6] Lock Register Read */
        uint32_t IERR : 1;             /*!< [7] Interrupt Enable Register Read */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_rtc_rar_t;

/*!
 * @name Constants and macros for entire RTC_RAR register
 */
/*@{*/
#define HW_RTC_RAR_ADDR(x)       ((uint32_t)(x) + 0x804U)

#define HW_RTC_RAR(x)            (*(__IO hw_rtc_rar_t *) HW_RTC_RAR_ADDR(x))
#define HW_RTC_RAR_RD(x)         (HW_RTC_RAR(x).U)
#define HW_RTC_RAR_WR(x, v)      (HW_RTC_RAR(x).U = (v))
#define HW_RTC_RAR_SET(x, v)     (HW_RTC_RAR_WR(x, HW_RTC_RAR_RD(x) |  (v)))
#define HW_RTC_RAR_CLR(x, v)     (HW_RTC_RAR_WR(x, HW_RTC_RAR_RD(x) & ~(v)))
#define HW_RTC_RAR_TOG(x, v)     (HW_RTC_RAR_WR(x, HW_RTC_RAR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual RTC_RAR bitfields
 */

/*!
 * @name Register RTC_RAR, field TSRR[0] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Time Seconds Register are ignored.
 * - 1 - Reads to the Time Seconds Register complete as normal.
 */
/*@{*/
#define BP_RTC_RAR_TSRR      (0U)          /*!< Bit position for RTC_RAR_TSRR. */
#define BM_RTC_RAR_TSRR      (0x00000001U) /*!< Bit mask for RTC_RAR_TSRR. */
#define BS_RTC_RAR_TSRR      (1U)          /*!< Bit field size in bits for RTC_RAR_TSRR. */

/*! @brief Read current value of the RTC_RAR_TSRR field. */
#define BR_RTC_RAR_TSRR(x)   (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_TSRR))

/*! @brief Format value for bitfield RTC_RAR_TSRR. */
#define BF_RTC_RAR_TSRR(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_RAR_TSRR) & BM_RTC_RAR_TSRR)

/*! @brief Set the TSRR field to a new value. */
#define BW_RTC_RAR_TSRR(x, v) (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_TSRR) = (v))
/*@}*/

/*!
 * @name Register RTC_RAR, field TPRR[1] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Time Pprescaler Register are ignored.
 * - 1 - Reads to the Time Prescaler Register complete as normal.
 */
/*@{*/
#define BP_RTC_RAR_TPRR      (1U)          /*!< Bit position for RTC_RAR_TPRR. */
#define BM_RTC_RAR_TPRR      (0x00000002U) /*!< Bit mask for RTC_RAR_TPRR. */
#define BS_RTC_RAR_TPRR      (1U)          /*!< Bit field size in bits for RTC_RAR_TPRR. */

/*! @brief Read current value of the RTC_RAR_TPRR field. */
#define BR_RTC_RAR_TPRR(x)   (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_TPRR))

/*! @brief Format value for bitfield RTC_RAR_TPRR. */
#define BF_RTC_RAR_TPRR(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_RAR_TPRR) & BM_RTC_RAR_TPRR)

/*! @brief Set the TPRR field to a new value. */
#define BW_RTC_RAR_TPRR(x, v) (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_TPRR) = (v))
/*@}*/

/*!
 * @name Register RTC_RAR, field TARR[2] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Time Alarm Register are ignored.
 * - 1 - Reads to the Time Alarm Register complete as normal.
 */
/*@{*/
#define BP_RTC_RAR_TARR      (2U)          /*!< Bit position for RTC_RAR_TARR. */
#define BM_RTC_RAR_TARR      (0x00000004U) /*!< Bit mask for RTC_RAR_TARR. */
#define BS_RTC_RAR_TARR      (1U)          /*!< Bit field size in bits for RTC_RAR_TARR. */

/*! @brief Read current value of the RTC_RAR_TARR field. */
#define BR_RTC_RAR_TARR(x)   (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_TARR))

/*! @brief Format value for bitfield RTC_RAR_TARR. */
#define BF_RTC_RAR_TARR(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_RAR_TARR) & BM_RTC_RAR_TARR)

/*! @brief Set the TARR field to a new value. */
#define BW_RTC_RAR_TARR(x, v) (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_TARR) = (v))
/*@}*/

/*!
 * @name Register RTC_RAR, field TCRR[3] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Time Compensation Register are ignored.
 * - 1 - Reads to the Time Compensation Register complete as normal.
 */
/*@{*/
#define BP_RTC_RAR_TCRR      (3U)          /*!< Bit position for RTC_RAR_TCRR. */
#define BM_RTC_RAR_TCRR      (0x00000008U) /*!< Bit mask for RTC_RAR_TCRR. */
#define BS_RTC_RAR_TCRR      (1U)          /*!< Bit field size in bits for RTC_RAR_TCRR. */

/*! @brief Read current value of the RTC_RAR_TCRR field. */
#define BR_RTC_RAR_TCRR(x)   (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_TCRR))

/*! @brief Format value for bitfield RTC_RAR_TCRR. */
#define BF_RTC_RAR_TCRR(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_RAR_TCRR) & BM_RTC_RAR_TCRR)

/*! @brief Set the TCRR field to a new value. */
#define BW_RTC_RAR_TCRR(x, v) (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_TCRR) = (v))
/*@}*/

/*!
 * @name Register RTC_RAR, field CRR[4] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Control Register are ignored.
 * - 1 - Reads to the Control Register complete as normal.
 */
/*@{*/
#define BP_RTC_RAR_CRR       (4U)          /*!< Bit position for RTC_RAR_CRR. */
#define BM_RTC_RAR_CRR       (0x00000010U) /*!< Bit mask for RTC_RAR_CRR. */
#define BS_RTC_RAR_CRR       (1U)          /*!< Bit field size in bits for RTC_RAR_CRR. */

/*! @brief Read current value of the RTC_RAR_CRR field. */
#define BR_RTC_RAR_CRR(x)    (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_CRR))

/*! @brief Format value for bitfield RTC_RAR_CRR. */
#define BF_RTC_RAR_CRR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_RAR_CRR) & BM_RTC_RAR_CRR)

/*! @brief Set the CRR field to a new value. */
#define BW_RTC_RAR_CRR(x, v) (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_CRR) = (v))
/*@}*/

/*!
 * @name Register RTC_RAR, field SRR[5] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Status Register are ignored.
 * - 1 - Reads to the Status Register complete as normal.
 */
/*@{*/
#define BP_RTC_RAR_SRR       (5U)          /*!< Bit position for RTC_RAR_SRR. */
#define BM_RTC_RAR_SRR       (0x00000020U) /*!< Bit mask for RTC_RAR_SRR. */
#define BS_RTC_RAR_SRR       (1U)          /*!< Bit field size in bits for RTC_RAR_SRR. */

/*! @brief Read current value of the RTC_RAR_SRR field. */
#define BR_RTC_RAR_SRR(x)    (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_SRR))

/*! @brief Format value for bitfield RTC_RAR_SRR. */
#define BF_RTC_RAR_SRR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_RAR_SRR) & BM_RTC_RAR_SRR)

/*! @brief Set the SRR field to a new value. */
#define BW_RTC_RAR_SRR(x, v) (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_SRR) = (v))
/*@}*/

/*!
 * @name Register RTC_RAR, field LRR[6] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Lock Register are ignored.
 * - 1 - Reads to the Lock Register complete as normal.
 */
/*@{*/
#define BP_RTC_RAR_LRR       (6U)          /*!< Bit position for RTC_RAR_LRR. */
#define BM_RTC_RAR_LRR       (0x00000040U) /*!< Bit mask for RTC_RAR_LRR. */
#define BS_RTC_RAR_LRR       (1U)          /*!< Bit field size in bits for RTC_RAR_LRR. */

/*! @brief Read current value of the RTC_RAR_LRR field. */
#define BR_RTC_RAR_LRR(x)    (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_LRR))

/*! @brief Format value for bitfield RTC_RAR_LRR. */
#define BF_RTC_RAR_LRR(v)    ((uint32_t)((uint32_t)(v) << BP_RTC_RAR_LRR) & BM_RTC_RAR_LRR)

/*! @brief Set the LRR field to a new value. */
#define BW_RTC_RAR_LRR(x, v) (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_LRR) = (v))
/*@}*/

/*!
 * @name Register RTC_RAR, field IERR[7] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Interrupt Enable Register are ignored.
 * - 1 - Reads to the Interrupt Enable Register complete as normal.
 */
/*@{*/
#define BP_RTC_RAR_IERR      (7U)          /*!< Bit position for RTC_RAR_IERR. */
#define BM_RTC_RAR_IERR      (0x00000080U) /*!< Bit mask for RTC_RAR_IERR. */
#define BS_RTC_RAR_IERR      (1U)          /*!< Bit field size in bits for RTC_RAR_IERR. */

/*! @brief Read current value of the RTC_RAR_IERR field. */
#define BR_RTC_RAR_IERR(x)   (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_IERR))

/*! @brief Format value for bitfield RTC_RAR_IERR. */
#define BF_RTC_RAR_IERR(v)   ((uint32_t)((uint32_t)(v) << BP_RTC_RAR_IERR) & BM_RTC_RAR_IERR)

/*! @brief Set the IERR field to a new value. */
#define BW_RTC_RAR_IERR(x, v) (BITBAND_ACCESS32(HW_RTC_RAR_ADDR(x), BP_RTC_RAR_IERR) = (v))
/*@}*/

/*******************************************************************************
 * hw_rtc_t - module struct
 ******************************************************************************/
/*!
 * @brief All RTC module registers.
 */
#pragma pack(1)
typedef struct _hw_rtc
{
    __IO hw_rtc_tsr_t TSR;                 /*!< [0x0] RTC Time Seconds Register */
    __IO hw_rtc_tpr_t TPR;                 /*!< [0x4] RTC Time Prescaler Register */
    __IO hw_rtc_tar_t TAR;                 /*!< [0x8] RTC Time Alarm Register */
    __IO hw_rtc_tcr_t TCR;                 /*!< [0xC] RTC Time Compensation Register */
    __IO hw_rtc_cr_t CR;                   /*!< [0x10] RTC Control Register */
    __IO hw_rtc_sr_t SR;                   /*!< [0x14] RTC Status Register */
    __IO hw_rtc_lr_t LR;                   /*!< [0x18] RTC Lock Register */
    __IO hw_rtc_ier_t IER;                 /*!< [0x1C] RTC Interrupt Enable Register */
    uint8_t _reserved0[2016];
    __IO hw_rtc_war_t WAR;                 /*!< [0x800] RTC Write Access Register */
    __IO hw_rtc_rar_t RAR;                 /*!< [0x804] RTC Read Access Register */
} hw_rtc_t;
#pragma pack()

/*! @brief Macro to access all RTC registers. */
/*! @param x RTC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_RTC_REGS(RTC_BASE)</code>. */
#define HW_RTC_REGS(x) (*(hw_rtc_t *)(x))

/*
 * MK64F12 SDHC
 *
 * Secured Digital Host Controller
 *
 * Registers defined in this header file:
 * - HW_SDHC_DSADDR - DMA System Address register
 * - HW_SDHC_BLKATTR - Block Attributes register
 * - HW_SDHC_CMDARG - Command Argument register
 * - HW_SDHC_XFERTYP - Transfer Type register
 * - HW_SDHC_CMDRSP0 - Command Response 0
 * - HW_SDHC_CMDRSP1 - Command Response 1
 * - HW_SDHC_CMDRSP2 - Command Response 2
 * - HW_SDHC_CMDRSP3 - Command Response 3
 * - HW_SDHC_DATPORT - Buffer Data Port register
 * - HW_SDHC_PRSSTAT - Present State register
 * - HW_SDHC_PROCTL - Protocol Control register
 * - HW_SDHC_SYSCTL - System Control register
 * - HW_SDHC_IRQSTAT - Interrupt Status register
 * - HW_SDHC_IRQSTATEN - Interrupt Status Enable register
 * - HW_SDHC_IRQSIGEN - Interrupt Signal Enable register
 * - HW_SDHC_AC12ERR - Auto CMD12 Error Status Register
 * - HW_SDHC_HTCAPBLT - Host Controller Capabilities
 * - HW_SDHC_WML - Watermark Level Register
 * - HW_SDHC_FEVT - Force Event register
 * - HW_SDHC_ADMAES - ADMA Error Status register
 * - HW_SDHC_ADSADDR - ADMA System Addressregister
 * - HW_SDHC_VENDOR - Vendor Specific register
 * - HW_SDHC_MMCBOOT - MMC Boot register
 * - HW_SDHC_HOSTVER - Host Controller Version
 *
 * - hw_sdhc_t - Struct containing all module registers.
 */

#define HW_SDHC_INSTANCE_COUNT (1U) /*!< Number of instances of the SDHC module. */
#define HW_SDHC (0U) /*!< Instance number for SDHC. */

/*******************************************************************************
 * HW_SDHC_DSADDR - DMA System Address register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_DSADDR - DMA System Address register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the physical system memory address used for DMA
 * transfers.
 */
typedef union _hw_sdhc_dsaddr
{
    uint32_t U;
    struct _hw_sdhc_dsaddr_bitfields
    {
        uint32_t RESERVED0 : 2;        /*!< [1:0]  */
        uint32_t DSADDR : 30;          /*!< [31:2] DMA System Address */
    } B;
} hw_sdhc_dsaddr_t;

/*!
 * @name Constants and macros for entire SDHC_DSADDR register
 */
/*@{*/
#define HW_SDHC_DSADDR_ADDR(x)   ((uint32_t)(x) + 0x0U)

#define HW_SDHC_DSADDR(x)        (*(__IO hw_sdhc_dsaddr_t *) HW_SDHC_DSADDR_ADDR(x))
#define HW_SDHC_DSADDR_RD(x)     (HW_SDHC_DSADDR(x).U)
#define HW_SDHC_DSADDR_WR(x, v)  (HW_SDHC_DSADDR(x).U = (v))
#define HW_SDHC_DSADDR_SET(x, v) (HW_SDHC_DSADDR_WR(x, HW_SDHC_DSADDR_RD(x) |  (v)))
#define HW_SDHC_DSADDR_CLR(x, v) (HW_SDHC_DSADDR_WR(x, HW_SDHC_DSADDR_RD(x) & ~(v)))
#define HW_SDHC_DSADDR_TOG(x, v) (HW_SDHC_DSADDR_WR(x, HW_SDHC_DSADDR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_DSADDR bitfields
 */

/*!
 * @name Register SDHC_DSADDR, field DSADDR[31:2] (RW)
 *
 * Contains the 32-bit system memory address for a DMA transfer. Because the
 * address must be word (4 bytes) align, the least 2 bits are reserved, always 0.
 * When the SDHC stops a DMA transfer, this register points to the system address
 * of the next contiguous data position. It can be accessed only when no
 * transaction is executing, that is, after a transaction has stopped. Read operation
 * during transfers may return an invalid value. The host driver shall initialize
 * this register before starting a DMA transaction. After DMA has stopped, the
 * system address of the next contiguous data position can be read from this register.
 * This register is protected during a data transfer. When data lines are
 * active, write to this register is ignored. The host driver shall wait, until
 * PRSSTAT[DLA] is cleared, before writing to this register. The SDHC internal DMA does
 * not support a virtual memory system. It supports only continuous physical
 * memory access. And due to AHB burst limitations, if the burst must cross the 1 KB
 * boundary, SDHC will automatically change SEQ burst type to NSEQ. Because this
 * register supports dynamic address reflecting, when IRQSTAT[TC] bit is set, it
 * automatically alters the value of internal address counter, so SW cannot
 * change this register when IRQSTAT[TC] is set.
 */
/*@{*/
#define BP_SDHC_DSADDR_DSADDR (2U)         /*!< Bit position for SDHC_DSADDR_DSADDR. */
#define BM_SDHC_DSADDR_DSADDR (0xFFFFFFFCU) /*!< Bit mask for SDHC_DSADDR_DSADDR. */
#define BS_SDHC_DSADDR_DSADDR (30U)        /*!< Bit field size in bits for SDHC_DSADDR_DSADDR. */

/*! @brief Read current value of the SDHC_DSADDR_DSADDR field. */
#define BR_SDHC_DSADDR_DSADDR(x) (HW_SDHC_DSADDR(x).B.DSADDR)

/*! @brief Format value for bitfield SDHC_DSADDR_DSADDR. */
#define BF_SDHC_DSADDR_DSADDR(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_DSADDR_DSADDR) & BM_SDHC_DSADDR_DSADDR)

/*! @brief Set the DSADDR field to a new value. */
#define BW_SDHC_DSADDR_DSADDR(x, v) (HW_SDHC_DSADDR_WR(x, (HW_SDHC_DSADDR_RD(x) & ~BM_SDHC_DSADDR_DSADDR) | BF_SDHC_DSADDR_DSADDR(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_BLKATTR - Block Attributes register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_BLKATTR - Block Attributes register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to configure the number of data blocks and the number
 * of bytes in each block.
 */
typedef union _hw_sdhc_blkattr
{
    uint32_t U;
    struct _hw_sdhc_blkattr_bitfields
    {
        uint32_t BLKSIZE : 13;         /*!< [12:0] Transfer Block Size */
        uint32_t RESERVED0 : 3;        /*!< [15:13]  */
        uint32_t BLKCNT : 16;          /*!< [31:16] Blocks Count For Current Transfer
                                        * */
    } B;
} hw_sdhc_blkattr_t;

/*!
 * @name Constants and macros for entire SDHC_BLKATTR register
 */
/*@{*/
#define HW_SDHC_BLKATTR_ADDR(x)  ((uint32_t)(x) + 0x4U)

#define HW_SDHC_BLKATTR(x)       (*(__IO hw_sdhc_blkattr_t *) HW_SDHC_BLKATTR_ADDR(x))
#define HW_SDHC_BLKATTR_RD(x)    (HW_SDHC_BLKATTR(x).U)
#define HW_SDHC_BLKATTR_WR(x, v) (HW_SDHC_BLKATTR(x).U = (v))
#define HW_SDHC_BLKATTR_SET(x, v) (HW_SDHC_BLKATTR_WR(x, HW_SDHC_BLKATTR_RD(x) |  (v)))
#define HW_SDHC_BLKATTR_CLR(x, v) (HW_SDHC_BLKATTR_WR(x, HW_SDHC_BLKATTR_RD(x) & ~(v)))
#define HW_SDHC_BLKATTR_TOG(x, v) (HW_SDHC_BLKATTR_WR(x, HW_SDHC_BLKATTR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_BLKATTR bitfields
 */

/*!
 * @name Register SDHC_BLKATTR, field BLKSIZE[12:0] (RW)
 *
 * Specifies the block size for block data transfers. Values ranging from 1 byte
 * up to the maximum buffer size can be set. It can be accessed only when no
 * transaction is executing, that is, after a transaction has stopped. Read
 * operations during transfers may return an invalid value, and write operations will be
 * ignored.
 *
 * Values:
 * - 0 - No data transfer.
 * - 1 - 1 Byte
 * - 10 - 2 Bytes
 * - 11 - 3 Bytes
 * - 100 - 4 Bytes
 * - 111111111 - 511 Bytes
 * - 1000000000 - 512 Bytes
 * - 100000000000 - 2048 Bytes
 * - 1000000000000 - 4096 Bytes
 */
/*@{*/
#define BP_SDHC_BLKATTR_BLKSIZE (0U)       /*!< Bit position for SDHC_BLKATTR_BLKSIZE. */
#define BM_SDHC_BLKATTR_BLKSIZE (0x00001FFFU) /*!< Bit mask for SDHC_BLKATTR_BLKSIZE. */
#define BS_SDHC_BLKATTR_BLKSIZE (13U)      /*!< Bit field size in bits for SDHC_BLKATTR_BLKSIZE. */

/*! @brief Read current value of the SDHC_BLKATTR_BLKSIZE field. */
#define BR_SDHC_BLKATTR_BLKSIZE(x) (HW_SDHC_BLKATTR(x).B.BLKSIZE)

/*! @brief Format value for bitfield SDHC_BLKATTR_BLKSIZE. */
#define BF_SDHC_BLKATTR_BLKSIZE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_BLKATTR_BLKSIZE) & BM_SDHC_BLKATTR_BLKSIZE)

/*! @brief Set the BLKSIZE field to a new value. */
#define BW_SDHC_BLKATTR_BLKSIZE(x, v) (HW_SDHC_BLKATTR_WR(x, (HW_SDHC_BLKATTR_RD(x) & ~BM_SDHC_BLKATTR_BLKSIZE) | BF_SDHC_BLKATTR_BLKSIZE(v)))
/*@}*/

/*!
 * @name Register SDHC_BLKATTR, field BLKCNT[31:16] (RW)
 *
 * This register is enabled when XFERTYP[BCEN] is set to 1 and is valid only for
 * multiple block transfers. For single block transfer, this register will
 * always read as 1. The host driver shall set this register to a value between 1 and
 * the maximum block count. The SDHC decrements the block count after each block
 * transfer and stops when the count reaches zero. Setting the block count to 0
 * results in no data blocks being transferred. This register must be accessed
 * only when no transaction is executing, that is, after transactions are stopped.
 * During data transfer, read operations on this register may return an invalid
 * value and write operations are ignored. When saving transfer content as a result
 * of a suspend command, the number of blocks yet to be transferred can be
 * determined by reading this register. The reading of this register must be applied
 * after transfer is paused by stop at block gap operation and before sending the
 * command marked as suspend. This is because when suspend command is sent out,
 * SDHC will regard the current transfer as aborted and change BLKCNT back to its
 * original value instead of keeping the dynamical indicator of remained block
 * count. When restoring transfer content prior to issuing a resume command, the
 * host driver shall restore the previously saved block count. Although the BLKCNT
 * field is 0 after reset, the read of reset value is 0x1. This is because when
 * XFERTYP[MSBSEL] is 0, indicating a single block transfer, the read value of
 * BLKCNT is always 1.
 *
 * Values:
 * - 0 - Stop count.
 * - 1 - 1 block
 * - 10 - 2 blocks
 * - 1111111111111111 - 65535 blocks
 */
/*@{*/
#define BP_SDHC_BLKATTR_BLKCNT (16U)       /*!< Bit position for SDHC_BLKATTR_BLKCNT. */
#define BM_SDHC_BLKATTR_BLKCNT (0xFFFF0000U) /*!< Bit mask for SDHC_BLKATTR_BLKCNT. */
#define BS_SDHC_BLKATTR_BLKCNT (16U)       /*!< Bit field size in bits for SDHC_BLKATTR_BLKCNT. */

/*! @brief Read current value of the SDHC_BLKATTR_BLKCNT field. */
#define BR_SDHC_BLKATTR_BLKCNT(x) (HW_SDHC_BLKATTR(x).B.BLKCNT)

/*! @brief Format value for bitfield SDHC_BLKATTR_BLKCNT. */
#define BF_SDHC_BLKATTR_BLKCNT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_BLKATTR_BLKCNT) & BM_SDHC_BLKATTR_BLKCNT)

/*! @brief Set the BLKCNT field to a new value. */
#define BW_SDHC_BLKATTR_BLKCNT(x, v) (HW_SDHC_BLKATTR_WR(x, (HW_SDHC_BLKATTR_RD(x) & ~BM_SDHC_BLKATTR_BLKCNT) | BF_SDHC_BLKATTR_BLKCNT(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_CMDARG - Command Argument register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_CMDARG - Command Argument register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the SD/MMC command argument.
 */
typedef union _hw_sdhc_cmdarg
{
    uint32_t U;
    struct _hw_sdhc_cmdarg_bitfields
    {
        uint32_t CMDARG : 32;          /*!< [31:0] Command Argument */
    } B;
} hw_sdhc_cmdarg_t;

/*!
 * @name Constants and macros for entire SDHC_CMDARG register
 */
/*@{*/
#define HW_SDHC_CMDARG_ADDR(x)   ((uint32_t)(x) + 0x8U)

#define HW_SDHC_CMDARG(x)        (*(__IO hw_sdhc_cmdarg_t *) HW_SDHC_CMDARG_ADDR(x))
#define HW_SDHC_CMDARG_RD(x)     (HW_SDHC_CMDARG(x).U)
#define HW_SDHC_CMDARG_WR(x, v)  (HW_SDHC_CMDARG(x).U = (v))
#define HW_SDHC_CMDARG_SET(x, v) (HW_SDHC_CMDARG_WR(x, HW_SDHC_CMDARG_RD(x) |  (v)))
#define HW_SDHC_CMDARG_CLR(x, v) (HW_SDHC_CMDARG_WR(x, HW_SDHC_CMDARG_RD(x) & ~(v)))
#define HW_SDHC_CMDARG_TOG(x, v) (HW_SDHC_CMDARG_WR(x, HW_SDHC_CMDARG_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_CMDARG bitfields
 */

/*!
 * @name Register SDHC_CMDARG, field CMDARG[31:0] (RW)
 *
 * The SD/MMC command argument is specified as bits 39-8 of the command format
 * in the SD or MMC specification. This register is write protected when
 * PRSSTAT[CDIHB0] is set.
 */
/*@{*/
#define BP_SDHC_CMDARG_CMDARG (0U)         /*!< Bit position for SDHC_CMDARG_CMDARG. */
#define BM_SDHC_CMDARG_CMDARG (0xFFFFFFFFU) /*!< Bit mask for SDHC_CMDARG_CMDARG. */
#define BS_SDHC_CMDARG_CMDARG (32U)        /*!< Bit field size in bits for SDHC_CMDARG_CMDARG. */

/*! @brief Read current value of the SDHC_CMDARG_CMDARG field. */
#define BR_SDHC_CMDARG_CMDARG(x) (HW_SDHC_CMDARG(x).U)

/*! @brief Format value for bitfield SDHC_CMDARG_CMDARG. */
#define BF_SDHC_CMDARG_CMDARG(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_CMDARG_CMDARG) & BM_SDHC_CMDARG_CMDARG)

/*! @brief Set the CMDARG field to a new value. */
#define BW_SDHC_CMDARG_CMDARG(x, v) (HW_SDHC_CMDARG_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_XFERTYP - Transfer Type register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_XFERTYP - Transfer Type register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to control the operation of data transfers. The host
 * driver shall set this register before issuing a command followed by a data
 * transfer, or before issuing a resume command. To prevent data loss, the SDHC
 * prevents writing to the bits that are involved in the data transfer of this
 * register, when data transfer is active. These bits are DPSEL, MBSEL, DTDSEL, AC12EN,
 * BCEN, and DMAEN. The host driver shall check PRSSTAT[CDIHB] and PRSSTAT[CIHB]
 * before writing to this register. When PRSSTAT[CDIHB] is set, any attempt to
 * send a command with data by writing to this register is ignored; when
 * PRSSTAT[CIHB] bit is set, any write to this register is ignored. On sending commands with
 * data transfer involved, it is mandatory that the block size is nonzero.
 * Besides, block count must also be nonzero, or indicated as single block transfer
 * (bit 5 of this register is 0 when written), or block count is disabled (bit 1 of
 * this register is 0 when written), otherwise SDHC will ignore the sending of
 * this command and do nothing. For write command, with all above restrictions, it
 * is also mandatory that the write protect switch is not active (WPSPL bit of
 * Present State Register is 1), otherwise SDHC will also ignore the command. If
 * the commands with data transfer does not receive the response in 64 clock
 * cycles, that is, response time-out, SDHC will regard the external device does not
 * accept the command and abort the data transfer. In this scenario, the driver
 * must issue the command again to retry the transfer. It is also possible that,
 * for some reason, the card responds to the command but SDHC does not receive the
 * response, and if it is internal DMA (either simple DMA or ADMA) read
 * operation, the external system memory is over-written by the internal DMA with data
 * sent back from the card. The following table shows the summary of how register
 * settings determine the type of data transfer. Transfer Type register setting for
 * various transfer types Multi/Single block select Block count enable Block
 * count Function 0 Don't care Don't care Single transfer 1 0 Don't care Infinite
 * transfer 1 1 Positive number Multiple transfer 1 1 Zero No data transfer The
 * following table shows the relationship between XFERTYP[CICEN] and XFERTYP[CCCEN],
 * in regards to XFERTYP[RSPTYP] as well as the name of the response type.
 * Relationship between parameters and the name of the response type Response type
 * (RSPTYP) Index check enable (CICEN) CRC check enable (CCCEN) Name of response
 * type 00 0 0 No Response 01 0 1 IR2 10 0 0 R3,R4 10 1 1 R1,R5,R6 11 1 1 R1b,R5b In
 * the SDIO specification, response type notation for R5b is not defined. R5
 * includes R5b in the SDIO specification. But R5b is defined in this specification
 * to specify that the SDHC will check the busy status after receiving a
 * response. For example, usually CMD52 is used with R5, but the I/O abort command shall
 * be used with R5b. The CRC field for R3 and R4 is expected to be all 1 bits.
 * The CRC check shall be disabled for these response types.
 */
typedef union _hw_sdhc_xfertyp
{
    uint32_t U;
    struct _hw_sdhc_xfertyp_bitfields
    {
        uint32_t DMAEN : 1;            /*!< [0] DMA Enable */
        uint32_t BCEN : 1;             /*!< [1] Block Count Enable */
        uint32_t AC12EN : 1;           /*!< [2] Auto CMD12 Enable */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t DTDSEL : 1;           /*!< [4] Data Transfer Direction Select */
        uint32_t MSBSEL : 1;           /*!< [5] Multi/Single Block Select */
        uint32_t RESERVED1 : 10;       /*!< [15:6]  */
        uint32_t RSPTYP : 2;           /*!< [17:16] Response Type Select */
        uint32_t RESERVED2 : 1;        /*!< [18]  */
        uint32_t CCCEN : 1;            /*!< [19] Command CRC Check Enable */
        uint32_t CICEN : 1;            /*!< [20] Command Index Check Enable */
        uint32_t DPSEL : 1;            /*!< [21] Data Present Select */
        uint32_t CMDTYP : 2;           /*!< [23:22] Command Type */
        uint32_t CMDINX : 6;           /*!< [29:24] Command Index */
        uint32_t RESERVED3 : 2;        /*!< [31:30]  */
    } B;
} hw_sdhc_xfertyp_t;

/*!
 * @name Constants and macros for entire SDHC_XFERTYP register
 */
/*@{*/
#define HW_SDHC_XFERTYP_ADDR(x)  ((uint32_t)(x) + 0xCU)

#define HW_SDHC_XFERTYP(x)       (*(__IO hw_sdhc_xfertyp_t *) HW_SDHC_XFERTYP_ADDR(x))
#define HW_SDHC_XFERTYP_RD(x)    (HW_SDHC_XFERTYP(x).U)
#define HW_SDHC_XFERTYP_WR(x, v) (HW_SDHC_XFERTYP(x).U = (v))
#define HW_SDHC_XFERTYP_SET(x, v) (HW_SDHC_XFERTYP_WR(x, HW_SDHC_XFERTYP_RD(x) |  (v)))
#define HW_SDHC_XFERTYP_CLR(x, v) (HW_SDHC_XFERTYP_WR(x, HW_SDHC_XFERTYP_RD(x) & ~(v)))
#define HW_SDHC_XFERTYP_TOG(x, v) (HW_SDHC_XFERTYP_WR(x, HW_SDHC_XFERTYP_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_XFERTYP bitfields
 */

/*!
 * @name Register SDHC_XFERTYP, field DMAEN[0] (RW)
 *
 * Enables DMA functionality. If this bit is set to 1, a DMA operation shall
 * begin when the host driver sets the DPSEL bit of this register. Whether the
 * simple DMA, or the advanced DMA, is active depends on PROCTL[DMAS].
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
/*@{*/
#define BP_SDHC_XFERTYP_DMAEN (0U)         /*!< Bit position for SDHC_XFERTYP_DMAEN. */
#define BM_SDHC_XFERTYP_DMAEN (0x00000001U) /*!< Bit mask for SDHC_XFERTYP_DMAEN. */
#define BS_SDHC_XFERTYP_DMAEN (1U)         /*!< Bit field size in bits for SDHC_XFERTYP_DMAEN. */

/*! @brief Read current value of the SDHC_XFERTYP_DMAEN field. */
#define BR_SDHC_XFERTYP_DMAEN(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DMAEN))

/*! @brief Format value for bitfield SDHC_XFERTYP_DMAEN. */
#define BF_SDHC_XFERTYP_DMAEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_DMAEN) & BM_SDHC_XFERTYP_DMAEN)

/*! @brief Set the DMAEN field to a new value. */
#define BW_SDHC_XFERTYP_DMAEN(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DMAEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field BCEN[1] (RW)
 *
 * Used to enable the Block Count register, which is only relevant for multiple
 * block transfers. When this bit is 0, the internal counter for block is
 * disabled, which is useful in executing an infinite transfer.
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
/*@{*/
#define BP_SDHC_XFERTYP_BCEN (1U)          /*!< Bit position for SDHC_XFERTYP_BCEN. */
#define BM_SDHC_XFERTYP_BCEN (0x00000002U) /*!< Bit mask for SDHC_XFERTYP_BCEN. */
#define BS_SDHC_XFERTYP_BCEN (1U)          /*!< Bit field size in bits for SDHC_XFERTYP_BCEN. */

/*! @brief Read current value of the SDHC_XFERTYP_BCEN field. */
#define BR_SDHC_XFERTYP_BCEN(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_BCEN))

/*! @brief Format value for bitfield SDHC_XFERTYP_BCEN. */
#define BF_SDHC_XFERTYP_BCEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_BCEN) & BM_SDHC_XFERTYP_BCEN)

/*! @brief Set the BCEN field to a new value. */
#define BW_SDHC_XFERTYP_BCEN(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_BCEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field AC12EN[2] (RW)
 *
 * Multiple block transfers for memory require a CMD12 to stop the transaction.
 * When this bit is set to 1, the SDHC will issue a CMD12 automatically when the
 * last block transfer has completed. The host driver shall not set this bit to
 * issue commands that do not require CMD12 to stop a multiple block data
 * transfer. In particular, secure commands defined in File Security Specification (see
 * reference list) do not require CMD12. In single block transfer, the SDHC will
 * ignore this bit whether it is set or not.
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
/*@{*/
#define BP_SDHC_XFERTYP_AC12EN (2U)        /*!< Bit position for SDHC_XFERTYP_AC12EN. */
#define BM_SDHC_XFERTYP_AC12EN (0x00000004U) /*!< Bit mask for SDHC_XFERTYP_AC12EN. */
#define BS_SDHC_XFERTYP_AC12EN (1U)        /*!< Bit field size in bits for SDHC_XFERTYP_AC12EN. */

/*! @brief Read current value of the SDHC_XFERTYP_AC12EN field. */
#define BR_SDHC_XFERTYP_AC12EN(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_AC12EN))

/*! @brief Format value for bitfield SDHC_XFERTYP_AC12EN. */
#define BF_SDHC_XFERTYP_AC12EN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_AC12EN) & BM_SDHC_XFERTYP_AC12EN)

/*! @brief Set the AC12EN field to a new value. */
#define BW_SDHC_XFERTYP_AC12EN(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_AC12EN) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field DTDSEL[4] (RW)
 *
 * Defines the direction of DAT line data transfers. The bit is set to 1 by the
 * host driver to transfer data from the SD card to the SDHC and is set to 0 for
 * all other commands.
 *
 * Values:
 * - 0 - Write host to card.
 * - 1 - Read card to host.
 */
/*@{*/
#define BP_SDHC_XFERTYP_DTDSEL (4U)        /*!< Bit position for SDHC_XFERTYP_DTDSEL. */
#define BM_SDHC_XFERTYP_DTDSEL (0x00000010U) /*!< Bit mask for SDHC_XFERTYP_DTDSEL. */
#define BS_SDHC_XFERTYP_DTDSEL (1U)        /*!< Bit field size in bits for SDHC_XFERTYP_DTDSEL. */

/*! @brief Read current value of the SDHC_XFERTYP_DTDSEL field. */
#define BR_SDHC_XFERTYP_DTDSEL(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DTDSEL))

/*! @brief Format value for bitfield SDHC_XFERTYP_DTDSEL. */
#define BF_SDHC_XFERTYP_DTDSEL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_DTDSEL) & BM_SDHC_XFERTYP_DTDSEL)

/*! @brief Set the DTDSEL field to a new value. */
#define BW_SDHC_XFERTYP_DTDSEL(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DTDSEL) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field MSBSEL[5] (RW)
 *
 * Enables multiple block DAT line data transfers. For any other commands, this
 * bit shall be set to 0. If this bit is 0, it is not necessary to set the block
 * count register.
 *
 * Values:
 * - 0 - Single block.
 * - 1 - Multiple blocks.
 */
/*@{*/
#define BP_SDHC_XFERTYP_MSBSEL (5U)        /*!< Bit position for SDHC_XFERTYP_MSBSEL. */
#define BM_SDHC_XFERTYP_MSBSEL (0x00000020U) /*!< Bit mask for SDHC_XFERTYP_MSBSEL. */
#define BS_SDHC_XFERTYP_MSBSEL (1U)        /*!< Bit field size in bits for SDHC_XFERTYP_MSBSEL. */

/*! @brief Read current value of the SDHC_XFERTYP_MSBSEL field. */
#define BR_SDHC_XFERTYP_MSBSEL(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_MSBSEL))

/*! @brief Format value for bitfield SDHC_XFERTYP_MSBSEL. */
#define BF_SDHC_XFERTYP_MSBSEL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_MSBSEL) & BM_SDHC_XFERTYP_MSBSEL)

/*! @brief Set the MSBSEL field to a new value. */
#define BW_SDHC_XFERTYP_MSBSEL(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_MSBSEL) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field RSPTYP[17:16] (RW)
 *
 * Values:
 * - 00 - No response.
 * - 01 - Response length 136.
 * - 10 - Response length 48.
 * - 11 - Response length 48, check busy after response.
 */
/*@{*/
#define BP_SDHC_XFERTYP_RSPTYP (16U)       /*!< Bit position for SDHC_XFERTYP_RSPTYP. */
#define BM_SDHC_XFERTYP_RSPTYP (0x00030000U) /*!< Bit mask for SDHC_XFERTYP_RSPTYP. */
#define BS_SDHC_XFERTYP_RSPTYP (2U)        /*!< Bit field size in bits for SDHC_XFERTYP_RSPTYP. */

/*! @brief Read current value of the SDHC_XFERTYP_RSPTYP field. */
#define BR_SDHC_XFERTYP_RSPTYP(x) (HW_SDHC_XFERTYP(x).B.RSPTYP)

/*! @brief Format value for bitfield SDHC_XFERTYP_RSPTYP. */
#define BF_SDHC_XFERTYP_RSPTYP(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_RSPTYP) & BM_SDHC_XFERTYP_RSPTYP)

/*! @brief Set the RSPTYP field to a new value. */
#define BW_SDHC_XFERTYP_RSPTYP(x, v) (HW_SDHC_XFERTYP_WR(x, (HW_SDHC_XFERTYP_RD(x) & ~BM_SDHC_XFERTYP_RSPTYP) | BF_SDHC_XFERTYP_RSPTYP(v)))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field CCCEN[19] (RW)
 *
 * If this bit is set to 1, the SDHC shall check the CRC field in the response.
 * If an error is detected, it is reported as a Command CRC Error. If this bit is
 * set to 0, the CRC field is not checked. The number of bits checked by the CRC
 * field value changes according to the length of the response.
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
/*@{*/
#define BP_SDHC_XFERTYP_CCCEN (19U)        /*!< Bit position for SDHC_XFERTYP_CCCEN. */
#define BM_SDHC_XFERTYP_CCCEN (0x00080000U) /*!< Bit mask for SDHC_XFERTYP_CCCEN. */
#define BS_SDHC_XFERTYP_CCCEN (1U)         /*!< Bit field size in bits for SDHC_XFERTYP_CCCEN. */

/*! @brief Read current value of the SDHC_XFERTYP_CCCEN field. */
#define BR_SDHC_XFERTYP_CCCEN(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_CCCEN))

/*! @brief Format value for bitfield SDHC_XFERTYP_CCCEN. */
#define BF_SDHC_XFERTYP_CCCEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_CCCEN) & BM_SDHC_XFERTYP_CCCEN)

/*! @brief Set the CCCEN field to a new value. */
#define BW_SDHC_XFERTYP_CCCEN(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_CCCEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field CICEN[20] (RW)
 *
 * If this bit is set to 1, the SDHC will check the index field in the response
 * to see if it has the same value as the command index. If it is not, it is
 * reported as a command index error. If this bit is set to 0, the index field is not
 * checked.
 *
 * Values:
 * - 0 - Disable
 * - 1 - Enable
 */
/*@{*/
#define BP_SDHC_XFERTYP_CICEN (20U)        /*!< Bit position for SDHC_XFERTYP_CICEN. */
#define BM_SDHC_XFERTYP_CICEN (0x00100000U) /*!< Bit mask for SDHC_XFERTYP_CICEN. */
#define BS_SDHC_XFERTYP_CICEN (1U)         /*!< Bit field size in bits for SDHC_XFERTYP_CICEN. */

/*! @brief Read current value of the SDHC_XFERTYP_CICEN field. */
#define BR_SDHC_XFERTYP_CICEN(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_CICEN))

/*! @brief Format value for bitfield SDHC_XFERTYP_CICEN. */
#define BF_SDHC_XFERTYP_CICEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_CICEN) & BM_SDHC_XFERTYP_CICEN)

/*! @brief Set the CICEN field to a new value. */
#define BW_SDHC_XFERTYP_CICEN(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_CICEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field DPSEL[21] (RW)
 *
 * This bit is set to 1 to indicate that data is present and shall be
 * transferred using the DAT line. It is set to 0 for the following: Commands using only
 * the CMD line, for example: CMD52. Commands with no data transfer, but using the
 * busy signal on DAT[0] line, R1b or R5b, for example: CMD38. In resume command,
 * this bit shall be set, and other bits in this register shall be set the same
 * as when the transfer was initially launched. When the Write Protect switch is
 * on, that is, the WPSPL bit is active as 0, any command with a write operation
 * will be ignored. That is to say, when this bit is set, while the DTDSEL bit is
 * 0, writes to the register Transfer Type are ignored.
 *
 * Values:
 * - 0 - No data present.
 * - 1 - Data present.
 */
/*@{*/
#define BP_SDHC_XFERTYP_DPSEL (21U)        /*!< Bit position for SDHC_XFERTYP_DPSEL. */
#define BM_SDHC_XFERTYP_DPSEL (0x00200000U) /*!< Bit mask for SDHC_XFERTYP_DPSEL. */
#define BS_SDHC_XFERTYP_DPSEL (1U)         /*!< Bit field size in bits for SDHC_XFERTYP_DPSEL. */

/*! @brief Read current value of the SDHC_XFERTYP_DPSEL field. */
#define BR_SDHC_XFERTYP_DPSEL(x) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DPSEL))

/*! @brief Format value for bitfield SDHC_XFERTYP_DPSEL. */
#define BF_SDHC_XFERTYP_DPSEL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_DPSEL) & BM_SDHC_XFERTYP_DPSEL)

/*! @brief Set the DPSEL field to a new value. */
#define BW_SDHC_XFERTYP_DPSEL(x, v) (BITBAND_ACCESS32(HW_SDHC_XFERTYP_ADDR(x), BP_SDHC_XFERTYP_DPSEL) = (v))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field CMDTYP[23:22] (RW)
 *
 * There are three types of special commands: suspend, resume, and abort. These
 * bits shall be set to 00b for all other commands. Suspend command: If the
 * suspend command succeeds, the SDHC shall assume that the card bus has been released
 * and that it is possible to issue the next command which uses the DAT line.
 * Because the SDHC does not monitor the content of command response, it does not
 * know if the suspend command succeeded or not. It is the host driver's
 * responsibility to check the status of the suspend command and send another command
 * marked as suspend to inform the SDHC that a suspend command was successfully
 * issued. After the end bit of command is sent, the SDHC deasserts read wait for read
 * transactions and stops checking busy for write transactions. In 4-bit mode,
 * the interrupt cycle starts. If the suspend command fails, the SDHC will
 * maintain its current state, and the host driver shall restart the transfer by setting
 * PROCTL[CREQ]. Resume command: The host driver restarts the data transfer by
 * restoring the registers saved before sending the suspend command and then sends
 * the resume command. The SDHC will check for a pending busy state before
 * starting write transfers. Abort command: If this command is set when executing a
 * read transfer, the SDHC will stop reads to the buffer. If this command is set
 * when executing a write transfer, the SDHC will stop driving the DAT line. After
 * issuing the abort command, the host driver must issue a software reset (abort
 * transaction).
 *
 * Values:
 * - 00 - Normal other commands.
 * - 01 - Suspend CMD52 for writing bus suspend in CCCR.
 * - 10 - Resume CMD52 for writing function select in CCCR.
 * - 11 - Abort CMD12, CMD52 for writing I/O abort in CCCR.
 */
/*@{*/
#define BP_SDHC_XFERTYP_CMDTYP (22U)       /*!< Bit position for SDHC_XFERTYP_CMDTYP. */
#define BM_SDHC_XFERTYP_CMDTYP (0x00C00000U) /*!< Bit mask for SDHC_XFERTYP_CMDTYP. */
#define BS_SDHC_XFERTYP_CMDTYP (2U)        /*!< Bit field size in bits for SDHC_XFERTYP_CMDTYP. */

/*! @brief Read current value of the SDHC_XFERTYP_CMDTYP field. */
#define BR_SDHC_XFERTYP_CMDTYP(x) (HW_SDHC_XFERTYP(x).B.CMDTYP)

/*! @brief Format value for bitfield SDHC_XFERTYP_CMDTYP. */
#define BF_SDHC_XFERTYP_CMDTYP(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_CMDTYP) & BM_SDHC_XFERTYP_CMDTYP)

/*! @brief Set the CMDTYP field to a new value. */
#define BW_SDHC_XFERTYP_CMDTYP(x, v) (HW_SDHC_XFERTYP_WR(x, (HW_SDHC_XFERTYP_RD(x) & ~BM_SDHC_XFERTYP_CMDTYP) | BF_SDHC_XFERTYP_CMDTYP(v)))
/*@}*/

/*!
 * @name Register SDHC_XFERTYP, field CMDINX[29:24] (RW)
 *
 * These bits shall be set to the command number that is specified in bits 45-40
 * of the command-format in the SD Memory Card Physical Layer Specification and
 * SDIO Card Specification.
 */
/*@{*/
#define BP_SDHC_XFERTYP_CMDINX (24U)       /*!< Bit position for SDHC_XFERTYP_CMDINX. */
#define BM_SDHC_XFERTYP_CMDINX (0x3F000000U) /*!< Bit mask for SDHC_XFERTYP_CMDINX. */
#define BS_SDHC_XFERTYP_CMDINX (6U)        /*!< Bit field size in bits for SDHC_XFERTYP_CMDINX. */

/*! @brief Read current value of the SDHC_XFERTYP_CMDINX field. */
#define BR_SDHC_XFERTYP_CMDINX(x) (HW_SDHC_XFERTYP(x).B.CMDINX)

/*! @brief Format value for bitfield SDHC_XFERTYP_CMDINX. */
#define BF_SDHC_XFERTYP_CMDINX(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_XFERTYP_CMDINX) & BM_SDHC_XFERTYP_CMDINX)

/*! @brief Set the CMDINX field to a new value. */
#define BW_SDHC_XFERTYP_CMDINX(x, v) (HW_SDHC_XFERTYP_WR(x, (HW_SDHC_XFERTYP_RD(x) & ~BM_SDHC_XFERTYP_CMDINX) | BF_SDHC_XFERTYP_CMDINX(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_CMDRSP0 - Command Response 0
 ******************************************************************************/

/*!
 * @brief HW_SDHC_CMDRSP0 - Command Response 0 (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to store part 0 of the response bits from the card.
 */
typedef union _hw_sdhc_cmdrsp0
{
    uint32_t U;
    struct _hw_sdhc_cmdrsp0_bitfields
    {
        uint32_t CMDRSP0 : 32;         /*!< [31:0] Command Response 0 */
    } B;
} hw_sdhc_cmdrsp0_t;

/*!
 * @name Constants and macros for entire SDHC_CMDRSP0 register
 */
/*@{*/
#define HW_SDHC_CMDRSP0_ADDR(x)  ((uint32_t)(x) + 0x10U)

#define HW_SDHC_CMDRSP0(x)       (*(__I hw_sdhc_cmdrsp0_t *) HW_SDHC_CMDRSP0_ADDR(x))
#define HW_SDHC_CMDRSP0_RD(x)    (HW_SDHC_CMDRSP0(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_CMDRSP0 bitfields
 */

/*!
 * @name Register SDHC_CMDRSP0, field CMDRSP0[31:0] (RO)
 */
/*@{*/
#define BP_SDHC_CMDRSP0_CMDRSP0 (0U)       /*!< Bit position for SDHC_CMDRSP0_CMDRSP0. */
#define BM_SDHC_CMDRSP0_CMDRSP0 (0xFFFFFFFFU) /*!< Bit mask for SDHC_CMDRSP0_CMDRSP0. */
#define BS_SDHC_CMDRSP0_CMDRSP0 (32U)      /*!< Bit field size in bits for SDHC_CMDRSP0_CMDRSP0. */

/*! @brief Read current value of the SDHC_CMDRSP0_CMDRSP0 field. */
#define BR_SDHC_CMDRSP0_CMDRSP0(x) (HW_SDHC_CMDRSP0(x).U)
/*@}*/

/*******************************************************************************
 * HW_SDHC_CMDRSP1 - Command Response 1
 ******************************************************************************/

/*!
 * @brief HW_SDHC_CMDRSP1 - Command Response 1 (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to store part 1 of the response bits from the card.
 */
typedef union _hw_sdhc_cmdrsp1
{
    uint32_t U;
    struct _hw_sdhc_cmdrsp1_bitfields
    {
        uint32_t CMDRSP1 : 32;         /*!< [31:0] Command Response 1 */
    } B;
} hw_sdhc_cmdrsp1_t;

/*!
 * @name Constants and macros for entire SDHC_CMDRSP1 register
 */
/*@{*/
#define HW_SDHC_CMDRSP1_ADDR(x)  ((uint32_t)(x) + 0x14U)

#define HW_SDHC_CMDRSP1(x)       (*(__I hw_sdhc_cmdrsp1_t *) HW_SDHC_CMDRSP1_ADDR(x))
#define HW_SDHC_CMDRSP1_RD(x)    (HW_SDHC_CMDRSP1(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_CMDRSP1 bitfields
 */

/*!
 * @name Register SDHC_CMDRSP1, field CMDRSP1[31:0] (RO)
 */
/*@{*/
#define BP_SDHC_CMDRSP1_CMDRSP1 (0U)       /*!< Bit position for SDHC_CMDRSP1_CMDRSP1. */
#define BM_SDHC_CMDRSP1_CMDRSP1 (0xFFFFFFFFU) /*!< Bit mask for SDHC_CMDRSP1_CMDRSP1. */
#define BS_SDHC_CMDRSP1_CMDRSP1 (32U)      /*!< Bit field size in bits for SDHC_CMDRSP1_CMDRSP1. */

/*! @brief Read current value of the SDHC_CMDRSP1_CMDRSP1 field. */
#define BR_SDHC_CMDRSP1_CMDRSP1(x) (HW_SDHC_CMDRSP1(x).U)
/*@}*/

/*******************************************************************************
 * HW_SDHC_CMDRSP2 - Command Response 2
 ******************************************************************************/

/*!
 * @brief HW_SDHC_CMDRSP2 - Command Response 2 (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to store part 2 of the response bits from the card.
 */
typedef union _hw_sdhc_cmdrsp2
{
    uint32_t U;
    struct _hw_sdhc_cmdrsp2_bitfields
    {
        uint32_t CMDRSP2 : 32;         /*!< [31:0] Command Response 2 */
    } B;
} hw_sdhc_cmdrsp2_t;

/*!
 * @name Constants and macros for entire SDHC_CMDRSP2 register
 */
/*@{*/
#define HW_SDHC_CMDRSP2_ADDR(x)  ((uint32_t)(x) + 0x18U)

#define HW_SDHC_CMDRSP2(x)       (*(__I hw_sdhc_cmdrsp2_t *) HW_SDHC_CMDRSP2_ADDR(x))
#define HW_SDHC_CMDRSP2_RD(x)    (HW_SDHC_CMDRSP2(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_CMDRSP2 bitfields
 */

/*!
 * @name Register SDHC_CMDRSP2, field CMDRSP2[31:0] (RO)
 */
/*@{*/
#define BP_SDHC_CMDRSP2_CMDRSP2 (0U)       /*!< Bit position for SDHC_CMDRSP2_CMDRSP2. */
#define BM_SDHC_CMDRSP2_CMDRSP2 (0xFFFFFFFFU) /*!< Bit mask for SDHC_CMDRSP2_CMDRSP2. */
#define BS_SDHC_CMDRSP2_CMDRSP2 (32U)      /*!< Bit field size in bits for SDHC_CMDRSP2_CMDRSP2. */

/*! @brief Read current value of the SDHC_CMDRSP2_CMDRSP2 field. */
#define BR_SDHC_CMDRSP2_CMDRSP2(x) (HW_SDHC_CMDRSP2(x).U)
/*@}*/

/*******************************************************************************
 * HW_SDHC_CMDRSP3 - Command Response 3
 ******************************************************************************/

/*!
 * @brief HW_SDHC_CMDRSP3 - Command Response 3 (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to store part 3 of the response bits from the card. The
 * following table describes the mapping of command responses from the SD bus to
 * command response registers for each response type. In the table, R[ ] refers
 * to a bit range within the response data as transmitted on the SD bus. Response
 * bit definition for each response type Response type Meaning of response
 * Response field Response register R1,R1b (normal response) Card status R[39:8]
 * CMDRSP0 R1b (Auto CMD12 response) Card status for auto CMD12 R[39:8] CMDRSP3 R2
 * (CID, CSD register) CID/CSD register [127:8] R[127:8] {CMDRSP3[23:0], CMDRSP2,
 * CMDRSP1, CMDRSP0} R3 (OCR register) OCR register for memory R[39:8] CMDRSP0 R4
 * (OCR register) OCR register for I/O etc. R[39:8] CMDRSP0 R5, R5b SDIO response
 * R[39:8] CMDRSP0 R6 (Publish RCA) New published RCA[31:16] and card
 * status[15:0] R[39:9] CMDRSP0 This table shows that most responses with a length of 48
 * (R[47:0]) have 32-bit of the response data (R[39:8]) stored in the CMDRSP0
 * register. Responses of type R1b (auto CMD12 responses) have response data bits
 * (R[39:8]) stored in the CMDRSP3 register. Responses with length 136 (R[135:0]) have
 * 120-bit of the response data (R[127:8]) stored in the CMDRSP0, 1, 2, and 3
 * registers. To be able to read the response status efficiently, the SDHC stores
 * only a part of the response data in the command response registers. This
 * enables the host driver to efficiently read 32-bit of response data in one read
 * cycle on a 32-bit bus system. Parts of the response, the index field and the CRC,
 * are checked by the SDHC, as specified by XFERTYP[CICEN] and XFERTYP[CCCEN],
 * and generate an error interrupt if any error is detected. The bit range for the
 * CRC check depends on the response length. If the response length is 48, the
 * SDHC will check R[47:1], and if the response length is 136 the SDHC will check
 * R[119:1]. Because the SDHC may have a multiple block data transfer executing
 * concurrently with a CMD_wo_DAT command, the SDHC stores the auto CMD12 response
 * in the CMDRSP3 register. The CMD_wo_DAT response is stored in CMDRSP0. This
 * allows the SDHC to avoid overwriting the Auto CMD12 response with the CMD_wo_DAT
 * and vice versa. When the SDHC modifies part of the command response
 * registers, as shown in the table above, it preserves the unmodified bits.
 */
typedef union _hw_sdhc_cmdrsp3
{
    uint32_t U;
    struct _hw_sdhc_cmdrsp3_bitfields
    {
        uint32_t CMDRSP3 : 32;         /*!< [31:0] Command Response 3 */
    } B;
} hw_sdhc_cmdrsp3_t;

/*!
 * @name Constants and macros for entire SDHC_CMDRSP3 register
 */
/*@{*/
#define HW_SDHC_CMDRSP3_ADDR(x)  ((uint32_t)(x) + 0x1CU)

#define HW_SDHC_CMDRSP3(x)       (*(__I hw_sdhc_cmdrsp3_t *) HW_SDHC_CMDRSP3_ADDR(x))
#define HW_SDHC_CMDRSP3_RD(x)    (HW_SDHC_CMDRSP3(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_CMDRSP3 bitfields
 */

/*!
 * @name Register SDHC_CMDRSP3, field CMDRSP3[31:0] (RO)
 */
/*@{*/
#define BP_SDHC_CMDRSP3_CMDRSP3 (0U)       /*!< Bit position for SDHC_CMDRSP3_CMDRSP3. */
#define BM_SDHC_CMDRSP3_CMDRSP3 (0xFFFFFFFFU) /*!< Bit mask for SDHC_CMDRSP3_CMDRSP3. */
#define BS_SDHC_CMDRSP3_CMDRSP3 (32U)      /*!< Bit field size in bits for SDHC_CMDRSP3_CMDRSP3. */

/*! @brief Read current value of the SDHC_CMDRSP3_CMDRSP3 field. */
#define BR_SDHC_CMDRSP3_CMDRSP3(x) (HW_SDHC_CMDRSP3(x).U)
/*@}*/

/*******************************************************************************
 * HW_SDHC_DATPORT - Buffer Data Port register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_DATPORT - Buffer Data Port register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This is a 32-bit data port register used to access the internal buffer and it
 * cannot be updated in Idle mode.
 */
typedef union _hw_sdhc_datport
{
    uint32_t U;
    struct _hw_sdhc_datport_bitfields
    {
        uint32_t DATCONT : 32;         /*!< [31:0] Data Content */
    } B;
} hw_sdhc_datport_t;

/*!
 * @name Constants and macros for entire SDHC_DATPORT register
 */
/*@{*/
#define HW_SDHC_DATPORT_ADDR(x)  ((uint32_t)(x) + 0x20U)

#define HW_SDHC_DATPORT(x)       (*(__IO hw_sdhc_datport_t *) HW_SDHC_DATPORT_ADDR(x))
#define HW_SDHC_DATPORT_RD(x)    (HW_SDHC_DATPORT(x).U)
#define HW_SDHC_DATPORT_WR(x, v) (HW_SDHC_DATPORT(x).U = (v))
#define HW_SDHC_DATPORT_SET(x, v) (HW_SDHC_DATPORT_WR(x, HW_SDHC_DATPORT_RD(x) |  (v)))
#define HW_SDHC_DATPORT_CLR(x, v) (HW_SDHC_DATPORT_WR(x, HW_SDHC_DATPORT_RD(x) & ~(v)))
#define HW_SDHC_DATPORT_TOG(x, v) (HW_SDHC_DATPORT_WR(x, HW_SDHC_DATPORT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_DATPORT bitfields
 */

/*!
 * @name Register SDHC_DATPORT, field DATCONT[31:0] (RW)
 *
 * The Buffer Data Port register is for 32-bit data access by the CPU or the
 * external DMA. When the internal DMA is enabled, any write to this register is
 * ignored, and any read from this register will always yield 0s.
 */
/*@{*/
#define BP_SDHC_DATPORT_DATCONT (0U)       /*!< Bit position for SDHC_DATPORT_DATCONT. */
#define BM_SDHC_DATPORT_DATCONT (0xFFFFFFFFU) /*!< Bit mask for SDHC_DATPORT_DATCONT. */
#define BS_SDHC_DATPORT_DATCONT (32U)      /*!< Bit field size in bits for SDHC_DATPORT_DATCONT. */

/*! @brief Read current value of the SDHC_DATPORT_DATCONT field. */
#define BR_SDHC_DATPORT_DATCONT(x) (HW_SDHC_DATPORT(x).U)

/*! @brief Format value for bitfield SDHC_DATPORT_DATCONT. */
#define BF_SDHC_DATPORT_DATCONT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_DATPORT_DATCONT) & BM_SDHC_DATPORT_DATCONT)

/*! @brief Set the DATCONT field to a new value. */
#define BW_SDHC_DATPORT_DATCONT(x, v) (HW_SDHC_DATPORT_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_PRSSTAT - Present State register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_PRSSTAT - Present State register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The host driver can get status of the SDHC from this 32-bit read-only
 * register. The host driver can issue CMD0, CMD12, CMD13 (for memory) and CMD52 (for
 * SDIO) when the DAT lines are busy during a data transfer. These commands can be
 * issued when Command Inhibit (CIHB) is set to zero. Other commands shall be
 * issued when Command Inhibit (CDIHB) is set to zero. Possible changes to the SD
 * Physical Specification may add other commands to this list in the future.
 */
typedef union _hw_sdhc_prsstat
{
    uint32_t U;
    struct _hw_sdhc_prsstat_bitfields
    {
        uint32_t CIHB : 1;             /*!< [0] Command Inhibit (CMD) */
        uint32_t CDIHB : 1;            /*!< [1] Command Inhibit (DAT) */
        uint32_t DLA : 1;              /*!< [2] Data Line Active */
        uint32_t SDSTB : 1;            /*!< [3] SD Clock Stable */
        uint32_t IPGOFF : 1;           /*!< [4] Bus Clock Gated Off Internally */
        uint32_t HCKOFF : 1;           /*!< [5] System Clock Gated Off Internally */
        uint32_t PEROFF : 1;           /*!< [6] SDHC clock Gated Off Internally */
        uint32_t SDOFF : 1;            /*!< [7] SD Clock Gated Off Internally */
        uint32_t WTA : 1;              /*!< [8] Write Transfer Active */
        uint32_t RTA : 1;              /*!< [9] Read Transfer Active */
        uint32_t BWEN : 1;             /*!< [10] Buffer Write Enable */
        uint32_t BREN : 1;             /*!< [11] Buffer Read Enable */
        uint32_t RESERVED0 : 4;        /*!< [15:12]  */
        uint32_t CINS : 1;             /*!< [16] Card Inserted */
        uint32_t RESERVED1 : 6;        /*!< [22:17]  */
        uint32_t CLSL : 1;             /*!< [23] CMD Line Signal Level */
        uint32_t DLSL : 8;             /*!< [31:24] DAT Line Signal Level */
    } B;
} hw_sdhc_prsstat_t;

/*!
 * @name Constants and macros for entire SDHC_PRSSTAT register
 */
/*@{*/
#define HW_SDHC_PRSSTAT_ADDR(x)  ((uint32_t)(x) + 0x24U)

#define HW_SDHC_PRSSTAT(x)       (*(__I hw_sdhc_prsstat_t *) HW_SDHC_PRSSTAT_ADDR(x))
#define HW_SDHC_PRSSTAT_RD(x)    (HW_SDHC_PRSSTAT(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_PRSSTAT bitfields
 */

/*!
 * @name Register SDHC_PRSSTAT, field CIHB[0] (RO)
 *
 * If this status bit is 0, it indicates that the CMD line is not in use and the
 * SDHC can issue a SD/MMC Command using the CMD line. This bit is set also
 * immediately after the Transfer Type register is written. This bit is cleared when
 * the command response is received. Even if the CDIHB bit is set to 1, Commands
 * using only the CMD line can be issued if this bit is 0. Changing from 1 to 0
 * generates a command complete interrupt in the interrupt status register. If the
 * SDHC cannot issue the command because of a command conflict error (see
 * command CRC error) or because of a command not issued by auto CMD12 error, this bit
 * will remain 1 and the command complete is not set. The status of issuing an
 * auto CMD12 does not show on this bit.
 *
 * Values:
 * - 0 - Can issue command using only CMD line.
 * - 1 - Cannot issue command.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_CIHB (0U)          /*!< Bit position for SDHC_PRSSTAT_CIHB. */
#define BM_SDHC_PRSSTAT_CIHB (0x00000001U) /*!< Bit mask for SDHC_PRSSTAT_CIHB. */
#define BS_SDHC_PRSSTAT_CIHB (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_CIHB. */

/*! @brief Read current value of the SDHC_PRSSTAT_CIHB field. */
#define BR_SDHC_PRSSTAT_CIHB(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_CIHB))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field CDIHB[1] (RO)
 *
 * This status bit is generated if either the DLA or the RTA is set to 1. If
 * this bit is 0, it indicates that the SDHC can issue the next SD/MMC Command.
 * Commands with a busy signal belong to CDIHB, for example, R1b, R5b type. Except in
 * the case when the command busy is finished, changing from 1 to 0 generates a
 * transfer complete interrupt in the Interrupt Status register. The SD host
 * driver can save registers for a suspend transaction after this bit has changed
 * from 1 to 0.
 *
 * Values:
 * - 0 - Can issue command which uses the DAT line.
 * - 1 - Cannot issue command which uses the DAT line.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_CDIHB (1U)         /*!< Bit position for SDHC_PRSSTAT_CDIHB. */
#define BM_SDHC_PRSSTAT_CDIHB (0x00000002U) /*!< Bit mask for SDHC_PRSSTAT_CDIHB. */
#define BS_SDHC_PRSSTAT_CDIHB (1U)         /*!< Bit field size in bits for SDHC_PRSSTAT_CDIHB. */

/*! @brief Read current value of the SDHC_PRSSTAT_CDIHB field. */
#define BR_SDHC_PRSSTAT_CDIHB(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_CDIHB))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field DLA[2] (RO)
 *
 * Indicates whether one of the DAT lines on the SD bus is in use. In the case
 * of read transactions: This status indicates whether a read transfer is
 * executing on the SD bus. Changes in this value from 1 to 0, between data blocks,
 * generates a block gap event interrupt in the Interrupt Status register. This bit
 * will be set in either of the following cases: After the end bit of the read
 * command. When writing a 1 to PROCTL[CREQ] to restart a read transfer. This bit
 * will be cleared in either of the following cases: When the end bit of the last
 * data block is sent from the SD bus to the SDHC. When the read wait state is
 * stopped by a suspend command and the DAT2 line is released. The SDHC will wait at
 * the next block gap by driving read wait at the start of the interrupt cycle.
 * If the read wait signal is already driven (data buffer cannot receive data),
 * the SDHC can wait for a current block gap by continuing to drive the read wait
 * signal. It is necessary to support read wait to use the suspend / resume
 * function. This bit will remain 1 during read wait. In the case of write
 * transactions: This status indicates that a write transfer is executing on the SD bus.
 * Changes in this value from 1 to 0 generate a transfer complete interrupt in the
 * interrupt status register. This bit will be set in either of the following
 * cases: After the end bit of the write command. When writing to 1 to PROCTL[CREQ] to
 * continue a write transfer. This bit will be cleared in either of the
 * following cases: When the SD card releases write busy of the last data block, the SDHC
 * will also detect if the output is not busy. If the SD card does not drive the
 * busy signal after the CRC status is received, the SDHC shall assume the card
 * drive "Not busy". When the SD card releases write busy, prior to waiting for
 * write transfer, and as a result of a stop at block gap request. In the case of
 * command with busy pending: This status indicates that a busy state follows the
 * command and the data line is in use. This bit will be cleared when the DAT0
 * line is released.
 *
 * Values:
 * - 0 - DAT line inactive.
 * - 1 - DAT line active.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_DLA  (2U)          /*!< Bit position for SDHC_PRSSTAT_DLA. */
#define BM_SDHC_PRSSTAT_DLA  (0x00000004U) /*!< Bit mask for SDHC_PRSSTAT_DLA. */
#define BS_SDHC_PRSSTAT_DLA  (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_DLA. */

/*! @brief Read current value of the SDHC_PRSSTAT_DLA field. */
#define BR_SDHC_PRSSTAT_DLA(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_DLA))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field SDSTB[3] (RO)
 *
 * Indicates that the internal card clock is stable. This bit is for the host
 * driver to poll clock status when changing the clock frequency. It is recommended
 * to clear SYSCTL[SDCLKEN] to remove glitch on the card clock when the
 * frequency is changing.
 *
 * Values:
 * - 0 - Clock is changing frequency and not stable.
 * - 1 - Clock is stable.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_SDSTB (3U)         /*!< Bit position for SDHC_PRSSTAT_SDSTB. */
#define BM_SDHC_PRSSTAT_SDSTB (0x00000008U) /*!< Bit mask for SDHC_PRSSTAT_SDSTB. */
#define BS_SDHC_PRSSTAT_SDSTB (1U)         /*!< Bit field size in bits for SDHC_PRSSTAT_SDSTB. */

/*! @brief Read current value of the SDHC_PRSSTAT_SDSTB field. */
#define BR_SDHC_PRSSTAT_SDSTB(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_SDSTB))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field IPGOFF[4] (RO)
 *
 * Indicates that the bus clock is internally gated off. This bit is for the
 * host driver to debug.
 *
 * Values:
 * - 0 - Bus clock is active.
 * - 1 - Bus clock is gated off.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_IPGOFF (4U)        /*!< Bit position for SDHC_PRSSTAT_IPGOFF. */
#define BM_SDHC_PRSSTAT_IPGOFF (0x00000010U) /*!< Bit mask for SDHC_PRSSTAT_IPGOFF. */
#define BS_SDHC_PRSSTAT_IPGOFF (1U)        /*!< Bit field size in bits for SDHC_PRSSTAT_IPGOFF. */

/*! @brief Read current value of the SDHC_PRSSTAT_IPGOFF field. */
#define BR_SDHC_PRSSTAT_IPGOFF(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_IPGOFF))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field HCKOFF[5] (RO)
 *
 * Indicates that the system clock is internally gated off. This bit is for the
 * host driver to debug during a data transfer.
 *
 * Values:
 * - 0 - System clock is active.
 * - 1 - System clock is gated off.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_HCKOFF (5U)        /*!< Bit position for SDHC_PRSSTAT_HCKOFF. */
#define BM_SDHC_PRSSTAT_HCKOFF (0x00000020U) /*!< Bit mask for SDHC_PRSSTAT_HCKOFF. */
#define BS_SDHC_PRSSTAT_HCKOFF (1U)        /*!< Bit field size in bits for SDHC_PRSSTAT_HCKOFF. */

/*! @brief Read current value of the SDHC_PRSSTAT_HCKOFF field. */
#define BR_SDHC_PRSSTAT_HCKOFF(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_HCKOFF))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field PEROFF[6] (RO)
 *
 * Indicates that the is internally gated off. This bit is for the host driver
 * to debug transaction on the SD bus. When INITA bit is set, SDHC sending 80
 * clock cycles to the card, SDCLKEN must be 1 to enable the output card clock,
 * otherwise the will never be gate off, so and will be always active. SDHC clock SDHC
 * clock SDHC clock bus clock
 *
 * Values:
 * - 0 - SDHC clock is active.
 * - 1 - SDHC clock is gated off.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_PEROFF (6U)        /*!< Bit position for SDHC_PRSSTAT_PEROFF. */
#define BM_SDHC_PRSSTAT_PEROFF (0x00000040U) /*!< Bit mask for SDHC_PRSSTAT_PEROFF. */
#define BS_SDHC_PRSSTAT_PEROFF (1U)        /*!< Bit field size in bits for SDHC_PRSSTAT_PEROFF. */

/*! @brief Read current value of the SDHC_PRSSTAT_PEROFF field. */
#define BR_SDHC_PRSSTAT_PEROFF(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_PEROFF))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field SDOFF[7] (RO)
 *
 * Indicates that the SD clock is internally gated off, because of buffer
 * over/under-run or read pause without read wait assertion, or the driver has cleared
 * SYSCTL[SDCLKEN] to stop the SD clock. This bit is for the host driver to debug
 * data transaction on the SD bus.
 *
 * Values:
 * - 0 - SD clock is active.
 * - 1 - SD clock is gated off.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_SDOFF (7U)         /*!< Bit position for SDHC_PRSSTAT_SDOFF. */
#define BM_SDHC_PRSSTAT_SDOFF (0x00000080U) /*!< Bit mask for SDHC_PRSSTAT_SDOFF. */
#define BS_SDHC_PRSSTAT_SDOFF (1U)         /*!< Bit field size in bits for SDHC_PRSSTAT_SDOFF. */

/*! @brief Read current value of the SDHC_PRSSTAT_SDOFF field. */
#define BR_SDHC_PRSSTAT_SDOFF(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_SDOFF))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field WTA[8] (RO)
 *
 * Indicates that a write transfer is active. If this bit is 0, it means no
 * valid write data exists in the SDHC. This bit is set in either of the following
 * cases: After the end bit of the write command. When writing 1 to PROCTL[CREQ] to
 * restart a write transfer. This bit is cleared in either of the following
 * cases: After getting the CRC status of the last data block as specified by the
 * transfer count (single and multiple). After getting the CRC status of any block
 * where data transmission is about to be stopped by a stop at block gap request.
 * During a write transaction, a block gap event interrupt is generated when this
 * bit is changed to 0, as result of the stop at block gap request being set.
 * This status is useful for the host driver in determining when to issue commands
 * during write busy state.
 *
 * Values:
 * - 0 - No valid data.
 * - 1 - Transferring data.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_WTA  (8U)          /*!< Bit position for SDHC_PRSSTAT_WTA. */
#define BM_SDHC_PRSSTAT_WTA  (0x00000100U) /*!< Bit mask for SDHC_PRSSTAT_WTA. */
#define BS_SDHC_PRSSTAT_WTA  (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_WTA. */

/*! @brief Read current value of the SDHC_PRSSTAT_WTA field. */
#define BR_SDHC_PRSSTAT_WTA(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_WTA))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field RTA[9] (RO)
 *
 * Used for detecting completion of a read transfer. This bit is set for either
 * of the following conditions: After the end bit of the read command. When
 * writing a 1 to PROCTL[CREQ] to restart a read transfer. A transfer complete
 * interrupt is generated when this bit changes to 0. This bit is cleared for either of
 * the following conditions: When the last data block as specified by block
 * length is transferred to the system, that is, all data are read away from SDHC
 * internal buffer. When all valid data blocks have been transferred from SDHC
 * internal buffer to the system and no current block transfers are being sent as a
 * result of the stop at block gap request being set to 1.
 *
 * Values:
 * - 0 - No valid data.
 * - 1 - Transferring data.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_RTA  (9U)          /*!< Bit position for SDHC_PRSSTAT_RTA. */
#define BM_SDHC_PRSSTAT_RTA  (0x00000200U) /*!< Bit mask for SDHC_PRSSTAT_RTA. */
#define BS_SDHC_PRSSTAT_RTA  (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_RTA. */

/*! @brief Read current value of the SDHC_PRSSTAT_RTA field. */
#define BR_SDHC_PRSSTAT_RTA(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_RTA))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field BWEN[10] (RO)
 *
 * Used for non-DMA write transfers. The SDHC can implement multiple buffers to
 * transfer data efficiently. This read-only flag indicates whether space is
 * available for write data. If this bit is 1, valid data greater than the watermark
 * level can be written to the buffer. This read-only flag indicates whether
 * space is available for write data.
 *
 * Values:
 * - 0 - Write disable, the buffer can hold valid data less than the write
 *     watermark level.
 * - 1 - Write enable, the buffer can hold valid data greater than the write
 *     watermark level.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_BWEN (10U)         /*!< Bit position for SDHC_PRSSTAT_BWEN. */
#define BM_SDHC_PRSSTAT_BWEN (0x00000400U) /*!< Bit mask for SDHC_PRSSTAT_BWEN. */
#define BS_SDHC_PRSSTAT_BWEN (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_BWEN. */

/*! @brief Read current value of the SDHC_PRSSTAT_BWEN field. */
#define BR_SDHC_PRSSTAT_BWEN(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_BWEN))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field BREN[11] (RO)
 *
 * Used for non-DMA read transfers. The SDHC may implement multiple buffers to
 * transfer data efficiently. This read-only flag indicates that valid data exists
 * in the host side buffer. If this bit is high, valid data greater than the
 * watermark level exist in the buffer. This read-only flag indicates that valid
 * data exists in the host side buffer.
 *
 * Values:
 * - 0 - Read disable, valid data less than the watermark level exist in the
 *     buffer.
 * - 1 - Read enable, valid data greater than the watermark level exist in the
 *     buffer.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_BREN (11U)         /*!< Bit position for SDHC_PRSSTAT_BREN. */
#define BM_SDHC_PRSSTAT_BREN (0x00000800U) /*!< Bit mask for SDHC_PRSSTAT_BREN. */
#define BS_SDHC_PRSSTAT_BREN (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_BREN. */

/*! @brief Read current value of the SDHC_PRSSTAT_BREN field. */
#define BR_SDHC_PRSSTAT_BREN(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_BREN))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field CINS[16] (RO)
 *
 * Indicates whether a card has been inserted. The SDHC debounces this signal so
 * that the host driver will not need to wait for it to stabilize. Changing from
 * a 0 to 1 generates a card insertion interrupt in the Interrupt Status
 * register. Changing from a 1 to 0 generates a card removal interrupt in the Interrupt
 * Status register. A write to the force event register does not effect this bit.
 * SYSCTL[RSTA] does not effect this bit. A software reset does not effect this
 * bit.
 *
 * Values:
 * - 0 - Power on reset or no card.
 * - 1 - Card inserted.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_CINS (16U)         /*!< Bit position for SDHC_PRSSTAT_CINS. */
#define BM_SDHC_PRSSTAT_CINS (0x00010000U) /*!< Bit mask for SDHC_PRSSTAT_CINS. */
#define BS_SDHC_PRSSTAT_CINS (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_CINS. */

/*! @brief Read current value of the SDHC_PRSSTAT_CINS field. */
#define BR_SDHC_PRSSTAT_CINS(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_CINS))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field CLSL[23] (RO)
 *
 * Used to check the CMD line level to recover from errors, and for debugging.
 * The reset value is effected by the external pullup/pulldown resistor, by
 * default, the read value of this bit after reset is 1b, when the command line is
 * pulled up.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_CLSL (23U)         /*!< Bit position for SDHC_PRSSTAT_CLSL. */
#define BM_SDHC_PRSSTAT_CLSL (0x00800000U) /*!< Bit mask for SDHC_PRSSTAT_CLSL. */
#define BS_SDHC_PRSSTAT_CLSL (1U)          /*!< Bit field size in bits for SDHC_PRSSTAT_CLSL. */

/*! @brief Read current value of the SDHC_PRSSTAT_CLSL field. */
#define BR_SDHC_PRSSTAT_CLSL(x) (BITBAND_ACCESS32(HW_SDHC_PRSSTAT_ADDR(x), BP_SDHC_PRSSTAT_CLSL))
/*@}*/

/*!
 * @name Register SDHC_PRSSTAT, field DLSL[31:24] (RO)
 *
 * Used to check the DAT line level to recover from errors, and for debugging.
 * This is especially useful in detecting the busy signal level from DAT[0]. The
 * reset value is effected by the external pullup/pulldown resistors. By default,
 * the read value of this field after reset is 8'b11110111, when DAT[3] is pulled
 * down and the other lines are pulled up.
 */
/*@{*/
#define BP_SDHC_PRSSTAT_DLSL (24U)         /*!< Bit position for SDHC_PRSSTAT_DLSL. */
#define BM_SDHC_PRSSTAT_DLSL (0xFF000000U) /*!< Bit mask for SDHC_PRSSTAT_DLSL. */
#define BS_SDHC_PRSSTAT_DLSL (8U)          /*!< Bit field size in bits for SDHC_PRSSTAT_DLSL. */

/*! @brief Read current value of the SDHC_PRSSTAT_DLSL field. */
#define BR_SDHC_PRSSTAT_DLSL(x) (HW_SDHC_PRSSTAT(x).B.DLSL)
/*@}*/

/*******************************************************************************
 * HW_SDHC_PROCTL - Protocol Control register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_PROCTL - Protocol Control register (RW)
 *
 * Reset value: 0x00000020U
 *
 * There are three cases to restart the transfer after stop at the block gap.
 * Which case is appropriate depends on whether the SDHC issues a suspend command
 * or the SD card accepts the suspend command: If the host driver does not issue a
 * suspend command, the continue request shall be used to restart the transfer.
 * If the host driver issues a suspend command and the SD card accepts it, a
 * resume command shall be used to restart the transfer. If the host driver issues a
 * suspend command and the SD card does not accept it, the continue request shall
 * be used to restart the transfer. Any time stop at block gap request stops the
 * data transfer, the host driver shall wait for a transfer complete (in the
 * interrupt status register), before attempting to restart the transfer. When
 * restarting the data transfer by continue request, the host driver shall clear the
 * stop at block gap request before or simultaneously.
 */
typedef union _hw_sdhc_proctl
{
    uint32_t U;
    struct _hw_sdhc_proctl_bitfields
    {
        uint32_t LCTL : 1;             /*!< [0] LED Control */
        uint32_t DTW : 2;              /*!< [2:1] Data Transfer Width */
        uint32_t D3CD : 1;             /*!< [3] DAT3 As Card Detection Pin */
        uint32_t EMODE : 2;            /*!< [5:4] Endian Mode */
        uint32_t CDTL : 1;             /*!< [6] Card Detect Test Level */
        uint32_t CDSS : 1;             /*!< [7] Card Detect Signal Selection */
        uint32_t DMAS : 2;             /*!< [9:8] DMA Select */
        uint32_t RESERVED0 : 6;        /*!< [15:10]  */
        uint32_t SABGREQ : 1;          /*!< [16] Stop At Block Gap Request */
        uint32_t CREQ : 1;             /*!< [17] Continue Request */
        uint32_t RWCTL : 1;            /*!< [18] Read Wait Control */
        uint32_t IABG : 1;             /*!< [19] Interrupt At Block Gap */
        uint32_t RESERVED1 : 4;        /*!< [23:20]  */
        uint32_t WECINT : 1;           /*!< [24] Wakeup Event Enable On Card Interrupt
                                        * */
        uint32_t WECINS : 1;           /*!< [25] Wakeup Event Enable On SD Card
                                        * Insertion */
        uint32_t WECRM : 1;            /*!< [26] Wakeup Event Enable On SD Card Removal
                                        * */
        uint32_t RESERVED2 : 5;        /*!< [31:27]  */
    } B;
} hw_sdhc_proctl_t;

/*!
 * @name Constants and macros for entire SDHC_PROCTL register
 */
/*@{*/
#define HW_SDHC_PROCTL_ADDR(x)   ((uint32_t)(x) + 0x28U)

#define HW_SDHC_PROCTL(x)        (*(__IO hw_sdhc_proctl_t *) HW_SDHC_PROCTL_ADDR(x))
#define HW_SDHC_PROCTL_RD(x)     (HW_SDHC_PROCTL(x).U)
#define HW_SDHC_PROCTL_WR(x, v)  (HW_SDHC_PROCTL(x).U = (v))
#define HW_SDHC_PROCTL_SET(x, v) (HW_SDHC_PROCTL_WR(x, HW_SDHC_PROCTL_RD(x) |  (v)))
#define HW_SDHC_PROCTL_CLR(x, v) (HW_SDHC_PROCTL_WR(x, HW_SDHC_PROCTL_RD(x) & ~(v)))
#define HW_SDHC_PROCTL_TOG(x, v) (HW_SDHC_PROCTL_WR(x, HW_SDHC_PROCTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_PROCTL bitfields
 */

/*!
 * @name Register SDHC_PROCTL, field LCTL[0] (RW)
 *
 * This bit, fully controlled by the host driver, is used to caution the user
 * not to remove the card while the card is being accessed. If the software is
 * going to issue multiple SD commands, this bit can be set during all these
 * transactions. It is not necessary to change for each transaction. When the software
 * issues multiple SD commands, setting the bit once before the first command is
 * sufficient: it is not necessary to reset the bit between commands.
 *
 * Values:
 * - 0 - LED off.
 * - 1 - LED on.
 */
/*@{*/
#define BP_SDHC_PROCTL_LCTL  (0U)          /*!< Bit position for SDHC_PROCTL_LCTL. */
#define BM_SDHC_PROCTL_LCTL  (0x00000001U) /*!< Bit mask for SDHC_PROCTL_LCTL. */
#define BS_SDHC_PROCTL_LCTL  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_LCTL. */

/*! @brief Read current value of the SDHC_PROCTL_LCTL field. */
#define BR_SDHC_PROCTL_LCTL(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_LCTL))

/*! @brief Format value for bitfield SDHC_PROCTL_LCTL. */
#define BF_SDHC_PROCTL_LCTL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_LCTL) & BM_SDHC_PROCTL_LCTL)

/*! @brief Set the LCTL field to a new value. */
#define BW_SDHC_PROCTL_LCTL(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_LCTL) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field DTW[2:1] (RW)
 *
 * Selects the data width of the SD bus for a data transfer. The host driver
 * shall set it to match the data width of the card. Possible data transfer width is
 * 1-bit, 4-bits or 8-bits.
 *
 * Values:
 * - 00 - 1-bit mode
 * - 01 - 4-bit mode
 * - 10 - 8-bit mode
 * - 11 - Reserved
 */
/*@{*/
#define BP_SDHC_PROCTL_DTW   (1U)          /*!< Bit position for SDHC_PROCTL_DTW. */
#define BM_SDHC_PROCTL_DTW   (0x00000006U) /*!< Bit mask for SDHC_PROCTL_DTW. */
#define BS_SDHC_PROCTL_DTW   (2U)          /*!< Bit field size in bits for SDHC_PROCTL_DTW. */

/*! @brief Read current value of the SDHC_PROCTL_DTW field. */
#define BR_SDHC_PROCTL_DTW(x) (HW_SDHC_PROCTL(x).B.DTW)

/*! @brief Format value for bitfield SDHC_PROCTL_DTW. */
#define BF_SDHC_PROCTL_DTW(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_DTW) & BM_SDHC_PROCTL_DTW)

/*! @brief Set the DTW field to a new value. */
#define BW_SDHC_PROCTL_DTW(x, v) (HW_SDHC_PROCTL_WR(x, (HW_SDHC_PROCTL_RD(x) & ~BM_SDHC_PROCTL_DTW) | BF_SDHC_PROCTL_DTW(v)))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field D3CD[3] (RW)
 *
 * If this bit is set, DAT3 should be pulled down to act as a card detection
 * pin. Be cautious when using this feature, because DAT3 is also a chip-select for
 * the SPI mode. A pulldown on this pin and CMD0 may set the card into the SPI
 * mode, which the SDHC does not support. Note: Keep this bit set if SDIO interrupt
 * is used.
 *
 * Values:
 * - 0 - DAT3 does not monitor card Insertion.
 * - 1 - DAT3 as card detection pin.
 */
/*@{*/
#define BP_SDHC_PROCTL_D3CD  (3U)          /*!< Bit position for SDHC_PROCTL_D3CD. */
#define BM_SDHC_PROCTL_D3CD  (0x00000008U) /*!< Bit mask for SDHC_PROCTL_D3CD. */
#define BS_SDHC_PROCTL_D3CD  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_D3CD. */

/*! @brief Read current value of the SDHC_PROCTL_D3CD field. */
#define BR_SDHC_PROCTL_D3CD(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_D3CD))

/*! @brief Format value for bitfield SDHC_PROCTL_D3CD. */
#define BF_SDHC_PROCTL_D3CD(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_D3CD) & BM_SDHC_PROCTL_D3CD)

/*! @brief Set the D3CD field to a new value. */
#define BW_SDHC_PROCTL_D3CD(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_D3CD) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field EMODE[5:4] (RW)
 *
 * The SDHC supports all four endian modes in data transfer.
 *
 * Values:
 * - 00 - Big endian mode
 * - 01 - Half word big endian mode
 * - 10 - Little endian mode
 * - 11 - Reserved
 */
/*@{*/
#define BP_SDHC_PROCTL_EMODE (4U)          /*!< Bit position for SDHC_PROCTL_EMODE. */
#define BM_SDHC_PROCTL_EMODE (0x00000030U) /*!< Bit mask for SDHC_PROCTL_EMODE. */
#define BS_SDHC_PROCTL_EMODE (2U)          /*!< Bit field size in bits for SDHC_PROCTL_EMODE. */

/*! @brief Read current value of the SDHC_PROCTL_EMODE field. */
#define BR_SDHC_PROCTL_EMODE(x) (HW_SDHC_PROCTL(x).B.EMODE)

/*! @brief Format value for bitfield SDHC_PROCTL_EMODE. */
#define BF_SDHC_PROCTL_EMODE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_EMODE) & BM_SDHC_PROCTL_EMODE)

/*! @brief Set the EMODE field to a new value. */
#define BW_SDHC_PROCTL_EMODE(x, v) (HW_SDHC_PROCTL_WR(x, (HW_SDHC_PROCTL_RD(x) & ~BM_SDHC_PROCTL_EMODE) | BF_SDHC_PROCTL_EMODE(v)))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field CDTL[6] (RW)
 *
 * Enabled while the CDSS is set to 1 and it indicates card insertion.
 *
 * Values:
 * - 0 - Card detect test level is 0, no card inserted.
 * - 1 - Card detect test level is 1, card inserted.
 */
/*@{*/
#define BP_SDHC_PROCTL_CDTL  (6U)          /*!< Bit position for SDHC_PROCTL_CDTL. */
#define BM_SDHC_PROCTL_CDTL  (0x00000040U) /*!< Bit mask for SDHC_PROCTL_CDTL. */
#define BS_SDHC_PROCTL_CDTL  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_CDTL. */

/*! @brief Read current value of the SDHC_PROCTL_CDTL field. */
#define BR_SDHC_PROCTL_CDTL(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CDTL))

/*! @brief Format value for bitfield SDHC_PROCTL_CDTL. */
#define BF_SDHC_PROCTL_CDTL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_CDTL) & BM_SDHC_PROCTL_CDTL)

/*! @brief Set the CDTL field to a new value. */
#define BW_SDHC_PROCTL_CDTL(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CDTL) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field CDSS[7] (RW)
 *
 * Selects the source for the card detection.
 *
 * Values:
 * - 0 - Card detection level is selected for normal purpose.
 * - 1 - Card detection test level is selected for test purpose.
 */
/*@{*/
#define BP_SDHC_PROCTL_CDSS  (7U)          /*!< Bit position for SDHC_PROCTL_CDSS. */
#define BM_SDHC_PROCTL_CDSS  (0x00000080U) /*!< Bit mask for SDHC_PROCTL_CDSS. */
#define BS_SDHC_PROCTL_CDSS  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_CDSS. */

/*! @brief Read current value of the SDHC_PROCTL_CDSS field. */
#define BR_SDHC_PROCTL_CDSS(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CDSS))

/*! @brief Format value for bitfield SDHC_PROCTL_CDSS. */
#define BF_SDHC_PROCTL_CDSS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_CDSS) & BM_SDHC_PROCTL_CDSS)

/*! @brief Set the CDSS field to a new value. */
#define BW_SDHC_PROCTL_CDSS(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CDSS) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field DMAS[9:8] (RW)
 *
 * This field is valid while DMA (SDMA or ADMA) is enabled and selects the DMA
 * operation.
 *
 * Values:
 * - 00 - No DMA or simple DMA is selected.
 * - 01 - ADMA1 is selected.
 * - 10 - ADMA2 is selected.
 * - 11 - Reserved
 */
/*@{*/
#define BP_SDHC_PROCTL_DMAS  (8U)          /*!< Bit position for SDHC_PROCTL_DMAS. */
#define BM_SDHC_PROCTL_DMAS  (0x00000300U) /*!< Bit mask for SDHC_PROCTL_DMAS. */
#define BS_SDHC_PROCTL_DMAS  (2U)          /*!< Bit field size in bits for SDHC_PROCTL_DMAS. */

/*! @brief Read current value of the SDHC_PROCTL_DMAS field. */
#define BR_SDHC_PROCTL_DMAS(x) (HW_SDHC_PROCTL(x).B.DMAS)

/*! @brief Format value for bitfield SDHC_PROCTL_DMAS. */
#define BF_SDHC_PROCTL_DMAS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_DMAS) & BM_SDHC_PROCTL_DMAS)

/*! @brief Set the DMAS field to a new value. */
#define BW_SDHC_PROCTL_DMAS(x, v) (HW_SDHC_PROCTL_WR(x, (HW_SDHC_PROCTL_RD(x) & ~BM_SDHC_PROCTL_DMAS) | BF_SDHC_PROCTL_DMAS(v)))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field SABGREQ[16] (RW)
 *
 * Used to stop executing a transaction at the next block gap for both DMA and
 * non-DMA transfers. Until the IRQSTATEN[TCSEN] is set to 1, indicating a
 * transfer completion, the host driver shall leave this bit set to 1. Clearing both
 * PROCTL[SABGREQ] and PROCTL[CREQ] does not cause the transaction to restart. Read
 * Wait is used to stop the read transaction at the block gap. The SDHC will
 * honor the PROCTL[SABGREQ] for write transfers, but for read transfers it requires
 * that SDIO card support read wait. Therefore, the host driver shall not set
 * this bit during read transfers unless the SDIO card supports read wait and has
 * set PROCTL[RWCTL] to 1, otherwise the SDHC will stop the SD bus clock to pause
 * the read operation during block gap. In the case of write transfers in which
 * the host driver writes data to the data port register, the host driver shall set
 * this bit after all block data is written. If this bit is set to 1, the host
 * driver shall not write data to the Data Port register after a block is sent.
 * Once this bit is set, the host driver shall not clear this bit before
 * IRQSTATEN[TCSEN] is set, otherwise the SDHC's behavior is undefined. This bit effects
 * PRSSTAT[RTA], PRSSTAT[WTA], and PRSSTAT[CDIHB].
 *
 * Values:
 * - 0 - Transfer
 * - 1 - Stop
 */
/*@{*/
#define BP_SDHC_PROCTL_SABGREQ (16U)       /*!< Bit position for SDHC_PROCTL_SABGREQ. */
#define BM_SDHC_PROCTL_SABGREQ (0x00010000U) /*!< Bit mask for SDHC_PROCTL_SABGREQ. */
#define BS_SDHC_PROCTL_SABGREQ (1U)        /*!< Bit field size in bits for SDHC_PROCTL_SABGREQ. */

/*! @brief Read current value of the SDHC_PROCTL_SABGREQ field. */
#define BR_SDHC_PROCTL_SABGREQ(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_SABGREQ))

/*! @brief Format value for bitfield SDHC_PROCTL_SABGREQ. */
#define BF_SDHC_PROCTL_SABGREQ(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_SABGREQ) & BM_SDHC_PROCTL_SABGREQ)

/*! @brief Set the SABGREQ field to a new value. */
#define BW_SDHC_PROCTL_SABGREQ(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_SABGREQ) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field CREQ[17] (RW)
 *
 * Used to restart a transaction which was stopped using the PROCTL[SABGREQ].
 * When a suspend operation is not accepted by the card, it is also by setting this
 * bit to restart the paused transfer. To cancel stop at the block gap, set
 * PROCTL[SABGREQ] to 0 and set this bit to 1 to restart the transfer. The SDHC
 * automatically clears this bit, therefore it is not necessary for the host driver to
 * set this bit to 0. If both PROCTL[SABGREQ] and this bit are 1, the continue
 * request is ignored.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Restart
 */
/*@{*/
#define BP_SDHC_PROCTL_CREQ  (17U)         /*!< Bit position for SDHC_PROCTL_CREQ. */
#define BM_SDHC_PROCTL_CREQ  (0x00020000U) /*!< Bit mask for SDHC_PROCTL_CREQ. */
#define BS_SDHC_PROCTL_CREQ  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_CREQ. */

/*! @brief Read current value of the SDHC_PROCTL_CREQ field. */
#define BR_SDHC_PROCTL_CREQ(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CREQ))

/*! @brief Format value for bitfield SDHC_PROCTL_CREQ. */
#define BF_SDHC_PROCTL_CREQ(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_CREQ) & BM_SDHC_PROCTL_CREQ)

/*! @brief Set the CREQ field to a new value. */
#define BW_SDHC_PROCTL_CREQ(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_CREQ) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field RWCTL[18] (RW)
 *
 * The read wait function is optional for SDIO cards. If the card supports read
 * wait, set this bit to enable use of the read wait protocol to stop read data
 * using the DAT[2] line. Otherwise, the SDHC has to stop the SD Clock to hold
 * read data, which restricts commands generation. When the host driver detects an
 * SDIO card insertion, it shall set this bit according to the CCCR of the card.
 * If the card does not support read wait, this bit shall never be set to 1,
 * otherwise DAT line conflicts may occur. If this bit is set to 0, stop at block gap
 * during read operation is also supported, but the SDHC will stop the SD Clock
 * to pause reading operation.
 *
 * Values:
 * - 0 - Disable read wait control, and stop SD clock at block gap when SABGREQ
 *     is set.
 * - 1 - Enable read wait control, and assert read wait without stopping SD
 *     clock at block gap when SABGREQ bit is set.
 */
/*@{*/
#define BP_SDHC_PROCTL_RWCTL (18U)         /*!< Bit position for SDHC_PROCTL_RWCTL. */
#define BM_SDHC_PROCTL_RWCTL (0x00040000U) /*!< Bit mask for SDHC_PROCTL_RWCTL. */
#define BS_SDHC_PROCTL_RWCTL (1U)          /*!< Bit field size in bits for SDHC_PROCTL_RWCTL. */

/*! @brief Read current value of the SDHC_PROCTL_RWCTL field. */
#define BR_SDHC_PROCTL_RWCTL(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_RWCTL))

/*! @brief Format value for bitfield SDHC_PROCTL_RWCTL. */
#define BF_SDHC_PROCTL_RWCTL(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_RWCTL) & BM_SDHC_PROCTL_RWCTL)

/*! @brief Set the RWCTL field to a new value. */
#define BW_SDHC_PROCTL_RWCTL(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_RWCTL) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field IABG[19] (RW)
 *
 * Valid only in 4-bit mode, of the SDIO card, and selects a sample point in the
 * interrupt cycle. Setting to 1 enables interrupt detection at the block gap
 * for a multiple block transfer. Setting to 0 disables interrupt detection during
 * a multiple block transfer. If the SDIO card can't signal an interrupt during a
 * multiple block transfer, this bit must be set to 0 to avoid an inadvertent
 * interrupt. When the host driver detects an SDIO card insertion, it shall set
 * this bit according to the CCCR of the card.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_PROCTL_IABG  (19U)         /*!< Bit position for SDHC_PROCTL_IABG. */
#define BM_SDHC_PROCTL_IABG  (0x00080000U) /*!< Bit mask for SDHC_PROCTL_IABG. */
#define BS_SDHC_PROCTL_IABG  (1U)          /*!< Bit field size in bits for SDHC_PROCTL_IABG. */

/*! @brief Read current value of the SDHC_PROCTL_IABG field. */
#define BR_SDHC_PROCTL_IABG(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_IABG))

/*! @brief Format value for bitfield SDHC_PROCTL_IABG. */
#define BF_SDHC_PROCTL_IABG(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_IABG) & BM_SDHC_PROCTL_IABG)

/*! @brief Set the IABG field to a new value. */
#define BW_SDHC_PROCTL_IABG(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_IABG) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field WECINT[24] (RW)
 *
 * Enables a wakeup event, via IRQSTAT[CINT]. This bit can be set to 1 if FN_WUS
 * (Wake Up Support) in CIS is set to 1. When this bit is set, the card
 * interrupt status and the SDHC interrupt can be asserted without SD_CLK toggling. When
 * the wakeup feature is not enabled, the SD_CLK must be active to assert the
 * card interrupt status and the SDHC interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_PROCTL_WECINT (24U)        /*!< Bit position for SDHC_PROCTL_WECINT. */
#define BM_SDHC_PROCTL_WECINT (0x01000000U) /*!< Bit mask for SDHC_PROCTL_WECINT. */
#define BS_SDHC_PROCTL_WECINT (1U)         /*!< Bit field size in bits for SDHC_PROCTL_WECINT. */

/*! @brief Read current value of the SDHC_PROCTL_WECINT field. */
#define BR_SDHC_PROCTL_WECINT(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECINT))

/*! @brief Format value for bitfield SDHC_PROCTL_WECINT. */
#define BF_SDHC_PROCTL_WECINT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_WECINT) & BM_SDHC_PROCTL_WECINT)

/*! @brief Set the WECINT field to a new value. */
#define BW_SDHC_PROCTL_WECINT(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECINT) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field WECINS[25] (RW)
 *
 * Enables a wakeup event, via IRQSTAT[CINS]. FN_WUS (Wake Up Support) in CIS
 * does not effect this bit. When this bit is set, IRQSTATEN[CINSEN] and the SDHC
 * interrupt can be asserted without SD_CLK toggling. When the wakeup feature is
 * not enabled, the SD_CLK must be active to assert IRQSTATEN[CINSEN] and the SDHC
 * interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_PROCTL_WECINS (25U)        /*!< Bit position for SDHC_PROCTL_WECINS. */
#define BM_SDHC_PROCTL_WECINS (0x02000000U) /*!< Bit mask for SDHC_PROCTL_WECINS. */
#define BS_SDHC_PROCTL_WECINS (1U)         /*!< Bit field size in bits for SDHC_PROCTL_WECINS. */

/*! @brief Read current value of the SDHC_PROCTL_WECINS field. */
#define BR_SDHC_PROCTL_WECINS(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECINS))

/*! @brief Format value for bitfield SDHC_PROCTL_WECINS. */
#define BF_SDHC_PROCTL_WECINS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_WECINS) & BM_SDHC_PROCTL_WECINS)

/*! @brief Set the WECINS field to a new value. */
#define BW_SDHC_PROCTL_WECINS(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECINS) = (v))
/*@}*/

/*!
 * @name Register SDHC_PROCTL, field WECRM[26] (RW)
 *
 * Enables a wakeup event, via IRQSTAT[CRM]. FN_WUS (Wake Up Support) in CIS
 * does not effect this bit. When this bit is set, IRQSTAT[CRM] and the SDHC
 * interrupt can be asserted without SD_CLK toggling. When the wakeup feature is not
 * enabled, the SD_CLK must be active to assert IRQSTAT[CRM] and the SDHC interrupt.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_PROCTL_WECRM (26U)         /*!< Bit position for SDHC_PROCTL_WECRM. */
#define BM_SDHC_PROCTL_WECRM (0x04000000U) /*!< Bit mask for SDHC_PROCTL_WECRM. */
#define BS_SDHC_PROCTL_WECRM (1U)          /*!< Bit field size in bits for SDHC_PROCTL_WECRM. */

/*! @brief Read current value of the SDHC_PROCTL_WECRM field. */
#define BR_SDHC_PROCTL_WECRM(x) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECRM))

/*! @brief Format value for bitfield SDHC_PROCTL_WECRM. */
#define BF_SDHC_PROCTL_WECRM(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_PROCTL_WECRM) & BM_SDHC_PROCTL_WECRM)

/*! @brief Set the WECRM field to a new value. */
#define BW_SDHC_PROCTL_WECRM(x, v) (BITBAND_ACCESS32(HW_SDHC_PROCTL_ADDR(x), BP_SDHC_PROCTL_WECRM) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_SYSCTL - System Control register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_SYSCTL - System Control register (RW)
 *
 * Reset value: 0x00008008U
 */
typedef union _hw_sdhc_sysctl
{
    uint32_t U;
    struct _hw_sdhc_sysctl_bitfields
    {
        uint32_t IPGEN : 1;            /*!< [0] IPG Clock Enable */
        uint32_t HCKEN : 1;            /*!< [1] System Clock Enable */
        uint32_t PEREN : 1;            /*!< [2] Peripheral Clock Enable */
        uint32_t SDCLKEN : 1;          /*!< [3] SD Clock Enable */
        uint32_t DVS : 4;              /*!< [7:4] Divisor */
        uint32_t SDCLKFS : 8;          /*!< [15:8] SDCLK Frequency Select */
        uint32_t DTOCV : 4;            /*!< [19:16] Data Timeout Counter Value */
        uint32_t RESERVED0 : 4;        /*!< [23:20]  */
        uint32_t RSTA : 1;             /*!< [24] Software Reset For ALL */
        uint32_t RSTC : 1;             /*!< [25] Software Reset For CMD Line */
        uint32_t RSTD : 1;             /*!< [26] Software Reset For DAT Line */
        uint32_t INITA : 1;            /*!< [27] Initialization Active */
        uint32_t RESERVED1 : 4;        /*!< [31:28]  */
    } B;
} hw_sdhc_sysctl_t;

/*!
 * @name Constants and macros for entire SDHC_SYSCTL register
 */
/*@{*/
#define HW_SDHC_SYSCTL_ADDR(x)   ((uint32_t)(x) + 0x2CU)

#define HW_SDHC_SYSCTL(x)        (*(__IO hw_sdhc_sysctl_t *) HW_SDHC_SYSCTL_ADDR(x))
#define HW_SDHC_SYSCTL_RD(x)     (HW_SDHC_SYSCTL(x).U)
#define HW_SDHC_SYSCTL_WR(x, v)  (HW_SDHC_SYSCTL(x).U = (v))
#define HW_SDHC_SYSCTL_SET(x, v) (HW_SDHC_SYSCTL_WR(x, HW_SDHC_SYSCTL_RD(x) |  (v)))
#define HW_SDHC_SYSCTL_CLR(x, v) (HW_SDHC_SYSCTL_WR(x, HW_SDHC_SYSCTL_RD(x) & ~(v)))
#define HW_SDHC_SYSCTL_TOG(x, v) (HW_SDHC_SYSCTL_WR(x, HW_SDHC_SYSCTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_SYSCTL bitfields
 */

/*!
 * @name Register SDHC_SYSCTL, field IPGEN[0] (RW)
 *
 * If this bit is set, bus clock will always be active and no automatic gating
 * is applied. The bus clock will be internally gated off, if none of the
 * following factors are met: The cmd part is reset, or Data part is reset, or Soft
 * reset, or The cmd is about to send, or Clock divisor is just updated, or Continue
 * request is just set, or This bit is set, or Card insertion is detected, or Card
 * removal is detected, or Card external interrupt is detected, or The SDHC
 * clock is not gated off The bus clock will not be auto gated off if the SDHC clock
 * is not gated off. So clearing only this bit has no effect unless the PEREN bit
 * is also cleared.
 *
 * Values:
 * - 0 - Bus clock will be internally gated off.
 * - 1 - Bus clock will not be automatically gated off.
 */
/*@{*/
#define BP_SDHC_SYSCTL_IPGEN (0U)          /*!< Bit position for SDHC_SYSCTL_IPGEN. */
#define BM_SDHC_SYSCTL_IPGEN (0x00000001U) /*!< Bit mask for SDHC_SYSCTL_IPGEN. */
#define BS_SDHC_SYSCTL_IPGEN (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_IPGEN. */

/*! @brief Read current value of the SDHC_SYSCTL_IPGEN field. */
#define BR_SDHC_SYSCTL_IPGEN(x) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_IPGEN))

/*! @brief Format value for bitfield SDHC_SYSCTL_IPGEN. */
#define BF_SDHC_SYSCTL_IPGEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_IPGEN) & BM_SDHC_SYSCTL_IPGEN)

/*! @brief Set the IPGEN field to a new value. */
#define BW_SDHC_SYSCTL_IPGEN(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_IPGEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field HCKEN[1] (RW)
 *
 * If this bit is set, system clock will always be active and no automatic
 * gating is applied. When this bit is cleared, system clock will be automatically off
 * when no data transfer is on the SD bus.
 *
 * Values:
 * - 0 - System clock will be internally gated off.
 * - 1 - System clock will not be automatically gated off.
 */
/*@{*/
#define BP_SDHC_SYSCTL_HCKEN (1U)          /*!< Bit position for SDHC_SYSCTL_HCKEN. */
#define BM_SDHC_SYSCTL_HCKEN (0x00000002U) /*!< Bit mask for SDHC_SYSCTL_HCKEN. */
#define BS_SDHC_SYSCTL_HCKEN (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_HCKEN. */

/*! @brief Read current value of the SDHC_SYSCTL_HCKEN field. */
#define BR_SDHC_SYSCTL_HCKEN(x) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_HCKEN))

/*! @brief Format value for bitfield SDHC_SYSCTL_HCKEN. */
#define BF_SDHC_SYSCTL_HCKEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_HCKEN) & BM_SDHC_SYSCTL_HCKEN)

/*! @brief Set the HCKEN field to a new value. */
#define BW_SDHC_SYSCTL_HCKEN(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_HCKEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field PEREN[2] (RW)
 *
 * If this bit is set, SDHC clock will always be active and no automatic gating
 * is applied. Thus the SDCLK is active except for when auto gating-off during
 * buffer danger (buffer about to over-run or under-run). When this bit is cleared,
 * the SDHC clock will be automatically off whenever there is no transaction on
 * the SD bus. Because this bit is only a feature enabling bit, clearing this bit
 * does not stop SDCLK immediately. The SDHC clock will be internally gated off,
 * if none of the following factors are met: The cmd part is reset, or Data part
 * is reset, or A soft reset, or The cmd is about to send, or Clock divisor is
 * just updated, or Continue request is just set, or This bit is set, or Card
 * insertion is detected, or Card removal is detected, or Card external interrupt is
 * detected, or 80 clocks for initialization phase is ongoing
 *
 * Values:
 * - 0 - SDHC clock will be internally gated off.
 * - 1 - SDHC clock will not be automatically gated off.
 */
/*@{*/
#define BP_SDHC_SYSCTL_PEREN (2U)          /*!< Bit position for SDHC_SYSCTL_PEREN. */
#define BM_SDHC_SYSCTL_PEREN (0x00000004U) /*!< Bit mask for SDHC_SYSCTL_PEREN. */
#define BS_SDHC_SYSCTL_PEREN (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_PEREN. */

/*! @brief Read current value of the SDHC_SYSCTL_PEREN field. */
#define BR_SDHC_SYSCTL_PEREN(x) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_PEREN))

/*! @brief Format value for bitfield SDHC_SYSCTL_PEREN. */
#define BF_SDHC_SYSCTL_PEREN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_PEREN) & BM_SDHC_SYSCTL_PEREN)

/*! @brief Set the PEREN field to a new value. */
#define BW_SDHC_SYSCTL_PEREN(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_PEREN) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field SDCLKEN[3] (RW)
 *
 * The host controller shall stop SDCLK when writing this bit to 0. SDCLK
 * frequency can be changed when this bit is 0. Then, the host controller shall
 * maintain the same clock frequency until SDCLK is stopped (stop at SDCLK = 0). If the
 * IRQSTAT[CINS] is cleared, this bit must be cleared by the host driver to save
 * power.
 */
/*@{*/
#define BP_SDHC_SYSCTL_SDCLKEN (3U)        /*!< Bit position for SDHC_SYSCTL_SDCLKEN. */
#define BM_SDHC_SYSCTL_SDCLKEN (0x00000008U) /*!< Bit mask for SDHC_SYSCTL_SDCLKEN. */
#define BS_SDHC_SYSCTL_SDCLKEN (1U)        /*!< Bit field size in bits for SDHC_SYSCTL_SDCLKEN. */

/*! @brief Read current value of the SDHC_SYSCTL_SDCLKEN field. */
#define BR_SDHC_SYSCTL_SDCLKEN(x) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_SDCLKEN))

/*! @brief Format value for bitfield SDHC_SYSCTL_SDCLKEN. */
#define BF_SDHC_SYSCTL_SDCLKEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_SDCLKEN) & BM_SDHC_SYSCTL_SDCLKEN)

/*! @brief Set the SDCLKEN field to a new value. */
#define BW_SDHC_SYSCTL_SDCLKEN(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_SDCLKEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field DVS[7:4] (RW)
 *
 * Used to provide a more exact divisor to generate the desired SD clock
 * frequency. Note the divider can even support odd divisor without deterioration of
 * duty cycle. The setting are as following:
 *
 * Values:
 * - 0 - Divisor by 1.
 * - 1 - Divisor by 2.
 * - 1110 - Divisor by 15.
 * - 1111 - Divisor by 16.
 */
/*@{*/
#define BP_SDHC_SYSCTL_DVS   (4U)          /*!< Bit position for SDHC_SYSCTL_DVS. */
#define BM_SDHC_SYSCTL_DVS   (0x000000F0U) /*!< Bit mask for SDHC_SYSCTL_DVS. */
#define BS_SDHC_SYSCTL_DVS   (4U)          /*!< Bit field size in bits for SDHC_SYSCTL_DVS. */

/*! @brief Read current value of the SDHC_SYSCTL_DVS field. */
#define BR_SDHC_SYSCTL_DVS(x) (HW_SDHC_SYSCTL(x).B.DVS)

/*! @brief Format value for bitfield SDHC_SYSCTL_DVS. */
#define BF_SDHC_SYSCTL_DVS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_DVS) & BM_SDHC_SYSCTL_DVS)

/*! @brief Set the DVS field to a new value. */
#define BW_SDHC_SYSCTL_DVS(x, v) (HW_SDHC_SYSCTL_WR(x, (HW_SDHC_SYSCTL_RD(x) & ~BM_SDHC_SYSCTL_DVS) | BF_SDHC_SYSCTL_DVS(v)))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field SDCLKFS[15:8] (RW)
 *
 * Used to select the frequency of the SDCLK pin. The frequency is not
 * programmed directly. Rather this register holds the prescaler (this register) and
 * divisor (next register) of the base clock frequency register. Setting 00h bypasses
 * the frequency prescaler of the SD Clock. Multiple bits must not be set, or the
 * behavior of this prescaler is undefined. The two default divider values can
 * be calculated by the frequency of SDHC clock and the following divisor bits.
 * The frequency of SDCLK is set by the following formula: Clock frequency = (Base
 * clock) / (prescaler x divisor) For example, if the base clock frequency is 96
 * MHz, and the target frequency is 25 MHz, then choosing the prescaler value of
 * 01h and divisor value of 1h will yield 24 MHz, which is the nearest frequency
 * less than or equal to the target. Similarly, to approach a clock value of 400
 * kHz, the prescaler value of 08h and divisor value of eh yields the exact clock
 * value of 400 kHz. The reset value of this field is 80h, so if the input base
 * clock ( SDHC clock ) is about 96 MHz, the default SD clock after reset is 375
 * kHz. According to the SD Physical Specification Version 1.1 and the SDIO Card
 * Specification Version 1.2, the maximum SD clock frequency is 50 MHz and shall
 * never exceed this limit. Only the following settings are allowed:
 *
 * Values:
 * - 1 - Base clock divided by 2.
 * - 10 - Base clock divided by 4.
 * - 100 - Base clock divided by 8.
 * - 1000 - Base clock divided by 16.
 * - 10000 - Base clock divided by 32.
 * - 100000 - Base clock divided by 64.
 * - 1000000 - Base clock divided by 128.
 * - 10000000 - Base clock divided by 256.
 */
/*@{*/
#define BP_SDHC_SYSCTL_SDCLKFS (8U)        /*!< Bit position for SDHC_SYSCTL_SDCLKFS. */
#define BM_SDHC_SYSCTL_SDCLKFS (0x0000FF00U) /*!< Bit mask for SDHC_SYSCTL_SDCLKFS. */
#define BS_SDHC_SYSCTL_SDCLKFS (8U)        /*!< Bit field size in bits for SDHC_SYSCTL_SDCLKFS. */

/*! @brief Read current value of the SDHC_SYSCTL_SDCLKFS field. */
#define BR_SDHC_SYSCTL_SDCLKFS(x) (HW_SDHC_SYSCTL(x).B.SDCLKFS)

/*! @brief Format value for bitfield SDHC_SYSCTL_SDCLKFS. */
#define BF_SDHC_SYSCTL_SDCLKFS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_SDCLKFS) & BM_SDHC_SYSCTL_SDCLKFS)

/*! @brief Set the SDCLKFS field to a new value. */
#define BW_SDHC_SYSCTL_SDCLKFS(x, v) (HW_SDHC_SYSCTL_WR(x, (HW_SDHC_SYSCTL_RD(x) & ~BM_SDHC_SYSCTL_SDCLKFS) | BF_SDHC_SYSCTL_SDCLKFS(v)))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field DTOCV[19:16] (RW)
 *
 * Determines the interval by which DAT line timeouts are detected. See
 * IRQSTAT[DTOE] for information on factors that dictate time-out generation. Time-out
 * clock frequency will be generated by dividing the base clock SDCLK value by this
 * value. The host driver can clear IRQSTATEN[DTOESEN] to prevent inadvertent
 * time-out events.
 *
 * Values:
 * - 0000 - SDCLK x 2 13
 * - 0001 - SDCLK x 2 14
 * - 1110 - SDCLK x 2 27
 * - 1111 - Reserved
 */
/*@{*/
#define BP_SDHC_SYSCTL_DTOCV (16U)         /*!< Bit position for SDHC_SYSCTL_DTOCV. */
#define BM_SDHC_SYSCTL_DTOCV (0x000F0000U) /*!< Bit mask for SDHC_SYSCTL_DTOCV. */
#define BS_SDHC_SYSCTL_DTOCV (4U)          /*!< Bit field size in bits for SDHC_SYSCTL_DTOCV. */

/*! @brief Read current value of the SDHC_SYSCTL_DTOCV field. */
#define BR_SDHC_SYSCTL_DTOCV(x) (HW_SDHC_SYSCTL(x).B.DTOCV)

/*! @brief Format value for bitfield SDHC_SYSCTL_DTOCV. */
#define BF_SDHC_SYSCTL_DTOCV(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_DTOCV) & BM_SDHC_SYSCTL_DTOCV)

/*! @brief Set the DTOCV field to a new value. */
#define BW_SDHC_SYSCTL_DTOCV(x, v) (HW_SDHC_SYSCTL_WR(x, (HW_SDHC_SYSCTL_RD(x) & ~BM_SDHC_SYSCTL_DTOCV) | BF_SDHC_SYSCTL_DTOCV(v)))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field RSTA[24] (WORZ)
 *
 * Effects the entire host controller except for the card detection circuit.
 * Register bits of type ROC, RW, RW1C, RWAC are cleared. During its initialization,
 * the host driver shall set this bit to 1 to reset the SDHC. The SDHC shall
 * reset this bit to 0 when the capabilities registers are valid and the host driver
 * can read them. Additional use of software reset for all does not affect the
 * value of the capabilities registers. After this bit is set, it is recommended
 * that the host driver reset the external card and reinitialize it.
 *
 * Values:
 * - 0 - No reset.
 * - 1 - Reset.
 */
/*@{*/
#define BP_SDHC_SYSCTL_RSTA  (24U)         /*!< Bit position for SDHC_SYSCTL_RSTA. */
#define BM_SDHC_SYSCTL_RSTA  (0x01000000U) /*!< Bit mask for SDHC_SYSCTL_RSTA. */
#define BS_SDHC_SYSCTL_RSTA  (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_RSTA. */

/*! @brief Format value for bitfield SDHC_SYSCTL_RSTA. */
#define BF_SDHC_SYSCTL_RSTA(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_RSTA) & BM_SDHC_SYSCTL_RSTA)

/*! @brief Set the RSTA field to a new value. */
#define BW_SDHC_SYSCTL_RSTA(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_RSTA) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field RSTC[25] (WORZ)
 *
 * Only part of the command circuit is reset. The following registers and bits
 * are cleared by this bit: PRSSTAT[CIHB] IRQSTAT[CC]
 *
 * Values:
 * - 0 - No reset.
 * - 1 - Reset.
 */
/*@{*/
#define BP_SDHC_SYSCTL_RSTC  (25U)         /*!< Bit position for SDHC_SYSCTL_RSTC. */
#define BM_SDHC_SYSCTL_RSTC  (0x02000000U) /*!< Bit mask for SDHC_SYSCTL_RSTC. */
#define BS_SDHC_SYSCTL_RSTC  (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_RSTC. */

/*! @brief Format value for bitfield SDHC_SYSCTL_RSTC. */
#define BF_SDHC_SYSCTL_RSTC(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_RSTC) & BM_SDHC_SYSCTL_RSTC)

/*! @brief Set the RSTC field to a new value. */
#define BW_SDHC_SYSCTL_RSTC(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_RSTC) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field RSTD[26] (WORZ)
 *
 * Only part of the data circuit is reset. DMA circuit is also reset. The
 * following registers and bits are cleared by this bit: Data Port register Buffer Is
 * Cleared And Initialized.Present State register Buffer Read Enable Buffer Write
 * Enable Read Transfer Active Write Transfer Active DAT Line Active Command
 * Inhibit (DAT) Protocol Control register Continue Request Stop At Block Gap Request
 * Interrupt Status register Buffer Read Ready Buffer Write Ready DMA Interrupt
 * Block Gap Event Transfer Complete
 *
 * Values:
 * - 0 - No reset.
 * - 1 - Reset.
 */
/*@{*/
#define BP_SDHC_SYSCTL_RSTD  (26U)         /*!< Bit position for SDHC_SYSCTL_RSTD. */
#define BM_SDHC_SYSCTL_RSTD  (0x04000000U) /*!< Bit mask for SDHC_SYSCTL_RSTD. */
#define BS_SDHC_SYSCTL_RSTD  (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_RSTD. */

/*! @brief Format value for bitfield SDHC_SYSCTL_RSTD. */
#define BF_SDHC_SYSCTL_RSTD(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_RSTD) & BM_SDHC_SYSCTL_RSTD)

/*! @brief Set the RSTD field to a new value. */
#define BW_SDHC_SYSCTL_RSTD(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_RSTD) = (v))
/*@}*/

/*!
 * @name Register SDHC_SYSCTL, field INITA[27] (RW)
 *
 * When this bit is set, 80 SD-clocks are sent to the card. After the 80 clocks
 * are sent, this bit is self-cleared. This bit is very useful during the card
 * power-up period when 74 SD-clocks are needed and the clock auto gating feature
 * is enabled. Writing 1 to this bit when this bit is already 1 has no effect.
 * Writing 0 to this bit at any time has no effect. When either of the PRSSTAT[CIHB]
 * and PRSSTAT[CDIHB] bits are set, writing 1 to this bit is ignored, that is,
 * when command line or data lines are active, write to this bit is not allowed.
 * On the otherhand, when this bit is set, that is, during intialization active
 * period, it is allowed to issue command, and the command bit stream will appear
 * on the CMD pad after all 80 clock cycles are done. So when this command ends,
 * the driver can make sure the 80 clock cycles are sent out. This is very useful
 * when the driver needs send 80 cycles to the card and does not want to wait
 * till this bit is self-cleared.
 */
/*@{*/
#define BP_SDHC_SYSCTL_INITA (27U)         /*!< Bit position for SDHC_SYSCTL_INITA. */
#define BM_SDHC_SYSCTL_INITA (0x08000000U) /*!< Bit mask for SDHC_SYSCTL_INITA. */
#define BS_SDHC_SYSCTL_INITA (1U)          /*!< Bit field size in bits for SDHC_SYSCTL_INITA. */

/*! @brief Read current value of the SDHC_SYSCTL_INITA field. */
#define BR_SDHC_SYSCTL_INITA(x) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_INITA))

/*! @brief Format value for bitfield SDHC_SYSCTL_INITA. */
#define BF_SDHC_SYSCTL_INITA(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_SYSCTL_INITA) & BM_SDHC_SYSCTL_INITA)

/*! @brief Set the INITA field to a new value. */
#define BW_SDHC_SYSCTL_INITA(x, v) (BITBAND_ACCESS32(HW_SDHC_SYSCTL_ADDR(x), BP_SDHC_SYSCTL_INITA) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_IRQSTAT - Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_IRQSTAT - Interrupt Status register (RW)
 *
 * Reset value: 0x00000000U
 *
 * An interrupt is generated when the Normal Interrupt Signal Enable is enabled
 * and at least one of the status bits is set to 1. For all bits, writing 1 to a
 * bit clears it; writing to 0 keeps the bit unchanged. More than one status can
 * be cleared with a single register write. For Card Interrupt, before writing 1
 * to clear, it is required that the card stops asserting the interrupt, meaning
 * that when the Card Driver services the interrupt condition, otherwise the CINT
 * bit will be asserted again. The table below shows the relationship between
 * the CTOE and the CC bits. SDHC status for CTOE/CC bit combinations Command
 * complete Command timeout error Meaning of the status 0 0 X X 1 Response not
 * received within 64 SDCLK cycles 1 0 Response received The table below shows the
 * relationship between the Transfer Complete and the Data Timeout Error. SDHC status
 * for data timeout error/transfer complete bit combinations Transfer complete
 * Data timeout error Meaning of the status 0 0 X 0 1 Timeout occurred during
 * transfer 1 X Data transfer complete The table below shows the relationship between
 * the command CRC Error (CCE) and Command Timeout Error (CTOE). SDHC status for
 * CCE/CTOE Bit Combinations Command complete Command timeout error Meaning of
 * the status 0 0 No error 0 1 Response timeout error 1 0 Response CRC error 1 1
 * CMD line conflict
 */
typedef union _hw_sdhc_irqstat
{
    uint32_t U;
    struct _hw_sdhc_irqstat_bitfields
    {
        uint32_t CC : 1;               /*!< [0] Command Complete */
        uint32_t TC : 1;               /*!< [1] Transfer Complete */
        uint32_t BGE : 1;              /*!< [2] Block Gap Event */
        uint32_t DINT : 1;             /*!< [3] DMA Interrupt */
        uint32_t BWR : 1;              /*!< [4] Buffer Write Ready */
        uint32_t BRR : 1;              /*!< [5] Buffer Read Ready */
        uint32_t CINS : 1;             /*!< [6] Card Insertion */
        uint32_t CRM : 1;              /*!< [7] Card Removal */
        uint32_t CINT : 1;             /*!< [8] Card Interrupt */
        uint32_t RESERVED0 : 7;        /*!< [15:9]  */
        uint32_t CTOE : 1;             /*!< [16] Command Timeout Error */
        uint32_t CCE : 1;              /*!< [17] Command CRC Error */
        uint32_t CEBE : 1;             /*!< [18] Command End Bit Error */
        uint32_t CIE : 1;              /*!< [19] Command Index Error */
        uint32_t DTOE : 1;             /*!< [20] Data Timeout Error */
        uint32_t DCE : 1;              /*!< [21] Data CRC Error */
        uint32_t DEBE : 1;             /*!< [22] Data End Bit Error */
        uint32_t RESERVED1 : 1;        /*!< [23]  */
        uint32_t AC12E : 1;            /*!< [24] Auto CMD12 Error */
        uint32_t RESERVED2 : 3;        /*!< [27:25]  */
        uint32_t DMAE : 1;             /*!< [28] DMA Error */
        uint32_t RESERVED3 : 3;        /*!< [31:29]  */
    } B;
} hw_sdhc_irqstat_t;

/*!
 * @name Constants and macros for entire SDHC_IRQSTAT register
 */
/*@{*/
#define HW_SDHC_IRQSTAT_ADDR(x)  ((uint32_t)(x) + 0x30U)

#define HW_SDHC_IRQSTAT(x)       (*(__IO hw_sdhc_irqstat_t *) HW_SDHC_IRQSTAT_ADDR(x))
#define HW_SDHC_IRQSTAT_RD(x)    (HW_SDHC_IRQSTAT(x).U)
#define HW_SDHC_IRQSTAT_WR(x, v) (HW_SDHC_IRQSTAT(x).U = (v))
#define HW_SDHC_IRQSTAT_SET(x, v) (HW_SDHC_IRQSTAT_WR(x, HW_SDHC_IRQSTAT_RD(x) |  (v)))
#define HW_SDHC_IRQSTAT_CLR(x, v) (HW_SDHC_IRQSTAT_WR(x, HW_SDHC_IRQSTAT_RD(x) & ~(v)))
#define HW_SDHC_IRQSTAT_TOG(x, v) (HW_SDHC_IRQSTAT_WR(x, HW_SDHC_IRQSTAT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_IRQSTAT bitfields
 */

/*!
 * @name Register SDHC_IRQSTAT, field CC[0] (W1C)
 *
 * This bit is set when you receive the end bit of the command response, except
 * Auto CMD12. See PRSSTAT[CIHB].
 *
 * Values:
 * - 0 - Command not complete.
 * - 1 - Command complete.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CC   (0U)          /*!< Bit position for SDHC_IRQSTAT_CC. */
#define BM_SDHC_IRQSTAT_CC   (0x00000001U) /*!< Bit mask for SDHC_IRQSTAT_CC. */
#define BS_SDHC_IRQSTAT_CC   (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CC. */

/*! @brief Read current value of the SDHC_IRQSTAT_CC field. */
#define BR_SDHC_IRQSTAT_CC(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CC))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CC. */
#define BF_SDHC_IRQSTAT_CC(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CC) & BM_SDHC_IRQSTAT_CC)

/*! @brief Set the CC field to a new value. */
#define BW_SDHC_IRQSTAT_CC(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CC) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field TC[1] (W1C)
 *
 * This bit is set when a read or write transfer is completed. In the case of a
 * read transaction: This bit is set at the falling edge of the read transfer
 * active status. There are two cases in which this interrupt is generated. The
 * first is when a data transfer is completed as specified by the data length, after
 * the last data has been read to the host system. The second is when data has
 * stopped at the block gap and completed the data transfer by setting
 * PROCTL[SABGREQ], after valid data has been read to the host system. In the case of a write
 * transaction: This bit is set at the falling edge of the DAT line active
 * status. There are two cases in which this interrupt is generated. The first is when
 * the last data is written to the SD card as specified by the data length and
 * the busy signal is released. The second is when data transfers are stopped at
 * the block gap, by setting PROCTL[SABGREQ], and the data transfers are
 * completed,after valid data is written to the SD card and the busy signal released.
 *
 * Values:
 * - 0 - Transfer not complete.
 * - 1 - Transfer complete.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_TC   (1U)          /*!< Bit position for SDHC_IRQSTAT_TC. */
#define BM_SDHC_IRQSTAT_TC   (0x00000002U) /*!< Bit mask for SDHC_IRQSTAT_TC. */
#define BS_SDHC_IRQSTAT_TC   (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_TC. */

/*! @brief Read current value of the SDHC_IRQSTAT_TC field. */
#define BR_SDHC_IRQSTAT_TC(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_TC))

/*! @brief Format value for bitfield SDHC_IRQSTAT_TC. */
#define BF_SDHC_IRQSTAT_TC(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_TC) & BM_SDHC_IRQSTAT_TC)

/*! @brief Set the TC field to a new value. */
#define BW_SDHC_IRQSTAT_TC(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_TC) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field BGE[2] (W1C)
 *
 * If PROCTL[SABGREQ] is set, this bit is set when a read or write transaction
 * is stopped at a block gap. If PROCTL[SABGREQ] is not set to 1, this bit is not
 * set to 1. In the case of a read transaction: This bit is set at the falling
 * edge of the DAT line active status, when the transaction is stopped at SD Bus
 * timing. The read wait must be supported in order to use this function. In the
 * case of write transaction: This bit is set at the falling edge of write transfer
 * active status, after getting CRC status at SD bus timing.
 *
 * Values:
 * - 0 - No block gap event.
 * - 1 - Transaction stopped at block gap.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_BGE  (2U)          /*!< Bit position for SDHC_IRQSTAT_BGE. */
#define BM_SDHC_IRQSTAT_BGE  (0x00000004U) /*!< Bit mask for SDHC_IRQSTAT_BGE. */
#define BS_SDHC_IRQSTAT_BGE  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_BGE. */

/*! @brief Read current value of the SDHC_IRQSTAT_BGE field. */
#define BR_SDHC_IRQSTAT_BGE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BGE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_BGE. */
#define BF_SDHC_IRQSTAT_BGE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_BGE) & BM_SDHC_IRQSTAT_BGE)

/*! @brief Set the BGE field to a new value. */
#define BW_SDHC_IRQSTAT_BGE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BGE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field DINT[3] (W1C)
 *
 * Occurs only when the internal DMA finishes the data transfer successfully.
 * Whenever errors occur during data transfer, this bit will not be set. Instead,
 * the DMAE bit will be set. Either Simple DMA or ADMA finishes data transferring,
 * this bit will be set.
 *
 * Values:
 * - 0 - No DMA Interrupt.
 * - 1 - DMA Interrupt is generated.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_DINT (3U)          /*!< Bit position for SDHC_IRQSTAT_DINT. */
#define BM_SDHC_IRQSTAT_DINT (0x00000008U) /*!< Bit mask for SDHC_IRQSTAT_DINT. */
#define BS_SDHC_IRQSTAT_DINT (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_DINT. */

/*! @brief Read current value of the SDHC_IRQSTAT_DINT field. */
#define BR_SDHC_IRQSTAT_DINT(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DINT))

/*! @brief Format value for bitfield SDHC_IRQSTAT_DINT. */
#define BF_SDHC_IRQSTAT_DINT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_DINT) & BM_SDHC_IRQSTAT_DINT)

/*! @brief Set the DINT field to a new value. */
#define BW_SDHC_IRQSTAT_DINT(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DINT) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field BWR[4] (W1C)
 *
 * This status bit is set if the Buffer Write Enable bit, in the Present State
 * register, changes from 0 to 1. See the Buffer Write Enable bit in the Present
 * State register for additional information.
 *
 * Values:
 * - 0 - Not ready to write buffer.
 * - 1 - Ready to write buffer.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_BWR  (4U)          /*!< Bit position for SDHC_IRQSTAT_BWR. */
#define BM_SDHC_IRQSTAT_BWR  (0x00000010U) /*!< Bit mask for SDHC_IRQSTAT_BWR. */
#define BS_SDHC_IRQSTAT_BWR  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_BWR. */

/*! @brief Read current value of the SDHC_IRQSTAT_BWR field. */
#define BR_SDHC_IRQSTAT_BWR(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BWR))

/*! @brief Format value for bitfield SDHC_IRQSTAT_BWR. */
#define BF_SDHC_IRQSTAT_BWR(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_BWR) & BM_SDHC_IRQSTAT_BWR)

/*! @brief Set the BWR field to a new value. */
#define BW_SDHC_IRQSTAT_BWR(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BWR) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field BRR[5] (W1C)
 *
 * This status bit is set if the Buffer Read Enable bit, in the Present State
 * register, changes from 0 to 1. See the Buffer Read Enable bit in the Present
 * State register for additional information.
 *
 * Values:
 * - 0 - Not ready to read buffer.
 * - 1 - Ready to read buffer.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_BRR  (5U)          /*!< Bit position for SDHC_IRQSTAT_BRR. */
#define BM_SDHC_IRQSTAT_BRR  (0x00000020U) /*!< Bit mask for SDHC_IRQSTAT_BRR. */
#define BS_SDHC_IRQSTAT_BRR  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_BRR. */

/*! @brief Read current value of the SDHC_IRQSTAT_BRR field. */
#define BR_SDHC_IRQSTAT_BRR(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BRR))

/*! @brief Format value for bitfield SDHC_IRQSTAT_BRR. */
#define BF_SDHC_IRQSTAT_BRR(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_BRR) & BM_SDHC_IRQSTAT_BRR)

/*! @brief Set the BRR field to a new value. */
#define BW_SDHC_IRQSTAT_BRR(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_BRR) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CINS[6] (W1C)
 *
 * This status bit is set if the Card Inserted bit in the Present State register
 * changes from 0 to 1. When the host driver writes this bit to 1 to clear this
 * status, the status of the Card Inserted in the Present State register must be
 * confirmed. Because the card state may possibly be changed when the host driver
 * clears this bit and the interrupt event may not be generated. When this bit
 * is cleared, it will be set again if a card is inserted. To leave it cleared,
 * clear the Card Inserted Status Enable bit in Interrupt Status Enable register.
 *
 * Values:
 * - 0 - Card state unstable or removed.
 * - 1 - Card inserted.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CINS (6U)          /*!< Bit position for SDHC_IRQSTAT_CINS. */
#define BM_SDHC_IRQSTAT_CINS (0x00000040U) /*!< Bit mask for SDHC_IRQSTAT_CINS. */
#define BS_SDHC_IRQSTAT_CINS (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CINS. */

/*! @brief Read current value of the SDHC_IRQSTAT_CINS field. */
#define BR_SDHC_IRQSTAT_CINS(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CINS))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CINS. */
#define BF_SDHC_IRQSTAT_CINS(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CINS) & BM_SDHC_IRQSTAT_CINS)

/*! @brief Set the CINS field to a new value. */
#define BW_SDHC_IRQSTAT_CINS(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CINS) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CRM[7] (W1C)
 *
 * This status bit is set if the Card Inserted bit in the Present State register
 * changes from 1 to 0. When the host driver writes this bit to 1 to clear this
 * status, the status of the Card Inserted in the Present State register must be
 * confirmed. Because the card state may possibly be changed when the host driver
 * clears this bit and the interrupt event may not be generated. When this bit
 * is cleared, it will be set again if no card is inserted. To leave it cleared,
 * clear the Card Removal Status Enable bit in Interrupt Status Enable register.
 *
 * Values:
 * - 0 - Card state unstable or inserted.
 * - 1 - Card removed.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CRM  (7U)          /*!< Bit position for SDHC_IRQSTAT_CRM. */
#define BM_SDHC_IRQSTAT_CRM  (0x00000080U) /*!< Bit mask for SDHC_IRQSTAT_CRM. */
#define BS_SDHC_IRQSTAT_CRM  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CRM. */

/*! @brief Read current value of the SDHC_IRQSTAT_CRM field. */
#define BR_SDHC_IRQSTAT_CRM(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CRM))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CRM. */
#define BF_SDHC_IRQSTAT_CRM(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CRM) & BM_SDHC_IRQSTAT_CRM)

/*! @brief Set the CRM field to a new value. */
#define BW_SDHC_IRQSTAT_CRM(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CRM) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CINT[8] (W1C)
 *
 * This status bit is set when an interrupt signal is detected from the external
 * card. In 1-bit mode, the SDHC will detect the Card Interrupt without the SD
 * Clock to support wakeup. In 4-bit mode, the card interrupt signal is sampled
 * during the interrupt cycle, so the interrupt from card can only be sampled
 * during interrupt cycle, introducing some delay between the interrupt signal from
 * the SDIO card and the interrupt to the host system. Writing this bit to 1 can
 * clear this bit, but as the interrupt factor from the SDIO card does not clear,
 * this bit is set again. To clear this bit, it is required to reset the interrupt
 * factor from the external card followed by a writing 1 to this bit. When this
 * status has been set, and the host driver needs to service this interrupt, the
 * Card Interrupt Signal Enable in the Interrupt Signal Enable register should be
 * 0 to stop driving the interrupt signal to the host system. After completion
 * of the card interrupt service (it must reset the interrupt factors in the SDIO
 * card and the interrupt signal may not be asserted), write 1 to clear this bit,
 * set the Card Interrupt Signal Enable to 1, and start sampling the interrupt
 * signal again.
 *
 * Values:
 * - 0 - No Card Interrupt.
 * - 1 - Generate Card Interrupt.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CINT (8U)          /*!< Bit position for SDHC_IRQSTAT_CINT. */
#define BM_SDHC_IRQSTAT_CINT (0x00000100U) /*!< Bit mask for SDHC_IRQSTAT_CINT. */
#define BS_SDHC_IRQSTAT_CINT (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CINT. */

/*! @brief Read current value of the SDHC_IRQSTAT_CINT field. */
#define BR_SDHC_IRQSTAT_CINT(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CINT))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CINT. */
#define BF_SDHC_IRQSTAT_CINT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CINT) & BM_SDHC_IRQSTAT_CINT)

/*! @brief Set the CINT field to a new value. */
#define BW_SDHC_IRQSTAT_CINT(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CINT) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CTOE[16] (W1C)
 *
 * Occurs only if no response is returned within 64 SDCLK cycles from the end
 * bit of the command. If the SDHC detects a CMD line conflict, in which case a
 * Command CRC Error shall also be set, this bit shall be set without waiting for 64
 * SDCLK cycles. This is because the command will be aborted by the SDHC.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Time out.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CTOE (16U)         /*!< Bit position for SDHC_IRQSTAT_CTOE. */
#define BM_SDHC_IRQSTAT_CTOE (0x00010000U) /*!< Bit mask for SDHC_IRQSTAT_CTOE. */
#define BS_SDHC_IRQSTAT_CTOE (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CTOE. */

/*! @brief Read current value of the SDHC_IRQSTAT_CTOE field. */
#define BR_SDHC_IRQSTAT_CTOE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CTOE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CTOE. */
#define BF_SDHC_IRQSTAT_CTOE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CTOE) & BM_SDHC_IRQSTAT_CTOE)

/*! @brief Set the CTOE field to a new value. */
#define BW_SDHC_IRQSTAT_CTOE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CTOE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CCE[17] (W1C)
 *
 * Command CRC Error is generated in two cases. If a response is returned and
 * the Command Timeout Error is set to 0, indicating no time-out, this bit is set
 * when detecting a CRC error in the command response. The SDHC detects a CMD line
 * conflict by monitoring the CMD line when a command is issued. If the SDHC
 * drives the CMD line to 1, but detects 0 on the CMD line at the next SDCLK edge,
 * then the SDHC shall abort the command (Stop driving CMD line) and set this bit
 * to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line
 * conflict.
 *
 * Values:
 * - 0 - No error.
 * - 1 - CRC Error generated.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CCE  (17U)         /*!< Bit position for SDHC_IRQSTAT_CCE. */
#define BM_SDHC_IRQSTAT_CCE  (0x00020000U) /*!< Bit mask for SDHC_IRQSTAT_CCE. */
#define BS_SDHC_IRQSTAT_CCE  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CCE. */

/*! @brief Read current value of the SDHC_IRQSTAT_CCE field. */
#define BR_SDHC_IRQSTAT_CCE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CCE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CCE. */
#define BF_SDHC_IRQSTAT_CCE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CCE) & BM_SDHC_IRQSTAT_CCE)

/*! @brief Set the CCE field to a new value. */
#define BW_SDHC_IRQSTAT_CCE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CCE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CEBE[18] (W1C)
 *
 * Occurs when detecting that the end bit of a command response is 0.
 *
 * Values:
 * - 0 - No error.
 * - 1 - End Bit Error generated.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CEBE (18U)         /*!< Bit position for SDHC_IRQSTAT_CEBE. */
#define BM_SDHC_IRQSTAT_CEBE (0x00040000U) /*!< Bit mask for SDHC_IRQSTAT_CEBE. */
#define BS_SDHC_IRQSTAT_CEBE (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CEBE. */

/*! @brief Read current value of the SDHC_IRQSTAT_CEBE field. */
#define BR_SDHC_IRQSTAT_CEBE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CEBE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CEBE. */
#define BF_SDHC_IRQSTAT_CEBE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CEBE) & BM_SDHC_IRQSTAT_CEBE)

/*! @brief Set the CEBE field to a new value. */
#define BW_SDHC_IRQSTAT_CEBE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CEBE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field CIE[19] (W1C)
 *
 * Occurs if a Command Index error occurs in the command response.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_CIE  (19U)         /*!< Bit position for SDHC_IRQSTAT_CIE. */
#define BM_SDHC_IRQSTAT_CIE  (0x00080000U) /*!< Bit mask for SDHC_IRQSTAT_CIE. */
#define BS_SDHC_IRQSTAT_CIE  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_CIE. */

/*! @brief Read current value of the SDHC_IRQSTAT_CIE field. */
#define BR_SDHC_IRQSTAT_CIE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CIE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_CIE. */
#define BF_SDHC_IRQSTAT_CIE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_CIE) & BM_SDHC_IRQSTAT_CIE)

/*! @brief Set the CIE field to a new value. */
#define BW_SDHC_IRQSTAT_CIE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_CIE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field DTOE[20] (W1C)
 *
 * Occurs when detecting one of following time-out conditions. Busy time-out for
 * R1b,R5b type Busy time-out after Write CRC status Read Data time-out
 *
 * Values:
 * - 0 - No error.
 * - 1 - Time out.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_DTOE (20U)         /*!< Bit position for SDHC_IRQSTAT_DTOE. */
#define BM_SDHC_IRQSTAT_DTOE (0x00100000U) /*!< Bit mask for SDHC_IRQSTAT_DTOE. */
#define BS_SDHC_IRQSTAT_DTOE (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_DTOE. */

/*! @brief Read current value of the SDHC_IRQSTAT_DTOE field. */
#define BR_SDHC_IRQSTAT_DTOE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DTOE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_DTOE. */
#define BF_SDHC_IRQSTAT_DTOE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_DTOE) & BM_SDHC_IRQSTAT_DTOE)

/*! @brief Set the DTOE field to a new value. */
#define BW_SDHC_IRQSTAT_DTOE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DTOE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field DCE[21] (W1C)
 *
 * Occurs when detecting a CRC error when transferring read data, which uses the
 * DAT line, or when detecting the Write CRC status having a value other than
 * 010.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_DCE  (21U)         /*!< Bit position for SDHC_IRQSTAT_DCE. */
#define BM_SDHC_IRQSTAT_DCE  (0x00200000U) /*!< Bit mask for SDHC_IRQSTAT_DCE. */
#define BS_SDHC_IRQSTAT_DCE  (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_DCE. */

/*! @brief Read current value of the SDHC_IRQSTAT_DCE field. */
#define BR_SDHC_IRQSTAT_DCE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DCE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_DCE. */
#define BF_SDHC_IRQSTAT_DCE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_DCE) & BM_SDHC_IRQSTAT_DCE)

/*! @brief Set the DCE field to a new value. */
#define BW_SDHC_IRQSTAT_DCE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DCE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field DEBE[22] (W1C)
 *
 * Occurs either when detecting 0 at the end bit position of read data, which
 * uses the DAT line, or at the end bit position of the CRC.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_DEBE (22U)         /*!< Bit position for SDHC_IRQSTAT_DEBE. */
#define BM_SDHC_IRQSTAT_DEBE (0x00400000U) /*!< Bit mask for SDHC_IRQSTAT_DEBE. */
#define BS_SDHC_IRQSTAT_DEBE (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_DEBE. */

/*! @brief Read current value of the SDHC_IRQSTAT_DEBE field. */
#define BR_SDHC_IRQSTAT_DEBE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DEBE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_DEBE. */
#define BF_SDHC_IRQSTAT_DEBE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_DEBE) & BM_SDHC_IRQSTAT_DEBE)

/*! @brief Set the DEBE field to a new value. */
#define BW_SDHC_IRQSTAT_DEBE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DEBE) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field AC12E[24] (W1C)
 *
 * Occurs when detecting that one of the bits in the Auto CMD12 Error Status
 * register has changed from 0 to 1. This bit is set to 1, not only when the errors
 * in Auto CMD12 occur, but also when the Auto CMD12 is not executed due to the
 * previous command error.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_AC12E (24U)        /*!< Bit position for SDHC_IRQSTAT_AC12E. */
#define BM_SDHC_IRQSTAT_AC12E (0x01000000U) /*!< Bit mask for SDHC_IRQSTAT_AC12E. */
#define BS_SDHC_IRQSTAT_AC12E (1U)         /*!< Bit field size in bits for SDHC_IRQSTAT_AC12E. */

/*! @brief Read current value of the SDHC_IRQSTAT_AC12E field. */
#define BR_SDHC_IRQSTAT_AC12E(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_AC12E))

/*! @brief Format value for bitfield SDHC_IRQSTAT_AC12E. */
#define BF_SDHC_IRQSTAT_AC12E(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_AC12E) & BM_SDHC_IRQSTAT_AC12E)

/*! @brief Set the AC12E field to a new value. */
#define BW_SDHC_IRQSTAT_AC12E(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_AC12E) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTAT, field DMAE[28] (W1C)
 *
 * Occurs when an Internal DMA transfer has failed. This bit is set to 1, when
 * some error occurs in the data transfer. This error can be caused by either
 * Simple DMA or ADMA, depending on which DMA is in use. The value in DMA System
 * Address register is the next fetch address where the error occurs. Because any
 * error corrupts the whole data block, the host driver shall restart the transfer
 * from the corrupted block boundary. The address of the block boundary can be
 * calculated either from the current DSADDR value or from the remaining number of
 * blocks and the block size.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_IRQSTAT_DMAE (28U)         /*!< Bit position for SDHC_IRQSTAT_DMAE. */
#define BM_SDHC_IRQSTAT_DMAE (0x10000000U) /*!< Bit mask for SDHC_IRQSTAT_DMAE. */
#define BS_SDHC_IRQSTAT_DMAE (1U)          /*!< Bit field size in bits for SDHC_IRQSTAT_DMAE. */

/*! @brief Read current value of the SDHC_IRQSTAT_DMAE field. */
#define BR_SDHC_IRQSTAT_DMAE(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DMAE))

/*! @brief Format value for bitfield SDHC_IRQSTAT_DMAE. */
#define BF_SDHC_IRQSTAT_DMAE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTAT_DMAE) & BM_SDHC_IRQSTAT_DMAE)

/*! @brief Set the DMAE field to a new value. */
#define BW_SDHC_IRQSTAT_DMAE(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTAT_ADDR(x), BP_SDHC_IRQSTAT_DMAE) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_IRQSTATEN - Interrupt Status Enable register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_IRQSTATEN - Interrupt Status Enable register (RW)
 *
 * Reset value: 0x117F013FU
 *
 * Setting the bits in this register to 1 enables the corresponding interrupt
 * status to be set by the specified event. If any bit is cleared, the
 * corresponding interrupt status bit is also cleared, that is, when the bit in this register
 * is cleared, the corresponding bit in interrupt status register is always 0.
 * Depending on PROCTL[IABG] bit setting, SDHC may be programmed to sample the
 * card interrupt signal during the interrupt period and hold its value in the
 * flip-flop. There will be some delays on the card interrupt, asserted from the card,
 * to the time the host system is informed. To detect a CMD line conflict, the
 * host driver must set both IRQSTATEN[CTOESEN] and IRQSTATEN[CCESEN] to 1.
 */
typedef union _hw_sdhc_irqstaten
{
    uint32_t U;
    struct _hw_sdhc_irqstaten_bitfields
    {
        uint32_t CCSEN : 1;            /*!< [0] Command Complete Status Enable */
        uint32_t TCSEN : 1;            /*!< [1] Transfer Complete Status Enable */
        uint32_t BGESEN : 1;           /*!< [2] Block Gap Event Status Enable */
        uint32_t DINTSEN : 1;          /*!< [3] DMA Interrupt Status Enable */
        uint32_t BWRSEN : 1;           /*!< [4] Buffer Write Ready Status Enable */
        uint32_t BRRSEN : 1;           /*!< [5] Buffer Read Ready Status Enable */
        uint32_t CINSEN : 1;           /*!< [6] Card Insertion Status Enable */
        uint32_t CRMSEN : 1;           /*!< [7] Card Removal Status Enable */
        uint32_t CINTSEN : 1;          /*!< [8] Card Interrupt Status Enable */
        uint32_t RESERVED0 : 7;        /*!< [15:9]  */
        uint32_t CTOESEN : 1;          /*!< [16] Command Timeout Error Status Enable */
        uint32_t CCESEN : 1;           /*!< [17] Command CRC Error Status Enable */
        uint32_t CEBESEN : 1;          /*!< [18] Command End Bit Error Status Enable */
        uint32_t CIESEN : 1;           /*!< [19] Command Index Error Status Enable */
        uint32_t DTOESEN : 1;          /*!< [20] Data Timeout Error Status Enable */
        uint32_t DCESEN : 1;           /*!< [21] Data CRC Error Status Enable */
        uint32_t DEBESEN : 1;          /*!< [22] Data End Bit Error Status Enable */
        uint32_t RESERVED1 : 1;        /*!< [23]  */
        uint32_t AC12ESEN : 1;         /*!< [24] Auto CMD12 Error Status Enable */
        uint32_t RESERVED2 : 3;        /*!< [27:25]  */
        uint32_t DMAESEN : 1;          /*!< [28] DMA Error Status Enable */
        uint32_t RESERVED3 : 3;        /*!< [31:29]  */
    } B;
} hw_sdhc_irqstaten_t;

/*!
 * @name Constants and macros for entire SDHC_IRQSTATEN register
 */
/*@{*/
#define HW_SDHC_IRQSTATEN_ADDR(x) ((uint32_t)(x) + 0x34U)

#define HW_SDHC_IRQSTATEN(x)     (*(__IO hw_sdhc_irqstaten_t *) HW_SDHC_IRQSTATEN_ADDR(x))
#define HW_SDHC_IRQSTATEN_RD(x)  (HW_SDHC_IRQSTATEN(x).U)
#define HW_SDHC_IRQSTATEN_WR(x, v) (HW_SDHC_IRQSTATEN(x).U = (v))
#define HW_SDHC_IRQSTATEN_SET(x, v) (HW_SDHC_IRQSTATEN_WR(x, HW_SDHC_IRQSTATEN_RD(x) |  (v)))
#define HW_SDHC_IRQSTATEN_CLR(x, v) (HW_SDHC_IRQSTATEN_WR(x, HW_SDHC_IRQSTATEN_RD(x) & ~(v)))
#define HW_SDHC_IRQSTATEN_TOG(x, v) (HW_SDHC_IRQSTATEN_WR(x, HW_SDHC_IRQSTATEN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_IRQSTATEN bitfields
 */

/*!
 * @name Register SDHC_IRQSTATEN, field CCSEN[0] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CCSEN (0U)       /*!< Bit position for SDHC_IRQSTATEN_CCSEN. */
#define BM_SDHC_IRQSTATEN_CCSEN (0x00000001U) /*!< Bit mask for SDHC_IRQSTATEN_CCSEN. */
#define BS_SDHC_IRQSTATEN_CCSEN (1U)       /*!< Bit field size in bits for SDHC_IRQSTATEN_CCSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CCSEN field. */
#define BR_SDHC_IRQSTATEN_CCSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CCSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CCSEN. */
#define BF_SDHC_IRQSTATEN_CCSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CCSEN) & BM_SDHC_IRQSTATEN_CCSEN)

/*! @brief Set the CCSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CCSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CCSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field TCSEN[1] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_TCSEN (1U)       /*!< Bit position for SDHC_IRQSTATEN_TCSEN. */
#define BM_SDHC_IRQSTATEN_TCSEN (0x00000002U) /*!< Bit mask for SDHC_IRQSTATEN_TCSEN. */
#define BS_SDHC_IRQSTATEN_TCSEN (1U)       /*!< Bit field size in bits for SDHC_IRQSTATEN_TCSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_TCSEN field. */
#define BR_SDHC_IRQSTATEN_TCSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_TCSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_TCSEN. */
#define BF_SDHC_IRQSTATEN_TCSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_TCSEN) & BM_SDHC_IRQSTATEN_TCSEN)

/*! @brief Set the TCSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_TCSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_TCSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field BGESEN[2] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_BGESEN (2U)      /*!< Bit position for SDHC_IRQSTATEN_BGESEN. */
#define BM_SDHC_IRQSTATEN_BGESEN (0x00000004U) /*!< Bit mask for SDHC_IRQSTATEN_BGESEN. */
#define BS_SDHC_IRQSTATEN_BGESEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_BGESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_BGESEN field. */
#define BR_SDHC_IRQSTATEN_BGESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BGESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_BGESEN. */
#define BF_SDHC_IRQSTATEN_BGESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_BGESEN) & BM_SDHC_IRQSTATEN_BGESEN)

/*! @brief Set the BGESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_BGESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BGESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field DINTSEN[3] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_DINTSEN (3U)     /*!< Bit position for SDHC_IRQSTATEN_DINTSEN. */
#define BM_SDHC_IRQSTATEN_DINTSEN (0x00000008U) /*!< Bit mask for SDHC_IRQSTATEN_DINTSEN. */
#define BS_SDHC_IRQSTATEN_DINTSEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_DINTSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_DINTSEN field. */
#define BR_SDHC_IRQSTATEN_DINTSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DINTSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_DINTSEN. */
#define BF_SDHC_IRQSTATEN_DINTSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_DINTSEN) & BM_SDHC_IRQSTATEN_DINTSEN)

/*! @brief Set the DINTSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_DINTSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DINTSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field BWRSEN[4] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_BWRSEN (4U)      /*!< Bit position for SDHC_IRQSTATEN_BWRSEN. */
#define BM_SDHC_IRQSTATEN_BWRSEN (0x00000010U) /*!< Bit mask for SDHC_IRQSTATEN_BWRSEN. */
#define BS_SDHC_IRQSTATEN_BWRSEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_BWRSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_BWRSEN field. */
#define BR_SDHC_IRQSTATEN_BWRSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BWRSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_BWRSEN. */
#define BF_SDHC_IRQSTATEN_BWRSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_BWRSEN) & BM_SDHC_IRQSTATEN_BWRSEN)

/*! @brief Set the BWRSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_BWRSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BWRSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field BRRSEN[5] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_BRRSEN (5U)      /*!< Bit position for SDHC_IRQSTATEN_BRRSEN. */
#define BM_SDHC_IRQSTATEN_BRRSEN (0x00000020U) /*!< Bit mask for SDHC_IRQSTATEN_BRRSEN. */
#define BS_SDHC_IRQSTATEN_BRRSEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_BRRSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_BRRSEN field. */
#define BR_SDHC_IRQSTATEN_BRRSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BRRSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_BRRSEN. */
#define BF_SDHC_IRQSTATEN_BRRSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_BRRSEN) & BM_SDHC_IRQSTATEN_BRRSEN)

/*! @brief Set the BRRSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_BRRSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_BRRSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CINSEN[6] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CINSEN (6U)      /*!< Bit position for SDHC_IRQSTATEN_CINSEN. */
#define BM_SDHC_IRQSTATEN_CINSEN (0x00000040U) /*!< Bit mask for SDHC_IRQSTATEN_CINSEN. */
#define BS_SDHC_IRQSTATEN_CINSEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_CINSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CINSEN field. */
#define BR_SDHC_IRQSTATEN_CINSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CINSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CINSEN. */
#define BF_SDHC_IRQSTATEN_CINSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CINSEN) & BM_SDHC_IRQSTATEN_CINSEN)

/*! @brief Set the CINSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CINSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CINSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CRMSEN[7] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CRMSEN (7U)      /*!< Bit position for SDHC_IRQSTATEN_CRMSEN. */
#define BM_SDHC_IRQSTATEN_CRMSEN (0x00000080U) /*!< Bit mask for SDHC_IRQSTATEN_CRMSEN. */
#define BS_SDHC_IRQSTATEN_CRMSEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_CRMSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CRMSEN field. */
#define BR_SDHC_IRQSTATEN_CRMSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CRMSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CRMSEN. */
#define BF_SDHC_IRQSTATEN_CRMSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CRMSEN) & BM_SDHC_IRQSTATEN_CRMSEN)

/*! @brief Set the CRMSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CRMSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CRMSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CINTSEN[8] (RW)
 *
 * If this bit is set to 0, the SDHC will clear the interrupt request to the
 * system. The card interrupt detection is stopped when this bit is cleared and
 * restarted when this bit is set to 1. The host driver must clear the this bit
 * before servicing the card interrupt and must set this bit again after all interrupt
 * requests from the card are cleared to prevent inadvertent interrupts.
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CINTSEN (8U)     /*!< Bit position for SDHC_IRQSTATEN_CINTSEN. */
#define BM_SDHC_IRQSTATEN_CINTSEN (0x00000100U) /*!< Bit mask for SDHC_IRQSTATEN_CINTSEN. */
#define BS_SDHC_IRQSTATEN_CINTSEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_CINTSEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CINTSEN field. */
#define BR_SDHC_IRQSTATEN_CINTSEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CINTSEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CINTSEN. */
#define BF_SDHC_IRQSTATEN_CINTSEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CINTSEN) & BM_SDHC_IRQSTATEN_CINTSEN)

/*! @brief Set the CINTSEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CINTSEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CINTSEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CTOESEN[16] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CTOESEN (16U)    /*!< Bit position for SDHC_IRQSTATEN_CTOESEN. */
#define BM_SDHC_IRQSTATEN_CTOESEN (0x00010000U) /*!< Bit mask for SDHC_IRQSTATEN_CTOESEN. */
#define BS_SDHC_IRQSTATEN_CTOESEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_CTOESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CTOESEN field. */
#define BR_SDHC_IRQSTATEN_CTOESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CTOESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CTOESEN. */
#define BF_SDHC_IRQSTATEN_CTOESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CTOESEN) & BM_SDHC_IRQSTATEN_CTOESEN)

/*! @brief Set the CTOESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CTOESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CTOESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CCESEN[17] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CCESEN (17U)     /*!< Bit position for SDHC_IRQSTATEN_CCESEN. */
#define BM_SDHC_IRQSTATEN_CCESEN (0x00020000U) /*!< Bit mask for SDHC_IRQSTATEN_CCESEN. */
#define BS_SDHC_IRQSTATEN_CCESEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_CCESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CCESEN field. */
#define BR_SDHC_IRQSTATEN_CCESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CCESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CCESEN. */
#define BF_SDHC_IRQSTATEN_CCESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CCESEN) & BM_SDHC_IRQSTATEN_CCESEN)

/*! @brief Set the CCESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CCESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CCESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CEBESEN[18] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CEBESEN (18U)    /*!< Bit position for SDHC_IRQSTATEN_CEBESEN. */
#define BM_SDHC_IRQSTATEN_CEBESEN (0x00040000U) /*!< Bit mask for SDHC_IRQSTATEN_CEBESEN. */
#define BS_SDHC_IRQSTATEN_CEBESEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_CEBESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CEBESEN field. */
#define BR_SDHC_IRQSTATEN_CEBESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CEBESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CEBESEN. */
#define BF_SDHC_IRQSTATEN_CEBESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CEBESEN) & BM_SDHC_IRQSTATEN_CEBESEN)

/*! @brief Set the CEBESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CEBESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CEBESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field CIESEN[19] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_CIESEN (19U)     /*!< Bit position for SDHC_IRQSTATEN_CIESEN. */
#define BM_SDHC_IRQSTATEN_CIESEN (0x00080000U) /*!< Bit mask for SDHC_IRQSTATEN_CIESEN. */
#define BS_SDHC_IRQSTATEN_CIESEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_CIESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_CIESEN field. */
#define BR_SDHC_IRQSTATEN_CIESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CIESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_CIESEN. */
#define BF_SDHC_IRQSTATEN_CIESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_CIESEN) & BM_SDHC_IRQSTATEN_CIESEN)

/*! @brief Set the CIESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_CIESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_CIESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field DTOESEN[20] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_DTOESEN (20U)    /*!< Bit position for SDHC_IRQSTATEN_DTOESEN. */
#define BM_SDHC_IRQSTATEN_DTOESEN (0x00100000U) /*!< Bit mask for SDHC_IRQSTATEN_DTOESEN. */
#define BS_SDHC_IRQSTATEN_DTOESEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_DTOESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_DTOESEN field. */
#define BR_SDHC_IRQSTATEN_DTOESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DTOESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_DTOESEN. */
#define BF_SDHC_IRQSTATEN_DTOESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_DTOESEN) & BM_SDHC_IRQSTATEN_DTOESEN)

/*! @brief Set the DTOESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_DTOESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DTOESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field DCESEN[21] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_DCESEN (21U)     /*!< Bit position for SDHC_IRQSTATEN_DCESEN. */
#define BM_SDHC_IRQSTATEN_DCESEN (0x00200000U) /*!< Bit mask for SDHC_IRQSTATEN_DCESEN. */
#define BS_SDHC_IRQSTATEN_DCESEN (1U)      /*!< Bit field size in bits for SDHC_IRQSTATEN_DCESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_DCESEN field. */
#define BR_SDHC_IRQSTATEN_DCESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DCESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_DCESEN. */
#define BF_SDHC_IRQSTATEN_DCESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_DCESEN) & BM_SDHC_IRQSTATEN_DCESEN)

/*! @brief Set the DCESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_DCESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DCESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field DEBESEN[22] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_DEBESEN (22U)    /*!< Bit position for SDHC_IRQSTATEN_DEBESEN. */
#define BM_SDHC_IRQSTATEN_DEBESEN (0x00400000U) /*!< Bit mask for SDHC_IRQSTATEN_DEBESEN. */
#define BS_SDHC_IRQSTATEN_DEBESEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_DEBESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_DEBESEN field. */
#define BR_SDHC_IRQSTATEN_DEBESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DEBESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_DEBESEN. */
#define BF_SDHC_IRQSTATEN_DEBESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_DEBESEN) & BM_SDHC_IRQSTATEN_DEBESEN)

/*! @brief Set the DEBESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_DEBESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DEBESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field AC12ESEN[24] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_AC12ESEN (24U)   /*!< Bit position for SDHC_IRQSTATEN_AC12ESEN. */
#define BM_SDHC_IRQSTATEN_AC12ESEN (0x01000000U) /*!< Bit mask for SDHC_IRQSTATEN_AC12ESEN. */
#define BS_SDHC_IRQSTATEN_AC12ESEN (1U)    /*!< Bit field size in bits for SDHC_IRQSTATEN_AC12ESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_AC12ESEN field. */
#define BR_SDHC_IRQSTATEN_AC12ESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_AC12ESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_AC12ESEN. */
#define BF_SDHC_IRQSTATEN_AC12ESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_AC12ESEN) & BM_SDHC_IRQSTATEN_AC12ESEN)

/*! @brief Set the AC12ESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_AC12ESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_AC12ESEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSTATEN, field DMAESEN[28] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSTATEN_DMAESEN (28U)    /*!< Bit position for SDHC_IRQSTATEN_DMAESEN. */
#define BM_SDHC_IRQSTATEN_DMAESEN (0x10000000U) /*!< Bit mask for SDHC_IRQSTATEN_DMAESEN. */
#define BS_SDHC_IRQSTATEN_DMAESEN (1U)     /*!< Bit field size in bits for SDHC_IRQSTATEN_DMAESEN. */

/*! @brief Read current value of the SDHC_IRQSTATEN_DMAESEN field. */
#define BR_SDHC_IRQSTATEN_DMAESEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DMAESEN))

/*! @brief Format value for bitfield SDHC_IRQSTATEN_DMAESEN. */
#define BF_SDHC_IRQSTATEN_DMAESEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSTATEN_DMAESEN) & BM_SDHC_IRQSTATEN_DMAESEN)

/*! @brief Set the DMAESEN field to a new value. */
#define BW_SDHC_IRQSTATEN_DMAESEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSTATEN_ADDR(x), BP_SDHC_IRQSTATEN_DMAESEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_IRQSIGEN - Interrupt Signal Enable register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_IRQSIGEN - Interrupt Signal Enable register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is used to select which interrupt status is indicated to the
 * host system as the interrupt. All of these status bits share the same interrupt
 * line. Setting any of these bits to 1 enables interrupt generation. The
 * corresponding status register bit will generate an interrupt when the corresponding
 * interrupt signal enable bit is set.
 */
typedef union _hw_sdhc_irqsigen
{
    uint32_t U;
    struct _hw_sdhc_irqsigen_bitfields
    {
        uint32_t CCIEN : 1;            /*!< [0] Command Complete Interrupt Enable */
        uint32_t TCIEN : 1;            /*!< [1] Transfer Complete Interrupt Enable */
        uint32_t BGEIEN : 1;           /*!< [2] Block Gap Event Interrupt Enable */
        uint32_t DINTIEN : 1;          /*!< [3] DMA Interrupt Enable */
        uint32_t BWRIEN : 1;           /*!< [4] Buffer Write Ready Interrupt Enable */
        uint32_t BRRIEN : 1;           /*!< [5] Buffer Read Ready Interrupt Enable */
        uint32_t CINSIEN : 1;          /*!< [6] Card Insertion Interrupt Enable */
        uint32_t CRMIEN : 1;           /*!< [7] Card Removal Interrupt Enable */
        uint32_t CINTIEN : 1;          /*!< [8] Card Interrupt Enable */
        uint32_t RESERVED0 : 7;        /*!< [15:9]  */
        uint32_t CTOEIEN : 1;          /*!< [16] Command Timeout Error Interrupt
                                        * Enable */
        uint32_t CCEIEN : 1;           /*!< [17] Command CRC Error Interrupt Enable */
        uint32_t CEBEIEN : 1;          /*!< [18] Command End Bit Error Interrupt
                                        * Enable */
        uint32_t CIEIEN : 1;           /*!< [19] Command Index Error Interrupt Enable */
        uint32_t DTOEIEN : 1;          /*!< [20] Data Timeout Error Interrupt Enable */
        uint32_t DCEIEN : 1;           /*!< [21] Data CRC Error Interrupt Enable */
        uint32_t DEBEIEN : 1;          /*!< [22] Data End Bit Error Interrupt Enable */
        uint32_t RESERVED1 : 1;        /*!< [23]  */
        uint32_t AC12EIEN : 1;         /*!< [24] Auto CMD12 Error Interrupt Enable */
        uint32_t RESERVED2 : 3;        /*!< [27:25]  */
        uint32_t DMAEIEN : 1;          /*!< [28] DMA Error Interrupt Enable */
        uint32_t RESERVED3 : 3;        /*!< [31:29]  */
    } B;
} hw_sdhc_irqsigen_t;

/*!
 * @name Constants and macros for entire SDHC_IRQSIGEN register
 */
/*@{*/
#define HW_SDHC_IRQSIGEN_ADDR(x) ((uint32_t)(x) + 0x38U)

#define HW_SDHC_IRQSIGEN(x)      (*(__IO hw_sdhc_irqsigen_t *) HW_SDHC_IRQSIGEN_ADDR(x))
#define HW_SDHC_IRQSIGEN_RD(x)   (HW_SDHC_IRQSIGEN(x).U)
#define HW_SDHC_IRQSIGEN_WR(x, v) (HW_SDHC_IRQSIGEN(x).U = (v))
#define HW_SDHC_IRQSIGEN_SET(x, v) (HW_SDHC_IRQSIGEN_WR(x, HW_SDHC_IRQSIGEN_RD(x) |  (v)))
#define HW_SDHC_IRQSIGEN_CLR(x, v) (HW_SDHC_IRQSIGEN_WR(x, HW_SDHC_IRQSIGEN_RD(x) & ~(v)))
#define HW_SDHC_IRQSIGEN_TOG(x, v) (HW_SDHC_IRQSIGEN_WR(x, HW_SDHC_IRQSIGEN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_IRQSIGEN bitfields
 */

/*!
 * @name Register SDHC_IRQSIGEN, field CCIEN[0] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CCIEN (0U)        /*!< Bit position for SDHC_IRQSIGEN_CCIEN. */
#define BM_SDHC_IRQSIGEN_CCIEN (0x00000001U) /*!< Bit mask for SDHC_IRQSIGEN_CCIEN. */
#define BS_SDHC_IRQSIGEN_CCIEN (1U)        /*!< Bit field size in bits for SDHC_IRQSIGEN_CCIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CCIEN field. */
#define BR_SDHC_IRQSIGEN_CCIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CCIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CCIEN. */
#define BF_SDHC_IRQSIGEN_CCIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CCIEN) & BM_SDHC_IRQSIGEN_CCIEN)

/*! @brief Set the CCIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CCIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CCIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field TCIEN[1] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_TCIEN (1U)        /*!< Bit position for SDHC_IRQSIGEN_TCIEN. */
#define BM_SDHC_IRQSIGEN_TCIEN (0x00000002U) /*!< Bit mask for SDHC_IRQSIGEN_TCIEN. */
#define BS_SDHC_IRQSIGEN_TCIEN (1U)        /*!< Bit field size in bits for SDHC_IRQSIGEN_TCIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_TCIEN field. */
#define BR_SDHC_IRQSIGEN_TCIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_TCIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_TCIEN. */
#define BF_SDHC_IRQSIGEN_TCIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_TCIEN) & BM_SDHC_IRQSIGEN_TCIEN)

/*! @brief Set the TCIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_TCIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_TCIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field BGEIEN[2] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_BGEIEN (2U)       /*!< Bit position for SDHC_IRQSIGEN_BGEIEN. */
#define BM_SDHC_IRQSIGEN_BGEIEN (0x00000004U) /*!< Bit mask for SDHC_IRQSIGEN_BGEIEN. */
#define BS_SDHC_IRQSIGEN_BGEIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_BGEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_BGEIEN field. */
#define BR_SDHC_IRQSIGEN_BGEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BGEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_BGEIEN. */
#define BF_SDHC_IRQSIGEN_BGEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_BGEIEN) & BM_SDHC_IRQSIGEN_BGEIEN)

/*! @brief Set the BGEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_BGEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BGEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field DINTIEN[3] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_DINTIEN (3U)      /*!< Bit position for SDHC_IRQSIGEN_DINTIEN. */
#define BM_SDHC_IRQSIGEN_DINTIEN (0x00000008U) /*!< Bit mask for SDHC_IRQSIGEN_DINTIEN. */
#define BS_SDHC_IRQSIGEN_DINTIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_DINTIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_DINTIEN field. */
#define BR_SDHC_IRQSIGEN_DINTIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DINTIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_DINTIEN. */
#define BF_SDHC_IRQSIGEN_DINTIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_DINTIEN) & BM_SDHC_IRQSIGEN_DINTIEN)

/*! @brief Set the DINTIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_DINTIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DINTIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field BWRIEN[4] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_BWRIEN (4U)       /*!< Bit position for SDHC_IRQSIGEN_BWRIEN. */
#define BM_SDHC_IRQSIGEN_BWRIEN (0x00000010U) /*!< Bit mask for SDHC_IRQSIGEN_BWRIEN. */
#define BS_SDHC_IRQSIGEN_BWRIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_BWRIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_BWRIEN field. */
#define BR_SDHC_IRQSIGEN_BWRIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BWRIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_BWRIEN. */
#define BF_SDHC_IRQSIGEN_BWRIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_BWRIEN) & BM_SDHC_IRQSIGEN_BWRIEN)

/*! @brief Set the BWRIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_BWRIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BWRIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field BRRIEN[5] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_BRRIEN (5U)       /*!< Bit position for SDHC_IRQSIGEN_BRRIEN. */
#define BM_SDHC_IRQSIGEN_BRRIEN (0x00000020U) /*!< Bit mask for SDHC_IRQSIGEN_BRRIEN. */
#define BS_SDHC_IRQSIGEN_BRRIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_BRRIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_BRRIEN field. */
#define BR_SDHC_IRQSIGEN_BRRIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BRRIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_BRRIEN. */
#define BF_SDHC_IRQSIGEN_BRRIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_BRRIEN) & BM_SDHC_IRQSIGEN_BRRIEN)

/*! @brief Set the BRRIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_BRRIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_BRRIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CINSIEN[6] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CINSIEN (6U)      /*!< Bit position for SDHC_IRQSIGEN_CINSIEN. */
#define BM_SDHC_IRQSIGEN_CINSIEN (0x00000040U) /*!< Bit mask for SDHC_IRQSIGEN_CINSIEN. */
#define BS_SDHC_IRQSIGEN_CINSIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_CINSIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CINSIEN field. */
#define BR_SDHC_IRQSIGEN_CINSIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CINSIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CINSIEN. */
#define BF_SDHC_IRQSIGEN_CINSIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CINSIEN) & BM_SDHC_IRQSIGEN_CINSIEN)

/*! @brief Set the CINSIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CINSIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CINSIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CRMIEN[7] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CRMIEN (7U)       /*!< Bit position for SDHC_IRQSIGEN_CRMIEN. */
#define BM_SDHC_IRQSIGEN_CRMIEN (0x00000080U) /*!< Bit mask for SDHC_IRQSIGEN_CRMIEN. */
#define BS_SDHC_IRQSIGEN_CRMIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_CRMIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CRMIEN field. */
#define BR_SDHC_IRQSIGEN_CRMIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CRMIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CRMIEN. */
#define BF_SDHC_IRQSIGEN_CRMIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CRMIEN) & BM_SDHC_IRQSIGEN_CRMIEN)

/*! @brief Set the CRMIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CRMIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CRMIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CINTIEN[8] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CINTIEN (8U)      /*!< Bit position for SDHC_IRQSIGEN_CINTIEN. */
#define BM_SDHC_IRQSIGEN_CINTIEN (0x00000100U) /*!< Bit mask for SDHC_IRQSIGEN_CINTIEN. */
#define BS_SDHC_IRQSIGEN_CINTIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_CINTIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CINTIEN field. */
#define BR_SDHC_IRQSIGEN_CINTIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CINTIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CINTIEN. */
#define BF_SDHC_IRQSIGEN_CINTIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CINTIEN) & BM_SDHC_IRQSIGEN_CINTIEN)

/*! @brief Set the CINTIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CINTIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CINTIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CTOEIEN[16] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CTOEIEN (16U)     /*!< Bit position for SDHC_IRQSIGEN_CTOEIEN. */
#define BM_SDHC_IRQSIGEN_CTOEIEN (0x00010000U) /*!< Bit mask for SDHC_IRQSIGEN_CTOEIEN. */
#define BS_SDHC_IRQSIGEN_CTOEIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_CTOEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CTOEIEN field. */
#define BR_SDHC_IRQSIGEN_CTOEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CTOEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CTOEIEN. */
#define BF_SDHC_IRQSIGEN_CTOEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CTOEIEN) & BM_SDHC_IRQSIGEN_CTOEIEN)

/*! @brief Set the CTOEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CTOEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CTOEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CCEIEN[17] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CCEIEN (17U)      /*!< Bit position for SDHC_IRQSIGEN_CCEIEN. */
#define BM_SDHC_IRQSIGEN_CCEIEN (0x00020000U) /*!< Bit mask for SDHC_IRQSIGEN_CCEIEN. */
#define BS_SDHC_IRQSIGEN_CCEIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_CCEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CCEIEN field. */
#define BR_SDHC_IRQSIGEN_CCEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CCEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CCEIEN. */
#define BF_SDHC_IRQSIGEN_CCEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CCEIEN) & BM_SDHC_IRQSIGEN_CCEIEN)

/*! @brief Set the CCEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CCEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CCEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CEBEIEN[18] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CEBEIEN (18U)     /*!< Bit position for SDHC_IRQSIGEN_CEBEIEN. */
#define BM_SDHC_IRQSIGEN_CEBEIEN (0x00040000U) /*!< Bit mask for SDHC_IRQSIGEN_CEBEIEN. */
#define BS_SDHC_IRQSIGEN_CEBEIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_CEBEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CEBEIEN field. */
#define BR_SDHC_IRQSIGEN_CEBEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CEBEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CEBEIEN. */
#define BF_SDHC_IRQSIGEN_CEBEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CEBEIEN) & BM_SDHC_IRQSIGEN_CEBEIEN)

/*! @brief Set the CEBEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CEBEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CEBEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field CIEIEN[19] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_CIEIEN (19U)      /*!< Bit position for SDHC_IRQSIGEN_CIEIEN. */
#define BM_SDHC_IRQSIGEN_CIEIEN (0x00080000U) /*!< Bit mask for SDHC_IRQSIGEN_CIEIEN. */
#define BS_SDHC_IRQSIGEN_CIEIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_CIEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_CIEIEN field. */
#define BR_SDHC_IRQSIGEN_CIEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CIEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_CIEIEN. */
#define BF_SDHC_IRQSIGEN_CIEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_CIEIEN) & BM_SDHC_IRQSIGEN_CIEIEN)

/*! @brief Set the CIEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_CIEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_CIEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field DTOEIEN[20] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_DTOEIEN (20U)     /*!< Bit position for SDHC_IRQSIGEN_DTOEIEN. */
#define BM_SDHC_IRQSIGEN_DTOEIEN (0x00100000U) /*!< Bit mask for SDHC_IRQSIGEN_DTOEIEN. */
#define BS_SDHC_IRQSIGEN_DTOEIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_DTOEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_DTOEIEN field. */
#define BR_SDHC_IRQSIGEN_DTOEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DTOEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_DTOEIEN. */
#define BF_SDHC_IRQSIGEN_DTOEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_DTOEIEN) & BM_SDHC_IRQSIGEN_DTOEIEN)

/*! @brief Set the DTOEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_DTOEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DTOEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field DCEIEN[21] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_DCEIEN (21U)      /*!< Bit position for SDHC_IRQSIGEN_DCEIEN. */
#define BM_SDHC_IRQSIGEN_DCEIEN (0x00200000U) /*!< Bit mask for SDHC_IRQSIGEN_DCEIEN. */
#define BS_SDHC_IRQSIGEN_DCEIEN (1U)       /*!< Bit field size in bits for SDHC_IRQSIGEN_DCEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_DCEIEN field. */
#define BR_SDHC_IRQSIGEN_DCEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DCEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_DCEIEN. */
#define BF_SDHC_IRQSIGEN_DCEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_DCEIEN) & BM_SDHC_IRQSIGEN_DCEIEN)

/*! @brief Set the DCEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_DCEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DCEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field DEBEIEN[22] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_DEBEIEN (22U)     /*!< Bit position for SDHC_IRQSIGEN_DEBEIEN. */
#define BM_SDHC_IRQSIGEN_DEBEIEN (0x00400000U) /*!< Bit mask for SDHC_IRQSIGEN_DEBEIEN. */
#define BS_SDHC_IRQSIGEN_DEBEIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_DEBEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_DEBEIEN field. */
#define BR_SDHC_IRQSIGEN_DEBEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DEBEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_DEBEIEN. */
#define BF_SDHC_IRQSIGEN_DEBEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_DEBEIEN) & BM_SDHC_IRQSIGEN_DEBEIEN)

/*! @brief Set the DEBEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_DEBEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DEBEIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field AC12EIEN[24] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_AC12EIEN (24U)    /*!< Bit position for SDHC_IRQSIGEN_AC12EIEN. */
#define BM_SDHC_IRQSIGEN_AC12EIEN (0x01000000U) /*!< Bit mask for SDHC_IRQSIGEN_AC12EIEN. */
#define BS_SDHC_IRQSIGEN_AC12EIEN (1U)     /*!< Bit field size in bits for SDHC_IRQSIGEN_AC12EIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_AC12EIEN field. */
#define BR_SDHC_IRQSIGEN_AC12EIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_AC12EIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_AC12EIEN. */
#define BF_SDHC_IRQSIGEN_AC12EIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_AC12EIEN) & BM_SDHC_IRQSIGEN_AC12EIEN)

/*! @brief Set the AC12EIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_AC12EIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_AC12EIEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_IRQSIGEN, field DMAEIEN[28] (RW)
 *
 * Values:
 * - 0 - Masked
 * - 1 - Enabled
 */
/*@{*/
#define BP_SDHC_IRQSIGEN_DMAEIEN (28U)     /*!< Bit position for SDHC_IRQSIGEN_DMAEIEN. */
#define BM_SDHC_IRQSIGEN_DMAEIEN (0x10000000U) /*!< Bit mask for SDHC_IRQSIGEN_DMAEIEN. */
#define BS_SDHC_IRQSIGEN_DMAEIEN (1U)      /*!< Bit field size in bits for SDHC_IRQSIGEN_DMAEIEN. */

/*! @brief Read current value of the SDHC_IRQSIGEN_DMAEIEN field. */
#define BR_SDHC_IRQSIGEN_DMAEIEN(x) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DMAEIEN))

/*! @brief Format value for bitfield SDHC_IRQSIGEN_DMAEIEN. */
#define BF_SDHC_IRQSIGEN_DMAEIEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_IRQSIGEN_DMAEIEN) & BM_SDHC_IRQSIGEN_DMAEIEN)

/*! @brief Set the DMAEIEN field to a new value. */
#define BW_SDHC_IRQSIGEN_DMAEIEN(x, v) (BITBAND_ACCESS32(HW_SDHC_IRQSIGEN_ADDR(x), BP_SDHC_IRQSIGEN_DMAEIEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_AC12ERR - Auto CMD12 Error Status Register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_AC12ERR - Auto CMD12 Error Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the AC12ESEN bit in the Status register is set, the host driver shall
 * check this register to identify what kind of error the Auto CMD12 indicated.
 * This register is valid only when the Auto CMD12 Error status bit is set. The
 * following table shows the relationship between the Auto CMGD12 CRC error and the
 * Auto CMD12 command timeout error. Relationship between Command CRC Error and
 * Command Timeout Error For Auto CMD12 Auto CMD12 CRC error Auto CMD12 timeout
 * error Type of error 0 0 No error 0 1 Response timeout error 1 0 Response CRC
 * error 1 1 CMD line conflict Changes in Auto CMD12 Error Status register can be
 * classified in three scenarios: When the SDHC is going to issue an Auto CMD12: Set
 * bit 0 to 1 if the Auto CMD12 can't be issued due to an error in the previous
 * command. Set bit 0 to 0 if the auto CMD12 is issued. At the end bit of an auto
 * CMD12 response: Check errors corresponding to bits 1-4. Set bits 1-4
 * corresponding to detected errors. Clear bits 1-4 corresponding to detected errors.
 * Before reading the Auto CMD12 error status bit 7: Set bit 7 to 1 if there is a
 * command that can't be issued. Clear bit 7 if there is no command to issue. The
 * timing for generating the auto CMD12 error and writing to the command register
 * are asynchronous. After that, bit 7 shall be sampled when the driver is not
 * writing to the command register. So it is suggested to read this register only
 * when IRQSTAT[AC12E] is set. An Auto CMD12 error interrupt is generated when one
 * of the error bits (0-4) is set to 1. The command not issued by auto CMD12
 * error does not generate an interrupt.
 */
typedef union _hw_sdhc_ac12err
{
    uint32_t U;
    struct _hw_sdhc_ac12err_bitfields
    {
        uint32_t AC12NE : 1;           /*!< [0] Auto CMD12 Not Executed */
        uint32_t AC12TOE : 1;          /*!< [1] Auto CMD12 Timeout Error */
        uint32_t AC12EBE : 1;          /*!< [2] Auto CMD12 End Bit Error */
        uint32_t AC12CE : 1;           /*!< [3] Auto CMD12 CRC Error */
        uint32_t AC12IE : 1;           /*!< [4] Auto CMD12 Index Error */
        uint32_t RESERVED0 : 2;        /*!< [6:5]  */
        uint32_t CNIBAC12E : 1;        /*!< [7] Command Not Issued By Auto CMD12
                                        * Error */
        uint32_t RESERVED1 : 24;       /*!< [31:8]  */
    } B;
} hw_sdhc_ac12err_t;

/*!
 * @name Constants and macros for entire SDHC_AC12ERR register
 */
/*@{*/
#define HW_SDHC_AC12ERR_ADDR(x)  ((uint32_t)(x) + 0x3CU)

#define HW_SDHC_AC12ERR(x)       (*(__I hw_sdhc_ac12err_t *) HW_SDHC_AC12ERR_ADDR(x))
#define HW_SDHC_AC12ERR_RD(x)    (HW_SDHC_AC12ERR(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_AC12ERR bitfields
 */

/*!
 * @name Register SDHC_AC12ERR, field AC12NE[0] (RO)
 *
 * If memory multiple block data transfer is not started, due to a command
 * error, this bit is not set because it is not necessary to issue an auto CMD12.
 * Setting this bit to 1 means the SDHC cannot issue the auto CMD12 to stop a memory
 * multiple block data transfer due to some error. If this bit is set to 1, other
 * error status bits (1-4) have no meaning.
 *
 * Values:
 * - 0 - Executed.
 * - 1 - Not executed.
 */
/*@{*/
#define BP_SDHC_AC12ERR_AC12NE (0U)        /*!< Bit position for SDHC_AC12ERR_AC12NE. */
#define BM_SDHC_AC12ERR_AC12NE (0x00000001U) /*!< Bit mask for SDHC_AC12ERR_AC12NE. */
#define BS_SDHC_AC12ERR_AC12NE (1U)        /*!< Bit field size in bits for SDHC_AC12ERR_AC12NE. */

/*! @brief Read current value of the SDHC_AC12ERR_AC12NE field. */
#define BR_SDHC_AC12ERR_AC12NE(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_AC12NE))
/*@}*/

/*!
 * @name Register SDHC_AC12ERR, field AC12TOE[1] (RO)
 *
 * Occurs if no response is returned within 64 SDCLK cycles from the end bit of
 * the command. If this bit is set to 1, the other error status bits (2-4) have
 * no meaning.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Time out.
 */
/*@{*/
#define BP_SDHC_AC12ERR_AC12TOE (1U)       /*!< Bit position for SDHC_AC12ERR_AC12TOE. */
#define BM_SDHC_AC12ERR_AC12TOE (0x00000002U) /*!< Bit mask for SDHC_AC12ERR_AC12TOE. */
#define BS_SDHC_AC12ERR_AC12TOE (1U)       /*!< Bit field size in bits for SDHC_AC12ERR_AC12TOE. */

/*! @brief Read current value of the SDHC_AC12ERR_AC12TOE field. */
#define BR_SDHC_AC12ERR_AC12TOE(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_AC12TOE))
/*@}*/

/*!
 * @name Register SDHC_AC12ERR, field AC12EBE[2] (RO)
 *
 * Occurs when detecting that the end bit of command response is 0 which must be
 * 1.
 *
 * Values:
 * - 0 - No error.
 * - 1 - End bit error generated.
 */
/*@{*/
#define BP_SDHC_AC12ERR_AC12EBE (2U)       /*!< Bit position for SDHC_AC12ERR_AC12EBE. */
#define BM_SDHC_AC12ERR_AC12EBE (0x00000004U) /*!< Bit mask for SDHC_AC12ERR_AC12EBE. */
#define BS_SDHC_AC12ERR_AC12EBE (1U)       /*!< Bit field size in bits for SDHC_AC12ERR_AC12EBE. */

/*! @brief Read current value of the SDHC_AC12ERR_AC12EBE field. */
#define BR_SDHC_AC12ERR_AC12EBE(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_AC12EBE))
/*@}*/

/*!
 * @name Register SDHC_AC12ERR, field AC12CE[3] (RO)
 *
 * Occurs when detecting a CRC error in the command response.
 *
 * Values:
 * - 0 - No CRC error.
 * - 1 - CRC error met in Auto CMD12 response.
 */
/*@{*/
#define BP_SDHC_AC12ERR_AC12CE (3U)        /*!< Bit position for SDHC_AC12ERR_AC12CE. */
#define BM_SDHC_AC12ERR_AC12CE (0x00000008U) /*!< Bit mask for SDHC_AC12ERR_AC12CE. */
#define BS_SDHC_AC12ERR_AC12CE (1U)        /*!< Bit field size in bits for SDHC_AC12ERR_AC12CE. */

/*! @brief Read current value of the SDHC_AC12ERR_AC12CE field. */
#define BR_SDHC_AC12ERR_AC12CE(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_AC12CE))
/*@}*/

/*!
 * @name Register SDHC_AC12ERR, field AC12IE[4] (RO)
 *
 * Occurs if the command index error occurs in response to a command.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error, the CMD index in response is not CMD12.
 */
/*@{*/
#define BP_SDHC_AC12ERR_AC12IE (4U)        /*!< Bit position for SDHC_AC12ERR_AC12IE. */
#define BM_SDHC_AC12ERR_AC12IE (0x00000010U) /*!< Bit mask for SDHC_AC12ERR_AC12IE. */
#define BS_SDHC_AC12ERR_AC12IE (1U)        /*!< Bit field size in bits for SDHC_AC12ERR_AC12IE. */

/*! @brief Read current value of the SDHC_AC12ERR_AC12IE field. */
#define BR_SDHC_AC12ERR_AC12IE(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_AC12IE))
/*@}*/

/*!
 * @name Register SDHC_AC12ERR, field CNIBAC12E[7] (RO)
 *
 * Setting this bit to 1 means CMD_wo_DAT is not executed due to an auto CMD12
 * error (D04-D01) in this register.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Not issued.
 */
/*@{*/
#define BP_SDHC_AC12ERR_CNIBAC12E (7U)     /*!< Bit position for SDHC_AC12ERR_CNIBAC12E. */
#define BM_SDHC_AC12ERR_CNIBAC12E (0x00000080U) /*!< Bit mask for SDHC_AC12ERR_CNIBAC12E. */
#define BS_SDHC_AC12ERR_CNIBAC12E (1U)     /*!< Bit field size in bits for SDHC_AC12ERR_CNIBAC12E. */

/*! @brief Read current value of the SDHC_AC12ERR_CNIBAC12E field. */
#define BR_SDHC_AC12ERR_CNIBAC12E(x) (BITBAND_ACCESS32(HW_SDHC_AC12ERR_ADDR(x), BP_SDHC_AC12ERR_CNIBAC12E))
/*@}*/

/*******************************************************************************
 * HW_SDHC_HTCAPBLT - Host Controller Capabilities
 ******************************************************************************/

/*!
 * @brief HW_SDHC_HTCAPBLT - Host Controller Capabilities (RO)
 *
 * Reset value: 0x07F30000U
 *
 * This register provides the host driver with information specific to the SDHC
 * implementation. The value in this register is the power-on-reset value, and
 * does not change with a software reset. Any write to this register is ignored.
 */
typedef union _hw_sdhc_htcapblt
{
    uint32_t U;
    struct _hw_sdhc_htcapblt_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t MBL : 3;              /*!< [18:16] Max Block Length */
        uint32_t RESERVED1 : 1;        /*!< [19]  */
        uint32_t ADMAS : 1;            /*!< [20] ADMA Support */
        uint32_t HSS : 1;              /*!< [21] High Speed Support */
        uint32_t DMAS : 1;             /*!< [22] DMA Support */
        uint32_t SRS : 1;              /*!< [23] Suspend/Resume Support */
        uint32_t VS33 : 1;             /*!< [24] Voltage Support 3.3 V */
        uint32_t RESERVED2 : 7;        /*!< [31:25]  */
    } B;
} hw_sdhc_htcapblt_t;

/*!
 * @name Constants and macros for entire SDHC_HTCAPBLT register
 */
/*@{*/
#define HW_SDHC_HTCAPBLT_ADDR(x) ((uint32_t)(x) + 0x40U)

#define HW_SDHC_HTCAPBLT(x)      (*(__I hw_sdhc_htcapblt_t *) HW_SDHC_HTCAPBLT_ADDR(x))
#define HW_SDHC_HTCAPBLT_RD(x)   (HW_SDHC_HTCAPBLT(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_HTCAPBLT bitfields
 */

/*!
 * @name Register SDHC_HTCAPBLT, field MBL[18:16] (RO)
 *
 * This value indicates the maximum block size that the host driver can read and
 * write to the buffer in the SDHC. The buffer shall transfer block size without
 * wait cycles.
 *
 * Values:
 * - 000 - 512 bytes
 * - 001 - 1024 bytes
 * - 010 - 2048 bytes
 * - 011 - 4096 bytes
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_MBL (16U)         /*!< Bit position for SDHC_HTCAPBLT_MBL. */
#define BM_SDHC_HTCAPBLT_MBL (0x00070000U) /*!< Bit mask for SDHC_HTCAPBLT_MBL. */
#define BS_SDHC_HTCAPBLT_MBL (3U)          /*!< Bit field size in bits for SDHC_HTCAPBLT_MBL. */

/*! @brief Read current value of the SDHC_HTCAPBLT_MBL field. */
#define BR_SDHC_HTCAPBLT_MBL(x) (HW_SDHC_HTCAPBLT(x).B.MBL)
/*@}*/

/*!
 * @name Register SDHC_HTCAPBLT, field ADMAS[20] (RO)
 *
 * This bit indicates whether the SDHC supports the ADMA feature.
 *
 * Values:
 * - 0 - Advanced DMA not supported.
 * - 1 - Advanced DMA supported.
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_ADMAS (20U)       /*!< Bit position for SDHC_HTCAPBLT_ADMAS. */
#define BM_SDHC_HTCAPBLT_ADMAS (0x00100000U) /*!< Bit mask for SDHC_HTCAPBLT_ADMAS. */
#define BS_SDHC_HTCAPBLT_ADMAS (1U)        /*!< Bit field size in bits for SDHC_HTCAPBLT_ADMAS. */

/*! @brief Read current value of the SDHC_HTCAPBLT_ADMAS field. */
#define BR_SDHC_HTCAPBLT_ADMAS(x) (BITBAND_ACCESS32(HW_SDHC_HTCAPBLT_ADDR(x), BP_SDHC_HTCAPBLT_ADMAS))
/*@}*/

/*!
 * @name Register SDHC_HTCAPBLT, field HSS[21] (RO)
 *
 * This bit indicates whether the SDHC supports high speed mode and the host
 * system can supply a SD Clock frequency from 25 MHz to 50 MHz.
 *
 * Values:
 * - 0 - High speed not supported.
 * - 1 - High speed supported.
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_HSS (21U)         /*!< Bit position for SDHC_HTCAPBLT_HSS. */
#define BM_SDHC_HTCAPBLT_HSS (0x00200000U) /*!< Bit mask for SDHC_HTCAPBLT_HSS. */
#define BS_SDHC_HTCAPBLT_HSS (1U)          /*!< Bit field size in bits for SDHC_HTCAPBLT_HSS. */

/*! @brief Read current value of the SDHC_HTCAPBLT_HSS field. */
#define BR_SDHC_HTCAPBLT_HSS(x) (BITBAND_ACCESS32(HW_SDHC_HTCAPBLT_ADDR(x), BP_SDHC_HTCAPBLT_HSS))
/*@}*/

/*!
 * @name Register SDHC_HTCAPBLT, field DMAS[22] (RO)
 *
 * This bit indicates whether the SDHC is capable of using the internal DMA to
 * transfer data between system memory and the data buffer directly.
 *
 * Values:
 * - 0 - DMA not supported.
 * - 1 - DMA supported.
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_DMAS (22U)        /*!< Bit position for SDHC_HTCAPBLT_DMAS. */
#define BM_SDHC_HTCAPBLT_DMAS (0x00400000U) /*!< Bit mask for SDHC_HTCAPBLT_DMAS. */
#define BS_SDHC_HTCAPBLT_DMAS (1U)         /*!< Bit field size in bits for SDHC_HTCAPBLT_DMAS. */

/*! @brief Read current value of the SDHC_HTCAPBLT_DMAS field. */
#define BR_SDHC_HTCAPBLT_DMAS(x) (BITBAND_ACCESS32(HW_SDHC_HTCAPBLT_ADDR(x), BP_SDHC_HTCAPBLT_DMAS))
/*@}*/

/*!
 * @name Register SDHC_HTCAPBLT, field SRS[23] (RO)
 *
 * This bit indicates whether the SDHC supports suspend / resume functionality.
 * If this bit is 0, the suspend and resume mechanism, as well as the read Wwait,
 * are not supported, and the host driver shall not issue either suspend or
 * resume commands.
 *
 * Values:
 * - 0 - Not supported.
 * - 1 - Supported.
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_SRS (23U)         /*!< Bit position for SDHC_HTCAPBLT_SRS. */
#define BM_SDHC_HTCAPBLT_SRS (0x00800000U) /*!< Bit mask for SDHC_HTCAPBLT_SRS. */
#define BS_SDHC_HTCAPBLT_SRS (1U)          /*!< Bit field size in bits for SDHC_HTCAPBLT_SRS. */

/*! @brief Read current value of the SDHC_HTCAPBLT_SRS field. */
#define BR_SDHC_HTCAPBLT_SRS(x) (BITBAND_ACCESS32(HW_SDHC_HTCAPBLT_ADDR(x), BP_SDHC_HTCAPBLT_SRS))
/*@}*/

/*!
 * @name Register SDHC_HTCAPBLT, field VS33[24] (RO)
 *
 * This bit shall depend on the host system ability.
 *
 * Values:
 * - 0 - 3.3 V not supported.
 * - 1 - 3.3 V supported.
 */
/*@{*/
#define BP_SDHC_HTCAPBLT_VS33 (24U)        /*!< Bit position for SDHC_HTCAPBLT_VS33. */
#define BM_SDHC_HTCAPBLT_VS33 (0x01000000U) /*!< Bit mask for SDHC_HTCAPBLT_VS33. */
#define BS_SDHC_HTCAPBLT_VS33 (1U)         /*!< Bit field size in bits for SDHC_HTCAPBLT_VS33. */

/*! @brief Read current value of the SDHC_HTCAPBLT_VS33 field. */
#define BR_SDHC_HTCAPBLT_VS33(x) (BITBAND_ACCESS32(HW_SDHC_HTCAPBLT_ADDR(x), BP_SDHC_HTCAPBLT_VS33))
/*@}*/

/*******************************************************************************
 * HW_SDHC_WML - Watermark Level Register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_WML - Watermark Level Register (RW)
 *
 * Reset value: 0x00100010U
 *
 * Both write and read watermark levels (FIFO threshold) are configurable. There
 * value can range from 1 to 128 words. Both write and read burst lengths are
 * also configurable. There value can range from 1 to 31 words.
 */
typedef union _hw_sdhc_wml
{
    uint32_t U;
    struct _hw_sdhc_wml_bitfields
    {
        uint32_t RDWML : 8;            /*!< [7:0] Read Watermark Level */
        uint32_t RESERVED0 : 8;        /*!< [15:8]  */
        uint32_t WRWML : 8;            /*!< [23:16] Write Watermark Level */
        uint32_t RESERVED1 : 8;        /*!< [31:24]  */
    } B;
} hw_sdhc_wml_t;

/*!
 * @name Constants and macros for entire SDHC_WML register
 */
/*@{*/
#define HW_SDHC_WML_ADDR(x)      ((uint32_t)(x) + 0x44U)

#define HW_SDHC_WML(x)           (*(__IO hw_sdhc_wml_t *) HW_SDHC_WML_ADDR(x))
#define HW_SDHC_WML_RD(x)        (HW_SDHC_WML(x).U)
#define HW_SDHC_WML_WR(x, v)     (HW_SDHC_WML(x).U = (v))
#define HW_SDHC_WML_SET(x, v)    (HW_SDHC_WML_WR(x, HW_SDHC_WML_RD(x) |  (v)))
#define HW_SDHC_WML_CLR(x, v)    (HW_SDHC_WML_WR(x, HW_SDHC_WML_RD(x) & ~(v)))
#define HW_SDHC_WML_TOG(x, v)    (HW_SDHC_WML_WR(x, HW_SDHC_WML_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_WML bitfields
 */

/*!
 * @name Register SDHC_WML, field RDWML[7:0] (RW)
 *
 * The number of words used as the watermark level (FIFO threshold) in a DMA
 * read operation. Also the number of words as a sequence of read bursts in
 * back-to-back mode. The maximum legal value for the read water mark level is 128.
 */
/*@{*/
#define BP_SDHC_WML_RDWML    (0U)          /*!< Bit position for SDHC_WML_RDWML. */
#define BM_SDHC_WML_RDWML    (0x000000FFU) /*!< Bit mask for SDHC_WML_RDWML. */
#define BS_SDHC_WML_RDWML    (8U)          /*!< Bit field size in bits for SDHC_WML_RDWML. */

/*! @brief Read current value of the SDHC_WML_RDWML field. */
#define BR_SDHC_WML_RDWML(x) (HW_SDHC_WML(x).B.RDWML)

/*! @brief Format value for bitfield SDHC_WML_RDWML. */
#define BF_SDHC_WML_RDWML(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_WML_RDWML) & BM_SDHC_WML_RDWML)

/*! @brief Set the RDWML field to a new value. */
#define BW_SDHC_WML_RDWML(x, v) (HW_SDHC_WML_WR(x, (HW_SDHC_WML_RD(x) & ~BM_SDHC_WML_RDWML) | BF_SDHC_WML_RDWML(v)))
/*@}*/

/*!
 * @name Register SDHC_WML, field WRWML[23:16] (RW)
 *
 * The number of words used as the watermark level (FIFO threshold) in a DMA
 * write operation. Also the number of words as a sequence of write bursts in
 * back-to-back mode. The maximum legal value for the write watermark level is 128.
 */
/*@{*/
#define BP_SDHC_WML_WRWML    (16U)         /*!< Bit position for SDHC_WML_WRWML. */
#define BM_SDHC_WML_WRWML    (0x00FF0000U) /*!< Bit mask for SDHC_WML_WRWML. */
#define BS_SDHC_WML_WRWML    (8U)          /*!< Bit field size in bits for SDHC_WML_WRWML. */

/*! @brief Read current value of the SDHC_WML_WRWML field. */
#define BR_SDHC_WML_WRWML(x) (HW_SDHC_WML(x).B.WRWML)

/*! @brief Format value for bitfield SDHC_WML_WRWML. */
#define BF_SDHC_WML_WRWML(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_WML_WRWML) & BM_SDHC_WML_WRWML)

/*! @brief Set the WRWML field to a new value. */
#define BW_SDHC_WML_WRWML(x, v) (HW_SDHC_WML_WR(x, (HW_SDHC_WML_RD(x) & ~BM_SDHC_WML_WRWML) | BF_SDHC_WML_WRWML(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_FEVT - Force Event register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_FEVT - Force Event register (WO)
 *
 * Reset value: 0x00000000U
 *
 * The Force Event (FEVT) register is not a physically implemented register.
 * Rather, it is an address at which the Interrupt Status register can be written if
 * the corresponding bit of the Interrupt Status Enable register is set. This
 * register is a write only register and writing 0 to it has no effect. Writing 1
 * to this register actually sets the corresponding bit of Interrupt Status
 * register. A read from this register always results in 0's. To change the
 * corresponding status bits in the interrupt status register, make sure to set
 * SYSCTL[IPGEN] so that bus clock is always active. Forcing a card interrupt will generate a
 * short pulse on the DAT[1] line, and the driver may treat this interrupt as a
 * normal interrupt. The interrupt service routine may skip polling the card
 * interrupt factor as the interrupt is selfcleared.
 */
typedef union _hw_sdhc_fevt
{
    uint32_t U;
    struct _hw_sdhc_fevt_bitfields
    {
        uint32_t AC12NE : 1;           /*!< [0] Force Event Auto Command 12 Not
                                        * Executed */
        uint32_t AC12TOE : 1;          /*!< [1] Force Event Auto Command 12 Time Out
                                        * Error */
        uint32_t AC12CE : 1;           /*!< [2] Force Event Auto Command 12 CRC Error */
        uint32_t AC12EBE : 1;          /*!< [3] Force Event Auto Command 12 End Bit
                                        * Error */
        uint32_t AC12IE : 1;           /*!< [4] Force Event Auto Command 12 Index Error
                                        * */
        uint32_t RESERVED0 : 2;        /*!< [6:5]  */
        uint32_t CNIBAC12E : 1;        /*!< [7] Force Event Command Not Executed By
                                        * Auto Command 12 Error */
        uint32_t RESERVED1 : 8;        /*!< [15:8]  */
        uint32_t CTOE : 1;             /*!< [16] Force Event Command Time Out Error */
        uint32_t CCE : 1;              /*!< [17] Force Event Command CRC Error */
        uint32_t CEBE : 1;             /*!< [18] Force Event Command End Bit Error */
        uint32_t CIE : 1;              /*!< [19] Force Event Command Index Error */
        uint32_t DTOE : 1;             /*!< [20] Force Event Data Time Out Error */
        uint32_t DCE : 1;              /*!< [21] Force Event Data CRC Error */
        uint32_t DEBE : 1;             /*!< [22] Force Event Data End Bit Error */
        uint32_t RESERVED2 : 1;        /*!< [23]  */
        uint32_t AC12E : 1;            /*!< [24] Force Event Auto Command 12 Error */
        uint32_t RESERVED3 : 3;        /*!< [27:25]  */
        uint32_t DMAE : 1;             /*!< [28] Force Event DMA Error */
        uint32_t RESERVED4 : 2;        /*!< [30:29]  */
        uint32_t CINT : 1;             /*!< [31] Force Event Card Interrupt */
    } B;
} hw_sdhc_fevt_t;

/*!
 * @name Constants and macros for entire SDHC_FEVT register
 */
/*@{*/
#define HW_SDHC_FEVT_ADDR(x)     ((uint32_t)(x) + 0x50U)

#define HW_SDHC_FEVT(x)          (*(__O hw_sdhc_fevt_t *) HW_SDHC_FEVT_ADDR(x))
#define HW_SDHC_FEVT_RD(x)       (HW_SDHC_FEVT(x).U)
#define HW_SDHC_FEVT_WR(x, v)    (HW_SDHC_FEVT(x).U = (v))
/*@}*/

/*
 * Constants & macros for individual SDHC_FEVT bitfields
 */

/*!
 * @name Register SDHC_FEVT, field AC12NE[0] (WORZ)
 *
 * Forces AC12ERR[AC12NE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12NE  (0U)          /*!< Bit position for SDHC_FEVT_AC12NE. */
#define BM_SDHC_FEVT_AC12NE  (0x00000001U) /*!< Bit mask for SDHC_FEVT_AC12NE. */
#define BS_SDHC_FEVT_AC12NE  (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12NE. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12NE. */
#define BF_SDHC_FEVT_AC12NE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12NE) & BM_SDHC_FEVT_AC12NE)

/*! @brief Set the AC12NE field to a new value. */
#define BW_SDHC_FEVT_AC12NE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12NE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field AC12TOE[1] (WORZ)
 *
 * Forces AC12ERR[AC12TOE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12TOE (1U)          /*!< Bit position for SDHC_FEVT_AC12TOE. */
#define BM_SDHC_FEVT_AC12TOE (0x00000002U) /*!< Bit mask for SDHC_FEVT_AC12TOE. */
#define BS_SDHC_FEVT_AC12TOE (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12TOE. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12TOE. */
#define BF_SDHC_FEVT_AC12TOE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12TOE) & BM_SDHC_FEVT_AC12TOE)

/*! @brief Set the AC12TOE field to a new value. */
#define BW_SDHC_FEVT_AC12TOE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12TOE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field AC12CE[2] (WORZ)
 *
 * Forces AC12ERR[AC12CE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12CE  (2U)          /*!< Bit position for SDHC_FEVT_AC12CE. */
#define BM_SDHC_FEVT_AC12CE  (0x00000004U) /*!< Bit mask for SDHC_FEVT_AC12CE. */
#define BS_SDHC_FEVT_AC12CE  (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12CE. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12CE. */
#define BF_SDHC_FEVT_AC12CE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12CE) & BM_SDHC_FEVT_AC12CE)

/*! @brief Set the AC12CE field to a new value. */
#define BW_SDHC_FEVT_AC12CE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12CE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field AC12EBE[3] (WORZ)
 *
 * Forces AC12ERR[AC12EBE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12EBE (3U)          /*!< Bit position for SDHC_FEVT_AC12EBE. */
#define BM_SDHC_FEVT_AC12EBE (0x00000008U) /*!< Bit mask for SDHC_FEVT_AC12EBE. */
#define BS_SDHC_FEVT_AC12EBE (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12EBE. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12EBE. */
#define BF_SDHC_FEVT_AC12EBE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12EBE) & BM_SDHC_FEVT_AC12EBE)

/*! @brief Set the AC12EBE field to a new value. */
#define BW_SDHC_FEVT_AC12EBE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12EBE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field AC12IE[4] (WORZ)
 *
 * Forces AC12ERR[AC12IE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12IE  (4U)          /*!< Bit position for SDHC_FEVT_AC12IE. */
#define BM_SDHC_FEVT_AC12IE  (0x00000010U) /*!< Bit mask for SDHC_FEVT_AC12IE. */
#define BS_SDHC_FEVT_AC12IE  (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12IE. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12IE. */
#define BF_SDHC_FEVT_AC12IE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12IE) & BM_SDHC_FEVT_AC12IE)

/*! @brief Set the AC12IE field to a new value. */
#define BW_SDHC_FEVT_AC12IE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12IE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CNIBAC12E[7] (WORZ)
 *
 * Forces AC12ERR[CNIBAC12E] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_CNIBAC12E (7U)        /*!< Bit position for SDHC_FEVT_CNIBAC12E. */
#define BM_SDHC_FEVT_CNIBAC12E (0x00000080U) /*!< Bit mask for SDHC_FEVT_CNIBAC12E. */
#define BS_SDHC_FEVT_CNIBAC12E (1U)        /*!< Bit field size in bits for SDHC_FEVT_CNIBAC12E. */

/*! @brief Format value for bitfield SDHC_FEVT_CNIBAC12E. */
#define BF_SDHC_FEVT_CNIBAC12E(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CNIBAC12E) & BM_SDHC_FEVT_CNIBAC12E)

/*! @brief Set the CNIBAC12E field to a new value. */
#define BW_SDHC_FEVT_CNIBAC12E(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CNIBAC12E) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CTOE[16] (WORZ)
 *
 * Forces IRQSTAT[CTOE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_CTOE    (16U)         /*!< Bit position for SDHC_FEVT_CTOE. */
#define BM_SDHC_FEVT_CTOE    (0x00010000U) /*!< Bit mask for SDHC_FEVT_CTOE. */
#define BS_SDHC_FEVT_CTOE    (1U)          /*!< Bit field size in bits for SDHC_FEVT_CTOE. */

/*! @brief Format value for bitfield SDHC_FEVT_CTOE. */
#define BF_SDHC_FEVT_CTOE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CTOE) & BM_SDHC_FEVT_CTOE)

/*! @brief Set the CTOE field to a new value. */
#define BW_SDHC_FEVT_CTOE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CTOE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CCE[17] (WORZ)
 *
 * Forces IRQSTAT[CCE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_CCE     (17U)         /*!< Bit position for SDHC_FEVT_CCE. */
#define BM_SDHC_FEVT_CCE     (0x00020000U) /*!< Bit mask for SDHC_FEVT_CCE. */
#define BS_SDHC_FEVT_CCE     (1U)          /*!< Bit field size in bits for SDHC_FEVT_CCE. */

/*! @brief Format value for bitfield SDHC_FEVT_CCE. */
#define BF_SDHC_FEVT_CCE(v)  ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CCE) & BM_SDHC_FEVT_CCE)

/*! @brief Set the CCE field to a new value. */
#define BW_SDHC_FEVT_CCE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CCE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CEBE[18] (WORZ)
 *
 * Forces IRQSTAT[CEBE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_CEBE    (18U)         /*!< Bit position for SDHC_FEVT_CEBE. */
#define BM_SDHC_FEVT_CEBE    (0x00040000U) /*!< Bit mask for SDHC_FEVT_CEBE. */
#define BS_SDHC_FEVT_CEBE    (1U)          /*!< Bit field size in bits for SDHC_FEVT_CEBE. */

/*! @brief Format value for bitfield SDHC_FEVT_CEBE. */
#define BF_SDHC_FEVT_CEBE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CEBE) & BM_SDHC_FEVT_CEBE)

/*! @brief Set the CEBE field to a new value. */
#define BW_SDHC_FEVT_CEBE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CEBE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CIE[19] (WORZ)
 *
 * Forces IRQSTAT[CCE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_CIE     (19U)         /*!< Bit position for SDHC_FEVT_CIE. */
#define BM_SDHC_FEVT_CIE     (0x00080000U) /*!< Bit mask for SDHC_FEVT_CIE. */
#define BS_SDHC_FEVT_CIE     (1U)          /*!< Bit field size in bits for SDHC_FEVT_CIE. */

/*! @brief Format value for bitfield SDHC_FEVT_CIE. */
#define BF_SDHC_FEVT_CIE(v)  ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CIE) & BM_SDHC_FEVT_CIE)

/*! @brief Set the CIE field to a new value. */
#define BW_SDHC_FEVT_CIE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CIE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field DTOE[20] (WORZ)
 *
 * Forces IRQSTAT[DTOE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_DTOE    (20U)         /*!< Bit position for SDHC_FEVT_DTOE. */
#define BM_SDHC_FEVT_DTOE    (0x00100000U) /*!< Bit mask for SDHC_FEVT_DTOE. */
#define BS_SDHC_FEVT_DTOE    (1U)          /*!< Bit field size in bits for SDHC_FEVT_DTOE. */

/*! @brief Format value for bitfield SDHC_FEVT_DTOE. */
#define BF_SDHC_FEVT_DTOE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_DTOE) & BM_SDHC_FEVT_DTOE)

/*! @brief Set the DTOE field to a new value. */
#define BW_SDHC_FEVT_DTOE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_DTOE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field DCE[21] (WORZ)
 *
 * Forces IRQSTAT[DCE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_DCE     (21U)         /*!< Bit position for SDHC_FEVT_DCE. */
#define BM_SDHC_FEVT_DCE     (0x00200000U) /*!< Bit mask for SDHC_FEVT_DCE. */
#define BS_SDHC_FEVT_DCE     (1U)          /*!< Bit field size in bits for SDHC_FEVT_DCE. */

/*! @brief Format value for bitfield SDHC_FEVT_DCE. */
#define BF_SDHC_FEVT_DCE(v)  ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_DCE) & BM_SDHC_FEVT_DCE)

/*! @brief Set the DCE field to a new value. */
#define BW_SDHC_FEVT_DCE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_DCE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field DEBE[22] (WORZ)
 *
 * Forces IRQSTAT[DEBE] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_DEBE    (22U)         /*!< Bit position for SDHC_FEVT_DEBE. */
#define BM_SDHC_FEVT_DEBE    (0x00400000U) /*!< Bit mask for SDHC_FEVT_DEBE. */
#define BS_SDHC_FEVT_DEBE    (1U)          /*!< Bit field size in bits for SDHC_FEVT_DEBE. */

/*! @brief Format value for bitfield SDHC_FEVT_DEBE. */
#define BF_SDHC_FEVT_DEBE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_DEBE) & BM_SDHC_FEVT_DEBE)

/*! @brief Set the DEBE field to a new value. */
#define BW_SDHC_FEVT_DEBE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_DEBE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field AC12E[24] (WORZ)
 *
 * Forces IRQSTAT[AC12E] to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_AC12E   (24U)         /*!< Bit position for SDHC_FEVT_AC12E. */
#define BM_SDHC_FEVT_AC12E   (0x01000000U) /*!< Bit mask for SDHC_FEVT_AC12E. */
#define BS_SDHC_FEVT_AC12E   (1U)          /*!< Bit field size in bits for SDHC_FEVT_AC12E. */

/*! @brief Format value for bitfield SDHC_FEVT_AC12E. */
#define BF_SDHC_FEVT_AC12E(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_AC12E) & BM_SDHC_FEVT_AC12E)

/*! @brief Set the AC12E field to a new value. */
#define BW_SDHC_FEVT_AC12E(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_AC12E) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field DMAE[28] (WORZ)
 *
 * Forces the DMAE bit of Interrupt Status Register to be set.
 */
/*@{*/
#define BP_SDHC_FEVT_DMAE    (28U)         /*!< Bit position for SDHC_FEVT_DMAE. */
#define BM_SDHC_FEVT_DMAE    (0x10000000U) /*!< Bit mask for SDHC_FEVT_DMAE. */
#define BS_SDHC_FEVT_DMAE    (1U)          /*!< Bit field size in bits for SDHC_FEVT_DMAE. */

/*! @brief Format value for bitfield SDHC_FEVT_DMAE. */
#define BF_SDHC_FEVT_DMAE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_DMAE) & BM_SDHC_FEVT_DMAE)

/*! @brief Set the DMAE field to a new value. */
#define BW_SDHC_FEVT_DMAE(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_DMAE) = (v))
/*@}*/

/*!
 * @name Register SDHC_FEVT, field CINT[31] (WORZ)
 *
 * Writing 1 to this bit generates a short low-level pulse on the internal
 * DAT[1] line, as if a self-clearing interrupt was received from the external card.
 * If enabled, the CINT bit will be set and the interrupt service routine may
 * treat this interrupt as a normal interrupt from the external card.
 */
/*@{*/
#define BP_SDHC_FEVT_CINT    (31U)         /*!< Bit position for SDHC_FEVT_CINT. */
#define BM_SDHC_FEVT_CINT    (0x80000000U) /*!< Bit mask for SDHC_FEVT_CINT. */
#define BS_SDHC_FEVT_CINT    (1U)          /*!< Bit field size in bits for SDHC_FEVT_CINT. */

/*! @brief Format value for bitfield SDHC_FEVT_CINT. */
#define BF_SDHC_FEVT_CINT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_FEVT_CINT) & BM_SDHC_FEVT_CINT)

/*! @brief Set the CINT field to a new value. */
#define BW_SDHC_FEVT_CINT(x, v) (BITBAND_ACCESS32(HW_SDHC_FEVT_ADDR(x), BP_SDHC_FEVT_CINT) = (v))
/*@}*/

/*******************************************************************************
 * HW_SDHC_ADMAES - ADMA Error Status register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_ADMAES - ADMA Error Status register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When an ADMA error interrupt has occurred, the ADMA Error States field in
 * this register holds the ADMA state and the ADMA System Address register holds the
 * address around the error descriptor. For recovering from this error, the host
 * driver requires the ADMA state to identify the error descriptor address as
 * follows: ST_STOP: Previous location set in the ADMA System Address register is
 * the error descriptor address. ST_FDS: Current location set in the ADMA System
 * Address register is the error descriptor address. ST_CADR: This state is never
 * set because it only increments the descriptor pointer and doesn't generate an
 * ADMA error. ST_TFR: Previous location set in the ADMA System Address register
 * is the error descriptor address. In case of a write operation, the host driver
 * must use the ACMD22 to get the number of the written block, rather than using
 * this information, because unwritten data may exist in the host controller.
 * The host controller generates the ADMA error interrupt when it detects invalid
 * descriptor data (valid = 0) in the ST_FDS state. The host driver can
 * distinguish this error by reading the valid bit of the error descriptor. ADMA Error
 * State coding D01-D00 ADMA Error State when error has occurred Contents of ADMA
 * System Address register 00 ST_STOP (Stop DMA) Holds the address of the next
 * executable descriptor command 01 ST_FDS (fetch descriptor) Holds the valid
 * descriptor address 10 ST_CADR (change address) No ADMA error is generated 11 ST_TFR
 * (Transfer Data) Holds the address of the next executable descriptor command
 */
typedef union _hw_sdhc_admaes
{
    uint32_t U;
    struct _hw_sdhc_admaes_bitfields
    {
        uint32_t ADMAES : 2;           /*!< [1:0] ADMA Error State (When ADMA Error Is
                                        * Occurred.) */
        uint32_t ADMALME : 1;          /*!< [2] ADMA Length Mismatch Error */
        uint32_t ADMADCE : 1;          /*!< [3] ADMA Descriptor Error */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_sdhc_admaes_t;

/*!
 * @name Constants and macros for entire SDHC_ADMAES register
 */
/*@{*/
#define HW_SDHC_ADMAES_ADDR(x)   ((uint32_t)(x) + 0x54U)

#define HW_SDHC_ADMAES(x)        (*(__I hw_sdhc_admaes_t *) HW_SDHC_ADMAES_ADDR(x))
#define HW_SDHC_ADMAES_RD(x)     (HW_SDHC_ADMAES(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_ADMAES bitfields
 */

/*!
 * @name Register SDHC_ADMAES, field ADMAES[1:0] (RO)
 *
 * Indicates the state of the ADMA when an error has occurred during an ADMA
 * data transfer.
 */
/*@{*/
#define BP_SDHC_ADMAES_ADMAES (0U)         /*!< Bit position for SDHC_ADMAES_ADMAES. */
#define BM_SDHC_ADMAES_ADMAES (0x00000003U) /*!< Bit mask for SDHC_ADMAES_ADMAES. */
#define BS_SDHC_ADMAES_ADMAES (2U)         /*!< Bit field size in bits for SDHC_ADMAES_ADMAES. */

/*! @brief Read current value of the SDHC_ADMAES_ADMAES field. */
#define BR_SDHC_ADMAES_ADMAES(x) (HW_SDHC_ADMAES(x).B.ADMAES)
/*@}*/

/*!
 * @name Register SDHC_ADMAES, field ADMALME[2] (RO)
 *
 * This error occurs in the following 2 cases: While the block count enable is
 * being set, the total data length specified by the descriptor table is different
 * from that specified by the block count and block length. Total data length
 * can not be divided by the block length.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_ADMAES_ADMALME (2U)        /*!< Bit position for SDHC_ADMAES_ADMALME. */
#define BM_SDHC_ADMAES_ADMALME (0x00000004U) /*!< Bit mask for SDHC_ADMAES_ADMALME. */
#define BS_SDHC_ADMAES_ADMALME (1U)        /*!< Bit field size in bits for SDHC_ADMAES_ADMALME. */

/*! @brief Read current value of the SDHC_ADMAES_ADMALME field. */
#define BR_SDHC_ADMAES_ADMALME(x) (BITBAND_ACCESS32(HW_SDHC_ADMAES_ADDR(x), BP_SDHC_ADMAES_ADMALME))
/*@}*/

/*!
 * @name Register SDHC_ADMAES, field ADMADCE[3] (RO)
 *
 * This error occurs when an invalid descriptor is fetched by ADMA.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Error.
 */
/*@{*/
#define BP_SDHC_ADMAES_ADMADCE (3U)        /*!< Bit position for SDHC_ADMAES_ADMADCE. */
#define BM_SDHC_ADMAES_ADMADCE (0x00000008U) /*!< Bit mask for SDHC_ADMAES_ADMADCE. */
#define BS_SDHC_ADMAES_ADMADCE (1U)        /*!< Bit field size in bits for SDHC_ADMAES_ADMADCE. */

/*! @brief Read current value of the SDHC_ADMAES_ADMADCE field. */
#define BR_SDHC_ADMAES_ADMADCE(x) (BITBAND_ACCESS32(HW_SDHC_ADMAES_ADDR(x), BP_SDHC_ADMAES_ADMADCE))
/*@}*/

/*******************************************************************************
 * HW_SDHC_ADSADDR - ADMA System Addressregister
 ******************************************************************************/

/*!
 * @brief HW_SDHC_ADSADDR - ADMA System Addressregister (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the physical system memory address used for ADMA
 * transfers.
 */
typedef union _hw_sdhc_adsaddr
{
    uint32_t U;
    struct _hw_sdhc_adsaddr_bitfields
    {
        uint32_t RESERVED0 : 2;        /*!< [1:0]  */
        uint32_t ADSADDR : 30;         /*!< [31:2] ADMA System Address */
    } B;
} hw_sdhc_adsaddr_t;

/*!
 * @name Constants and macros for entire SDHC_ADSADDR register
 */
/*@{*/
#define HW_SDHC_ADSADDR_ADDR(x)  ((uint32_t)(x) + 0x58U)

#define HW_SDHC_ADSADDR(x)       (*(__IO hw_sdhc_adsaddr_t *) HW_SDHC_ADSADDR_ADDR(x))
#define HW_SDHC_ADSADDR_RD(x)    (HW_SDHC_ADSADDR(x).U)
#define HW_SDHC_ADSADDR_WR(x, v) (HW_SDHC_ADSADDR(x).U = (v))
#define HW_SDHC_ADSADDR_SET(x, v) (HW_SDHC_ADSADDR_WR(x, HW_SDHC_ADSADDR_RD(x) |  (v)))
#define HW_SDHC_ADSADDR_CLR(x, v) (HW_SDHC_ADSADDR_WR(x, HW_SDHC_ADSADDR_RD(x) & ~(v)))
#define HW_SDHC_ADSADDR_TOG(x, v) (HW_SDHC_ADSADDR_WR(x, HW_SDHC_ADSADDR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_ADSADDR bitfields
 */

/*!
 * @name Register SDHC_ADSADDR, field ADSADDR[31:2] (RW)
 *
 * Holds the word address of the executing command in the descriptor table. At
 * the start of ADMA, the host driver shall set the start address of the
 * Descriptor table. The ADMA engine increments this register address whenever fetching a
 * descriptor command. When the ADMA is stopped at the block gap, this register
 * indicates the address of the next executable descriptor command. When the ADMA
 * error interrupt is generated, this register shall hold the valid descriptor
 * address depending on the ADMA state. The lower 2 bits of this register is tied
 * to '0' so the ADMA address is always word-aligned. Because this register
 * supports dynamic address reflecting, when TC bit is set, it automatically alters the
 * value of internal address counter, so SW cannot change this register when TC
 * bit is set.
 */
/*@{*/
#define BP_SDHC_ADSADDR_ADSADDR (2U)       /*!< Bit position for SDHC_ADSADDR_ADSADDR. */
#define BM_SDHC_ADSADDR_ADSADDR (0xFFFFFFFCU) /*!< Bit mask for SDHC_ADSADDR_ADSADDR. */
#define BS_SDHC_ADSADDR_ADSADDR (30U)      /*!< Bit field size in bits for SDHC_ADSADDR_ADSADDR. */

/*! @brief Read current value of the SDHC_ADSADDR_ADSADDR field. */
#define BR_SDHC_ADSADDR_ADSADDR(x) (HW_SDHC_ADSADDR(x).B.ADSADDR)

/*! @brief Format value for bitfield SDHC_ADSADDR_ADSADDR. */
#define BF_SDHC_ADSADDR_ADSADDR(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_ADSADDR_ADSADDR) & BM_SDHC_ADSADDR_ADSADDR)

/*! @brief Set the ADSADDR field to a new value. */
#define BW_SDHC_ADSADDR_ADSADDR(x, v) (HW_SDHC_ADSADDR_WR(x, (HW_SDHC_ADSADDR_RD(x) & ~BM_SDHC_ADSADDR_ADSADDR) | BF_SDHC_ADSADDR_ADSADDR(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_VENDOR - Vendor Specific register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_VENDOR - Vendor Specific register (RW)
 *
 * Reset value: 0x00000001U
 *
 * This register contains the vendor-specific control/status register.
 */
typedef union _hw_sdhc_vendor
{
    uint32_t U;
    struct _hw_sdhc_vendor_bitfields
    {
        uint32_t EXTDMAEN : 1;         /*!< [0] External DMA Request Enable */
        uint32_t EXBLKNU : 1;          /*!< [1] Exact Block Number Block Read Enable
                                        * For SDIO CMD53 */
        uint32_t RESERVED0 : 14;       /*!< [15:2]  */
        uint32_t INTSTVAL : 8;         /*!< [23:16] Internal State Value */
        uint32_t RESERVED1 : 8;        /*!< [31:24]  */
    } B;
} hw_sdhc_vendor_t;

/*!
 * @name Constants and macros for entire SDHC_VENDOR register
 */
/*@{*/
#define HW_SDHC_VENDOR_ADDR(x)   ((uint32_t)(x) + 0xC0U)

#define HW_SDHC_VENDOR(x)        (*(__IO hw_sdhc_vendor_t *) HW_SDHC_VENDOR_ADDR(x))
#define HW_SDHC_VENDOR_RD(x)     (HW_SDHC_VENDOR(x).U)
#define HW_SDHC_VENDOR_WR(x, v)  (HW_SDHC_VENDOR(x).U = (v))
#define HW_SDHC_VENDOR_SET(x, v) (HW_SDHC_VENDOR_WR(x, HW_SDHC_VENDOR_RD(x) |  (v)))
#define HW_SDHC_VENDOR_CLR(x, v) (HW_SDHC_VENDOR_WR(x, HW_SDHC_VENDOR_RD(x) & ~(v)))
#define HW_SDHC_VENDOR_TOG(x, v) (HW_SDHC_VENDOR_WR(x, HW_SDHC_VENDOR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_VENDOR bitfields
 */

/*!
 * @name Register SDHC_VENDOR, field EXTDMAEN[0] (RW)
 *
 * Enables the request to external DMA. When the internal DMA (either simple DMA
 * or advanced DMA) is not in use, and this bit is set, SDHC will send out DMA
 * request when the internal buffer is ready. This bit is particularly useful when
 * transferring data by CPU polling mode, and it is not allowed to send out the
 * external DMA request. By default, this bit is set.
 *
 * Values:
 * - 0 - In any scenario, SDHC does not send out the external DMA request.
 * - 1 - When internal DMA is not active, the external DMA request will be sent
 *     out.
 */
/*@{*/
#define BP_SDHC_VENDOR_EXTDMAEN (0U)       /*!< Bit position for SDHC_VENDOR_EXTDMAEN. */
#define BM_SDHC_VENDOR_EXTDMAEN (0x00000001U) /*!< Bit mask for SDHC_VENDOR_EXTDMAEN. */
#define BS_SDHC_VENDOR_EXTDMAEN (1U)       /*!< Bit field size in bits for SDHC_VENDOR_EXTDMAEN. */

/*! @brief Read current value of the SDHC_VENDOR_EXTDMAEN field. */
#define BR_SDHC_VENDOR_EXTDMAEN(x) (BITBAND_ACCESS32(HW_SDHC_VENDOR_ADDR(x), BP_SDHC_VENDOR_EXTDMAEN))

/*! @brief Format value for bitfield SDHC_VENDOR_EXTDMAEN. */
#define BF_SDHC_VENDOR_EXTDMAEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_VENDOR_EXTDMAEN) & BM_SDHC_VENDOR_EXTDMAEN)

/*! @brief Set the EXTDMAEN field to a new value. */
#define BW_SDHC_VENDOR_EXTDMAEN(x, v) (BITBAND_ACCESS32(HW_SDHC_VENDOR_ADDR(x), BP_SDHC_VENDOR_EXTDMAEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_VENDOR, field EXBLKNU[1] (RW)
 *
 * This bit must be set before S/W issues CMD53 multi-block read with exact
 * block number. This bit must not be set if the CMD53 multi-block read is not exact
 * block number.
 *
 * Values:
 * - 0 - None exact block read.
 * - 1 - Exact block read for SDIO CMD53.
 */
/*@{*/
#define BP_SDHC_VENDOR_EXBLKNU (1U)        /*!< Bit position for SDHC_VENDOR_EXBLKNU. */
#define BM_SDHC_VENDOR_EXBLKNU (0x00000002U) /*!< Bit mask for SDHC_VENDOR_EXBLKNU. */
#define BS_SDHC_VENDOR_EXBLKNU (1U)        /*!< Bit field size in bits for SDHC_VENDOR_EXBLKNU. */

/*! @brief Read current value of the SDHC_VENDOR_EXBLKNU field. */
#define BR_SDHC_VENDOR_EXBLKNU(x) (BITBAND_ACCESS32(HW_SDHC_VENDOR_ADDR(x), BP_SDHC_VENDOR_EXBLKNU))

/*! @brief Format value for bitfield SDHC_VENDOR_EXBLKNU. */
#define BF_SDHC_VENDOR_EXBLKNU(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_VENDOR_EXBLKNU) & BM_SDHC_VENDOR_EXBLKNU)

/*! @brief Set the EXBLKNU field to a new value. */
#define BW_SDHC_VENDOR_EXBLKNU(x, v) (BITBAND_ACCESS32(HW_SDHC_VENDOR_ADDR(x), BP_SDHC_VENDOR_EXBLKNU) = (v))
/*@}*/

/*!
 * @name Register SDHC_VENDOR, field INTSTVAL[23:16] (RO)
 *
 * Internal state value, reflecting the corresponding state value selected by
 * Debug Select field. This field is read-only and write to this field does not
 * have effect.
 */
/*@{*/
#define BP_SDHC_VENDOR_INTSTVAL (16U)      /*!< Bit position for SDHC_VENDOR_INTSTVAL. */
#define BM_SDHC_VENDOR_INTSTVAL (0x00FF0000U) /*!< Bit mask for SDHC_VENDOR_INTSTVAL. */
#define BS_SDHC_VENDOR_INTSTVAL (8U)       /*!< Bit field size in bits for SDHC_VENDOR_INTSTVAL. */

/*! @brief Read current value of the SDHC_VENDOR_INTSTVAL field. */
#define BR_SDHC_VENDOR_INTSTVAL(x) (HW_SDHC_VENDOR(x).B.INTSTVAL)
/*@}*/

/*******************************************************************************
 * HW_SDHC_MMCBOOT - MMC Boot register
 ******************************************************************************/

/*!
 * @brief HW_SDHC_MMCBOOT - MMC Boot register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the MMC fast boot control register.
 */
typedef union _hw_sdhc_mmcboot
{
    uint32_t U;
    struct _hw_sdhc_mmcboot_bitfields
    {
        uint32_t DTOCVACK : 4;         /*!< [3:0] Boot ACK Time Out Counter Value */
        uint32_t BOOTACK : 1;          /*!< [4] Boot Ack Mode Select */
        uint32_t BOOTMODE : 1;         /*!< [5] Boot Mode Select */
        uint32_t BOOTEN : 1;           /*!< [6] Boot Mode Enable */
        uint32_t AUTOSABGEN : 1;       /*!< [7]  */
        uint32_t RESERVED0 : 8;        /*!< [15:8]  */
        uint32_t BOOTBLKCNT : 16;      /*!< [31:16]  */
    } B;
} hw_sdhc_mmcboot_t;

/*!
 * @name Constants and macros for entire SDHC_MMCBOOT register
 */
/*@{*/
#define HW_SDHC_MMCBOOT_ADDR(x)  ((uint32_t)(x) + 0xC4U)

#define HW_SDHC_MMCBOOT(x)       (*(__IO hw_sdhc_mmcboot_t *) HW_SDHC_MMCBOOT_ADDR(x))
#define HW_SDHC_MMCBOOT_RD(x)    (HW_SDHC_MMCBOOT(x).U)
#define HW_SDHC_MMCBOOT_WR(x, v) (HW_SDHC_MMCBOOT(x).U = (v))
#define HW_SDHC_MMCBOOT_SET(x, v) (HW_SDHC_MMCBOOT_WR(x, HW_SDHC_MMCBOOT_RD(x) |  (v)))
#define HW_SDHC_MMCBOOT_CLR(x, v) (HW_SDHC_MMCBOOT_WR(x, HW_SDHC_MMCBOOT_RD(x) & ~(v)))
#define HW_SDHC_MMCBOOT_TOG(x, v) (HW_SDHC_MMCBOOT_WR(x, HW_SDHC_MMCBOOT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SDHC_MMCBOOT bitfields
 */

/*!
 * @name Register SDHC_MMCBOOT, field DTOCVACK[3:0] (RW)
 *
 * Values:
 * - 0000 - SDCLK x 2^8
 * - 0001 - SDCLK x 2^9
 * - 0010 - SDCLK x 2^10
 * - 0011 - SDCLK x 2^11
 * - 0100 - SDCLK x 2^12
 * - 0101 - SDCLK x 2^13
 * - 0110 - SDCLK x 2^14
 * - 0111 - SDCLK x 2^15
 * - 1110 - SDCLK x 2^22
 * - 1111 - Reserved
 */
/*@{*/
#define BP_SDHC_MMCBOOT_DTOCVACK (0U)      /*!< Bit position for SDHC_MMCBOOT_DTOCVACK. */
#define BM_SDHC_MMCBOOT_DTOCVACK (0x0000000FU) /*!< Bit mask for SDHC_MMCBOOT_DTOCVACK. */
#define BS_SDHC_MMCBOOT_DTOCVACK (4U)      /*!< Bit field size in bits for SDHC_MMCBOOT_DTOCVACK. */

/*! @brief Read current value of the SDHC_MMCBOOT_DTOCVACK field. */
#define BR_SDHC_MMCBOOT_DTOCVACK(x) (HW_SDHC_MMCBOOT(x).B.DTOCVACK)

/*! @brief Format value for bitfield SDHC_MMCBOOT_DTOCVACK. */
#define BF_SDHC_MMCBOOT_DTOCVACK(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_DTOCVACK) & BM_SDHC_MMCBOOT_DTOCVACK)

/*! @brief Set the DTOCVACK field to a new value. */
#define BW_SDHC_MMCBOOT_DTOCVACK(x, v) (HW_SDHC_MMCBOOT_WR(x, (HW_SDHC_MMCBOOT_RD(x) & ~BM_SDHC_MMCBOOT_DTOCVACK) | BF_SDHC_MMCBOOT_DTOCVACK(v)))
/*@}*/

/*!
 * @name Register SDHC_MMCBOOT, field BOOTACK[4] (RW)
 *
 * Values:
 * - 0 - No ack.
 * - 1 - Ack.
 */
/*@{*/
#define BP_SDHC_MMCBOOT_BOOTACK (4U)       /*!< Bit position for SDHC_MMCBOOT_BOOTACK. */
#define BM_SDHC_MMCBOOT_BOOTACK (0x00000010U) /*!< Bit mask for SDHC_MMCBOOT_BOOTACK. */
#define BS_SDHC_MMCBOOT_BOOTACK (1U)       /*!< Bit field size in bits for SDHC_MMCBOOT_BOOTACK. */

/*! @brief Read current value of the SDHC_MMCBOOT_BOOTACK field. */
#define BR_SDHC_MMCBOOT_BOOTACK(x) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTACK))

/*! @brief Format value for bitfield SDHC_MMCBOOT_BOOTACK. */
#define BF_SDHC_MMCBOOT_BOOTACK(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_BOOTACK) & BM_SDHC_MMCBOOT_BOOTACK)

/*! @brief Set the BOOTACK field to a new value. */
#define BW_SDHC_MMCBOOT_BOOTACK(x, v) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTACK) = (v))
/*@}*/

/*!
 * @name Register SDHC_MMCBOOT, field BOOTMODE[5] (RW)
 *
 * Values:
 * - 0 - Normal boot.
 * - 1 - Alternative boot.
 */
/*@{*/
#define BP_SDHC_MMCBOOT_BOOTMODE (5U)      /*!< Bit position for SDHC_MMCBOOT_BOOTMODE. */
#define BM_SDHC_MMCBOOT_BOOTMODE (0x00000020U) /*!< Bit mask for SDHC_MMCBOOT_BOOTMODE. */
#define BS_SDHC_MMCBOOT_BOOTMODE (1U)      /*!< Bit field size in bits for SDHC_MMCBOOT_BOOTMODE. */

/*! @brief Read current value of the SDHC_MMCBOOT_BOOTMODE field. */
#define BR_SDHC_MMCBOOT_BOOTMODE(x) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTMODE))

/*! @brief Format value for bitfield SDHC_MMCBOOT_BOOTMODE. */
#define BF_SDHC_MMCBOOT_BOOTMODE(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_BOOTMODE) & BM_SDHC_MMCBOOT_BOOTMODE)

/*! @brief Set the BOOTMODE field to a new value. */
#define BW_SDHC_MMCBOOT_BOOTMODE(x, v) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTMODE) = (v))
/*@}*/

/*!
 * @name Register SDHC_MMCBOOT, field BOOTEN[6] (RW)
 *
 * Values:
 * - 0 - Fast boot disable.
 * - 1 - Fast boot enable.
 */
/*@{*/
#define BP_SDHC_MMCBOOT_BOOTEN (6U)        /*!< Bit position for SDHC_MMCBOOT_BOOTEN. */
#define BM_SDHC_MMCBOOT_BOOTEN (0x00000040U) /*!< Bit mask for SDHC_MMCBOOT_BOOTEN. */
#define BS_SDHC_MMCBOOT_BOOTEN (1U)        /*!< Bit field size in bits for SDHC_MMCBOOT_BOOTEN. */

/*! @brief Read current value of the SDHC_MMCBOOT_BOOTEN field. */
#define BR_SDHC_MMCBOOT_BOOTEN(x) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTEN))

/*! @brief Format value for bitfield SDHC_MMCBOOT_BOOTEN. */
#define BF_SDHC_MMCBOOT_BOOTEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_BOOTEN) & BM_SDHC_MMCBOOT_BOOTEN)

/*! @brief Set the BOOTEN field to a new value. */
#define BW_SDHC_MMCBOOT_BOOTEN(x, v) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_BOOTEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_MMCBOOT, field AUTOSABGEN[7] (RW)
 *
 * When boot, enable auto stop at block gap function. This function will be
 * triggered, and host will stop at block gap when received card block cnt is equal
 * to BOOTBLKCNT.
 */
/*@{*/
#define BP_SDHC_MMCBOOT_AUTOSABGEN (7U)    /*!< Bit position for SDHC_MMCBOOT_AUTOSABGEN. */
#define BM_SDHC_MMCBOOT_AUTOSABGEN (0x00000080U) /*!< Bit mask for SDHC_MMCBOOT_AUTOSABGEN. */
#define BS_SDHC_MMCBOOT_AUTOSABGEN (1U)    /*!< Bit field size in bits for SDHC_MMCBOOT_AUTOSABGEN. */

/*! @brief Read current value of the SDHC_MMCBOOT_AUTOSABGEN field. */
#define BR_SDHC_MMCBOOT_AUTOSABGEN(x) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_AUTOSABGEN))

/*! @brief Format value for bitfield SDHC_MMCBOOT_AUTOSABGEN. */
#define BF_SDHC_MMCBOOT_AUTOSABGEN(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_AUTOSABGEN) & BM_SDHC_MMCBOOT_AUTOSABGEN)

/*! @brief Set the AUTOSABGEN field to a new value. */
#define BW_SDHC_MMCBOOT_AUTOSABGEN(x, v) (BITBAND_ACCESS32(HW_SDHC_MMCBOOT_ADDR(x), BP_SDHC_MMCBOOT_AUTOSABGEN) = (v))
/*@}*/

/*!
 * @name Register SDHC_MMCBOOT, field BOOTBLKCNT[31:16] (RW)
 *
 * Defines the stop at block gap value of automatic mode. When received card
 * block cnt is equal to BOOTBLKCNT and AUTOSABGEN is 1, then stop at block gap.
 */
/*@{*/
#define BP_SDHC_MMCBOOT_BOOTBLKCNT (16U)   /*!< Bit position for SDHC_MMCBOOT_BOOTBLKCNT. */
#define BM_SDHC_MMCBOOT_BOOTBLKCNT (0xFFFF0000U) /*!< Bit mask for SDHC_MMCBOOT_BOOTBLKCNT. */
#define BS_SDHC_MMCBOOT_BOOTBLKCNT (16U)   /*!< Bit field size in bits for SDHC_MMCBOOT_BOOTBLKCNT. */

/*! @brief Read current value of the SDHC_MMCBOOT_BOOTBLKCNT field. */
#define BR_SDHC_MMCBOOT_BOOTBLKCNT(x) (HW_SDHC_MMCBOOT(x).B.BOOTBLKCNT)

/*! @brief Format value for bitfield SDHC_MMCBOOT_BOOTBLKCNT. */
#define BF_SDHC_MMCBOOT_BOOTBLKCNT(v) ((uint32_t)((uint32_t)(v) << BP_SDHC_MMCBOOT_BOOTBLKCNT) & BM_SDHC_MMCBOOT_BOOTBLKCNT)

/*! @brief Set the BOOTBLKCNT field to a new value. */
#define BW_SDHC_MMCBOOT_BOOTBLKCNT(x, v) (HW_SDHC_MMCBOOT_WR(x, (HW_SDHC_MMCBOOT_RD(x) & ~BM_SDHC_MMCBOOT_BOOTBLKCNT) | BF_SDHC_MMCBOOT_BOOTBLKCNT(v)))
/*@}*/

/*******************************************************************************
 * HW_SDHC_HOSTVER - Host Controller Version
 ******************************************************************************/

/*!
 * @brief HW_SDHC_HOSTVER - Host Controller Version (RO)
 *
 * Reset value: 0x00001201U
 *
 * This register contains the vendor host controller version information. All
 * bits are read only and will read the same as the power-reset value.
 */
typedef union _hw_sdhc_hostver
{
    uint32_t U;
    struct _hw_sdhc_hostver_bitfields
    {
        uint32_t SVN : 8;              /*!< [7:0] Specification Version Number */
        uint32_t VVN : 8;              /*!< [15:8] Vendor Version Number */
        uint32_t RESERVED0 : 16;       /*!< [31:16]  */
    } B;
} hw_sdhc_hostver_t;

/*!
 * @name Constants and macros for entire SDHC_HOSTVER register
 */
/*@{*/
#define HW_SDHC_HOSTVER_ADDR(x)  ((uint32_t)(x) + 0xFCU)

#define HW_SDHC_HOSTVER(x)       (*(__I hw_sdhc_hostver_t *) HW_SDHC_HOSTVER_ADDR(x))
#define HW_SDHC_HOSTVER_RD(x)    (HW_SDHC_HOSTVER(x).U)
/*@}*/

/*
 * Constants & macros for individual SDHC_HOSTVER bitfields
 */

/*!
 * @name Register SDHC_HOSTVER, field SVN[7:0] (RO)
 *
 * These status bits indicate the host controller specification version.
 *
 * Values:
 * - 1 - SD host specification version 2.0, supports test event register and
 *     ADMA.
 */
/*@{*/
#define BP_SDHC_HOSTVER_SVN  (0U)          /*!< Bit position for SDHC_HOSTVER_SVN. */
#define BM_SDHC_HOSTVER_SVN  (0x000000FFU) /*!< Bit mask for SDHC_HOSTVER_SVN. */
#define BS_SDHC_HOSTVER_SVN  (8U)          /*!< Bit field size in bits for SDHC_HOSTVER_SVN. */

/*! @brief Read current value of the SDHC_HOSTVER_SVN field. */
#define BR_SDHC_HOSTVER_SVN(x) (HW_SDHC_HOSTVER(x).B.SVN)
/*@}*/

/*!
 * @name Register SDHC_HOSTVER, field VVN[15:8] (RO)
 *
 * These status bits are reserved for the vendor version number. The host driver
 * shall not use this status.
 *
 * Values:
 * - 0 - Freescale SDHC version 1.0
 * - 10000 - Freescale SDHC version 2.0
 * - 10001 - Freescale SDHC version 2.1
 * - 10010 - Freescale SDHC version 2.2
 */
/*@{*/
#define BP_SDHC_HOSTVER_VVN  (8U)          /*!< Bit position for SDHC_HOSTVER_VVN. */
#define BM_SDHC_HOSTVER_VVN  (0x0000FF00U) /*!< Bit mask for SDHC_HOSTVER_VVN. */
#define BS_SDHC_HOSTVER_VVN  (8U)          /*!< Bit field size in bits for SDHC_HOSTVER_VVN. */

/*! @brief Read current value of the SDHC_HOSTVER_VVN field. */
#define BR_SDHC_HOSTVER_VVN(x) (HW_SDHC_HOSTVER(x).B.VVN)
/*@}*/

/*******************************************************************************
 * hw_sdhc_t - module struct
 ******************************************************************************/
/*!
 * @brief All SDHC module registers.
 */
#pragma pack(1)
typedef struct _hw_sdhc
{
    __IO hw_sdhc_dsaddr_t DSADDR;          /*!< [0x0] DMA System Address register */
    __IO hw_sdhc_blkattr_t BLKATTR;        /*!< [0x4] Block Attributes register */
    __IO hw_sdhc_cmdarg_t CMDARG;          /*!< [0x8] Command Argument register */
    __IO hw_sdhc_xfertyp_t XFERTYP;        /*!< [0xC] Transfer Type register */
    __I hw_sdhc_cmdrsp0_t CMDRSP0;         /*!< [0x10] Command Response 0 */
    __I hw_sdhc_cmdrsp1_t CMDRSP1;         /*!< [0x14] Command Response 1 */
    __I hw_sdhc_cmdrsp2_t CMDRSP2;         /*!< [0x18] Command Response 2 */
    __I hw_sdhc_cmdrsp3_t CMDRSP3;         /*!< [0x1C] Command Response 3 */
    __IO hw_sdhc_datport_t DATPORT;        /*!< [0x20] Buffer Data Port register */
    __I hw_sdhc_prsstat_t PRSSTAT;         /*!< [0x24] Present State register */
    __IO hw_sdhc_proctl_t PROCTL;          /*!< [0x28] Protocol Control register */
    __IO hw_sdhc_sysctl_t SYSCTL;          /*!< [0x2C] System Control register */
    __IO hw_sdhc_irqstat_t IRQSTAT;        /*!< [0x30] Interrupt Status register */
    __IO hw_sdhc_irqstaten_t IRQSTATEN;    /*!< [0x34] Interrupt Status Enable register */
    __IO hw_sdhc_irqsigen_t IRQSIGEN;      /*!< [0x38] Interrupt Signal Enable register */
    __I hw_sdhc_ac12err_t AC12ERR;         /*!< [0x3C] Auto CMD12 Error Status Register */
    __I hw_sdhc_htcapblt_t HTCAPBLT;       /*!< [0x40] Host Controller Capabilities */
    __IO hw_sdhc_wml_t WML;                /*!< [0x44] Watermark Level Register */
    uint8_t _reserved0[8];
    __O hw_sdhc_fevt_t FEVT;               /*!< [0x50] Force Event register */
    __I hw_sdhc_admaes_t ADMAES;           /*!< [0x54] ADMA Error Status register */
    __IO hw_sdhc_adsaddr_t ADSADDR;        /*!< [0x58] ADMA System Addressregister */
    uint8_t _reserved1[100];
    __IO hw_sdhc_vendor_t VENDOR;          /*!< [0xC0] Vendor Specific register */
    __IO hw_sdhc_mmcboot_t MMCBOOT;        /*!< [0xC4] MMC Boot register */
    uint8_t _reserved2[52];
    __I hw_sdhc_hostver_t HOSTVER;         /*!< [0xFC] Host Controller Version */
} hw_sdhc_t;
#pragma pack()

/*! @brief Macro to access all SDHC registers. */
/*! @param x SDHC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_SDHC_REGS(SDHC_BASE)</code>. */
#define HW_SDHC_REGS(x) (*(hw_sdhc_t *)(x))

/*
 * MK64F12 SIM
 *
 * System Integration Module
 *
 * Registers defined in this header file:
 * - HW_SIM_SOPT1 - System Options Register 1
 * - HW_SIM_SOPT1CFG - SOPT1 Configuration Register
 * - HW_SIM_SOPT2 - System Options Register 2
 * - HW_SIM_SOPT4 - System Options Register 4
 * - HW_SIM_SOPT5 - System Options Register 5
 * - HW_SIM_SOPT7 - System Options Register 7
 * - HW_SIM_SDID - System Device Identification Register
 * - HW_SIM_SCGC1 - System Clock Gating Control Register 1
 * - HW_SIM_SCGC2 - System Clock Gating Control Register 2
 * - HW_SIM_SCGC3 - System Clock Gating Control Register 3
 * - HW_SIM_SCGC4 - System Clock Gating Control Register 4
 * - HW_SIM_SCGC5 - System Clock Gating Control Register 5
 * - HW_SIM_SCGC6 - System Clock Gating Control Register 6
 * - HW_SIM_SCGC7 - System Clock Gating Control Register 7
 * - HW_SIM_CLKDIV1 - System Clock Divider Register 1
 * - HW_SIM_CLKDIV2 - System Clock Divider Register 2
 * - HW_SIM_FCFG1 - Flash Configuration Register 1
 * - HW_SIM_FCFG2 - Flash Configuration Register 2
 * - HW_SIM_UIDH - Unique Identification Register High
 * - HW_SIM_UIDMH - Unique Identification Register Mid-High
 * - HW_SIM_UIDML - Unique Identification Register Mid Low
 * - HW_SIM_UIDL - Unique Identification Register Low
 *
 * - hw_sim_t - Struct containing all module registers.
 */

#define HW_SIM_INSTANCE_COUNT (1U) /*!< Number of instances of the SIM module. */
#define HW_SIM (0U) /*!< Instance number for SIM. */

/*******************************************************************************
 * HW_SIM_SOPT1 - System Options Register 1
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT1 - System Options Register 1 (RW)
 *
 * Reset value: 0x80000000U
 *
 * The SOPT1 register is only reset on POR or LVD.
 */
typedef union _hw_sim_sopt1
{
    uint32_t U;
    struct _hw_sim_sopt1_bitfields
    {
        uint32_t RESERVED0 : 12;       /*!< [11:0]  */
        uint32_t RAMSIZE : 4;          /*!< [15:12] RAM size */
        uint32_t RESERVED1 : 2;        /*!< [17:16]  */
        uint32_t OSC32KSEL : 2;        /*!< [19:18] 32K oscillator clock select */
        uint32_t RESERVED2 : 9;        /*!< [28:20]  */
        uint32_t USBVSTBY : 1;         /*!< [29] USB voltage regulator in standby
                                        * mode during VLPR and VLPW modes */
        uint32_t USBSSTBY : 1;         /*!< [30] USB voltage regulator in standby
                                        * mode during Stop, VLPS, LLS and VLLS modes. */
        uint32_t USBREGEN : 1;         /*!< [31] USB voltage regulator enable */
    } B;
} hw_sim_sopt1_t;

/*!
 * @name Constants and macros for entire SIM_SOPT1 register
 */
/*@{*/
#define HW_SIM_SOPT1_ADDR(x)     ((uint32_t)(x) + 0x0U)

#define HW_SIM_SOPT1(x)          (*(__IO hw_sim_sopt1_t *) HW_SIM_SOPT1_ADDR(x))
#define HW_SIM_SOPT1_RD(x)       (HW_SIM_SOPT1(x).U)
#define HW_SIM_SOPT1_WR(x, v)    (HW_SIM_SOPT1(x).U = (v))
#define HW_SIM_SOPT1_SET(x, v)   (HW_SIM_SOPT1_WR(x, HW_SIM_SOPT1_RD(x) |  (v)))
#define HW_SIM_SOPT1_CLR(x, v)   (HW_SIM_SOPT1_WR(x, HW_SIM_SOPT1_RD(x) & ~(v)))
#define HW_SIM_SOPT1_TOG(x, v)   (HW_SIM_SOPT1_WR(x, HW_SIM_SOPT1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1 bitfields
 */

/*!
 * @name Register SIM_SOPT1, field RAMSIZE[15:12] (RO)
 *
 * This field specifies the amount of system RAM available on the device.
 *
 * Values:
 * - 0001 - 8 KB
 * - 0011 - 16 KB
 * - 0100 - 24 KB
 * - 0101 - 32 KB
 * - 0110 - 48 KB
 * - 0111 - 64 KB
 * - 1000 - 96 KB
 * - 1001 - 128 KB
 * - 1011 - 256 KB
 */
/*@{*/
#define BP_SIM_SOPT1_RAMSIZE (12U)         /*!< Bit position for SIM_SOPT1_RAMSIZE. */
#define BM_SIM_SOPT1_RAMSIZE (0x0000F000U) /*!< Bit mask for SIM_SOPT1_RAMSIZE. */
#define BS_SIM_SOPT1_RAMSIZE (4U)          /*!< Bit field size in bits for SIM_SOPT1_RAMSIZE. */

/*! @brief Read current value of the SIM_SOPT1_RAMSIZE field. */
#define BR_SIM_SOPT1_RAMSIZE(x) (HW_SIM_SOPT1(x).B.RAMSIZE)
/*@}*/

/*!
 * @name Register SIM_SOPT1, field OSC32KSEL[19:18] (RW)
 *
 * Selects the 32 kHz clock source (ERCLK32K) for LPTMR. This field is reset
 * only on POR/LVD.
 *
 * Values:
 * - 00 - System oscillator (OSC32KCLK)
 * - 01 - Reserved
 * - 10 - RTC 32.768kHz oscillator
 * - 11 - LPO 1 kHz
 */
/*@{*/
#define BP_SIM_SOPT1_OSC32KSEL (18U)       /*!< Bit position for SIM_SOPT1_OSC32KSEL. */
#define BM_SIM_SOPT1_OSC32KSEL (0x000C0000U) /*!< Bit mask for SIM_SOPT1_OSC32KSEL. */
#define BS_SIM_SOPT1_OSC32KSEL (2U)        /*!< Bit field size in bits for SIM_SOPT1_OSC32KSEL. */

/*! @brief Read current value of the SIM_SOPT1_OSC32KSEL field. */
#define BR_SIM_SOPT1_OSC32KSEL(x) (HW_SIM_SOPT1(x).B.OSC32KSEL)

/*! @brief Format value for bitfield SIM_SOPT1_OSC32KSEL. */
#define BF_SIM_SOPT1_OSC32KSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1_OSC32KSEL) & BM_SIM_SOPT1_OSC32KSEL)

/*! @brief Set the OSC32KSEL field to a new value. */
#define BW_SIM_SOPT1_OSC32KSEL(x, v) (HW_SIM_SOPT1_WR(x, (HW_SIM_SOPT1_RD(x) & ~BM_SIM_SOPT1_OSC32KSEL) | BF_SIM_SOPT1_OSC32KSEL(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field USBVSTBY[29] (RW)
 *
 * Controls whether the USB voltage regulator is placed in standby mode during
 * VLPR and VLPW modes.
 *
 * Values:
 * - 0 - USB voltage regulator not in standby during VLPR and VLPW modes.
 * - 1 - USB voltage regulator in standby during VLPR and VLPW modes.
 */
/*@{*/
#define BP_SIM_SOPT1_USBVSTBY (29U)        /*!< Bit position for SIM_SOPT1_USBVSTBY. */
#define BM_SIM_SOPT1_USBVSTBY (0x20000000U) /*!< Bit mask for SIM_SOPT1_USBVSTBY. */
#define BS_SIM_SOPT1_USBVSTBY (1U)         /*!< Bit field size in bits for SIM_SOPT1_USBVSTBY. */

/*! @brief Read current value of the SIM_SOPT1_USBVSTBY field. */
#define BR_SIM_SOPT1_USBVSTBY(x) (BITBAND_ACCESS32(HW_SIM_SOPT1_ADDR(x), BP_SIM_SOPT1_USBVSTBY))

/*! @brief Format value for bitfield SIM_SOPT1_USBVSTBY. */
#define BF_SIM_SOPT1_USBVSTBY(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1_USBVSTBY) & BM_SIM_SOPT1_USBVSTBY)

/*! @brief Set the USBVSTBY field to a new value. */
#define BW_SIM_SOPT1_USBVSTBY(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT1_ADDR(x), BP_SIM_SOPT1_USBVSTBY) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field USBSSTBY[30] (RW)
 *
 * Controls whether the USB voltage regulator is placed in standby mode during
 * Stop, VLPS, LLS and VLLS modes.
 *
 * Values:
 * - 0 - USB voltage regulator not in standby during Stop, VLPS, LLS and VLLS
 *     modes.
 * - 1 - USB voltage regulator in standby during Stop, VLPS, LLS and VLLS modes.
 */
/*@{*/
#define BP_SIM_SOPT1_USBSSTBY (30U)        /*!< Bit position for SIM_SOPT1_USBSSTBY. */
#define BM_SIM_SOPT1_USBSSTBY (0x40000000U) /*!< Bit mask for SIM_SOPT1_USBSSTBY. */
#define BS_SIM_SOPT1_USBSSTBY (1U)         /*!< Bit field size in bits for SIM_SOPT1_USBSSTBY. */

/*! @brief Read current value of the SIM_SOPT1_USBSSTBY field. */
#define BR_SIM_SOPT1_USBSSTBY(x) (BITBAND_ACCESS32(HW_SIM_SOPT1_ADDR(x), BP_SIM_SOPT1_USBSSTBY))

/*! @brief Format value for bitfield SIM_SOPT1_USBSSTBY. */
#define BF_SIM_SOPT1_USBSSTBY(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1_USBSSTBY) & BM_SIM_SOPT1_USBSSTBY)

/*! @brief Set the USBSSTBY field to a new value. */
#define BW_SIM_SOPT1_USBSSTBY(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT1_ADDR(x), BP_SIM_SOPT1_USBSSTBY) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field USBREGEN[31] (RW)
 *
 * Controls whether the USB voltage regulator is enabled.
 *
 * Values:
 * - 0 - USB voltage regulator is disabled.
 * - 1 - USB voltage regulator is enabled.
 */
/*@{*/
#define BP_SIM_SOPT1_USBREGEN (31U)        /*!< Bit position for SIM_SOPT1_USBREGEN. */
#define BM_SIM_SOPT1_USBREGEN (0x80000000U) /*!< Bit mask for SIM_SOPT1_USBREGEN. */
#define BS_SIM_SOPT1_USBREGEN (1U)         /*!< Bit field size in bits for SIM_SOPT1_USBREGEN. */

/*! @brief Read current value of the SIM_SOPT1_USBREGEN field. */
#define BR_SIM_SOPT1_USBREGEN(x) (BITBAND_ACCESS32(HW_SIM_SOPT1_ADDR(x), BP_SIM_SOPT1_USBREGEN))

/*! @brief Format value for bitfield SIM_SOPT1_USBREGEN. */
#define BF_SIM_SOPT1_USBREGEN(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1_USBREGEN) & BM_SIM_SOPT1_USBREGEN)

/*! @brief Set the USBREGEN field to a new value. */
#define BW_SIM_SOPT1_USBREGEN(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT1_ADDR(x), BP_SIM_SOPT1_USBREGEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_SIM_SOPT1CFG - SOPT1 Configuration Register
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT1CFG - SOPT1 Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SOPT1CFG register is reset on System Reset not VLLS.
 */
typedef union _hw_sim_sopt1cfg
{
    uint32_t U;
    struct _hw_sim_sopt1cfg_bitfields
    {
        uint32_t RESERVED0 : 24;       /*!< [23:0]  */
        uint32_t URWE : 1;             /*!< [24] USB voltage regulator enable write
                                        * enable */
        uint32_t UVSWE : 1;            /*!< [25] USB voltage regulator VLP standby write
                                        * enable */
        uint32_t USSWE : 1;            /*!< [26] USB voltage regulator stop standby
                                        * write enable */
        uint32_t RESERVED1 : 5;        /*!< [31:27]  */
    } B;
} hw_sim_sopt1cfg_t;

/*!
 * @name Constants and macros for entire SIM_SOPT1CFG register
 */
/*@{*/
#define HW_SIM_SOPT1CFG_ADDR(x)  ((uint32_t)(x) + 0x4U)

#define HW_SIM_SOPT1CFG(x)       (*(__IO hw_sim_sopt1cfg_t *) HW_SIM_SOPT1CFG_ADDR(x))
#define HW_SIM_SOPT1CFG_RD(x)    (HW_SIM_SOPT1CFG(x).U)
#define HW_SIM_SOPT1CFG_WR(x, v) (HW_SIM_SOPT1CFG(x).U = (v))
#define HW_SIM_SOPT1CFG_SET(x, v) (HW_SIM_SOPT1CFG_WR(x, HW_SIM_SOPT1CFG_RD(x) |  (v)))
#define HW_SIM_SOPT1CFG_CLR(x, v) (HW_SIM_SOPT1CFG_WR(x, HW_SIM_SOPT1CFG_RD(x) & ~(v)))
#define HW_SIM_SOPT1CFG_TOG(x, v) (HW_SIM_SOPT1CFG_WR(x, HW_SIM_SOPT1CFG_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1CFG bitfields
 */

/*!
 * @name Register SIM_SOPT1CFG, field URWE[24] (RW)
 *
 * Writing one to the URWE bit allows the SOPT1 USBREGEN bit to be written. This
 * register bit clears after a write to USBREGEN.
 *
 * Values:
 * - 0 - SOPT1 USBREGEN cannot be written.
 * - 1 - SOPT1 USBREGEN can be written.
 */
/*@{*/
#define BP_SIM_SOPT1CFG_URWE (24U)         /*!< Bit position for SIM_SOPT1CFG_URWE. */
#define BM_SIM_SOPT1CFG_URWE (0x01000000U) /*!< Bit mask for SIM_SOPT1CFG_URWE. */
#define BS_SIM_SOPT1CFG_URWE (1U)          /*!< Bit field size in bits for SIM_SOPT1CFG_URWE. */

/*! @brief Read current value of the SIM_SOPT1CFG_URWE field. */
#define BR_SIM_SOPT1CFG_URWE(x) (BITBAND_ACCESS32(HW_SIM_SOPT1CFG_ADDR(x), BP_SIM_SOPT1CFG_URWE))

/*! @brief Format value for bitfield SIM_SOPT1CFG_URWE. */
#define BF_SIM_SOPT1CFG_URWE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1CFG_URWE) & BM_SIM_SOPT1CFG_URWE)

/*! @brief Set the URWE field to a new value. */
#define BW_SIM_SOPT1CFG_URWE(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT1CFG_ADDR(x), BP_SIM_SOPT1CFG_URWE) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT1CFG, field UVSWE[25] (RW)
 *
 * Writing one to the UVSWE bit allows the SOPT1 USBVSTBY bit to be written.
 * This register bit clears after a write to USBVSTBY.
 *
 * Values:
 * - 0 - SOPT1 USBVSTBY cannot be written.
 * - 1 - SOPT1 USBVSTBY can be written.
 */
/*@{*/
#define BP_SIM_SOPT1CFG_UVSWE (25U)        /*!< Bit position for SIM_SOPT1CFG_UVSWE. */
#define BM_SIM_SOPT1CFG_UVSWE (0x02000000U) /*!< Bit mask for SIM_SOPT1CFG_UVSWE. */
#define BS_SIM_SOPT1CFG_UVSWE (1U)         /*!< Bit field size in bits for SIM_SOPT1CFG_UVSWE. */

/*! @brief Read current value of the SIM_SOPT1CFG_UVSWE field. */
#define BR_SIM_SOPT1CFG_UVSWE(x) (BITBAND_ACCESS32(HW_SIM_SOPT1CFG_ADDR(x), BP_SIM_SOPT1CFG_UVSWE))

/*! @brief Format value for bitfield SIM_SOPT1CFG_UVSWE. */
#define BF_SIM_SOPT1CFG_UVSWE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1CFG_UVSWE) & BM_SIM_SOPT1CFG_UVSWE)

/*! @brief Set the UVSWE field to a new value. */
#define BW_SIM_SOPT1CFG_UVSWE(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT1CFG_ADDR(x), BP_SIM_SOPT1CFG_UVSWE) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT1CFG, field USSWE[26] (RW)
 *
 * Writing one to the USSWE bit allows the SOPT1 USBSSTBY bit to be written.
 * This register bit clears after a write to USBSSTBY.
 *
 * Values:
 * - 0 - SOPT1 USBSSTBY cannot be written.
 * - 1 - SOPT1 USBSSTBY can be written.
 */
/*@{*/
#define BP_SIM_SOPT1CFG_USSWE (26U)        /*!< Bit position for SIM_SOPT1CFG_USSWE. */
#define BM_SIM_SOPT1CFG_USSWE (0x04000000U) /*!< Bit mask for SIM_SOPT1CFG_USSWE. */
#define BS_SIM_SOPT1CFG_USSWE (1U)         /*!< Bit field size in bits for SIM_SOPT1CFG_USSWE. */

/*! @brief Read current value of the SIM_SOPT1CFG_USSWE field. */
#define BR_SIM_SOPT1CFG_USSWE(x) (BITBAND_ACCESS32(HW_SIM_SOPT1CFG_ADDR(x), BP_SIM_SOPT1CFG_USSWE))

/*! @brief Format value for bitfield SIM_SOPT1CFG_USSWE. */
#define BF_SIM_SOPT1CFG_USSWE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT1CFG_USSWE) & BM_SIM_SOPT1CFG_USSWE)

/*! @brief Set the USSWE field to a new value. */
#define BW_SIM_SOPT1CFG_USSWE(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT1CFG_ADDR(x), BP_SIM_SOPT1CFG_USSWE) = (v))
/*@}*/

/*******************************************************************************
 * HW_SIM_SOPT2 - System Options Register 2
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT2 - System Options Register 2 (RW)
 *
 * Reset value: 0x00001000U
 *
 * SOPT2 contains the controls for selecting many of the module clock source
 * options on this device. See the Clock Distribution chapter for more information
 * including clocking diagrams and definitions of device clocks.
 */
typedef union _hw_sim_sopt2
{
    uint32_t U;
    struct _hw_sim_sopt2_bitfields
    {
        uint32_t RESERVED0 : 4;        /*!< [3:0]  */
        uint32_t RTCCLKOUTSEL : 1;     /*!< [4] RTC clock out select */
        uint32_t CLKOUTSEL : 3;        /*!< [7:5] CLKOUT select */
        uint32_t FBSL : 2;             /*!< [9:8] FlexBus security level */
        uint32_t RESERVED1 : 1;        /*!< [10]  */
        uint32_t PTD7PAD : 1;          /*!< [11] PTD7 pad drive strength */
        uint32_t TRACECLKSEL : 1;      /*!< [12] Debug trace clock select */
        uint32_t RESERVED2 : 3;        /*!< [15:13]  */
        uint32_t PLLFLLSEL : 2;        /*!< [17:16] PLL/FLL clock select */
        uint32_t USBSRC : 1;           /*!< [18] USB clock source select */
        uint32_t RMIISRC : 1;          /*!< [19] RMII clock source select */
        uint32_t TIMESRC : 2;          /*!< [21:20] IEEE 1588 timestamp clock source
                                        * select */
        uint32_t RESERVED3 : 6;        /*!< [27:22]  */
        uint32_t SDHCSRC : 2;          /*!< [29:28] SDHC clock source select */
        uint32_t RESERVED4 : 2;        /*!< [31:30]  */
    } B;
} hw_sim_sopt2_t;

/*!
 * @name Constants and macros for entire SIM_SOPT2 register
 */
/*@{*/
#define HW_SIM_SOPT2_ADDR(x)     ((uint32_t)(x) + 0x1004U)

#define HW_SIM_SOPT2(x)          (*(__IO hw_sim_sopt2_t *) HW_SIM_SOPT2_ADDR(x))
#define HW_SIM_SOPT2_RD(x)       (HW_SIM_SOPT2(x).U)
#define HW_SIM_SOPT2_WR(x, v)    (HW_SIM_SOPT2(x).U = (v))
#define HW_SIM_SOPT2_SET(x, v)   (HW_SIM_SOPT2_WR(x, HW_SIM_SOPT2_RD(x) |  (v)))
#define HW_SIM_SOPT2_CLR(x, v)   (HW_SIM_SOPT2_WR(x, HW_SIM_SOPT2_RD(x) & ~(v)))
#define HW_SIM_SOPT2_TOG(x, v)   (HW_SIM_SOPT2_WR(x, HW_SIM_SOPT2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT2 bitfields
 */

/*!
 * @name Register SIM_SOPT2, field RTCCLKOUTSEL[4] (RW)
 *
 * Selects either the RTC 1 Hz clock or the 32.768kHz clock to be output on the
 * RTC_CLKOUT pin.
 *
 * Values:
 * - 0 - RTC 1 Hz clock is output on the RTC_CLKOUT pin.
 * - 1 - RTC 32.768kHz clock is output on the RTC_CLKOUT pin.
 */
/*@{*/
#define BP_SIM_SOPT2_RTCCLKOUTSEL (4U)     /*!< Bit position for SIM_SOPT2_RTCCLKOUTSEL. */
#define BM_SIM_SOPT2_RTCCLKOUTSEL (0x00000010U) /*!< Bit mask for SIM_SOPT2_RTCCLKOUTSEL. */
#define BS_SIM_SOPT2_RTCCLKOUTSEL (1U)     /*!< Bit field size in bits for SIM_SOPT2_RTCCLKOUTSEL. */

/*! @brief Read current value of the SIM_SOPT2_RTCCLKOUTSEL field. */
#define BR_SIM_SOPT2_RTCCLKOUTSEL(x) (BITBAND_ACCESS32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_RTCCLKOUTSEL))

/*! @brief Format value for bitfield SIM_SOPT2_RTCCLKOUTSEL. */
#define BF_SIM_SOPT2_RTCCLKOUTSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_RTCCLKOUTSEL) & BM_SIM_SOPT2_RTCCLKOUTSEL)

/*! @brief Set the RTCCLKOUTSEL field to a new value. */
#define BW_SIM_SOPT2_RTCCLKOUTSEL(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_RTCCLKOUTSEL) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field CLKOUTSEL[7:5] (RW)
 *
 * Selects the clock to output on the CLKOUT pin.
 *
 * Values:
 * - 000 - FlexBus CLKOUT
 * - 001 - Reserved
 * - 010 - Flash clock
 * - 011 - LPO clock (1 kHz)
 * - 100 - MCGIRCLK
 * - 101 - RTC 32.768kHz clock
 * - 110 - OSCERCLK0
 * - 111 - IRC 48 MHz clock
 */
/*@{*/
#define BP_SIM_SOPT2_CLKOUTSEL (5U)        /*!< Bit position for SIM_SOPT2_CLKOUTSEL. */
#define BM_SIM_SOPT2_CLKOUTSEL (0x000000E0U) /*!< Bit mask for SIM_SOPT2_CLKOUTSEL. */
#define BS_SIM_SOPT2_CLKOUTSEL (3U)        /*!< Bit field size in bits for SIM_SOPT2_CLKOUTSEL. */

/*! @brief Read current value of the SIM_SOPT2_CLKOUTSEL field. */
#define BR_SIM_SOPT2_CLKOUTSEL(x) (HW_SIM_SOPT2(x).B.CLKOUTSEL)

/*! @brief Format value for bitfield SIM_SOPT2_CLKOUTSEL. */
#define BF_SIM_SOPT2_CLKOUTSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_CLKOUTSEL) & BM_SIM_SOPT2_CLKOUTSEL)

/*! @brief Set the CLKOUTSEL field to a new value. */
#define BW_SIM_SOPT2_CLKOUTSEL(x, v) (HW_SIM_SOPT2_WR(x, (HW_SIM_SOPT2_RD(x) & ~BM_SIM_SOPT2_CLKOUTSEL) | BF_SIM_SOPT2_CLKOUTSEL(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field FBSL[9:8] (RW)
 *
 * If flash security is enabled, then this field affects what CPU operations can
 * access off-chip via the FlexBus interface. This field has no effect if flash
 * security is not enabled.
 *
 * Values:
 * - 00 - All off-chip accesses (instruction and data) via the FlexBus are
 *     disallowed.
 * - 01 - All off-chip accesses (instruction and data) via the FlexBus are
 *     disallowed.
 * - 10 - Off-chip instruction accesses are disallowed. Data accesses are
 *     allowed.
 * - 11 - Off-chip instruction accesses and data accesses are allowed.
 */
/*@{*/
#define BP_SIM_SOPT2_FBSL    (8U)          /*!< Bit position for SIM_SOPT2_FBSL. */
#define BM_SIM_SOPT2_FBSL    (0x00000300U) /*!< Bit mask for SIM_SOPT2_FBSL. */
#define BS_SIM_SOPT2_FBSL    (2U)          /*!< Bit field size in bits for SIM_SOPT2_FBSL. */

/*! @brief Read current value of the SIM_SOPT2_FBSL field. */
#define BR_SIM_SOPT2_FBSL(x) (HW_SIM_SOPT2(x).B.FBSL)

/*! @brief Format value for bitfield SIM_SOPT2_FBSL. */
#define BF_SIM_SOPT2_FBSL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_FBSL) & BM_SIM_SOPT2_FBSL)

/*! @brief Set the FBSL field to a new value. */
#define BW_SIM_SOPT2_FBSL(x, v) (HW_SIM_SOPT2_WR(x, (HW_SIM_SOPT2_RD(x) & ~BM_SIM_SOPT2_FBSL) | BF_SIM_SOPT2_FBSL(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field PTD7PAD[11] (RW)
 *
 * Controls the output drive strength of the PTD7 pin by selecting either one or
 * two pads to drive it.
 *
 * Values:
 * - 0 - Single-pad drive strength for PTD7.
 * - 1 - Double pad drive strength for PTD7.
 */
/*@{*/
#define BP_SIM_SOPT2_PTD7PAD (11U)         /*!< Bit position for SIM_SOPT2_PTD7PAD. */
#define BM_SIM_SOPT2_PTD7PAD (0x00000800U) /*!< Bit mask for SIM_SOPT2_PTD7PAD. */
#define BS_SIM_SOPT2_PTD7PAD (1U)          /*!< Bit field size in bits for SIM_SOPT2_PTD7PAD. */

/*! @brief Read current value of the SIM_SOPT2_PTD7PAD field. */
#define BR_SIM_SOPT2_PTD7PAD(x) (BITBAND_ACCESS32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_PTD7PAD))

/*! @brief Format value for bitfield SIM_SOPT2_PTD7PAD. */
#define BF_SIM_SOPT2_PTD7PAD(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_PTD7PAD) & BM_SIM_SOPT2_PTD7PAD)

/*! @brief Set the PTD7PAD field to a new value. */
#define BW_SIM_SOPT2_PTD7PAD(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_PTD7PAD) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field TRACECLKSEL[12] (RW)
 *
 * Selects the core/system clock or MCG output clock (MCGOUTCLK) as the trace
 * clock source.
 *
 * Values:
 * - 0 - MCGOUTCLK
 * - 1 - Core/system clock
 */
/*@{*/
#define BP_SIM_SOPT2_TRACECLKSEL (12U)     /*!< Bit position for SIM_SOPT2_TRACECLKSEL. */
#define BM_SIM_SOPT2_TRACECLKSEL (0x00001000U) /*!< Bit mask for SIM_SOPT2_TRACECLKSEL. */
#define BS_SIM_SOPT2_TRACECLKSEL (1U)      /*!< Bit field size in bits for SIM_SOPT2_TRACECLKSEL. */

/*! @brief Read current value of the SIM_SOPT2_TRACECLKSEL field. */
#define BR_SIM_SOPT2_TRACECLKSEL(x) (BITBAND_ACCESS32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_TRACECLKSEL))

/*! @brief Format value for bitfield SIM_SOPT2_TRACECLKSEL. */
#define BF_SIM_SOPT2_TRACECLKSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_TRACECLKSEL) & BM_SIM_SOPT2_TRACECLKSEL)

/*! @brief Set the TRACECLKSEL field to a new value. */
#define BW_SIM_SOPT2_TRACECLKSEL(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_TRACECLKSEL) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field PLLFLLSEL[17:16] (RW)
 *
 * Selects the high frequency clock for various peripheral clocking options.
 *
 * Values:
 * - 00 - MCGFLLCLK clock
 * - 01 - MCGPLLCLK clock
 * - 10 - Reserved
 * - 11 - IRC48 MHz clock
 */
/*@{*/
#define BP_SIM_SOPT2_PLLFLLSEL (16U)       /*!< Bit position for SIM_SOPT2_PLLFLLSEL. */
#define BM_SIM_SOPT2_PLLFLLSEL (0x00030000U) /*!< Bit mask for SIM_SOPT2_PLLFLLSEL. */
#define BS_SIM_SOPT2_PLLFLLSEL (2U)        /*!< Bit field size in bits for SIM_SOPT2_PLLFLLSEL. */

/*! @brief Read current value of the SIM_SOPT2_PLLFLLSEL field. */
#define BR_SIM_SOPT2_PLLFLLSEL(x) (HW_SIM_SOPT2(x).B.PLLFLLSEL)

/*! @brief Format value for bitfield SIM_SOPT2_PLLFLLSEL. */
#define BF_SIM_SOPT2_PLLFLLSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_PLLFLLSEL) & BM_SIM_SOPT2_PLLFLLSEL)

/*! @brief Set the PLLFLLSEL field to a new value. */
#define BW_SIM_SOPT2_PLLFLLSEL(x, v) (HW_SIM_SOPT2_WR(x, (HW_SIM_SOPT2_RD(x) & ~BM_SIM_SOPT2_PLLFLLSEL) | BF_SIM_SOPT2_PLLFLLSEL(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field USBSRC[18] (RW)
 *
 * Selects the clock source for the USB 48 MHz clock.
 *
 * Values:
 * - 0 - External bypass clock (USB_CLKIN).
 * - 1 - MCGFLLCLK , or MCGPLLCLK , or IRC48M clock as selected by
 *     SOPT2[PLLFLLSEL], and then divided by the USB fractional divider as configured by
 *     SIM_CLKDIV2[USBFRAC, USBDIV].
 */
/*@{*/
#define BP_SIM_SOPT2_USBSRC  (18U)         /*!< Bit position for SIM_SOPT2_USBSRC. */
#define BM_SIM_SOPT2_USBSRC  (0x00040000U) /*!< Bit mask for SIM_SOPT2_USBSRC. */
#define BS_SIM_SOPT2_USBSRC  (1U)          /*!< Bit field size in bits for SIM_SOPT2_USBSRC. */

/*! @brief Read current value of the SIM_SOPT2_USBSRC field. */
#define BR_SIM_SOPT2_USBSRC(x) (BITBAND_ACCESS32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_USBSRC))

/*! @brief Format value for bitfield SIM_SOPT2_USBSRC. */
#define BF_SIM_SOPT2_USBSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_USBSRC) & BM_SIM_SOPT2_USBSRC)

/*! @brief Set the USBSRC field to a new value. */
#define BW_SIM_SOPT2_USBSRC(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_USBSRC) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field RMIISRC[19] (RW)
 *
 * Selects the clock source for the Ethernet RMII interface
 *
 * Values:
 * - 0 - EXTAL clock
 * - 1 - External bypass clock (ENET_1588_CLKIN).
 */
/*@{*/
#define BP_SIM_SOPT2_RMIISRC (19U)         /*!< Bit position for SIM_SOPT2_RMIISRC. */
#define BM_SIM_SOPT2_RMIISRC (0x00080000U) /*!< Bit mask for SIM_SOPT2_RMIISRC. */
#define BS_SIM_SOPT2_RMIISRC (1U)          /*!< Bit field size in bits for SIM_SOPT2_RMIISRC. */

/*! @brief Read current value of the SIM_SOPT2_RMIISRC field. */
#define BR_SIM_SOPT2_RMIISRC(x) (BITBAND_ACCESS32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_RMIISRC))

/*! @brief Format value for bitfield SIM_SOPT2_RMIISRC. */
#define BF_SIM_SOPT2_RMIISRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_RMIISRC) & BM_SIM_SOPT2_RMIISRC)

/*! @brief Set the RMIISRC field to a new value. */
#define BW_SIM_SOPT2_RMIISRC(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT2_ADDR(x), BP_SIM_SOPT2_RMIISRC) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field TIMESRC[21:20] (RW)
 *
 * Selects the clock source for the Ethernet timestamp clock.
 *
 * Values:
 * - 00 - Core/system clock.
 * - 01 - MCGFLLCLK , or MCGPLLCLK , or IRC48M clock as selected by
 *     SOPT2[PLLFLLSEL].
 * - 10 - OSCERCLK clock
 * - 11 - External bypass clock (ENET_1588_CLKIN).
 */
/*@{*/
#define BP_SIM_SOPT2_TIMESRC (20U)         /*!< Bit position for SIM_SOPT2_TIMESRC. */
#define BM_SIM_SOPT2_TIMESRC (0x00300000U) /*!< Bit mask for SIM_SOPT2_TIMESRC. */
#define BS_SIM_SOPT2_TIMESRC (2U)          /*!< Bit field size in bits for SIM_SOPT2_TIMESRC. */

/*! @brief Read current value of the SIM_SOPT2_TIMESRC field. */
#define BR_SIM_SOPT2_TIMESRC(x) (HW_SIM_SOPT2(x).B.TIMESRC)

/*! @brief Format value for bitfield SIM_SOPT2_TIMESRC. */
#define BF_SIM_SOPT2_TIMESRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_TIMESRC) & BM_SIM_SOPT2_TIMESRC)

/*! @brief Set the TIMESRC field to a new value. */
#define BW_SIM_SOPT2_TIMESRC(x, v) (HW_SIM_SOPT2_WR(x, (HW_SIM_SOPT2_RD(x) & ~BM_SIM_SOPT2_TIMESRC) | BF_SIM_SOPT2_TIMESRC(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field SDHCSRC[29:28] (RW)
 *
 * Selects the clock source for the SDHC clock .
 *
 * Values:
 * - 00 - Core/system clock.
 * - 01 - MCGFLLCLK, or MCGPLLCLK , or IRC48M clock as selected by
 *     SOPT2[PLLFLLSEL].
 * - 10 - OSCERCLK clock
 * - 11 - External bypass clock (SDHC0_CLKIN)
 */
/*@{*/
#define BP_SIM_SOPT2_SDHCSRC (28U)         /*!< Bit position for SIM_SOPT2_SDHCSRC. */
#define BM_SIM_SOPT2_SDHCSRC (0x30000000U) /*!< Bit mask for SIM_SOPT2_SDHCSRC. */
#define BS_SIM_SOPT2_SDHCSRC (2U)          /*!< Bit field size in bits for SIM_SOPT2_SDHCSRC. */

/*! @brief Read current value of the SIM_SOPT2_SDHCSRC field. */
#define BR_SIM_SOPT2_SDHCSRC(x) (HW_SIM_SOPT2(x).B.SDHCSRC)

/*! @brief Format value for bitfield SIM_SOPT2_SDHCSRC. */
#define BF_SIM_SOPT2_SDHCSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT2_SDHCSRC) & BM_SIM_SOPT2_SDHCSRC)

/*! @brief Set the SDHCSRC field to a new value. */
#define BW_SIM_SOPT2_SDHCSRC(x, v) (HW_SIM_SOPT2_WR(x, (HW_SIM_SOPT2_RD(x) & ~BM_SIM_SOPT2_SDHCSRC) | BF_SIM_SOPT2_SDHCSRC(v)))
/*@}*/

/*******************************************************************************
 * HW_SIM_SOPT4 - System Options Register 4
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT4 - System Options Register 4 (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_sopt4
{
    uint32_t U;
    struct _hw_sim_sopt4_bitfields
    {
        uint32_t FTM0FLT0 : 1;         /*!< [0] FTM0 Fault 0 Select */
        uint32_t FTM0FLT1 : 1;         /*!< [1] FTM0 Fault 1 Select */
        uint32_t FTM0FLT2 : 1;         /*!< [2] FTM0 Fault 2 Select */
        uint32_t RESERVED0 : 1;        /*!< [3]  */
        uint32_t FTM1FLT0 : 1;         /*!< [4] FTM1 Fault 0 Select */
        uint32_t RESERVED1 : 3;        /*!< [7:5]  */
        uint32_t FTM2FLT0 : 1;         /*!< [8] FTM2 Fault 0 Select */
        uint32_t RESERVED2 : 3;        /*!< [11:9]  */
        uint32_t FTM3FLT0 : 1;         /*!< [12] FTM3 Fault 0 Select */
        uint32_t RESERVED3 : 5;        /*!< [17:13]  */
        uint32_t FTM1CH0SRC : 2;       /*!< [19:18] FTM1 channel 0 input capture
                                        * source select */
        uint32_t FTM2CH0SRC : 2;       /*!< [21:20] FTM2 channel 0 input capture
                                        * source select */
        uint32_t RESERVED4 : 2;        /*!< [23:22]  */
        uint32_t FTM0CLKSEL : 1;       /*!< [24] FlexTimer 0 External Clock Pin
                                        * Select */
        uint32_t FTM1CLKSEL : 1;       /*!< [25] FTM1 External Clock Pin Select */
        uint32_t FTM2CLKSEL : 1;       /*!< [26] FlexTimer 2 External Clock Pin
                                        * Select */
        uint32_t FTM3CLKSEL : 1;       /*!< [27] FlexTimer 3 External Clock Pin
                                        * Select */
        uint32_t FTM0TRG0SRC : 1;      /*!< [28] FlexTimer 0 Hardware Trigger 0
                                        * Source Select */
        uint32_t FTM0TRG1SRC : 1;      /*!< [29] FlexTimer 0 Hardware Trigger 1
                                        * Source Select */
        uint32_t FTM3TRG0SRC : 1;      /*!< [30] FlexTimer 3 Hardware Trigger 0
                                        * Source Select */
        uint32_t FTM3TRG1SRC : 1;      /*!< [31] FlexTimer 3 Hardware Trigger 1
                                        * Source Select */
    } B;
} hw_sim_sopt4_t;

/*!
 * @name Constants and macros for entire SIM_SOPT4 register
 */
/*@{*/
#define HW_SIM_SOPT4_ADDR(x)     ((uint32_t)(x) + 0x100CU)

#define HW_SIM_SOPT4(x)          (*(__IO hw_sim_sopt4_t *) HW_SIM_SOPT4_ADDR(x))
#define HW_SIM_SOPT4_RD(x)       (HW_SIM_SOPT4(x).U)
#define HW_SIM_SOPT4_WR(x, v)    (HW_SIM_SOPT4(x).U = (v))
#define HW_SIM_SOPT4_SET(x, v)   (HW_SIM_SOPT4_WR(x, HW_SIM_SOPT4_RD(x) |  (v)))
#define HW_SIM_SOPT4_CLR(x, v)   (HW_SIM_SOPT4_WR(x, HW_SIM_SOPT4_RD(x) & ~(v)))
#define HW_SIM_SOPT4_TOG(x, v)   (HW_SIM_SOPT4_WR(x, HW_SIM_SOPT4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT4 bitfields
 */

/*!
 * @name Register SIM_SOPT4, field FTM0FLT0[0] (RW)
 *
 * Selects the source of FTM0 fault 0. The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0 - FTM0_FLT0 pin
 * - 1 - CMP0 out
 */
/*@{*/
#define BP_SIM_SOPT4_FTM0FLT0 (0U)         /*!< Bit position for SIM_SOPT4_FTM0FLT0. */
#define BM_SIM_SOPT4_FTM0FLT0 (0x00000001U) /*!< Bit mask for SIM_SOPT4_FTM0FLT0. */
#define BS_SIM_SOPT4_FTM0FLT0 (1U)         /*!< Bit field size in bits for SIM_SOPT4_FTM0FLT0. */

/*! @brief Read current value of the SIM_SOPT4_FTM0FLT0 field. */
#define BR_SIM_SOPT4_FTM0FLT0(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0FLT0))

/*! @brief Format value for bitfield SIM_SOPT4_FTM0FLT0. */
#define BF_SIM_SOPT4_FTM0FLT0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM0FLT0) & BM_SIM_SOPT4_FTM0FLT0)

/*! @brief Set the FTM0FLT0 field to a new value. */
#define BW_SIM_SOPT4_FTM0FLT0(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0FLT0) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0FLT1[1] (RW)
 *
 * Selects the source of FTM0 fault 1. The pin source for fault 1 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0 - FTM0_FLT1 pin
 * - 1 - CMP1 out
 */
/*@{*/
#define BP_SIM_SOPT4_FTM0FLT1 (1U)         /*!< Bit position for SIM_SOPT4_FTM0FLT1. */
#define BM_SIM_SOPT4_FTM0FLT1 (0x00000002U) /*!< Bit mask for SIM_SOPT4_FTM0FLT1. */
#define BS_SIM_SOPT4_FTM0FLT1 (1U)         /*!< Bit field size in bits for SIM_SOPT4_FTM0FLT1. */

/*! @brief Read current value of the SIM_SOPT4_FTM0FLT1 field. */
#define BR_SIM_SOPT4_FTM0FLT1(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0FLT1))

/*! @brief Format value for bitfield SIM_SOPT4_FTM0FLT1. */
#define BF_SIM_SOPT4_FTM0FLT1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM0FLT1) & BM_SIM_SOPT4_FTM0FLT1)

/*! @brief Set the FTM0FLT1 field to a new value. */
#define BW_SIM_SOPT4_FTM0FLT1(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0FLT1) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0FLT2[2] (RW)
 *
 * Selects the source of FTM0 fault 2. The pin source for fault 2 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0 - FTM0_FLT2 pin
 * - 1 - CMP2 out
 */
/*@{*/
#define BP_SIM_SOPT4_FTM0FLT2 (2U)         /*!< Bit position for SIM_SOPT4_FTM0FLT2. */
#define BM_SIM_SOPT4_FTM0FLT2 (0x00000004U) /*!< Bit mask for SIM_SOPT4_FTM0FLT2. */
#define BS_SIM_SOPT4_FTM0FLT2 (1U)         /*!< Bit field size in bits for SIM_SOPT4_FTM0FLT2. */

/*! @brief Read current value of the SIM_SOPT4_FTM0FLT2 field. */
#define BR_SIM_SOPT4_FTM0FLT2(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0FLT2))

/*! @brief Format value for bitfield SIM_SOPT4_FTM0FLT2. */
#define BF_SIM_SOPT4_FTM0FLT2(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM0FLT2) & BM_SIM_SOPT4_FTM0FLT2)

/*! @brief Set the FTM0FLT2 field to a new value. */
#define BW_SIM_SOPT4_FTM0FLT2(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0FLT2) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1FLT0[4] (RW)
 *
 * Selects the source of FTM1 fault 0. The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0 - FTM1_FLT0 pin
 * - 1 - CMP0 out
 */
/*@{*/
#define BP_SIM_SOPT4_FTM1FLT0 (4U)         /*!< Bit position for SIM_SOPT4_FTM1FLT0. */
#define BM_SIM_SOPT4_FTM1FLT0 (0x00000010U) /*!< Bit mask for SIM_SOPT4_FTM1FLT0. */
#define BS_SIM_SOPT4_FTM1FLT0 (1U)         /*!< Bit field size in bits for SIM_SOPT4_FTM1FLT0. */

/*! @brief Read current value of the SIM_SOPT4_FTM1FLT0 field. */
#define BR_SIM_SOPT4_FTM1FLT0(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM1FLT0))

/*! @brief Format value for bitfield SIM_SOPT4_FTM1FLT0. */
#define BF_SIM_SOPT4_FTM1FLT0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM1FLT0) & BM_SIM_SOPT4_FTM1FLT0)

/*! @brief Set the FTM1FLT0 field to a new value. */
#define BW_SIM_SOPT4_FTM1FLT0(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM1FLT0) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2FLT0[8] (RW)
 *
 * Selects the source of FTM2 fault 0. The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate PORTx pin
 * control register.
 *
 * Values:
 * - 0 - FTM2_FLT0 pin
 * - 1 - CMP0 out
 */
/*@{*/
#define BP_SIM_SOPT4_FTM2FLT0 (8U)         /*!< Bit position for SIM_SOPT4_FTM2FLT0. */
#define BM_SIM_SOPT4_FTM2FLT0 (0x00000100U) /*!< Bit mask for SIM_SOPT4_FTM2FLT0. */
#define BS_SIM_SOPT4_FTM2FLT0 (1U)         /*!< Bit field size in bits for SIM_SOPT4_FTM2FLT0. */

/*! @brief Read current value of the SIM_SOPT4_FTM2FLT0 field. */
#define BR_SIM_SOPT4_FTM2FLT0(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM2FLT0))

/*! @brief Format value for bitfield SIM_SOPT4_FTM2FLT0. */
#define BF_SIM_SOPT4_FTM2FLT0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM2FLT0) & BM_SIM_SOPT4_FTM2FLT0)

/*! @brief Set the FTM2FLT0 field to a new value. */
#define BW_SIM_SOPT4_FTM2FLT0(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM2FLT0) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM3FLT0[12] (RW)
 *
 * Selects the source of FTM3 fault 0. The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate PORTx pin
 * control register.
 *
 * Values:
 * - 0 - FTM3_FLT0 pin
 * - 1 - CMP0 out
 */
/*@{*/
#define BP_SIM_SOPT4_FTM3FLT0 (12U)        /*!< Bit position for SIM_SOPT4_FTM3FLT0. */
#define BM_SIM_SOPT4_FTM3FLT0 (0x00001000U) /*!< Bit mask for SIM_SOPT4_FTM3FLT0. */
#define BS_SIM_SOPT4_FTM3FLT0 (1U)         /*!< Bit field size in bits for SIM_SOPT4_FTM3FLT0. */

/*! @brief Read current value of the SIM_SOPT4_FTM3FLT0 field. */
#define BR_SIM_SOPT4_FTM3FLT0(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM3FLT0))

/*! @brief Format value for bitfield SIM_SOPT4_FTM3FLT0. */
#define BF_SIM_SOPT4_FTM3FLT0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM3FLT0) & BM_SIM_SOPT4_FTM3FLT0)

/*! @brief Set the FTM3FLT0 field to a new value. */
#define BW_SIM_SOPT4_FTM3FLT0(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM3FLT0) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1CH0SRC[19:18] (RW)
 *
 * Selects the source for FTM1 channel 0 input capture. When the FTM is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 00 - FTM1_CH0 signal
 * - 01 - CMP0 output
 * - 10 - CMP1 output
 * - 11 - USB start of frame pulse
 */
/*@{*/
#define BP_SIM_SOPT4_FTM1CH0SRC (18U)      /*!< Bit position for SIM_SOPT4_FTM1CH0SRC. */
#define BM_SIM_SOPT4_FTM1CH0SRC (0x000C0000U) /*!< Bit mask for SIM_SOPT4_FTM1CH0SRC. */
#define BS_SIM_SOPT4_FTM1CH0SRC (2U)       /*!< Bit field size in bits for SIM_SOPT4_FTM1CH0SRC. */

/*! @brief Read current value of the SIM_SOPT4_FTM1CH0SRC field. */
#define BR_SIM_SOPT4_FTM1CH0SRC(x) (HW_SIM_SOPT4(x).B.FTM1CH0SRC)

/*! @brief Format value for bitfield SIM_SOPT4_FTM1CH0SRC. */
#define BF_SIM_SOPT4_FTM1CH0SRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM1CH0SRC) & BM_SIM_SOPT4_FTM1CH0SRC)

/*! @brief Set the FTM1CH0SRC field to a new value. */
#define BW_SIM_SOPT4_FTM1CH0SRC(x, v) (HW_SIM_SOPT4_WR(x, (HW_SIM_SOPT4_RD(x) & ~BM_SIM_SOPT4_FTM1CH0SRC) | BF_SIM_SOPT4_FTM1CH0SRC(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2CH0SRC[21:20] (RW)
 *
 * Selects the source for FTM2 channel 0 input capture. When the FTM is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 00 - FTM2_CH0 signal
 * - 01 - CMP0 output
 * - 10 - CMP1 output
 * - 11 - Reserved
 */
/*@{*/
#define BP_SIM_SOPT4_FTM2CH0SRC (20U)      /*!< Bit position for SIM_SOPT4_FTM2CH0SRC. */
#define BM_SIM_SOPT4_FTM2CH0SRC (0x00300000U) /*!< Bit mask for SIM_SOPT4_FTM2CH0SRC. */
#define BS_SIM_SOPT4_FTM2CH0SRC (2U)       /*!< Bit field size in bits for SIM_SOPT4_FTM2CH0SRC. */

/*! @brief Read current value of the SIM_SOPT4_FTM2CH0SRC field. */
#define BR_SIM_SOPT4_FTM2CH0SRC(x) (HW_SIM_SOPT4(x).B.FTM2CH0SRC)

/*! @brief Format value for bitfield SIM_SOPT4_FTM2CH0SRC. */
#define BF_SIM_SOPT4_FTM2CH0SRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM2CH0SRC) & BM_SIM_SOPT4_FTM2CH0SRC)

/*! @brief Set the FTM2CH0SRC field to a new value. */
#define BW_SIM_SOPT4_FTM2CH0SRC(x, v) (HW_SIM_SOPT4_WR(x, (HW_SIM_SOPT4_RD(x) & ~BM_SIM_SOPT4_FTM2CH0SRC) | BF_SIM_SOPT4_FTM2CH0SRC(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0CLKSEL[24] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM0 module. The
 * selected pin must also be configured for the FTM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0 - FTM_CLK0 pin
 * - 1 - FTM_CLK1 pin
 */
/*@{*/
#define BP_SIM_SOPT4_FTM0CLKSEL (24U)      /*!< Bit position for SIM_SOPT4_FTM0CLKSEL. */
#define BM_SIM_SOPT4_FTM0CLKSEL (0x01000000U) /*!< Bit mask for SIM_SOPT4_FTM0CLKSEL. */
#define BS_SIM_SOPT4_FTM0CLKSEL (1U)       /*!< Bit field size in bits for SIM_SOPT4_FTM0CLKSEL. */

/*! @brief Read current value of the SIM_SOPT4_FTM0CLKSEL field. */
#define BR_SIM_SOPT4_FTM0CLKSEL(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0CLKSEL))

/*! @brief Format value for bitfield SIM_SOPT4_FTM0CLKSEL. */
#define BF_SIM_SOPT4_FTM0CLKSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM0CLKSEL) & BM_SIM_SOPT4_FTM0CLKSEL)

/*! @brief Set the FTM0CLKSEL field to a new value. */
#define BW_SIM_SOPT4_FTM0CLKSEL(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0CLKSEL) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1CLKSEL[25] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM1 module. The
 * selected pin must also be configured for the FTM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0 - FTM_CLK0 pin
 * - 1 - FTM_CLK1 pin
 */
/*@{*/
#define BP_SIM_SOPT4_FTM1CLKSEL (25U)      /*!< Bit position for SIM_SOPT4_FTM1CLKSEL. */
#define BM_SIM_SOPT4_FTM1CLKSEL (0x02000000U) /*!< Bit mask for SIM_SOPT4_FTM1CLKSEL. */
#define BS_SIM_SOPT4_FTM1CLKSEL (1U)       /*!< Bit field size in bits for SIM_SOPT4_FTM1CLKSEL. */

/*! @brief Read current value of the SIM_SOPT4_FTM1CLKSEL field. */
#define BR_SIM_SOPT4_FTM1CLKSEL(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM1CLKSEL))

/*! @brief Format value for bitfield SIM_SOPT4_FTM1CLKSEL. */
#define BF_SIM_SOPT4_FTM1CLKSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM1CLKSEL) & BM_SIM_SOPT4_FTM1CLKSEL)

/*! @brief Set the FTM1CLKSEL field to a new value. */
#define BW_SIM_SOPT4_FTM1CLKSEL(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM1CLKSEL) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2CLKSEL[26] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM2 module. The
 * selected pin must also be configured for the FTM2 module external clock function
 * through the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0 - FTM2 external clock driven by FTM_CLK0 pin.
 * - 1 - FTM2 external clock driven by FTM_CLK1 pin.
 */
/*@{*/
#define BP_SIM_SOPT4_FTM2CLKSEL (26U)      /*!< Bit position for SIM_SOPT4_FTM2CLKSEL. */
#define BM_SIM_SOPT4_FTM2CLKSEL (0x04000000U) /*!< Bit mask for SIM_SOPT4_FTM2CLKSEL. */
#define BS_SIM_SOPT4_FTM2CLKSEL (1U)       /*!< Bit field size in bits for SIM_SOPT4_FTM2CLKSEL. */

/*! @brief Read current value of the SIM_SOPT4_FTM2CLKSEL field. */
#define BR_SIM_SOPT4_FTM2CLKSEL(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM2CLKSEL))

/*! @brief Format value for bitfield SIM_SOPT4_FTM2CLKSEL. */
#define BF_SIM_SOPT4_FTM2CLKSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM2CLKSEL) & BM_SIM_SOPT4_FTM2CLKSEL)

/*! @brief Set the FTM2CLKSEL field to a new value. */
#define BW_SIM_SOPT4_FTM2CLKSEL(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM2CLKSEL) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM3CLKSEL[27] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM3 module. The
 * selected pin must also be configured for the FTM3 module external clock function
 * through the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0 - FTM3 external clock driven by FTM_CLK0 pin.
 * - 1 - FTM3 external clock driven by FTM_CLK1 pin.
 */
/*@{*/
#define BP_SIM_SOPT4_FTM3CLKSEL (27U)      /*!< Bit position for SIM_SOPT4_FTM3CLKSEL. */
#define BM_SIM_SOPT4_FTM3CLKSEL (0x08000000U) /*!< Bit mask for SIM_SOPT4_FTM3CLKSEL. */
#define BS_SIM_SOPT4_FTM3CLKSEL (1U)       /*!< Bit field size in bits for SIM_SOPT4_FTM3CLKSEL. */

/*! @brief Read current value of the SIM_SOPT4_FTM3CLKSEL field. */
#define BR_SIM_SOPT4_FTM3CLKSEL(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM3CLKSEL))

/*! @brief Format value for bitfield SIM_SOPT4_FTM3CLKSEL. */
#define BF_SIM_SOPT4_FTM3CLKSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM3CLKSEL) & BM_SIM_SOPT4_FTM3CLKSEL)

/*! @brief Set the FTM3CLKSEL field to a new value. */
#define BW_SIM_SOPT4_FTM3CLKSEL(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM3CLKSEL) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0TRG0SRC[28] (RW)
 *
 * Selects the source of FTM0 hardware trigger 0.
 *
 * Values:
 * - 0 - HSCMP0 output drives FTM0 hardware trigger 0
 * - 1 - FTM1 channel match drives FTM0 hardware trigger 0
 */
/*@{*/
#define BP_SIM_SOPT4_FTM0TRG0SRC (28U)     /*!< Bit position for SIM_SOPT4_FTM0TRG0SRC. */
#define BM_SIM_SOPT4_FTM0TRG0SRC (0x10000000U) /*!< Bit mask for SIM_SOPT4_FTM0TRG0SRC. */
#define BS_SIM_SOPT4_FTM0TRG0SRC (1U)      /*!< Bit field size in bits for SIM_SOPT4_FTM0TRG0SRC. */

/*! @brief Read current value of the SIM_SOPT4_FTM0TRG0SRC field. */
#define BR_SIM_SOPT4_FTM0TRG0SRC(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0TRG0SRC))

/*! @brief Format value for bitfield SIM_SOPT4_FTM0TRG0SRC. */
#define BF_SIM_SOPT4_FTM0TRG0SRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM0TRG0SRC) & BM_SIM_SOPT4_FTM0TRG0SRC)

/*! @brief Set the FTM0TRG0SRC field to a new value. */
#define BW_SIM_SOPT4_FTM0TRG0SRC(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0TRG0SRC) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0TRG1SRC[29] (RW)
 *
 * Selects the source of FTM0 hardware trigger 1.
 *
 * Values:
 * - 0 - PDB output trigger 1 drives FTM0 hardware trigger 1
 * - 1 - FTM2 channel match drives FTM0 hardware trigger 1
 */
/*@{*/
#define BP_SIM_SOPT4_FTM0TRG1SRC (29U)     /*!< Bit position for SIM_SOPT4_FTM0TRG1SRC. */
#define BM_SIM_SOPT4_FTM0TRG1SRC (0x20000000U) /*!< Bit mask for SIM_SOPT4_FTM0TRG1SRC. */
#define BS_SIM_SOPT4_FTM0TRG1SRC (1U)      /*!< Bit field size in bits for SIM_SOPT4_FTM0TRG1SRC. */

/*! @brief Read current value of the SIM_SOPT4_FTM0TRG1SRC field. */
#define BR_SIM_SOPT4_FTM0TRG1SRC(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0TRG1SRC))

/*! @brief Format value for bitfield SIM_SOPT4_FTM0TRG1SRC. */
#define BF_SIM_SOPT4_FTM0TRG1SRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM0TRG1SRC) & BM_SIM_SOPT4_FTM0TRG1SRC)

/*! @brief Set the FTM0TRG1SRC field to a new value. */
#define BW_SIM_SOPT4_FTM0TRG1SRC(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM0TRG1SRC) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM3TRG0SRC[30] (RW)
 *
 * Selects the source of FTM3 hardware trigger 0.
 *
 * Values:
 * - 0 - Reserved
 * - 1 - FTM1 channel match drives FTM3 hardware trigger 0
 */
/*@{*/
#define BP_SIM_SOPT4_FTM3TRG0SRC (30U)     /*!< Bit position for SIM_SOPT4_FTM3TRG0SRC. */
#define BM_SIM_SOPT4_FTM3TRG0SRC (0x40000000U) /*!< Bit mask for SIM_SOPT4_FTM3TRG0SRC. */
#define BS_SIM_SOPT4_FTM3TRG0SRC (1U)      /*!< Bit field size in bits for SIM_SOPT4_FTM3TRG0SRC. */

/*! @brief Read current value of the SIM_SOPT4_FTM3TRG0SRC field. */
#define BR_SIM_SOPT4_FTM3TRG0SRC(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM3TRG0SRC))

/*! @brief Format value for bitfield SIM_SOPT4_FTM3TRG0SRC. */
#define BF_SIM_SOPT4_FTM3TRG0SRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM3TRG0SRC) & BM_SIM_SOPT4_FTM3TRG0SRC)

/*! @brief Set the FTM3TRG0SRC field to a new value. */
#define BW_SIM_SOPT4_FTM3TRG0SRC(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM3TRG0SRC) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM3TRG1SRC[31] (RW)
 *
 * Selects the source of FTM3 hardware trigger 1.
 *
 * Values:
 * - 0 - Reserved
 * - 1 - FTM2 channel match drives FTM3 hardware trigger 1
 */
/*@{*/
#define BP_SIM_SOPT4_FTM3TRG1SRC (31U)     /*!< Bit position for SIM_SOPT4_FTM3TRG1SRC. */
#define BM_SIM_SOPT4_FTM3TRG1SRC (0x80000000U) /*!< Bit mask for SIM_SOPT4_FTM3TRG1SRC. */
#define BS_SIM_SOPT4_FTM3TRG1SRC (1U)      /*!< Bit field size in bits for SIM_SOPT4_FTM3TRG1SRC. */

/*! @brief Read current value of the SIM_SOPT4_FTM3TRG1SRC field. */
#define BR_SIM_SOPT4_FTM3TRG1SRC(x) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM3TRG1SRC))

/*! @brief Format value for bitfield SIM_SOPT4_FTM3TRG1SRC. */
#define BF_SIM_SOPT4_FTM3TRG1SRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT4_FTM3TRG1SRC) & BM_SIM_SOPT4_FTM3TRG1SRC)

/*! @brief Set the FTM3TRG1SRC field to a new value. */
#define BW_SIM_SOPT4_FTM3TRG1SRC(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT4_ADDR(x), BP_SIM_SOPT4_FTM3TRG1SRC) = (v))
/*@}*/

/*******************************************************************************
 * HW_SIM_SOPT5 - System Options Register 5
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT5 - System Options Register 5 (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_sopt5
{
    uint32_t U;
    struct _hw_sim_sopt5_bitfields
    {
        uint32_t UART0TXSRC : 2;       /*!< [1:0] UART 0 transmit data source
                                        * select */
        uint32_t UART0RXSRC : 2;       /*!< [3:2] UART 0 receive data source select
                                        * */
        uint32_t UART1TXSRC : 2;       /*!< [5:4] UART 1 transmit data source
                                        * select */
        uint32_t UART1RXSRC : 2;       /*!< [7:6] UART 1 receive data source select
                                        * */
        uint32_t RESERVED0 : 24;       /*!< [31:8]  */
    } B;
} hw_sim_sopt5_t;

/*!
 * @name Constants and macros for entire SIM_SOPT5 register
 */
/*@{*/
#define HW_SIM_SOPT5_ADDR(x)     ((uint32_t)(x) + 0x1010U)

#define HW_SIM_SOPT5(x)          (*(__IO hw_sim_sopt5_t *) HW_SIM_SOPT5_ADDR(x))
#define HW_SIM_SOPT5_RD(x)       (HW_SIM_SOPT5(x).U)
#define HW_SIM_SOPT5_WR(x, v)    (HW_SIM_SOPT5(x).U = (v))
#define HW_SIM_SOPT5_SET(x, v)   (HW_SIM_SOPT5_WR(x, HW_SIM_SOPT5_RD(x) |  (v)))
#define HW_SIM_SOPT5_CLR(x, v)   (HW_SIM_SOPT5_WR(x, HW_SIM_SOPT5_RD(x) & ~(v)))
#define HW_SIM_SOPT5_TOG(x, v)   (HW_SIM_SOPT5_WR(x, HW_SIM_SOPT5_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT5 bitfields
 */

/*!
 * @name Register SIM_SOPT5, field UART0TXSRC[1:0] (RW)
 *
 * Selects the source for the UART 0 transmit data.
 *
 * Values:
 * - 00 - UART0_TX pin
 * - 01 - UART0_TX pin modulated with FTM1 channel 0 output
 * - 10 - UART0_TX pin modulated with FTM2 channel 0 output
 * - 11 - Reserved
 */
/*@{*/
#define BP_SIM_SOPT5_UART0TXSRC (0U)       /*!< Bit position for SIM_SOPT5_UART0TXSRC. */
#define BM_SIM_SOPT5_UART0TXSRC (0x00000003U) /*!< Bit mask for SIM_SOPT5_UART0TXSRC. */
#define BS_SIM_SOPT5_UART0TXSRC (2U)       /*!< Bit field size in bits for SIM_SOPT5_UART0TXSRC. */

/*! @brief Read current value of the SIM_SOPT5_UART0TXSRC field. */
#define BR_SIM_SOPT5_UART0TXSRC(x) (HW_SIM_SOPT5(x).B.UART0TXSRC)

/*! @brief Format value for bitfield SIM_SOPT5_UART0TXSRC. */
#define BF_SIM_SOPT5_UART0TXSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT5_UART0TXSRC) & BM_SIM_SOPT5_UART0TXSRC)

/*! @brief Set the UART0TXSRC field to a new value. */
#define BW_SIM_SOPT5_UART0TXSRC(x, v) (HW_SIM_SOPT5_WR(x, (HW_SIM_SOPT5_RD(x) & ~BM_SIM_SOPT5_UART0TXSRC) | BF_SIM_SOPT5_UART0TXSRC(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART0RXSRC[3:2] (RW)
 *
 * Selects the source for the UART 0 receive data.
 *
 * Values:
 * - 00 - UART0_RX pin
 * - 01 - CMP0
 * - 10 - CMP1
 * - 11 - Reserved
 */
/*@{*/
#define BP_SIM_SOPT5_UART0RXSRC (2U)       /*!< Bit position for SIM_SOPT5_UART0RXSRC. */
#define BM_SIM_SOPT5_UART0RXSRC (0x0000000CU) /*!< Bit mask for SIM_SOPT5_UART0RXSRC. */
#define BS_SIM_SOPT5_UART0RXSRC (2U)       /*!< Bit field size in bits for SIM_SOPT5_UART0RXSRC. */

/*! @brief Read current value of the SIM_SOPT5_UART0RXSRC field. */
#define BR_SIM_SOPT5_UART0RXSRC(x) (HW_SIM_SOPT5(x).B.UART0RXSRC)

/*! @brief Format value for bitfield SIM_SOPT5_UART0RXSRC. */
#define BF_SIM_SOPT5_UART0RXSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT5_UART0RXSRC) & BM_SIM_SOPT5_UART0RXSRC)

/*! @brief Set the UART0RXSRC field to a new value. */
#define BW_SIM_SOPT5_UART0RXSRC(x, v) (HW_SIM_SOPT5_WR(x, (HW_SIM_SOPT5_RD(x) & ~BM_SIM_SOPT5_UART0RXSRC) | BF_SIM_SOPT5_UART0RXSRC(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART1TXSRC[5:4] (RW)
 *
 * Selects the source for the UART 1 transmit data.
 *
 * Values:
 * - 00 - UART1_TX pin
 * - 01 - UART1_TX pin modulated with FTM1 channel 0 output
 * - 10 - UART1_TX pin modulated with FTM2 channel 0 output
 * - 11 - Reserved
 */
/*@{*/
#define BP_SIM_SOPT5_UART1TXSRC (4U)       /*!< Bit position for SIM_SOPT5_UART1TXSRC. */
#define BM_SIM_SOPT5_UART1TXSRC (0x00000030U) /*!< Bit mask for SIM_SOPT5_UART1TXSRC. */
#define BS_SIM_SOPT5_UART1TXSRC (2U)       /*!< Bit field size in bits for SIM_SOPT5_UART1TXSRC. */

/*! @brief Read current value of the SIM_SOPT5_UART1TXSRC field. */
#define BR_SIM_SOPT5_UART1TXSRC(x) (HW_SIM_SOPT5(x).B.UART1TXSRC)

/*! @brief Format value for bitfield SIM_SOPT5_UART1TXSRC. */
#define BF_SIM_SOPT5_UART1TXSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT5_UART1TXSRC) & BM_SIM_SOPT5_UART1TXSRC)

/*! @brief Set the UART1TXSRC field to a new value. */
#define BW_SIM_SOPT5_UART1TXSRC(x, v) (HW_SIM_SOPT5_WR(x, (HW_SIM_SOPT5_RD(x) & ~BM_SIM_SOPT5_UART1TXSRC) | BF_SIM_SOPT5_UART1TXSRC(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART1RXSRC[7:6] (RW)
 *
 * Selects the source for the UART 1 receive data.
 *
 * Values:
 * - 00 - UART1_RX pin
 * - 01 - CMP0
 * - 10 - CMP1
 * - 11 - Reserved
 */
/*@{*/
#define BP_SIM_SOPT5_UART1RXSRC (6U)       /*!< Bit position for SIM_SOPT5_UART1RXSRC. */
#define BM_SIM_SOPT5_UART1RXSRC (0x000000C0U) /*!< Bit mask for SIM_SOPT5_UART1RXSRC. */
#define BS_SIM_SOPT5_UART1RXSRC (2U)       /*!< Bit field size in bits for SIM_SOPT5_UART1RXSRC. */

/*! @brief Read current value of the SIM_SOPT5_UART1RXSRC field. */
#define BR_SIM_SOPT5_UART1RXSRC(x) (HW_SIM_SOPT5(x).B.UART1RXSRC)

/*! @brief Format value for bitfield SIM_SOPT5_UART1RXSRC. */
#define BF_SIM_SOPT5_UART1RXSRC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT5_UART1RXSRC) & BM_SIM_SOPT5_UART1RXSRC)

/*! @brief Set the UART1RXSRC field to a new value. */
#define BW_SIM_SOPT5_UART1RXSRC(x, v) (HW_SIM_SOPT5_WR(x, (HW_SIM_SOPT5_RD(x) & ~BM_SIM_SOPT5_UART1RXSRC) | BF_SIM_SOPT5_UART1RXSRC(v)))
/*@}*/

/*******************************************************************************
 * HW_SIM_SOPT7 - System Options Register 7
 ******************************************************************************/

/*!
 * @brief HW_SIM_SOPT7 - System Options Register 7 (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_sopt7
{
    uint32_t U;
    struct _hw_sim_sopt7_bitfields
    {
        uint32_t ADC0TRGSEL : 4;       /*!< [3:0] ADC0 trigger select */
        uint32_t ADC0PRETRGSEL : 1;    /*!< [4] ADC0 pretrigger select */
        uint32_t RESERVED0 : 2;        /*!< [6:5]  */
        uint32_t ADC0ALTTRGEN : 1;     /*!< [7] ADC0 alternate trigger enable */
        uint32_t ADC1TRGSEL : 4;       /*!< [11:8] ADC1 trigger select */
        uint32_t ADC1PRETRGSEL : 1;    /*!< [12] ADC1 pre-trigger select */
        uint32_t RESERVED1 : 2;        /*!< [14:13]  */
        uint32_t ADC1ALTTRGEN : 1;     /*!< [15] ADC1 alternate trigger enable */
        uint32_t RESERVED2 : 16;       /*!< [31:16]  */
    } B;
} hw_sim_sopt7_t;

/*!
 * @name Constants and macros for entire SIM_SOPT7 register
 */
/*@{*/
#define HW_SIM_SOPT7_ADDR(x)     ((uint32_t)(x) + 0x1018U)

#define HW_SIM_SOPT7(x)          (*(__IO hw_sim_sopt7_t *) HW_SIM_SOPT7_ADDR(x))
#define HW_SIM_SOPT7_RD(x)       (HW_SIM_SOPT7(x).U)
#define HW_SIM_SOPT7_WR(x, v)    (HW_SIM_SOPT7(x).U = (v))
#define HW_SIM_SOPT7_SET(x, v)   (HW_SIM_SOPT7_WR(x, HW_SIM_SOPT7_RD(x) |  (v)))
#define HW_SIM_SOPT7_CLR(x, v)   (HW_SIM_SOPT7_WR(x, HW_SIM_SOPT7_RD(x) & ~(v)))
#define HW_SIM_SOPT7_TOG(x, v)   (HW_SIM_SOPT7_WR(x, HW_SIM_SOPT7_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT7 bitfields
 */

/*!
 * @name Register SIM_SOPT7, field ADC0TRGSEL[3:0] (RW)
 *
 * Selects the ADC0 trigger source when alternative triggers are functional in
 * stop and VLPS modes. .
 *
 * Values:
 * - 0000 - PDB external trigger pin input (PDB0_EXTRG)
 * - 0001 - High speed comparator 0 output
 * - 0010 - High speed comparator 1 output
 * - 0011 - High speed comparator 2 output
 * - 0100 - PIT trigger 0
 * - 0101 - PIT trigger 1
 * - 0110 - PIT trigger 2
 * - 0111 - PIT trigger 3
 * - 1000 - FTM0 trigger
 * - 1001 - FTM1 trigger
 * - 1010 - FTM2 trigger
 * - 1011 - FTM3 trigger
 * - 1100 - RTC alarm
 * - 1101 - RTC seconds
 * - 1110 - Low-power timer (LPTMR) trigger
 * - 1111 - Reserved
 */
/*@{*/
#define BP_SIM_SOPT7_ADC0TRGSEL (0U)       /*!< Bit position for SIM_SOPT7_ADC0TRGSEL. */
#define BM_SIM_SOPT7_ADC0TRGSEL (0x0000000FU) /*!< Bit mask for SIM_SOPT7_ADC0TRGSEL. */
#define BS_SIM_SOPT7_ADC0TRGSEL (4U)       /*!< Bit field size in bits for SIM_SOPT7_ADC0TRGSEL. */

/*! @brief Read current value of the SIM_SOPT7_ADC0TRGSEL field. */
#define BR_SIM_SOPT7_ADC0TRGSEL(x) (HW_SIM_SOPT7(x).B.ADC0TRGSEL)

/*! @brief Format value for bitfield SIM_SOPT7_ADC0TRGSEL. */
#define BF_SIM_SOPT7_ADC0TRGSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT7_ADC0TRGSEL) & BM_SIM_SOPT7_ADC0TRGSEL)

/*! @brief Set the ADC0TRGSEL field to a new value. */
#define BW_SIM_SOPT7_ADC0TRGSEL(x, v) (HW_SIM_SOPT7_WR(x, (HW_SIM_SOPT7_RD(x) & ~BM_SIM_SOPT7_ADC0TRGSEL) | BF_SIM_SOPT7_ADC0TRGSEL(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0PRETRGSEL[4] (RW)
 *
 * Selects the ADC0 pre-trigger source when alternative triggers are enabled
 * through ADC0ALTTRGEN.
 *
 * Values:
 * - 0 - Pre-trigger A
 * - 1 - Pre-trigger B
 */
/*@{*/
#define BP_SIM_SOPT7_ADC0PRETRGSEL (4U)    /*!< Bit position for SIM_SOPT7_ADC0PRETRGSEL. */
#define BM_SIM_SOPT7_ADC0PRETRGSEL (0x00000010U) /*!< Bit mask for SIM_SOPT7_ADC0PRETRGSEL. */
#define BS_SIM_SOPT7_ADC0PRETRGSEL (1U)    /*!< Bit field size in bits for SIM_SOPT7_ADC0PRETRGSEL. */

/*! @brief Read current value of the SIM_SOPT7_ADC0PRETRGSEL field. */
#define BR_SIM_SOPT7_ADC0PRETRGSEL(x) (BITBAND_ACCESS32(HW_SIM_SOPT7_ADDR(x), BP_SIM_SOPT7_ADC0PRETRGSEL))

/*! @brief Format value for bitfield SIM_SOPT7_ADC0PRETRGSEL. */
#define BF_SIM_SOPT7_ADC0PRETRGSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT7_ADC0PRETRGSEL) & BM_SIM_SOPT7_ADC0PRETRGSEL)

/*! @brief Set the ADC0PRETRGSEL field to a new value. */
#define BW_SIM_SOPT7_ADC0PRETRGSEL(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT7_ADDR(x), BP_SIM_SOPT7_ADC0PRETRGSEL) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0ALTTRGEN[7] (RW)
 *
 * Enable alternative conversion triggers for ADC0.
 *
 * Values:
 * - 0 - PDB trigger selected for ADC0.
 * - 1 - Alternate trigger selected for ADC0.
 */
/*@{*/
#define BP_SIM_SOPT7_ADC0ALTTRGEN (7U)     /*!< Bit position for SIM_SOPT7_ADC0ALTTRGEN. */
#define BM_SIM_SOPT7_ADC0ALTTRGEN (0x00000080U) /*!< Bit mask for SIM_SOPT7_ADC0ALTTRGEN. */
#define BS_SIM_SOPT7_ADC0ALTTRGEN (1U)     /*!< Bit field size in bits for SIM_SOPT7_ADC0ALTTRGEN. */

/*! @brief Read current value of the SIM_SOPT7_ADC0ALTTRGEN field. */
#define BR_SIM_SOPT7_ADC0ALTTRGEN(x) (BITBAND_ACCESS32(HW_SIM_SOPT7_ADDR(x), BP_SIM_SOPT7_ADC0ALTTRGEN))

/*! @brief Format value for bitfield SIM_SOPT7_ADC0ALTTRGEN. */
#define BF_SIM_SOPT7_ADC0ALTTRGEN(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT7_ADC0ALTTRGEN) & BM_SIM_SOPT7_ADC0ALTTRGEN)

/*! @brief Set the ADC0ALTTRGEN field to a new value. */
#define BW_SIM_SOPT7_ADC0ALTTRGEN(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT7_ADDR(x), BP_SIM_SOPT7_ADC0ALTTRGEN) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC1TRGSEL[11:8] (RW)
 *
 * Selects the ADC1 trigger source when alternative triggers are functional in
 * stop and VLPS modes.
 *
 * Values:
 * - 0000 - PDB external trigger pin input (PDB0_EXTRG)
 * - 0001 - High speed comparator 0 output
 * - 0010 - High speed comparator 1 output
 * - 0011 - High speed comparator 2 output
 * - 0100 - PIT trigger 0
 * - 0101 - PIT trigger 1
 * - 0110 - PIT trigger 2
 * - 0111 - PIT trigger 3
 * - 1000 - FTM0 trigger
 * - 1001 - FTM1 trigger
 * - 1010 - FTM2 trigger
 * - 1011 - FTM3 trigger
 * - 1100 - RTC alarm
 * - 1101 - RTC seconds
 * - 1110 - Low-power timer (LPTMR) trigger
 * - 1111 - Reserved
 */
/*@{*/
#define BP_SIM_SOPT7_ADC1TRGSEL (8U)       /*!< Bit position for SIM_SOPT7_ADC1TRGSEL. */
#define BM_SIM_SOPT7_ADC1TRGSEL (0x00000F00U) /*!< Bit mask for SIM_SOPT7_ADC1TRGSEL. */
#define BS_SIM_SOPT7_ADC1TRGSEL (4U)       /*!< Bit field size in bits for SIM_SOPT7_ADC1TRGSEL. */

/*! @brief Read current value of the SIM_SOPT7_ADC1TRGSEL field. */
#define BR_SIM_SOPT7_ADC1TRGSEL(x) (HW_SIM_SOPT7(x).B.ADC1TRGSEL)

/*! @brief Format value for bitfield SIM_SOPT7_ADC1TRGSEL. */
#define BF_SIM_SOPT7_ADC1TRGSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT7_ADC1TRGSEL) & BM_SIM_SOPT7_ADC1TRGSEL)

/*! @brief Set the ADC1TRGSEL field to a new value. */
#define BW_SIM_SOPT7_ADC1TRGSEL(x, v) (HW_SIM_SOPT7_WR(x, (HW_SIM_SOPT7_RD(x) & ~BM_SIM_SOPT7_ADC1TRGSEL) | BF_SIM_SOPT7_ADC1TRGSEL(v)))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC1PRETRGSEL[12] (RW)
 *
 * Selects the ADC1 pre-trigger source when alternative triggers are enabled
 * through ADC1ALTTRGEN.
 *
 * Values:
 * - 0 - Pre-trigger A selected for ADC1.
 * - 1 - Pre-trigger B selected for ADC1.
 */
/*@{*/
#define BP_SIM_SOPT7_ADC1PRETRGSEL (12U)   /*!< Bit position for SIM_SOPT7_ADC1PRETRGSEL. */
#define BM_SIM_SOPT7_ADC1PRETRGSEL (0x00001000U) /*!< Bit mask for SIM_SOPT7_ADC1PRETRGSEL. */
#define BS_SIM_SOPT7_ADC1PRETRGSEL (1U)    /*!< Bit field size in bits for SIM_SOPT7_ADC1PRETRGSEL. */

/*! @brief Read current value of the SIM_SOPT7_ADC1PRETRGSEL field. */
#define BR_SIM_SOPT7_ADC1PRETRGSEL(x) (BITBAND_ACCESS32(HW_SIM_SOPT7_ADDR(x), BP_SIM_SOPT7_ADC1PRETRGSEL))

/*! @brief Format value for bitfield SIM_SOPT7_ADC1PRETRGSEL. */
#define BF_SIM_SOPT7_ADC1PRETRGSEL(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT7_ADC1PRETRGSEL) & BM_SIM_SOPT7_ADC1PRETRGSEL)

/*! @brief Set the ADC1PRETRGSEL field to a new value. */
#define BW_SIM_SOPT7_ADC1PRETRGSEL(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT7_ADDR(x), BP_SIM_SOPT7_ADC1PRETRGSEL) = (v))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC1ALTTRGEN[15] (RW)
 *
 * Enable alternative conversion triggers for ADC1.
 *
 * Values:
 * - 0 - PDB trigger selected for ADC1
 * - 1 - Alternate trigger selected for ADC1 as defined by ADC1TRGSEL.
 */
/*@{*/
#define BP_SIM_SOPT7_ADC1ALTTRGEN (15U)    /*!< Bit position for SIM_SOPT7_ADC1ALTTRGEN. */
#define BM_SIM_SOPT7_ADC1ALTTRGEN (0x00008000U) /*!< Bit mask for SIM_SOPT7_ADC1ALTTRGEN. */
#define BS_SIM_SOPT7_ADC1ALTTRGEN (1U)     /*!< Bit field size in bits for SIM_SOPT7_ADC1ALTTRGEN. */

/*! @brief Read current value of the SIM_SOPT7_ADC1ALTTRGEN field. */
#define BR_SIM_SOPT7_ADC1ALTTRGEN(x) (BITBAND_ACCESS32(HW_SIM_SOPT7_ADDR(x), BP_SIM_SOPT7_ADC1ALTTRGEN))

/*! @brief Format value for bitfield SIM_SOPT7_ADC1ALTTRGEN. */
#define BF_SIM_SOPT7_ADC1ALTTRGEN(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SOPT7_ADC1ALTTRGEN) & BM_SIM_SOPT7_ADC1ALTTRGEN)

/*! @brief Set the ADC1ALTTRGEN field to a new value. */
#define BW_SIM_SOPT7_ADC1ALTTRGEN(x, v) (BITBAND_ACCESS32(HW_SIM_SOPT7_ADDR(x), BP_SIM_SOPT7_ADC1ALTTRGEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_SIM_SDID - System Device Identification Register
 ******************************************************************************/

/*!
 * @brief HW_SIM_SDID - System Device Identification Register (RO)
 *
 * Reset value: 0x00000380U
 */
typedef union _hw_sim_sdid
{
    uint32_t U;
    struct _hw_sim_sdid_bitfields
    {
        uint32_t PINID : 4;            /*!< [3:0] Pincount identification */
        uint32_t FAMID : 3;            /*!< [6:4] Kinetis family identification */
        uint32_t DIEID : 5;            /*!< [11:7] Device Die ID */
        uint32_t REVID : 4;            /*!< [15:12] Device revision number */
        uint32_t RESERVED0 : 4;        /*!< [19:16]  */
        uint32_t SERIESID : 4;         /*!< [23:20] Kinetis Series ID */
        uint32_t SUBFAMID : 4;         /*!< [27:24] Kinetis Sub-Family ID */
        uint32_t FAMILYID : 4;         /*!< [31:28] Kinetis Family ID */
    } B;
} hw_sim_sdid_t;

/*!
 * @name Constants and macros for entire SIM_SDID register
 */
/*@{*/
#define HW_SIM_SDID_ADDR(x)      ((uint32_t)(x) + 0x1024U)

#define HW_SIM_SDID(x)           (*(__I hw_sim_sdid_t *) HW_SIM_SDID_ADDR(x))
#define HW_SIM_SDID_RD(x)        (HW_SIM_SDID(x).U)
/*@}*/

/*
 * Constants & macros for individual SIM_SDID bitfields
 */

/*!
 * @name Register SIM_SDID, field PINID[3:0] (RO)
 *
 * Specifies the pincount of the device.
 *
 * Values:
 * - 0000 - Reserved
 * - 0001 - Reserved
 * - 0010 - 32-pin
 * - 0011 - Reserved
 * - 0100 - 48-pin
 * - 0101 - 64-pin
 * - 0110 - 80-pin
 * - 0111 - 81-pin or 121-pin
 * - 1000 - 100-pin
 * - 1001 - 121-pin
 * - 1010 - 144-pin
 * - 1011 - Custom pinout (WLCSP)
 * - 1100 - 169-pin
 * - 1101 - Reserved
 * - 1110 - 256-pin
 * - 1111 - Reserved
 */
/*@{*/
#define BP_SIM_SDID_PINID    (0U)          /*!< Bit position for SIM_SDID_PINID. */
#define BM_SIM_SDID_PINID    (0x0000000FU) /*!< Bit mask for SIM_SDID_PINID. */
#define BS_SIM_SDID_PINID    (4U)          /*!< Bit field size in bits for SIM_SDID_PINID. */

/*! @brief Read current value of the SIM_SDID_PINID field. */
#define BR_SIM_SDID_PINID(x) (HW_SIM_SDID(x).B.PINID)
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMID[6:4] (RO)
 *
 * This field is maintained for compatibility only, but has been superceded by
 * the SERIESID, FAMILYID and SUBFAMID fields in this register.
 *
 * Values:
 * - 000 - K1x Family (without tamper)
 * - 001 - K2x Family (without tamper)
 * - 010 - K3x Family or K1x/K6x Family (with tamper)
 * - 011 - K4x Family or K2x Family (with tamper)
 * - 100 - K6x Family (without tamper)
 * - 101 - K7x Family
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
#define BP_SIM_SDID_FAMID    (4U)          /*!< Bit position for SIM_SDID_FAMID. */
#define BM_SIM_SDID_FAMID    (0x00000070U) /*!< Bit mask for SIM_SDID_FAMID. */
#define BS_SIM_SDID_FAMID    (3U)          /*!< Bit field size in bits for SIM_SDID_FAMID. */

/*! @brief Read current value of the SIM_SDID_FAMID field. */
#define BR_SIM_SDID_FAMID(x) (HW_SIM_SDID(x).B.FAMID)
/*@}*/

/*!
 * @name Register SIM_SDID, field DIEID[11:7] (RO)
 *
 * Specifies the silicon feature set identication number for the device.
 */
/*@{*/
#define BP_SIM_SDID_DIEID    (7U)          /*!< Bit position for SIM_SDID_DIEID. */
#define BM_SIM_SDID_DIEID    (0x00000F80U) /*!< Bit mask for SIM_SDID_DIEID. */
#define BS_SIM_SDID_DIEID    (5U)          /*!< Bit field size in bits for SIM_SDID_DIEID. */

/*! @brief Read current value of the SIM_SDID_DIEID field. */
#define BR_SIM_SDID_DIEID(x) (HW_SIM_SDID(x).B.DIEID)
/*@}*/

/*!
 * @name Register SIM_SDID, field REVID[15:12] (RO)
 *
 * Specifies the silicon implementation number for the device.
 */
/*@{*/
#define BP_SIM_SDID_REVID    (12U)         /*!< Bit position for SIM_SDID_REVID. */
#define BM_SIM_SDID_REVID    (0x0000F000U) /*!< Bit mask for SIM_SDID_REVID. */
#define BS_SIM_SDID_REVID    (4U)          /*!< Bit field size in bits for SIM_SDID_REVID. */

/*! @brief Read current value of the SIM_SDID_REVID field. */
#define BR_SIM_SDID_REVID(x) (HW_SIM_SDID(x).B.REVID)
/*@}*/

/*!
 * @name Register SIM_SDID, field SERIESID[23:20] (RO)
 *
 * Specifies the Kinetis series of the device.
 *
 * Values:
 * - 0000 - Kinetis K series
 * - 0001 - Kinetis L series
 * - 0101 - Kinetis W series
 * - 0110 - Kinetis V series
 */
/*@{*/
#define BP_SIM_SDID_SERIESID (20U)         /*!< Bit position for SIM_SDID_SERIESID. */
#define BM_SIM_SDID_SERIESID (0x00F00000U) /*!< Bit mask for SIM_SDID_SERIESID. */
#define BS_SIM_SDID_SERIESID (4U)          /*!< Bit field size in bits for SIM_SDID_SERIESID. */

/*! @brief Read current value of the SIM_SDID_SERIESID field. */
#define BR_SIM_SDID_SERIESID(x) (HW_SIM_SDID(x).B.SERIESID)
/*@}*/

/*!
 * @name Register SIM_SDID, field SUBFAMID[27:24] (RO)
 *
 * Specifies the Kinetis sub-family of the device.
 *
 * Values:
 * - 0000 - Kx0 Subfamily
 * - 0001 - Kx1 Subfamily (tamper detect)
 * - 0010 - Kx2 Subfamily
 * - 0011 - Kx3 Subfamily (tamper detect)
 * - 0100 - Kx4 Subfamily
 * - 0101 - Kx5 Subfamily (tamper detect)
 * - 0110 - Kx6 Subfamily
 */
/*@{*/
#define BP_SIM_SDID_SUBFAMID (24U)         /*!< Bit position for SIM_SDID_SUBFAMID. */
#define BM_SIM_SDID_SUBFAMID (0x0F000000U) /*!< Bit mask for SIM_SDID_SUBFAMID. */
#define BS_SIM_SDID_SUBFAMID (4U)          /*!< Bit field size in bits for SIM_SDID_SUBFAMID. */

/*! @brief Read current value of the SIM_SDID_SUBFAMID field. */
#define BR_SIM_SDID_SUBFAMID(x) (HW_SIM_SDID(x).B.SUBFAMID)
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMILYID[31:28] (RO)
 *
 * Specifies the Kinetis family of the device.
 *
 * Values:
 * - 0001 - K1x Family
 * - 0010 - K2x Family
 * - 0011 - K3x Family
 * - 0100 - K4x Family
 * - 0110 - K6x Family
 * - 0111 - K7x Family
 */
/*@{*/
#define BP_SIM_SDID_FAMILYID (28U)         /*!< Bit position for SIM_SDID_FAMILYID. */
#define BM_SIM_SDID_FAMILYID (0xF0000000U) /*!< Bit mask for SIM_SDID_FAMILYID. */
#define BS_SIM_SDID_FAMILYID (4U)          /*!< Bit field size in bits for SIM_SDID_FAMILYID. */

/*! @brief Read current value of the SIM_SDID_FAMILYID field. */
#define BR_SIM_SDID_FAMILYID(x) (HW_SIM_SDID(x).B.FAMILYID)
/*@}*/

/*******************************************************************************
 * HW_SIM_SCGC1 - System Clock Gating Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_SIM_SCGC1 - System Clock Gating Control Register 1 (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_scgc1
{
    uint32_t U;
    struct _hw_sim_scgc1_bitfields
    {
        uint32_t RESERVED0 : 6;        /*!< [5:0]  */
        uint32_t I2C2b : 1;            /*!< [6] I2C2 Clock Gate Control */
        uint32_t RESERVED1 : 3;        /*!< [9:7]  */
        uint32_t UART4b : 1;           /*!< [10] UART4 Clock Gate Control */
        uint32_t UART5b : 1;           /*!< [11] UART5 Clock Gate Control */
        uint32_t RESERVED2 : 20;       /*!< [31:12]  */
    } B;
} hw_sim_scgc1_t;

/*!
 * @name Constants and macros for entire SIM_SCGC1 register
 */
/*@{*/
#define HW_SIM_SCGC1_ADDR(x)     ((uint32_t)(x) + 0x1028U)

/* Unified clock gate bit access macros */
#define HW_SIM_SCGC_BIT_ADDR(x, n) (HW_SIM_SCGC1_ADDR(x) + ((((uint32_t)(n) >> 5) - 0U) * 4U))
#define BP_SIM_SCGC_BIT(n)         ((uint32_t)(n) & ((1U << 5) - 1U))
#define BW_SIM_SCGC_BIT(x, n, v)   (BITBAND_ACCESS32(HW_SIM_SCGC_BIT_ADDR((x), (n)), BP_SIM_SCGC_BIT(n)) = (uint32_t)(v))
#define BR_SIM_SCGC_BIT(x, n)      (BITBAND_ACCESS32(HW_SIM_SCGC_BIT_ADDR((x), (n)), BP_SIM_SCGC_BIT(n)))

#define HW_SIM_SCGC1(x)          (*(__IO hw_sim_scgc1_t *) HW_SIM_SCGC1_ADDR(x))
#define HW_SIM_SCGC1_RD(x)       (HW_SIM_SCGC1(x).U)
#define HW_SIM_SCGC1_WR(x, v)    (HW_SIM_SCGC1(x).U = (v))
#define HW_SIM_SCGC1_SET(x, v)   (HW_SIM_SCGC1_WR(x, HW_SIM_SCGC1_RD(x) |  (v)))
#define HW_SIM_SCGC1_CLR(x, v)   (HW_SIM_SCGC1_WR(x, HW_SIM_SCGC1_RD(x) & ~(v)))
#define HW_SIM_SCGC1_TOG(x, v)   (HW_SIM_SCGC1_WR(x, HW_SIM_SCGC1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC1 bitfields
 */

/*!
 * @name Register SIM_SCGC1, field I2C2[6] (RW)
 *
 * This bit controls the clock gate to the I2C2 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC1_I2C2    (6U)          /*!< Bit position for SIM_SCGC1_I2C2. */
#define BM_SIM_SCGC1_I2C2    (0x00000040U) /*!< Bit mask for SIM_SCGC1_I2C2. */
#define BS_SIM_SCGC1_I2C2    (1U)          /*!< Bit field size in bits for SIM_SCGC1_I2C2. */

/*! @brief Read current value of the SIM_SCGC1_I2C2 field. */
#define BR_SIM_SCGC1_I2C2(x) (BITBAND_ACCESS32(HW_SIM_SCGC1_ADDR(x), BP_SIM_SCGC1_I2C2))

/*! @brief Format value for bitfield SIM_SCGC1_I2C2. */
#define BF_SIM_SCGC1_I2C2(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC1_I2C2) & BM_SIM_SCGC1_I2C2)

/*! @brief Set the I2C2 field to a new value. */
#define BW_SIM_SCGC1_I2C2(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC1_ADDR(x), BP_SIM_SCGC1_I2C2) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC1, field UART4[10] (RW)
 *
 * This bit controls the clock gate to the UART4 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC1_UART4   (10U)         /*!< Bit position for SIM_SCGC1_UART4. */
#define BM_SIM_SCGC1_UART4   (0x00000400U) /*!< Bit mask for SIM_SCGC1_UART4. */
#define BS_SIM_SCGC1_UART4   (1U)          /*!< Bit field size in bits for SIM_SCGC1_UART4. */

/*! @brief Read current value of the SIM_SCGC1_UART4 field. */
#define BR_SIM_SCGC1_UART4(x) (BITBAND_ACCESS32(HW_SIM_SCGC1_ADDR(x), BP_SIM_SCGC1_UART4))

/*! @brief Format value for bitfield SIM_SCGC1_UART4. */
#define BF_SIM_SCGC1_UART4(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC1_UART4) & BM_SIM_SCGC1_UART4)

/*! @brief Set the UART4 field to a new value. */
#define BW_SIM_SCGC1_UART4(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC1_ADDR(x), BP_SIM_SCGC1_UART4) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC1, field UART5[11] (RW)
 *
 * This bit controls the clock gate to the UART5 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC1_UART5   (11U)         /*!< Bit position for SIM_SCGC1_UART5. */
#define BM_SIM_SCGC1_UART5   (0x00000800U) /*!< Bit mask for SIM_SCGC1_UART5. */
#define BS_SIM_SCGC1_UART5   (1U)          /*!< Bit field size in bits for SIM_SCGC1_UART5. */

/*! @brief Read current value of the SIM_SCGC1_UART5 field. */
#define BR_SIM_SCGC1_UART5(x) (BITBAND_ACCESS32(HW_SIM_SCGC1_ADDR(x), BP_SIM_SCGC1_UART5))

/*! @brief Format value for bitfield SIM_SCGC1_UART5. */
#define BF_SIM_SCGC1_UART5(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC1_UART5) & BM_SIM_SCGC1_UART5)

/*! @brief Set the UART5 field to a new value. */
#define BW_SIM_SCGC1_UART5(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC1_ADDR(x), BP_SIM_SCGC1_UART5) = (v))
/*@}*/

/*******************************************************************************
 * HW_SIM_SCGC2 - System Clock Gating Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_SIM_SCGC2 - System Clock Gating Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * DAC0 can be accessed through both AIPS0 and AIPS1. When accessing through
 * AIPS1, define the clock gate control bits in the SCGC2. When accessing through
 * AIPS0, define the clock gate control bits in SCGC6.
 */
typedef union _hw_sim_scgc2
{
    uint32_t U;
    struct _hw_sim_scgc2_bitfields
    {
        uint32_t ENETb : 1;            /*!< [0] ENET Clock Gate Control */
        uint32_t RESERVED0 : 11;       /*!< [11:1]  */
        uint32_t DAC0b : 1;            /*!< [12] DAC0 Clock Gate Control */
        uint32_t DAC1b : 1;            /*!< [13] DAC1 Clock Gate Control */
        uint32_t RESERVED1 : 18;       /*!< [31:14]  */
    } B;
} hw_sim_scgc2_t;

/*!
 * @name Constants and macros for entire SIM_SCGC2 register
 */
/*@{*/
#define HW_SIM_SCGC2_ADDR(x)     ((uint32_t)(x) + 0x102CU)

#define HW_SIM_SCGC2(x)          (*(__IO hw_sim_scgc2_t *) HW_SIM_SCGC2_ADDR(x))
#define HW_SIM_SCGC2_RD(x)       (HW_SIM_SCGC2(x).U)
#define HW_SIM_SCGC2_WR(x, v)    (HW_SIM_SCGC2(x).U = (v))
#define HW_SIM_SCGC2_SET(x, v)   (HW_SIM_SCGC2_WR(x, HW_SIM_SCGC2_RD(x) |  (v)))
#define HW_SIM_SCGC2_CLR(x, v)   (HW_SIM_SCGC2_WR(x, HW_SIM_SCGC2_RD(x) & ~(v)))
#define HW_SIM_SCGC2_TOG(x, v)   (HW_SIM_SCGC2_WR(x, HW_SIM_SCGC2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC2 bitfields
 */

/*!
 * @name Register SIM_SCGC2, field ENET[0] (RW)
 *
 * This bit controls the clock gate to the ENET module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC2_ENET    (0U)          /*!< Bit position for SIM_SCGC2_ENET. */
#define BM_SIM_SCGC2_ENET    (0x00000001U) /*!< Bit mask for SIM_SCGC2_ENET. */
#define BS_SIM_SCGC2_ENET    (1U)          /*!< Bit field size in bits for SIM_SCGC2_ENET. */

/*! @brief Read current value of the SIM_SCGC2_ENET field. */
#define BR_SIM_SCGC2_ENET(x) (BITBAND_ACCESS32(HW_SIM_SCGC2_ADDR(x), BP_SIM_SCGC2_ENET))

/*! @brief Format value for bitfield SIM_SCGC2_ENET. */
#define BF_SIM_SCGC2_ENET(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC2_ENET) & BM_SIM_SCGC2_ENET)

/*! @brief Set the ENET field to a new value. */
#define BW_SIM_SCGC2_ENET(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC2_ADDR(x), BP_SIM_SCGC2_ENET) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC2, field DAC0[12] (RW)
 *
 * This bit controls the clock gate to the DAC0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC2_DAC0    (12U)         /*!< Bit position for SIM_SCGC2_DAC0. */
#define BM_SIM_SCGC2_DAC0    (0x00001000U) /*!< Bit mask for SIM_SCGC2_DAC0. */
#define BS_SIM_SCGC2_DAC0    (1U)          /*!< Bit field size in bits for SIM_SCGC2_DAC0. */

/*! @brief Read current value of the SIM_SCGC2_DAC0 field. */
#define BR_SIM_SCGC2_DAC0(x) (BITBAND_ACCESS32(HW_SIM_SCGC2_ADDR(x), BP_SIM_SCGC2_DAC0))

/*! @brief Format value for bitfield SIM_SCGC2_DAC0. */
#define BF_SIM_SCGC2_DAC0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC2_DAC0) & BM_SIM_SCGC2_DAC0)

/*! @brief Set the DAC0 field to a new value. */
#define BW_SIM_SCGC2_DAC0(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC2_ADDR(x), BP_SIM_SCGC2_DAC0) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC2, field DAC1[13] (RW)
 *
 * This bit controls the clock gate to the DAC1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC2_DAC1    (13U)         /*!< Bit position for SIM_SCGC2_DAC1. */
#define BM_SIM_SCGC2_DAC1    (0x00002000U) /*!< Bit mask for SIM_SCGC2_DAC1. */
#define BS_SIM_SCGC2_DAC1    (1U)          /*!< Bit field size in bits for SIM_SCGC2_DAC1. */

/*! @brief Read current value of the SIM_SCGC2_DAC1 field. */
#define BR_SIM_SCGC2_DAC1(x) (BITBAND_ACCESS32(HW_SIM_SCGC2_ADDR(x), BP_SIM_SCGC2_DAC1))

/*! @brief Format value for bitfield SIM_SCGC2_DAC1. */
#define BF_SIM_SCGC2_DAC1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC2_DAC1) & BM_SIM_SCGC2_DAC1)

/*! @brief Set the DAC1 field to a new value. */
#define BW_SIM_SCGC2_DAC1(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC2_ADDR(x), BP_SIM_SCGC2_DAC1) = (v))
/*@}*/

/*******************************************************************************
 * HW_SIM_SCGC3 - System Clock Gating Control Register 3
 ******************************************************************************/

/*!
 * @brief HW_SIM_SCGC3 - System Clock Gating Control Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * FTM2 and RNGA can be accessed through both AIPS0 and AIPS1. When accessing
 * through AIPS1, define the clock gate control bits in the SCGC3. When accessing
 * through AIPS0, define the clock gate control bits in SCGC6.
 */
typedef union _hw_sim_scgc3
{
    uint32_t U;
    struct _hw_sim_scgc3_bitfields
    {
        uint32_t RNGA : 1;             /*!< [0] RNGA Clock Gate Control */
        uint32_t RESERVED0 : 11;       /*!< [11:1]  */
        uint32_t SPI2b : 1;            /*!< [12] SPI2 Clock Gate Control */
        uint32_t RESERVED1 : 4;        /*!< [16:13]  */
        uint32_t SDHCb : 1;            /*!< [17] SDHC Clock Gate Control */
        uint32_t RESERVED2 : 6;        /*!< [23:18]  */
        uint32_t FTM2b : 1;            /*!< [24] FTM2 Clock Gate Control */
        uint32_t FTM3b : 1;            /*!< [25] FTM3 Clock Gate Control */
        uint32_t RESERVED3 : 1;        /*!< [26]  */
        uint32_t ADC1b : 1;            /*!< [27] ADC1 Clock Gate Control */
        uint32_t RESERVED4 : 4;        /*!< [31:28]  */
    } B;
} hw_sim_scgc3_t;

/*!
 * @name Constants and macros for entire SIM_SCGC3 register
 */
/*@{*/
#define HW_SIM_SCGC3_ADDR(x)     ((uint32_t)(x) + 0x1030U)

#define HW_SIM_SCGC3(x)          (*(__IO hw_sim_scgc3_t *) HW_SIM_SCGC3_ADDR(x))
#define HW_SIM_SCGC3_RD(x)       (HW_SIM_SCGC3(x).U)
#define HW_SIM_SCGC3_WR(x, v)    (HW_SIM_SCGC3(x).U = (v))
#define HW_SIM_SCGC3_SET(x, v)   (HW_SIM_SCGC3_WR(x, HW_SIM_SCGC3_RD(x) |  (v)))
#define HW_SIM_SCGC3_CLR(x, v)   (HW_SIM_SCGC3_WR(x, HW_SIM_SCGC3_RD(x) & ~(v)))
#define HW_SIM_SCGC3_TOG(x, v)   (HW_SIM_SCGC3_WR(x, HW_SIM_SCGC3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC3 bitfields
 */

/*!
 * @name Register SIM_SCGC3, field RNGA[0] (RW)
 *
 * This bit controls the clock gate to the RNGA module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC3_RNGA    (0U)          /*!< Bit position for SIM_SCGC3_RNGA. */
#define BM_SIM_SCGC3_RNGA    (0x00000001U) /*!< Bit mask for SIM_SCGC3_RNGA. */
#define BS_SIM_SCGC3_RNGA    (1U)          /*!< Bit field size in bits for SIM_SCGC3_RNGA. */

/*! @brief Read current value of the SIM_SCGC3_RNGA field. */
#define BR_SIM_SCGC3_RNGA(x) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_RNGA))

/*! @brief Format value for bitfield SIM_SCGC3_RNGA. */
#define BF_SIM_SCGC3_RNGA(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC3_RNGA) & BM_SIM_SCGC3_RNGA)

/*! @brief Set the RNGA field to a new value. */
#define BW_SIM_SCGC3_RNGA(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_RNGA) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC3, field SPI2[12] (RW)
 *
 * This bit controls the clock gate to the SPI2 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC3_SPI2    (12U)         /*!< Bit position for SIM_SCGC3_SPI2. */
#define BM_SIM_SCGC3_SPI2    (0x00001000U) /*!< Bit mask for SIM_SCGC3_SPI2. */
#define BS_SIM_SCGC3_SPI2    (1U)          /*!< Bit field size in bits for SIM_SCGC3_SPI2. */

/*! @brief Read current value of the SIM_SCGC3_SPI2 field. */
#define BR_SIM_SCGC3_SPI2(x) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_SPI2))

/*! @brief Format value for bitfield SIM_SCGC3_SPI2. */
#define BF_SIM_SCGC3_SPI2(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC3_SPI2) & BM_SIM_SCGC3_SPI2)

/*! @brief Set the SPI2 field to a new value. */
#define BW_SIM_SCGC3_SPI2(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_SPI2) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC3, field SDHC[17] (RW)
 *
 * This bit controls the clock gate to the SDHC module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC3_SDHC    (17U)         /*!< Bit position for SIM_SCGC3_SDHC. */
#define BM_SIM_SCGC3_SDHC    (0x00020000U) /*!< Bit mask for SIM_SCGC3_SDHC. */
#define BS_SIM_SCGC3_SDHC    (1U)          /*!< Bit field size in bits for SIM_SCGC3_SDHC. */

/*! @brief Read current value of the SIM_SCGC3_SDHC field. */
#define BR_SIM_SCGC3_SDHC(x) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_SDHC))

/*! @brief Format value for bitfield SIM_SCGC3_SDHC. */
#define BF_SIM_SCGC3_SDHC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC3_SDHC) & BM_SIM_SCGC3_SDHC)

/*! @brief Set the SDHC field to a new value. */
#define BW_SIM_SCGC3_SDHC(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_SDHC) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC3, field FTM2[24] (RW)
 *
 * This bit controls the clock gate to the FTM2 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC3_FTM2    (24U)         /*!< Bit position for SIM_SCGC3_FTM2. */
#define BM_SIM_SCGC3_FTM2    (0x01000000U) /*!< Bit mask for SIM_SCGC3_FTM2. */
#define BS_SIM_SCGC3_FTM2    (1U)          /*!< Bit field size in bits for SIM_SCGC3_FTM2. */

/*! @brief Read current value of the SIM_SCGC3_FTM2 field. */
#define BR_SIM_SCGC3_FTM2(x) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_FTM2))

/*! @brief Format value for bitfield SIM_SCGC3_FTM2. */
#define BF_SIM_SCGC3_FTM2(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC3_FTM2) & BM_SIM_SCGC3_FTM2)

/*! @brief Set the FTM2 field to a new value. */
#define BW_SIM_SCGC3_FTM2(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_FTM2) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC3, field FTM3[25] (RW)
 *
 * This bit controls the clock gate to the FTM3 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC3_FTM3    (25U)         /*!< Bit position for SIM_SCGC3_FTM3. */
#define BM_SIM_SCGC3_FTM3    (0x02000000U) /*!< Bit mask for SIM_SCGC3_FTM3. */
#define BS_SIM_SCGC3_FTM3    (1U)          /*!< Bit field size in bits for SIM_SCGC3_FTM3. */

/*! @brief Read current value of the SIM_SCGC3_FTM3 field. */
#define BR_SIM_SCGC3_FTM3(x) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_FTM3))

/*! @brief Format value for bitfield SIM_SCGC3_FTM3. */
#define BF_SIM_SCGC3_FTM3(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC3_FTM3) & BM_SIM_SCGC3_FTM3)

/*! @brief Set the FTM3 field to a new value. */
#define BW_SIM_SCGC3_FTM3(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_FTM3) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC3, field ADC1[27] (RW)
 *
 * This bit controls the clock gate to the ADC1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC3_ADC1    (27U)         /*!< Bit position for SIM_SCGC3_ADC1. */
#define BM_SIM_SCGC3_ADC1    (0x08000000U) /*!< Bit mask for SIM_SCGC3_ADC1. */
#define BS_SIM_SCGC3_ADC1    (1U)          /*!< Bit field size in bits for SIM_SCGC3_ADC1. */

/*! @brief Read current value of the SIM_SCGC3_ADC1 field. */
#define BR_SIM_SCGC3_ADC1(x) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_ADC1))

/*! @brief Format value for bitfield SIM_SCGC3_ADC1. */
#define BF_SIM_SCGC3_ADC1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC3_ADC1) & BM_SIM_SCGC3_ADC1)

/*! @brief Set the ADC1 field to a new value. */
#define BW_SIM_SCGC3_ADC1(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC3_ADDR(x), BP_SIM_SCGC3_ADC1) = (v))
/*@}*/

/*******************************************************************************
 * HW_SIM_SCGC4 - System Clock Gating Control Register 4
 ******************************************************************************/

/*!
 * @brief HW_SIM_SCGC4 - System Clock Gating Control Register 4 (RW)
 *
 * Reset value: 0xF0100030U
 */
typedef union _hw_sim_scgc4
{
    uint32_t U;
    struct _hw_sim_scgc4_bitfields
    {
        uint32_t RESERVED0 : 1;        /*!< [0]  */
        uint32_t EWMb : 1;             /*!< [1] EWM Clock Gate Control */
        uint32_t CMTb : 1;             /*!< [2] CMT Clock Gate Control */
        uint32_t RESERVED1 : 3;        /*!< [5:3]  */
        uint32_t I2C0b : 1;            /*!< [6] I2C0 Clock Gate Control */
        uint32_t I2C1b : 1;            /*!< [7] I2C1 Clock Gate Control */
        uint32_t RESERVED2 : 2;        /*!< [9:8]  */
        uint32_t UART0b : 1;           /*!< [10] UART0 Clock Gate Control */
        uint32_t UART1b : 1;           /*!< [11] UART1 Clock Gate Control */
        uint32_t UART2b : 1;           /*!< [12] UART2 Clock Gate Control */
        uint32_t UART3b : 1;           /*!< [13] UART3 Clock Gate Control */
        uint32_t RESERVED3 : 4;        /*!< [17:14]  */
        uint32_t USBOTG : 1;           /*!< [18] USB Clock Gate Control */
        uint32_t CMP : 1;              /*!< [19] Comparator Clock Gate Control */
        uint32_t VREFb : 1;            /*!< [20] VREF Clock Gate Control */
        uint32_t RESERVED4 : 11;       /*!< [31:21]  */
    } B;
} hw_sim_scgc4_t;

/*!
 * @name Constants and macros for entire SIM_SCGC4 register
 */
/*@{*/
#define HW_SIM_SCGC4_ADDR(x)     ((uint32_t)(x) + 0x1034U)

#define HW_SIM_SCGC4(x)          (*(__IO hw_sim_scgc4_t *) HW_SIM_SCGC4_ADDR(x))
#define HW_SIM_SCGC4_RD(x)       (HW_SIM_SCGC4(x).U)
#define HW_SIM_SCGC4_WR(x, v)    (HW_SIM_SCGC4(x).U = (v))
#define HW_SIM_SCGC4_SET(x, v)   (HW_SIM_SCGC4_WR(x, HW_SIM_SCGC4_RD(x) |  (v)))
#define HW_SIM_SCGC4_CLR(x, v)   (HW_SIM_SCGC4_WR(x, HW_SIM_SCGC4_RD(x) & ~(v)))
#define HW_SIM_SCGC4_TOG(x, v)   (HW_SIM_SCGC4_WR(x, HW_SIM_SCGC4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC4 bitfields
 */

/*!
 * @name Register SIM_SCGC4, field EWM[1] (RW)
 *
 * This bit controls the clock gate to the EWM module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_EWM     (1U)          /*!< Bit position for SIM_SCGC4_EWM. */
#define BM_SIM_SCGC4_EWM     (0x00000002U) /*!< Bit mask for SIM_SCGC4_EWM. */
#define BS_SIM_SCGC4_EWM     (1U)          /*!< Bit field size in bits for SIM_SCGC4_EWM. */

/*! @brief Read current value of the SIM_SCGC4_EWM field. */
#define BR_SIM_SCGC4_EWM(x)  (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_EWM))

/*! @brief Format value for bitfield SIM_SCGC4_EWM. */
#define BF_SIM_SCGC4_EWM(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_EWM) & BM_SIM_SCGC4_EWM)

/*! @brief Set the EWM field to a new value. */
#define BW_SIM_SCGC4_EWM(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_EWM) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field CMT[2] (RW)
 *
 * This bit controls the clock gate to the CMT module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_CMT     (2U)          /*!< Bit position for SIM_SCGC4_CMT. */
#define BM_SIM_SCGC4_CMT     (0x00000004U) /*!< Bit mask for SIM_SCGC4_CMT. */
#define BS_SIM_SCGC4_CMT     (1U)          /*!< Bit field size in bits for SIM_SCGC4_CMT. */

/*! @brief Read current value of the SIM_SCGC4_CMT field. */
#define BR_SIM_SCGC4_CMT(x)  (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_CMT))

/*! @brief Format value for bitfield SIM_SCGC4_CMT. */
#define BF_SIM_SCGC4_CMT(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_CMT) & BM_SIM_SCGC4_CMT)

/*! @brief Set the CMT field to a new value. */
#define BW_SIM_SCGC4_CMT(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_CMT) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field I2C0[6] (RW)
 *
 * This bit controls the clock gate to the I 2 C0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_I2C0    (6U)          /*!< Bit position for SIM_SCGC4_I2C0. */
#define BM_SIM_SCGC4_I2C0    (0x00000040U) /*!< Bit mask for SIM_SCGC4_I2C0. */
#define BS_SIM_SCGC4_I2C0    (1U)          /*!< Bit field size in bits for SIM_SCGC4_I2C0. */

/*! @brief Read current value of the SIM_SCGC4_I2C0 field. */
#define BR_SIM_SCGC4_I2C0(x) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_I2C0))

/*! @brief Format value for bitfield SIM_SCGC4_I2C0. */
#define BF_SIM_SCGC4_I2C0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_I2C0) & BM_SIM_SCGC4_I2C0)

/*! @brief Set the I2C0 field to a new value. */
#define BW_SIM_SCGC4_I2C0(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_I2C0) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field I2C1[7] (RW)
 *
 * This bit controls the clock gate to the I 2 C1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_I2C1    (7U)          /*!< Bit position for SIM_SCGC4_I2C1. */
#define BM_SIM_SCGC4_I2C1    (0x00000080U) /*!< Bit mask for SIM_SCGC4_I2C1. */
#define BS_SIM_SCGC4_I2C1    (1U)          /*!< Bit field size in bits for SIM_SCGC4_I2C1. */

/*! @brief Read current value of the SIM_SCGC4_I2C1 field. */
#define BR_SIM_SCGC4_I2C1(x) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_I2C1))

/*! @brief Format value for bitfield SIM_SCGC4_I2C1. */
#define BF_SIM_SCGC4_I2C1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_I2C1) & BM_SIM_SCGC4_I2C1)

/*! @brief Set the I2C1 field to a new value. */
#define BW_SIM_SCGC4_I2C1(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_I2C1) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART0[10] (RW)
 *
 * This bit controls the clock gate to the UART0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_UART0   (10U)         /*!< Bit position for SIM_SCGC4_UART0. */
#define BM_SIM_SCGC4_UART0   (0x00000400U) /*!< Bit mask for SIM_SCGC4_UART0. */
#define BS_SIM_SCGC4_UART0   (1U)          /*!< Bit field size in bits for SIM_SCGC4_UART0. */

/*! @brief Read current value of the SIM_SCGC4_UART0 field. */
#define BR_SIM_SCGC4_UART0(x) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_UART0))

/*! @brief Format value for bitfield SIM_SCGC4_UART0. */
#define BF_SIM_SCGC4_UART0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_UART0) & BM_SIM_SCGC4_UART0)

/*! @brief Set the UART0 field to a new value. */
#define BW_SIM_SCGC4_UART0(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_UART0) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART1[11] (RW)
 *
 * This bit controls the clock gate to the UART1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_UART1   (11U)         /*!< Bit position for SIM_SCGC4_UART1. */
#define BM_SIM_SCGC4_UART1   (0x00000800U) /*!< Bit mask for SIM_SCGC4_UART1. */
#define BS_SIM_SCGC4_UART1   (1U)          /*!< Bit field size in bits for SIM_SCGC4_UART1. */

/*! @brief Read current value of the SIM_SCGC4_UART1 field. */
#define BR_SIM_SCGC4_UART1(x) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_UART1))

/*! @brief Format value for bitfield SIM_SCGC4_UART1. */
#define BF_SIM_SCGC4_UART1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_UART1) & BM_SIM_SCGC4_UART1)

/*! @brief Set the UART1 field to a new value. */
#define BW_SIM_SCGC4_UART1(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_UART1) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART2[12] (RW)
 *
 * This bit controls the clock gate to the UART2 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_UART2   (12U)         /*!< Bit position for SIM_SCGC4_UART2. */
#define BM_SIM_SCGC4_UART2   (0x00001000U) /*!< Bit mask for SIM_SCGC4_UART2. */
#define BS_SIM_SCGC4_UART2   (1U)          /*!< Bit field size in bits for SIM_SCGC4_UART2. */

/*! @brief Read current value of the SIM_SCGC4_UART2 field. */
#define BR_SIM_SCGC4_UART2(x) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_UART2))

/*! @brief Format value for bitfield SIM_SCGC4_UART2. */
#define BF_SIM_SCGC4_UART2(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_UART2) & BM_SIM_SCGC4_UART2)

/*! @brief Set the UART2 field to a new value. */
#define BW_SIM_SCGC4_UART2(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_UART2) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART3[13] (RW)
 *
 * This bit controls the clock gate to the UART3 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_UART3   (13U)         /*!< Bit position for SIM_SCGC4_UART3. */
#define BM_SIM_SCGC4_UART3   (0x00002000U) /*!< Bit mask for SIM_SCGC4_UART3. */
#define BS_SIM_SCGC4_UART3   (1U)          /*!< Bit field size in bits for SIM_SCGC4_UART3. */

/*! @brief Read current value of the SIM_SCGC4_UART3 field. */
#define BR_SIM_SCGC4_UART3(x) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_UART3))

/*! @brief Format value for bitfield SIM_SCGC4_UART3. */
#define BF_SIM_SCGC4_UART3(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_UART3) & BM_SIM_SCGC4_UART3)

/*! @brief Set the UART3 field to a new value. */
#define BW_SIM_SCGC4_UART3(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_UART3) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field USBOTG[18] (RW)
 *
 * This bit controls the clock gate to the USB module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_USBOTG  (18U)         /*!< Bit position for SIM_SCGC4_USBOTG. */
#define BM_SIM_SCGC4_USBOTG  (0x00040000U) /*!< Bit mask for SIM_SCGC4_USBOTG. */
#define BS_SIM_SCGC4_USBOTG  (1U)          /*!< Bit field size in bits for SIM_SCGC4_USBOTG. */

/*! @brief Read current value of the SIM_SCGC4_USBOTG field. */
#define BR_SIM_SCGC4_USBOTG(x) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_USBOTG))

/*! @brief Format value for bitfield SIM_SCGC4_USBOTG. */
#define BF_SIM_SCGC4_USBOTG(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_USBOTG) & BM_SIM_SCGC4_USBOTG)

/*! @brief Set the USBOTG field to a new value. */
#define BW_SIM_SCGC4_USBOTG(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_USBOTG) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field CMP[19] (RW)
 *
 * This bit controls the clock gate to the comparator module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_CMP     (19U)         /*!< Bit position for SIM_SCGC4_CMP. */
#define BM_SIM_SCGC4_CMP     (0x00080000U) /*!< Bit mask for SIM_SCGC4_CMP. */
#define BS_SIM_SCGC4_CMP     (1U)          /*!< Bit field size in bits for SIM_SCGC4_CMP. */

/*! @brief Read current value of the SIM_SCGC4_CMP field. */
#define BR_SIM_SCGC4_CMP(x)  (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_CMP))

/*! @brief Format value for bitfield SIM_SCGC4_CMP. */
#define BF_SIM_SCGC4_CMP(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_CMP) & BM_SIM_SCGC4_CMP)

/*! @brief Set the CMP field to a new value. */
#define BW_SIM_SCGC4_CMP(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_CMP) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field VREF[20] (RW)
 *
 * This bit controls the clock gate to the VREF module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC4_VREF    (20U)         /*!< Bit position for SIM_SCGC4_VREF. */
#define BM_SIM_SCGC4_VREF    (0x00100000U) /*!< Bit mask for SIM_SCGC4_VREF. */
#define BS_SIM_SCGC4_VREF    (1U)          /*!< Bit field size in bits for SIM_SCGC4_VREF. */

/*! @brief Read current value of the SIM_SCGC4_VREF field. */
#define BR_SIM_SCGC4_VREF(x) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_VREF))

/*! @brief Format value for bitfield SIM_SCGC4_VREF. */
#define BF_SIM_SCGC4_VREF(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC4_VREF) & BM_SIM_SCGC4_VREF)

/*! @brief Set the VREF field to a new value. */
#define BW_SIM_SCGC4_VREF(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC4_ADDR(x), BP_SIM_SCGC4_VREF) = (v))
/*@}*/

/*******************************************************************************
 * HW_SIM_SCGC5 - System Clock Gating Control Register 5
 ******************************************************************************/

/*!
 * @brief HW_SIM_SCGC5 - System Clock Gating Control Register 5 (RW)
 *
 * Reset value: 0x00040182U
 */
typedef union _hw_sim_scgc5
{
    uint32_t U;
    struct _hw_sim_scgc5_bitfields
    {
        uint32_t LPTMR : 1;            /*!< [0] Low Power Timer Access Control */
        uint32_t RESERVED0 : 8;        /*!< [8:1]  */
        uint32_t PORTAb : 1;           /*!< [9] Port A Clock Gate Control */
        uint32_t PORTBb : 1;           /*!< [10] Port B Clock Gate Control */
        uint32_t PORTCb : 1;           /*!< [11] Port C Clock Gate Control */
        uint32_t PORTDb : 1;           /*!< [12] Port D Clock Gate Control */
        uint32_t PORTEb : 1;           /*!< [13] Port E Clock Gate Control */
        uint32_t RESERVED1 : 18;       /*!< [31:14]  */
    } B;
} hw_sim_scgc5_t;

/*!
 * @name Constants and macros for entire SIM_SCGC5 register
 */
/*@{*/
#define HW_SIM_SCGC5_ADDR(x)     ((uint32_t)(x) + 0x1038U)

#define HW_SIM_SCGC5(x)          (*(__IO hw_sim_scgc5_t *) HW_SIM_SCGC5_ADDR(x))
#define HW_SIM_SCGC5_RD(x)       (HW_SIM_SCGC5(x).U)
#define HW_SIM_SCGC5_WR(x, v)    (HW_SIM_SCGC5(x).U = (v))
#define HW_SIM_SCGC5_SET(x, v)   (HW_SIM_SCGC5_WR(x, HW_SIM_SCGC5_RD(x) |  (v)))
#define HW_SIM_SCGC5_CLR(x, v)   (HW_SIM_SCGC5_WR(x, HW_SIM_SCGC5_RD(x) & ~(v)))
#define HW_SIM_SCGC5_TOG(x, v)   (HW_SIM_SCGC5_WR(x, HW_SIM_SCGC5_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC5 bitfields
 */

/*!
 * @name Register SIM_SCGC5, field LPTMR[0] (RW)
 *
 * This bit controls software access to the Low Power Timer module.
 *
 * Values:
 * - 0 - Access disabled
 * - 1 - Access enabled
 */
/*@{*/
#define BP_SIM_SCGC5_LPTMR   (0U)          /*!< Bit position for SIM_SCGC5_LPTMR. */
#define BM_SIM_SCGC5_LPTMR   (0x00000001U) /*!< Bit mask for SIM_SCGC5_LPTMR. */
#define BS_SIM_SCGC5_LPTMR   (1U)          /*!< Bit field size in bits for SIM_SCGC5_LPTMR. */

/*! @brief Read current value of the SIM_SCGC5_LPTMR field. */
#define BR_SIM_SCGC5_LPTMR(x) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_LPTMR))

/*! @brief Format value for bitfield SIM_SCGC5_LPTMR. */
#define BF_SIM_SCGC5_LPTMR(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_LPTMR) & BM_SIM_SCGC5_LPTMR)

/*! @brief Set the LPTMR field to a new value. */
#define BW_SIM_SCGC5_LPTMR(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_LPTMR) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTA[9] (RW)
 *
 * This bit controls the clock gate to the Port A module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_PORTA   (9U)          /*!< Bit position for SIM_SCGC5_PORTA. */
#define BM_SIM_SCGC5_PORTA   (0x00000200U) /*!< Bit mask for SIM_SCGC5_PORTA. */
#define BS_SIM_SCGC5_PORTA   (1U)          /*!< Bit field size in bits for SIM_SCGC5_PORTA. */

/*! @brief Read current value of the SIM_SCGC5_PORTA field. */
#define BR_SIM_SCGC5_PORTA(x) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTA))

/*! @brief Format value for bitfield SIM_SCGC5_PORTA. */
#define BF_SIM_SCGC5_PORTA(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_PORTA) & BM_SIM_SCGC5_PORTA)

/*! @brief Set the PORTA field to a new value. */
#define BW_SIM_SCGC5_PORTA(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTA) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTB[10] (RW)
 *
 * This bit controls the clock gate to the Port B module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_PORTB   (10U)         /*!< Bit position for SIM_SCGC5_PORTB. */
#define BM_SIM_SCGC5_PORTB   (0x00000400U) /*!< Bit mask for SIM_SCGC5_PORTB. */
#define BS_SIM_SCGC5_PORTB   (1U)          /*!< Bit field size in bits for SIM_SCGC5_PORTB. */

/*! @brief Read current value of the SIM_SCGC5_PORTB field. */
#define BR_SIM_SCGC5_PORTB(x) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTB))

/*! @brief Format value for bitfield SIM_SCGC5_PORTB. */
#define BF_SIM_SCGC5_PORTB(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_PORTB) & BM_SIM_SCGC5_PORTB)

/*! @brief Set the PORTB field to a new value. */
#define BW_SIM_SCGC5_PORTB(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTB) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTC[11] (RW)
 *
 * This bit controls the clock gate to the Port C module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_PORTC   (11U)         /*!< Bit position for SIM_SCGC5_PORTC. */
#define BM_SIM_SCGC5_PORTC   (0x00000800U) /*!< Bit mask for SIM_SCGC5_PORTC. */
#define BS_SIM_SCGC5_PORTC   (1U)          /*!< Bit field size in bits for SIM_SCGC5_PORTC. */

/*! @brief Read current value of the SIM_SCGC5_PORTC field. */
#define BR_SIM_SCGC5_PORTC(x) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTC))

/*! @brief Format value for bitfield SIM_SCGC5_PORTC. */
#define BF_SIM_SCGC5_PORTC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_PORTC) & BM_SIM_SCGC5_PORTC)

/*! @brief Set the PORTC field to a new value. */
#define BW_SIM_SCGC5_PORTC(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTC) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTD[12] (RW)
 *
 * This bit controls the clock gate to the Port D module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_PORTD   (12U)         /*!< Bit position for SIM_SCGC5_PORTD. */
#define BM_SIM_SCGC5_PORTD   (0x00001000U) /*!< Bit mask for SIM_SCGC5_PORTD. */
#define BS_SIM_SCGC5_PORTD   (1U)          /*!< Bit field size in bits for SIM_SCGC5_PORTD. */

/*! @brief Read current value of the SIM_SCGC5_PORTD field. */
#define BR_SIM_SCGC5_PORTD(x) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTD))

/*! @brief Format value for bitfield SIM_SCGC5_PORTD. */
#define BF_SIM_SCGC5_PORTD(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_PORTD) & BM_SIM_SCGC5_PORTD)

/*! @brief Set the PORTD field to a new value. */
#define BW_SIM_SCGC5_PORTD(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTD) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTE[13] (RW)
 *
 * This bit controls the clock gate to the Port E module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC5_PORTE   (13U)         /*!< Bit position for SIM_SCGC5_PORTE. */
#define BM_SIM_SCGC5_PORTE   (0x00002000U) /*!< Bit mask for SIM_SCGC5_PORTE. */
#define BS_SIM_SCGC5_PORTE   (1U)          /*!< Bit field size in bits for SIM_SCGC5_PORTE. */

/*! @brief Read current value of the SIM_SCGC5_PORTE field. */
#define BR_SIM_SCGC5_PORTE(x) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTE))

/*! @brief Format value for bitfield SIM_SCGC5_PORTE. */
#define BF_SIM_SCGC5_PORTE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC5_PORTE) & BM_SIM_SCGC5_PORTE)

/*! @brief Set the PORTE field to a new value. */
#define BW_SIM_SCGC5_PORTE(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC5_ADDR(x), BP_SIM_SCGC5_PORTE) = (v))
/*@}*/

/*******************************************************************************
 * HW_SIM_SCGC6 - System Clock Gating Control Register 6
 ******************************************************************************/

/*!
 * @brief HW_SIM_SCGC6 - System Clock Gating Control Register 6 (RW)
 *
 * Reset value: 0x40000001U
 *
 * DAC0, FTM2, and RNGA can be accessed through both AIPS0 and AIPS1. When
 * accessing through AIPS1, define the clock gate control bits in the SCGC2 and SCGC3.
 * When accessing through AIPS0, define the clock gate control bits in SCGC6.
 */
typedef union _hw_sim_scgc6
{
    uint32_t U;
    struct _hw_sim_scgc6_bitfields
    {
        uint32_t FTF : 1;              /*!< [0] Flash Memory Clock Gate Control */
        uint32_t DMAMUXb : 1;          /*!< [1] DMA Mux Clock Gate Control */
        uint32_t RESERVED0 : 2;        /*!< [3:2]  */
        uint32_t FLEXCAN0 : 1;         /*!< [4] FlexCAN0 Clock Gate Control */
        uint32_t RESERVED1 : 4;        /*!< [8:5]  */
        uint32_t RNGA : 1;             /*!< [9] RNGA Clock Gate Control */
        uint32_t RESERVED2 : 2;        /*!< [11:10]  */
        uint32_t SPI0b : 1;            /*!< [12] SPI0 Clock Gate Control */
        uint32_t SPI1b : 1;            /*!< [13] SPI1 Clock Gate Control */
        uint32_t RESERVED3 : 1;        /*!< [14]  */
        uint32_t I2S : 1;              /*!< [15] I2S Clock Gate Control */
        uint32_t RESERVED4 : 2;        /*!< [17:16]  */
        uint32_t CRC : 1;              /*!< [18] CRC Clock Gate Control */
        uint32_t RESERVED5 : 2;        /*!< [20:19]  */
        uint32_t USBDCDb : 1;          /*!< [21] USB DCD Clock Gate Control */
        uint32_t PDB : 1;              /*!< [22] PDB Clock Gate Control */
        uint32_t PITb : 1;             /*!< [23] PIT Clock Gate Control */
        uint32_t FTM0b : 1;            /*!< [24] FTM0 Clock Gate Control */
        uint32_t FTM1b : 1;            /*!< [25] FTM1 Clock Gate Control */
        uint32_t FTM2b : 1;            /*!< [26] FTM2 Clock Gate Control */
        uint32_t ADC0b : 1;            /*!< [27] ADC0 Clock Gate Control */
        uint32_t RESERVED6 : 1;        /*!< [28]  */
        uint32_t RTCb : 1;             /*!< [29] RTC Access Control */
        uint32_t RESERVED7 : 1;        /*!< [30]  */
        uint32_t DAC0b : 1;            /*!< [31] DAC0 Clock Gate Control */
    } B;
} hw_sim_scgc6_t;

/*!
 * @name Constants and macros for entire SIM_SCGC6 register
 */
/*@{*/
#define HW_SIM_SCGC6_ADDR(x)     ((uint32_t)(x) + 0x103CU)

#define HW_SIM_SCGC6(x)          (*(__IO hw_sim_scgc6_t *) HW_SIM_SCGC6_ADDR(x))
#define HW_SIM_SCGC6_RD(x)       (HW_SIM_SCGC6(x).U)
#define HW_SIM_SCGC6_WR(x, v)    (HW_SIM_SCGC6(x).U = (v))
#define HW_SIM_SCGC6_SET(x, v)   (HW_SIM_SCGC6_WR(x, HW_SIM_SCGC6_RD(x) |  (v)))
#define HW_SIM_SCGC6_CLR(x, v)   (HW_SIM_SCGC6_WR(x, HW_SIM_SCGC6_RD(x) & ~(v)))
#define HW_SIM_SCGC6_TOG(x, v)   (HW_SIM_SCGC6_WR(x, HW_SIM_SCGC6_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC6 bitfields
 */

/*!
 * @name Register SIM_SCGC6, field FTF[0] (RW)
 *
 * This bit controls the clock gate to the flash memory. Flash reads are still
 * supported while the flash memory is clock gated, but entry into low power modes
 * is blocked.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_FTF     (0U)          /*!< Bit position for SIM_SCGC6_FTF. */
#define BM_SIM_SCGC6_FTF     (0x00000001U) /*!< Bit mask for SIM_SCGC6_FTF. */
#define BS_SIM_SCGC6_FTF     (1U)          /*!< Bit field size in bits for SIM_SCGC6_FTF. */

/*! @brief Read current value of the SIM_SCGC6_FTF field. */
#define BR_SIM_SCGC6_FTF(x)  (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_FTF))

/*! @brief Format value for bitfield SIM_SCGC6_FTF. */
#define BF_SIM_SCGC6_FTF(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_FTF) & BM_SIM_SCGC6_FTF)

/*! @brief Set the FTF field to a new value. */
#define BW_SIM_SCGC6_FTF(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_FTF) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DMAMUX[1] (RW)
 *
 * This bit controls the clock gate to the DMA Mux module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_DMAMUX  (1U)          /*!< Bit position for SIM_SCGC6_DMAMUX. */
#define BM_SIM_SCGC6_DMAMUX  (0x00000002U) /*!< Bit mask for SIM_SCGC6_DMAMUX. */
#define BS_SIM_SCGC6_DMAMUX  (1U)          /*!< Bit field size in bits for SIM_SCGC6_DMAMUX. */

/*! @brief Read current value of the SIM_SCGC6_DMAMUX field. */
#define BR_SIM_SCGC6_DMAMUX(x) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_DMAMUX))

/*! @brief Format value for bitfield SIM_SCGC6_DMAMUX. */
#define BF_SIM_SCGC6_DMAMUX(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_DMAMUX) & BM_SIM_SCGC6_DMAMUX)

/*! @brief Set the DMAMUX field to a new value. */
#define BW_SIM_SCGC6_DMAMUX(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_DMAMUX) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FLEXCAN0[4] (RW)
 *
 * This bit controls the clock gate to the FlexCAN0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_FLEXCAN0 (4U)         /*!< Bit position for SIM_SCGC6_FLEXCAN0. */
#define BM_SIM_SCGC6_FLEXCAN0 (0x00000010U) /*!< Bit mask for SIM_SCGC6_FLEXCAN0. */
#define BS_SIM_SCGC6_FLEXCAN0 (1U)         /*!< Bit field size in bits for SIM_SCGC6_FLEXCAN0. */

/*! @brief Read current value of the SIM_SCGC6_FLEXCAN0 field. */
#define BR_SIM_SCGC6_FLEXCAN0(x) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_FLEXCAN0))

/*! @brief Format value for bitfield SIM_SCGC6_FLEXCAN0. */
#define BF_SIM_SCGC6_FLEXCAN0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_FLEXCAN0) & BM_SIM_SCGC6_FLEXCAN0)

/*! @brief Set the FLEXCAN0 field to a new value. */
#define BW_SIM_SCGC6_FLEXCAN0(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_FLEXCAN0) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field RNGA[9] (RW)
 *
 * This bit controls the clock gate to the RNGA module.
 */
/*@{*/
#define BP_SIM_SCGC6_RNGA    (9U)          /*!< Bit position for SIM_SCGC6_RNGA. */
#define BM_SIM_SCGC6_RNGA    (0x00000200U) /*!< Bit mask for SIM_SCGC6_RNGA. */
#define BS_SIM_SCGC6_RNGA    (1U)          /*!< Bit field size in bits for SIM_SCGC6_RNGA. */

/*! @brief Read current value of the SIM_SCGC6_RNGA field. */
#define BR_SIM_SCGC6_RNGA(x) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_RNGA))

/*! @brief Format value for bitfield SIM_SCGC6_RNGA. */
#define BF_SIM_SCGC6_RNGA(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_RNGA) & BM_SIM_SCGC6_RNGA)

/*! @brief Set the RNGA field to a new value. */
#define BW_SIM_SCGC6_RNGA(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_RNGA) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field SPI0[12] (RW)
 *
 * This bit controls the clock gate to the SPI0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_SPI0    (12U)         /*!< Bit position for SIM_SCGC6_SPI0. */
#define BM_SIM_SCGC6_SPI0    (0x00001000U) /*!< Bit mask for SIM_SCGC6_SPI0. */
#define BS_SIM_SCGC6_SPI0    (1U)          /*!< Bit field size in bits for SIM_SCGC6_SPI0. */

/*! @brief Read current value of the SIM_SCGC6_SPI0 field. */
#define BR_SIM_SCGC6_SPI0(x) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_SPI0))

/*! @brief Format value for bitfield SIM_SCGC6_SPI0. */
#define BF_SIM_SCGC6_SPI0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_SPI0) & BM_SIM_SCGC6_SPI0)

/*! @brief Set the SPI0 field to a new value. */
#define BW_SIM_SCGC6_SPI0(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_SPI0) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field SPI1[13] (RW)
 *
 * This bit controls the clock gate to the SPI1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_SPI1    (13U)         /*!< Bit position for SIM_SCGC6_SPI1. */
#define BM_SIM_SCGC6_SPI1    (0x00002000U) /*!< Bit mask for SIM_SCGC6_SPI1. */
#define BS_SIM_SCGC6_SPI1    (1U)          /*!< Bit field size in bits for SIM_SCGC6_SPI1. */

/*! @brief Read current value of the SIM_SCGC6_SPI1 field. */
#define BR_SIM_SCGC6_SPI1(x) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_SPI1))

/*! @brief Format value for bitfield SIM_SCGC6_SPI1. */
#define BF_SIM_SCGC6_SPI1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_SPI1) & BM_SIM_SCGC6_SPI1)

/*! @brief Set the SPI1 field to a new value. */
#define BW_SIM_SCGC6_SPI1(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_SPI1) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field I2S[15] (RW)
 *
 * This bit controls the clock gate to the I 2 S module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_I2S     (15U)         /*!< Bit position for SIM_SCGC6_I2S. */
#define BM_SIM_SCGC6_I2S     (0x00008000U) /*!< Bit mask for SIM_SCGC6_I2S. */
#define BS_SIM_SCGC6_I2S     (1U)          /*!< Bit field size in bits for SIM_SCGC6_I2S. */

/*! @brief Read current value of the SIM_SCGC6_I2S field. */
#define BR_SIM_SCGC6_I2S(x)  (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_I2S))

/*! @brief Format value for bitfield SIM_SCGC6_I2S. */
#define BF_SIM_SCGC6_I2S(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_I2S) & BM_SIM_SCGC6_I2S)

/*! @brief Set the I2S field to a new value. */
#define BW_SIM_SCGC6_I2S(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_I2S) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field CRC[18] (RW)
 *
 * This bit controls the clock gate to the CRC module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_CRC     (18U)         /*!< Bit position for SIM_SCGC6_CRC. */
#define BM_SIM_SCGC6_CRC     (0x00040000U) /*!< Bit mask for SIM_SCGC6_CRC. */
#define BS_SIM_SCGC6_CRC     (1U)          /*!< Bit field size in bits for SIM_SCGC6_CRC. */

/*! @brief Read current value of the SIM_SCGC6_CRC field. */
#define BR_SIM_SCGC6_CRC(x)  (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_CRC))

/*! @brief Format value for bitfield SIM_SCGC6_CRC. */
#define BF_SIM_SCGC6_CRC(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_CRC) & BM_SIM_SCGC6_CRC)

/*! @brief Set the CRC field to a new value. */
#define BW_SIM_SCGC6_CRC(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_CRC) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field USBDCD[21] (RW)
 *
 * This bit controls the clock gate to the USB DCD module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_USBDCD  (21U)         /*!< Bit position for SIM_SCGC6_USBDCD. */
#define BM_SIM_SCGC6_USBDCD  (0x00200000U) /*!< Bit mask for SIM_SCGC6_USBDCD. */
#define BS_SIM_SCGC6_USBDCD  (1U)          /*!< Bit field size in bits for SIM_SCGC6_USBDCD. */

/*! @brief Read current value of the SIM_SCGC6_USBDCD field. */
#define BR_SIM_SCGC6_USBDCD(x) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_USBDCD))

/*! @brief Format value for bitfield SIM_SCGC6_USBDCD. */
#define BF_SIM_SCGC6_USBDCD(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_USBDCD) & BM_SIM_SCGC6_USBDCD)

/*! @brief Set the USBDCD field to a new value. */
#define BW_SIM_SCGC6_USBDCD(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_USBDCD) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PDB[22] (RW)
 *
 * This bit controls the clock gate to the PDB module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_PDB     (22U)         /*!< Bit position for SIM_SCGC6_PDB. */
#define BM_SIM_SCGC6_PDB     (0x00400000U) /*!< Bit mask for SIM_SCGC6_PDB. */
#define BS_SIM_SCGC6_PDB     (1U)          /*!< Bit field size in bits for SIM_SCGC6_PDB. */

/*! @brief Read current value of the SIM_SCGC6_PDB field. */
#define BR_SIM_SCGC6_PDB(x)  (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_PDB))

/*! @brief Format value for bitfield SIM_SCGC6_PDB. */
#define BF_SIM_SCGC6_PDB(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_PDB) & BM_SIM_SCGC6_PDB)

/*! @brief Set the PDB field to a new value. */
#define BW_SIM_SCGC6_PDB(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_PDB) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PIT[23] (RW)
 *
 * This bit controls the clock gate to the PIT module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_PIT     (23U)         /*!< Bit position for SIM_SCGC6_PIT. */
#define BM_SIM_SCGC6_PIT     (0x00800000U) /*!< Bit mask for SIM_SCGC6_PIT. */
#define BS_SIM_SCGC6_PIT     (1U)          /*!< Bit field size in bits for SIM_SCGC6_PIT. */

/*! @brief Read current value of the SIM_SCGC6_PIT field. */
#define BR_SIM_SCGC6_PIT(x)  (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_PIT))

/*! @brief Format value for bitfield SIM_SCGC6_PIT. */
#define BF_SIM_SCGC6_PIT(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_PIT) & BM_SIM_SCGC6_PIT)

/*! @brief Set the PIT field to a new value. */
#define BW_SIM_SCGC6_PIT(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_PIT) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM0[24] (RW)
 *
 * This bit controls the clock gate to the FTM0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_FTM0    (24U)         /*!< Bit position for SIM_SCGC6_FTM0. */
#define BM_SIM_SCGC6_FTM0    (0x01000000U) /*!< Bit mask for SIM_SCGC6_FTM0. */
#define BS_SIM_SCGC6_FTM0    (1U)          /*!< Bit field size in bits for SIM_SCGC6_FTM0. */

/*! @brief Read current value of the SIM_SCGC6_FTM0 field. */
#define BR_SIM_SCGC6_FTM0(x) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_FTM0))

/*! @brief Format value for bitfield SIM_SCGC6_FTM0. */
#define BF_SIM_SCGC6_FTM0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_FTM0) & BM_SIM_SCGC6_FTM0)

/*! @brief Set the FTM0 field to a new value. */
#define BW_SIM_SCGC6_FTM0(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_FTM0) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM1[25] (RW)
 *
 * This bit controls the clock gate to the FTM1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_FTM1    (25U)         /*!< Bit position for SIM_SCGC6_FTM1. */
#define BM_SIM_SCGC6_FTM1    (0x02000000U) /*!< Bit mask for SIM_SCGC6_FTM1. */
#define BS_SIM_SCGC6_FTM1    (1U)          /*!< Bit field size in bits for SIM_SCGC6_FTM1. */

/*! @brief Read current value of the SIM_SCGC6_FTM1 field. */
#define BR_SIM_SCGC6_FTM1(x) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_FTM1))

/*! @brief Format value for bitfield SIM_SCGC6_FTM1. */
#define BF_SIM_SCGC6_FTM1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_FTM1) & BM_SIM_SCGC6_FTM1)

/*! @brief Set the FTM1 field to a new value. */
#define BW_SIM_SCGC6_FTM1(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_FTM1) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM2[26] (RW)
 *
 * This bit controls the clock gate to the FTM2 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_FTM2    (26U)         /*!< Bit position for SIM_SCGC6_FTM2. */
#define BM_SIM_SCGC6_FTM2    (0x04000000U) /*!< Bit mask for SIM_SCGC6_FTM2. */
#define BS_SIM_SCGC6_FTM2    (1U)          /*!< Bit field size in bits for SIM_SCGC6_FTM2. */

/*! @brief Read current value of the SIM_SCGC6_FTM2 field. */
#define BR_SIM_SCGC6_FTM2(x) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_FTM2))

/*! @brief Format value for bitfield SIM_SCGC6_FTM2. */
#define BF_SIM_SCGC6_FTM2(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_FTM2) & BM_SIM_SCGC6_FTM2)

/*! @brief Set the FTM2 field to a new value. */
#define BW_SIM_SCGC6_FTM2(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_FTM2) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field ADC0[27] (RW)
 *
 * This bit controls the clock gate to the ADC0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_ADC0    (27U)         /*!< Bit position for SIM_SCGC6_ADC0. */
#define BM_SIM_SCGC6_ADC0    (0x08000000U) /*!< Bit mask for SIM_SCGC6_ADC0. */
#define BS_SIM_SCGC6_ADC0    (1U)          /*!< Bit field size in bits for SIM_SCGC6_ADC0. */

/*! @brief Read current value of the SIM_SCGC6_ADC0 field. */
#define BR_SIM_SCGC6_ADC0(x) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_ADC0))

/*! @brief Format value for bitfield SIM_SCGC6_ADC0. */
#define BF_SIM_SCGC6_ADC0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_ADC0) & BM_SIM_SCGC6_ADC0)

/*! @brief Set the ADC0 field to a new value. */
#define BW_SIM_SCGC6_ADC0(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_ADC0) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field RTC[29] (RW)
 *
 * This bit controls software access and interrupts to the RTC module.
 *
 * Values:
 * - 0 - Access and interrupts disabled
 * - 1 - Access and interrupts enabled
 */
/*@{*/
#define BP_SIM_SCGC6_RTC     (29U)         /*!< Bit position for SIM_SCGC6_RTC. */
#define BM_SIM_SCGC6_RTC     (0x20000000U) /*!< Bit mask for SIM_SCGC6_RTC. */
#define BS_SIM_SCGC6_RTC     (1U)          /*!< Bit field size in bits for SIM_SCGC6_RTC. */

/*! @brief Read current value of the SIM_SCGC6_RTC field. */
#define BR_SIM_SCGC6_RTC(x)  (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_RTC))

/*! @brief Format value for bitfield SIM_SCGC6_RTC. */
#define BF_SIM_SCGC6_RTC(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_RTC) & BM_SIM_SCGC6_RTC)

/*! @brief Set the RTC field to a new value. */
#define BW_SIM_SCGC6_RTC(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_RTC) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DAC0[31] (RW)
 *
 * This bit controls the clock gate to the DAC0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC6_DAC0    (31U)         /*!< Bit position for SIM_SCGC6_DAC0. */
#define BM_SIM_SCGC6_DAC0    (0x80000000U) /*!< Bit mask for SIM_SCGC6_DAC0. */
#define BS_SIM_SCGC6_DAC0    (1U)          /*!< Bit field size in bits for SIM_SCGC6_DAC0. */

/*! @brief Read current value of the SIM_SCGC6_DAC0 field. */
#define BR_SIM_SCGC6_DAC0(x) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_DAC0))

/*! @brief Format value for bitfield SIM_SCGC6_DAC0. */
#define BF_SIM_SCGC6_DAC0(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC6_DAC0) & BM_SIM_SCGC6_DAC0)

/*! @brief Set the DAC0 field to a new value. */
#define BW_SIM_SCGC6_DAC0(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC6_ADDR(x), BP_SIM_SCGC6_DAC0) = (v))
/*@}*/

/*******************************************************************************
 * HW_SIM_SCGC7 - System Clock Gating Control Register 7
 ******************************************************************************/

/*!
 * @brief HW_SIM_SCGC7 - System Clock Gating Control Register 7 (RW)
 *
 * Reset value: 0x00000006U
 */
typedef union _hw_sim_scgc7
{
    uint32_t U;
    struct _hw_sim_scgc7_bitfields
    {
        uint32_t FLEXBUS : 1;          /*!< [0] FlexBus Clock Gate Control */
        uint32_t DMA : 1;              /*!< [1] DMA Clock Gate Control */
        uint32_t MPUb : 1;             /*!< [2] MPU Clock Gate Control */
        uint32_t RESERVED0 : 29;       /*!< [31:3]  */
    } B;
} hw_sim_scgc7_t;

/*!
 * @name Constants and macros for entire SIM_SCGC7 register
 */
/*@{*/
#define HW_SIM_SCGC7_ADDR(x)     ((uint32_t)(x) + 0x1040U)

#define HW_SIM_SCGC7(x)          (*(__IO hw_sim_scgc7_t *) HW_SIM_SCGC7_ADDR(x))
#define HW_SIM_SCGC7_RD(x)       (HW_SIM_SCGC7(x).U)
#define HW_SIM_SCGC7_WR(x, v)    (HW_SIM_SCGC7(x).U = (v))
#define HW_SIM_SCGC7_SET(x, v)   (HW_SIM_SCGC7_WR(x, HW_SIM_SCGC7_RD(x) |  (v)))
#define HW_SIM_SCGC7_CLR(x, v)   (HW_SIM_SCGC7_WR(x, HW_SIM_SCGC7_RD(x) & ~(v)))
#define HW_SIM_SCGC7_TOG(x, v)   (HW_SIM_SCGC7_WR(x, HW_SIM_SCGC7_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC7 bitfields
 */

/*!
 * @name Register SIM_SCGC7, field FLEXBUS[0] (RW)
 *
 * This bit controls the clock gate to the FlexBus module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC7_FLEXBUS (0U)          /*!< Bit position for SIM_SCGC7_FLEXBUS. */
#define BM_SIM_SCGC7_FLEXBUS (0x00000001U) /*!< Bit mask for SIM_SCGC7_FLEXBUS. */
#define BS_SIM_SCGC7_FLEXBUS (1U)          /*!< Bit field size in bits for SIM_SCGC7_FLEXBUS. */

/*! @brief Read current value of the SIM_SCGC7_FLEXBUS field. */
#define BR_SIM_SCGC7_FLEXBUS(x) (BITBAND_ACCESS32(HW_SIM_SCGC7_ADDR(x), BP_SIM_SCGC7_FLEXBUS))

/*! @brief Format value for bitfield SIM_SCGC7_FLEXBUS. */
#define BF_SIM_SCGC7_FLEXBUS(v) ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC7_FLEXBUS) & BM_SIM_SCGC7_FLEXBUS)

/*! @brief Set the FLEXBUS field to a new value. */
#define BW_SIM_SCGC7_FLEXBUS(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC7_ADDR(x), BP_SIM_SCGC7_FLEXBUS) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC7, field DMA[1] (RW)
 *
 * This bit controls the clock gate to the DMA module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC7_DMA     (1U)          /*!< Bit position for SIM_SCGC7_DMA. */
#define BM_SIM_SCGC7_DMA     (0x00000002U) /*!< Bit mask for SIM_SCGC7_DMA. */
#define BS_SIM_SCGC7_DMA     (1U)          /*!< Bit field size in bits for SIM_SCGC7_DMA. */

/*! @brief Read current value of the SIM_SCGC7_DMA field. */
#define BR_SIM_SCGC7_DMA(x)  (BITBAND_ACCESS32(HW_SIM_SCGC7_ADDR(x), BP_SIM_SCGC7_DMA))

/*! @brief Format value for bitfield SIM_SCGC7_DMA. */
#define BF_SIM_SCGC7_DMA(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC7_DMA) & BM_SIM_SCGC7_DMA)

/*! @brief Set the DMA field to a new value. */
#define BW_SIM_SCGC7_DMA(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC7_ADDR(x), BP_SIM_SCGC7_DMA) = (v))
/*@}*/

/*!
 * @name Register SIM_SCGC7, field MPU[2] (RW)
 *
 * This bit controls the clock gate to the MPU module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
#define BP_SIM_SCGC7_MPU     (2U)          /*!< Bit position for SIM_SCGC7_MPU. */
#define BM_SIM_SCGC7_MPU     (0x00000004U) /*!< Bit mask for SIM_SCGC7_MPU. */
#define BS_SIM_SCGC7_MPU     (1U)          /*!< Bit field size in bits for SIM_SCGC7_MPU. */

/*! @brief Read current value of the SIM_SCGC7_MPU field. */
#define BR_SIM_SCGC7_MPU(x)  (BITBAND_ACCESS32(HW_SIM_SCGC7_ADDR(x), BP_SIM_SCGC7_MPU))

/*! @brief Format value for bitfield SIM_SCGC7_MPU. */
#define BF_SIM_SCGC7_MPU(v)  ((uint32_t)((uint32_t)(v) << BP_SIM_SCGC7_MPU) & BM_SIM_SCGC7_MPU)

/*! @brief Set the MPU field to a new value. */
#define BW_SIM_SCGC7_MPU(x, v) (BITBAND_ACCESS32(HW_SIM_SCGC7_ADDR(x), BP_SIM_SCGC7_MPU) = (v))
/*@}*/

/*******************************************************************************
 * HW_SIM_CLKDIV1 - System Clock Divider Register 1
 ******************************************************************************/

/*!
 * @brief HW_SIM_CLKDIV1 - System Clock Divider Register 1 (RW)
 *
 * Reset value: 0x00010000U
 *
 * When updating CLKDIV1, update all fields using the one write command.
 * Attempting to write an invalid clock ratio to the CLKDIV1 register will cause the
 * write to be ignored. The maximum divide ratio that can be programmed between
 * core/system clock and the other divided clocks is divide by 8. When OUTDIV1 equals
 * 0000 (divide by 1), the other dividers cannot be set higher than 0111 (divide
 * by 8). The CLKDIV1 register cannot be written to when the device is in VLPR
 * mode.
 */
typedef union _hw_sim_clkdiv1
{
    uint32_t U;
    struct _hw_sim_clkdiv1_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t OUTDIV4 : 4;          /*!< [19:16] Clock 4 output divider value */
        uint32_t OUTDIV3 : 4;          /*!< [23:20] Clock 3 output divider value */
        uint32_t OUTDIV2 : 4;          /*!< [27:24] Clock 2 output divider value */
        uint32_t OUTDIV1 : 4;          /*!< [31:28] Clock 1 output divider value */
    } B;
} hw_sim_clkdiv1_t;

/*!
 * @name Constants and macros for entire SIM_CLKDIV1 register
 */
/*@{*/
#define HW_SIM_CLKDIV1_ADDR(x)   ((uint32_t)(x) + 0x1044U)

#define HW_SIM_CLKDIV1(x)        (*(__IO hw_sim_clkdiv1_t *) HW_SIM_CLKDIV1_ADDR(x))
#define HW_SIM_CLKDIV1_RD(x)     (HW_SIM_CLKDIV1(x).U)
#define HW_SIM_CLKDIV1_WR(x, v)  (HW_SIM_CLKDIV1(x).U = (v))
#define HW_SIM_CLKDIV1_SET(x, v) (HW_SIM_CLKDIV1_WR(x, HW_SIM_CLKDIV1_RD(x) |  (v)))
#define HW_SIM_CLKDIV1_CLR(x, v) (HW_SIM_CLKDIV1_WR(x, HW_SIM_CLKDIV1_RD(x) & ~(v)))
#define HW_SIM_CLKDIV1_TOG(x, v) (HW_SIM_CLKDIV1_WR(x, HW_SIM_CLKDIV1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV1 bitfields
 */

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV4[19:16] (RW)
 *
 * This field sets the divide value for the flash clock from MCGOUTCLK. At the
 * end of reset, it is loaded with either 0001 or 1111 depending on
 * FTF_FOPT[LPBOOT]. The flash clock frequency must be an integer divide of the system clock
 * frequency.
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
#define BP_SIM_CLKDIV1_OUTDIV4 (16U)       /*!< Bit position for SIM_CLKDIV1_OUTDIV4. */
#define BM_SIM_CLKDIV1_OUTDIV4 (0x000F0000U) /*!< Bit mask for SIM_CLKDIV1_OUTDIV4. */
#define BS_SIM_CLKDIV1_OUTDIV4 (4U)        /*!< Bit field size in bits for SIM_CLKDIV1_OUTDIV4. */

/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV4 field. */
#define BR_SIM_CLKDIV1_OUTDIV4(x) (HW_SIM_CLKDIV1(x).B.OUTDIV4)

/*! @brief Format value for bitfield SIM_CLKDIV1_OUTDIV4. */
#define BF_SIM_CLKDIV1_OUTDIV4(v) ((uint32_t)((uint32_t)(v) << BP_SIM_CLKDIV1_OUTDIV4) & BM_SIM_CLKDIV1_OUTDIV4)

/*! @brief Set the OUTDIV4 field to a new value. */
#define BW_SIM_CLKDIV1_OUTDIV4(x, v) (HW_SIM_CLKDIV1_WR(x, (HW_SIM_CLKDIV1_RD(x) & ~BM_SIM_CLKDIV1_OUTDIV4) | BF_SIM_CLKDIV1_OUTDIV4(v)))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV3[23:20] (RW)
 *
 * This field sets the divide value for the FlexBus clock (external pin FB_CLK)
 * from MCGOUTCLK. At the end of reset, it is loaded with either 0001 or 1111
 * depending on FTF_FOPT[LPBOOT]. The FlexBus clock frequency must be an integer
 * divide of the system clock frequency.
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
#define BP_SIM_CLKDIV1_OUTDIV3 (20U)       /*!< Bit position for SIM_CLKDIV1_OUTDIV3. */
#define BM_SIM_CLKDIV1_OUTDIV3 (0x00F00000U) /*!< Bit mask for SIM_CLKDIV1_OUTDIV3. */
#define BS_SIM_CLKDIV1_OUTDIV3 (4U)        /*!< Bit field size in bits for SIM_CLKDIV1_OUTDIV3. */

/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV3 field. */
#define BR_SIM_CLKDIV1_OUTDIV3(x) (HW_SIM_CLKDIV1(x).B.OUTDIV3)

/*! @brief Format value for bitfield SIM_CLKDIV1_OUTDIV3. */
#define BF_SIM_CLKDIV1_OUTDIV3(v) ((uint32_t)((uint32_t)(v) << BP_SIM_CLKDIV1_OUTDIV3) & BM_SIM_CLKDIV1_OUTDIV3)

/*! @brief Set the OUTDIV3 field to a new value. */
#define BW_SIM_CLKDIV1_OUTDIV3(x, v) (HW_SIM_CLKDIV1_WR(x, (HW_SIM_CLKDIV1_RD(x) & ~BM_SIM_CLKDIV1_OUTDIV3) | BF_SIM_CLKDIV1_OUTDIV3(v)))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV2[27:24] (RW)
 *
 * This field sets the divide value for the bus clock from MCGOUTCLK. At the end
 * of reset, it is loaded with either 0000 or 0111 depending on
 * FTF_FOPT[LPBOOT]. The bus clock frequency must be an integer divide of the core/system clock
 * frequency.
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
#define BP_SIM_CLKDIV1_OUTDIV2 (24U)       /*!< Bit position for SIM_CLKDIV1_OUTDIV2. */
#define BM_SIM_CLKDIV1_OUTDIV2 (0x0F000000U) /*!< Bit mask for SIM_CLKDIV1_OUTDIV2. */
#define BS_SIM_CLKDIV1_OUTDIV2 (4U)        /*!< Bit field size in bits for SIM_CLKDIV1_OUTDIV2. */

/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV2 field. */
#define BR_SIM_CLKDIV1_OUTDIV2(x) (HW_SIM_CLKDIV1(x).B.OUTDIV2)

/*! @brief Format value for bitfield SIM_CLKDIV1_OUTDIV2. */
#define BF_SIM_CLKDIV1_OUTDIV2(v) ((uint32_t)((uint32_t)(v) << BP_SIM_CLKDIV1_OUTDIV2) & BM_SIM_CLKDIV1_OUTDIV2)

/*! @brief Set the OUTDIV2 field to a new value. */
#define BW_SIM_CLKDIV1_OUTDIV2(x, v) (HW_SIM_CLKDIV1_WR(x, (HW_SIM_CLKDIV1_RD(x) & ~BM_SIM_CLKDIV1_OUTDIV2) | BF_SIM_CLKDIV1_OUTDIV2(v)))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV1[31:28] (RW)
 *
 * This field sets the divide value for the core/system clock from MCGOUTCLK. At
 * the end of reset, it is loaded with either 0000 or 0111 depending on
 * FTF_FOPT[LPBOOT].
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
#define BP_SIM_CLKDIV1_OUTDIV1 (28U)       /*!< Bit position for SIM_CLKDIV1_OUTDIV1. */
#define BM_SIM_CLKDIV1_OUTDIV1 (0xF0000000U) /*!< Bit mask for SIM_CLKDIV1_OUTDIV1. */
#define BS_SIM_CLKDIV1_OUTDIV1 (4U)        /*!< Bit field size in bits for SIM_CLKDIV1_OUTDIV1. */

/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV1 field. */
#define BR_SIM_CLKDIV1_OUTDIV1(x) (HW_SIM_CLKDIV1(x).B.OUTDIV1)

/*! @brief Format value for bitfield SIM_CLKDIV1_OUTDIV1. */
#define BF_SIM_CLKDIV1_OUTDIV1(v) ((uint32_t)((uint32_t)(v) << BP_SIM_CLKDIV1_OUTDIV1) & BM_SIM_CLKDIV1_OUTDIV1)

/*! @brief Set the OUTDIV1 field to a new value. */
#define BW_SIM_CLKDIV1_OUTDIV1(x, v) (HW_SIM_CLKDIV1_WR(x, (HW_SIM_CLKDIV1_RD(x) & ~BM_SIM_CLKDIV1_OUTDIV1) | BF_SIM_CLKDIV1_OUTDIV1(v)))
/*@}*/

/*******************************************************************************
 * HW_SIM_CLKDIV2 - System Clock Divider Register 2
 ******************************************************************************/

/*!
 * @brief HW_SIM_CLKDIV2 - System Clock Divider Register 2 (RW)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_clkdiv2
{
    uint32_t U;
    struct _hw_sim_clkdiv2_bitfields
    {
        uint32_t USBFRAC : 1;          /*!< [0] USB clock divider fraction */
        uint32_t USBDIV : 3;           /*!< [3:1] USB clock divider divisor */
        uint32_t RESERVED0 : 28;       /*!< [31:4]  */
    } B;
} hw_sim_clkdiv2_t;

/*!
 * @name Constants and macros for entire SIM_CLKDIV2 register
 */
/*@{*/
#define HW_SIM_CLKDIV2_ADDR(x)   ((uint32_t)(x) + 0x1048U)

#define HW_SIM_CLKDIV2(x)        (*(__IO hw_sim_clkdiv2_t *) HW_SIM_CLKDIV2_ADDR(x))
#define HW_SIM_CLKDIV2_RD(x)     (HW_SIM_CLKDIV2(x).U)
#define HW_SIM_CLKDIV2_WR(x, v)  (HW_SIM_CLKDIV2(x).U = (v))
#define HW_SIM_CLKDIV2_SET(x, v) (HW_SIM_CLKDIV2_WR(x, HW_SIM_CLKDIV2_RD(x) |  (v)))
#define HW_SIM_CLKDIV2_CLR(x, v) (HW_SIM_CLKDIV2_WR(x, HW_SIM_CLKDIV2_RD(x) & ~(v)))
#define HW_SIM_CLKDIV2_TOG(x, v) (HW_SIM_CLKDIV2_WR(x, HW_SIM_CLKDIV2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV2 bitfields
 */

/*!
 * @name Register SIM_CLKDIV2, field USBFRAC[0] (RW)
 *
 * This field sets the fraction multiply value for the fractional clock divider
 * when the MCGFLLCLK/MCGPLLCLK clock is the USB clock source (SOPT2[USBSRC] =
 * 1). Divider output clock = Divider input clock * [ (USBFRAC+1) / (USBDIV+1) ]
 */
/*@{*/
#define BP_SIM_CLKDIV2_USBFRAC (0U)        /*!< Bit position for SIM_CLKDIV2_USBFRAC. */
#define BM_SIM_CLKDIV2_USBFRAC (0x00000001U) /*!< Bit mask for SIM_CLKDIV2_USBFRAC. */
#define BS_SIM_CLKDIV2_USBFRAC (1U)        /*!< Bit field size in bits for SIM_CLKDIV2_USBFRAC. */

/*! @brief Read current value of the SIM_CLKDIV2_USBFRAC field. */
#define BR_SIM_CLKDIV2_USBFRAC(x) (BITBAND_ACCESS32(HW_SIM_CLKDIV2_ADDR(x), BP_SIM_CLKDIV2_USBFRAC))

/*! @brief Format value for bitfield SIM_CLKDIV2_USBFRAC. */
#define BF_SIM_CLKDIV2_USBFRAC(v) ((uint32_t)((uint32_t)(v) << BP_SIM_CLKDIV2_USBFRAC) & BM_SIM_CLKDIV2_USBFRAC)

/*! @brief Set the USBFRAC field to a new value. */
#define BW_SIM_CLKDIV2_USBFRAC(x, v) (BITBAND_ACCESS32(HW_SIM_CLKDIV2_ADDR(x), BP_SIM_CLKDIV2_USBFRAC) = (v))
/*@}*/

/*!
 * @name Register SIM_CLKDIV2, field USBDIV[3:1] (RW)
 *
 * This field sets the divide value for the fractional clock divider when the
 * MCGFLLCLK/MCGPLLCLK clock is the USB clock source (SOPT2[USBSRC] = 1). Divider
 * output clock = Divider input clock * [ (USBFRAC+1) / (USBDIV+1) ]
 */
/*@{*/
#define BP_SIM_CLKDIV2_USBDIV (1U)         /*!< Bit position for SIM_CLKDIV2_USBDIV. */
#define BM_SIM_CLKDIV2_USBDIV (0x0000000EU) /*!< Bit mask for SIM_CLKDIV2_USBDIV. */
#define BS_SIM_CLKDIV2_USBDIV (3U)         /*!< Bit field size in bits for SIM_CLKDIV2_USBDIV. */

/*! @brief Read current value of the SIM_CLKDIV2_USBDIV field. */
#define BR_SIM_CLKDIV2_USBDIV(x) (HW_SIM_CLKDIV2(x).B.USBDIV)

/*! @brief Format value for bitfield SIM_CLKDIV2_USBDIV. */
#define BF_SIM_CLKDIV2_USBDIV(v) ((uint32_t)((uint32_t)(v) << BP_SIM_CLKDIV2_USBDIV) & BM_SIM_CLKDIV2_USBDIV)

/*! @brief Set the USBDIV field to a new value. */
#define BW_SIM_CLKDIV2_USBDIV(x, v) (HW_SIM_CLKDIV2_WR(x, (HW_SIM_CLKDIV2_RD(x) & ~BM_SIM_CLKDIV2_USBDIV) | BF_SIM_CLKDIV2_USBDIV(v)))
/*@}*/

/*******************************************************************************
 * HW_SIM_FCFG1 - Flash Configuration Register 1
 ******************************************************************************/

/*!
 * @brief HW_SIM_FCFG1 - Flash Configuration Register 1 (RW)
 *
 * Reset value: 0xFF0F0F00U
 *
 * For devices with FlexNVM: The reset value of EESIZE and DEPART are based on
 * user programming in user IFR via the PGMPART flash command. For devices with
 * program flash only:
 */
typedef union _hw_sim_fcfg1
{
    uint32_t U;
    struct _hw_sim_fcfg1_bitfields
    {
        uint32_t FLASHDIS : 1;         /*!< [0] Flash Disable */
        uint32_t FLASHDOZE : 1;        /*!< [1] Flash Doze */
        uint32_t RESERVED0 : 6;        /*!< [7:2]  */
        uint32_t DEPART : 4;           /*!< [11:8] FlexNVM partition */
        uint32_t RESERVED1 : 4;        /*!< [15:12]  */
        uint32_t EESIZE : 4;           /*!< [19:16] EEPROM size */
        uint32_t RESERVED2 : 4;        /*!< [23:20]  */
        uint32_t PFSIZE : 4;           /*!< [27:24] Program flash size */
        uint32_t NVMSIZE : 4;          /*!< [31:28] FlexNVM size */
    } B;
} hw_sim_fcfg1_t;

/*!
 * @name Constants and macros for entire SIM_FCFG1 register
 */
/*@{*/
#define HW_SIM_FCFG1_ADDR(x)     ((uint32_t)(x) + 0x104CU)

#define HW_SIM_FCFG1(x)          (*(__IO hw_sim_fcfg1_t *) HW_SIM_FCFG1_ADDR(x))
#define HW_SIM_FCFG1_RD(x)       (HW_SIM_FCFG1(x).U)
#define HW_SIM_FCFG1_WR(x, v)    (HW_SIM_FCFG1(x).U = (v))
#define HW_SIM_FCFG1_SET(x, v)   (HW_SIM_FCFG1_WR(x, HW_SIM_FCFG1_RD(x) |  (v)))
#define HW_SIM_FCFG1_CLR(x, v)   (HW_SIM_FCFG1_WR(x, HW_SIM_FCFG1_RD(x) & ~(v)))
#define HW_SIM_FCFG1_TOG(x, v)   (HW_SIM_FCFG1_WR(x, HW_SIM_FCFG1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG1 bitfields
 */

/*!
 * @name Register SIM_FCFG1, field FLASHDIS[0] (RW)
 *
 * Flash accesses are disabled (and generate a bus error) and the Flash memory
 * is placed in a low power state. This bit should not be changed during VLP
 * modes. Relocate the interrupt vectors out of Flash memory before disabling the
 * Flash.
 *
 * Values:
 * - 0 - Flash is enabled
 * - 1 - Flash is disabled
 */
/*@{*/
#define BP_SIM_FCFG1_FLASHDIS (0U)         /*!< Bit position for SIM_FCFG1_FLASHDIS. */
#define BM_SIM_FCFG1_FLASHDIS (0x00000001U) /*!< Bit mask for SIM_FCFG1_FLASHDIS. */
#define BS_SIM_FCFG1_FLASHDIS (1U)         /*!< Bit field size in bits for SIM_FCFG1_FLASHDIS. */

/*! @brief Read current value of the SIM_FCFG1_FLASHDIS field. */
#define BR_SIM_FCFG1_FLASHDIS(x) (BITBAND_ACCESS32(HW_SIM_FCFG1_ADDR(x), BP_SIM_FCFG1_FLASHDIS))

/*! @brief Format value for bitfield SIM_FCFG1_FLASHDIS. */
#define BF_SIM_FCFG1_FLASHDIS(v) ((uint32_t)((uint32_t)(v) << BP_SIM_FCFG1_FLASHDIS) & BM_SIM_FCFG1_FLASHDIS)

/*! @brief Set the FLASHDIS field to a new value. */
#define BW_SIM_FCFG1_FLASHDIS(x, v) (BITBAND_ACCESS32(HW_SIM_FCFG1_ADDR(x), BP_SIM_FCFG1_FLASHDIS) = (v))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field FLASHDOZE[1] (RW)
 *
 * When set, Flash memory is disabled for the duration of Wait mode. An attempt
 * by the DMA or other bus master to access the Flash when the Flash is disabled
 * will result in a bus error. This bit should be clear during VLP modes. The
 * Flash will be automatically enabled again at the end of Wait mode so interrupt
 * vectors do not need to be relocated out of Flash memory. The wakeup time from
 * Wait mode is extended when this bit is set.
 *
 * Values:
 * - 0 - Flash remains enabled during Wait mode
 * - 1 - Flash is disabled for the duration of Wait mode
 */
/*@{*/
#define BP_SIM_FCFG1_FLASHDOZE (1U)        /*!< Bit position for SIM_FCFG1_FLASHDOZE. */
#define BM_SIM_FCFG1_FLASHDOZE (0x00000002U) /*!< Bit mask for SIM_FCFG1_FLASHDOZE. */
#define BS_SIM_FCFG1_FLASHDOZE (1U)        /*!< Bit field size in bits for SIM_FCFG1_FLASHDOZE. */

/*! @brief Read current value of the SIM_FCFG1_FLASHDOZE field. */
#define BR_SIM_FCFG1_FLASHDOZE(x) (BITBAND_ACCESS32(HW_SIM_FCFG1_ADDR(x), BP_SIM_FCFG1_FLASHDOZE))

/*! @brief Format value for bitfield SIM_FCFG1_FLASHDOZE. */
#define BF_SIM_FCFG1_FLASHDOZE(v) ((uint32_t)((uint32_t)(v) << BP_SIM_FCFG1_FLASHDOZE) & BM_SIM_FCFG1_FLASHDOZE)

/*! @brief Set the FLASHDOZE field to a new value. */
#define BW_SIM_FCFG1_FLASHDOZE(x, v) (BITBAND_ACCESS32(HW_SIM_FCFG1_ADDR(x), BP_SIM_FCFG1_FLASHDOZE) = (v))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field DEPART[11:8] (RO)
 *
 * For devices with FlexNVM: Data flash / EEPROM backup split . See DEPART bit
 * description in FTFE chapter. For devices without FlexNVM: Reserved
 */
/*@{*/
#define BP_SIM_FCFG1_DEPART  (8U)          /*!< Bit position for SIM_FCFG1_DEPART. */
#define BM_SIM_FCFG1_DEPART  (0x00000F00U) /*!< Bit mask for SIM_FCFG1_DEPART. */
#define BS_SIM_FCFG1_DEPART  (4U)          /*!< Bit field size in bits for SIM_FCFG1_DEPART. */

/*! @brief Read current value of the SIM_FCFG1_DEPART field. */
#define BR_SIM_FCFG1_DEPART(x) (HW_SIM_FCFG1(x).B.DEPART)
/*@}*/

/*!
 * @name Register SIM_FCFG1, field EESIZE[19:16] (RO)
 *
 * EEPROM data size .
 *
 * Values:
 * - 0000 - 16 KB
 * - 0001 - 8 KB
 * - 0010 - 4 KB
 * - 0011 - 2 KB
 * - 0100 - 1 KB
 * - 0101 - 512 Bytes
 * - 0110 - 256 Bytes
 * - 0111 - 128 Bytes
 * - 1000 - 64 Bytes
 * - 1001 - 32 Bytes
 * - 1111 - 0 Bytes
 */
/*@{*/
#define BP_SIM_FCFG1_EESIZE  (16U)         /*!< Bit position for SIM_FCFG1_EESIZE. */
#define BM_SIM_FCFG1_EESIZE  (0x000F0000U) /*!< Bit mask for SIM_FCFG1_EESIZE. */
#define BS_SIM_FCFG1_EESIZE  (4U)          /*!< Bit field size in bits for SIM_FCFG1_EESIZE. */

/*! @brief Read current value of the SIM_FCFG1_EESIZE field. */
#define BR_SIM_FCFG1_EESIZE(x) (HW_SIM_FCFG1(x).B.EESIZE)
/*@}*/

/*!
 * @name Register SIM_FCFG1, field PFSIZE[27:24] (RO)
 *
 * This field specifies the amount of program flash memory available on the
 * device . Undefined values are reserved.
 *
 * Values:
 * - 0011 - 32 KB of program flash memory
 * - 0101 - 64 KB of program flash memory
 * - 0111 - 128 KB of program flash memory
 * - 1001 - 256 KB of program flash memory
 * - 1011 - 512 KB of program flash memory
 * - 1101 - 1024 KB of program flash memory
 * - 1111 - 1024 KB of program flash memory
 */
/*@{*/
#define BP_SIM_FCFG1_PFSIZE  (24U)         /*!< Bit position for SIM_FCFG1_PFSIZE. */
#define BM_SIM_FCFG1_PFSIZE  (0x0F000000U) /*!< Bit mask for SIM_FCFG1_PFSIZE. */
#define BS_SIM_FCFG1_PFSIZE  (4U)          /*!< Bit field size in bits for SIM_FCFG1_PFSIZE. */

/*! @brief Read current value of the SIM_FCFG1_PFSIZE field. */
#define BR_SIM_FCFG1_PFSIZE(x) (HW_SIM_FCFG1(x).B.PFSIZE)
/*@}*/

/*!
 * @name Register SIM_FCFG1, field NVMSIZE[31:28] (RO)
 *
 * This field specifies the amount of FlexNVM memory available on the device .
 * Undefined values are reserved.
 *
 * Values:
 * - 0000 - 0 KB of FlexNVM
 * - 0011 - 32 KB of FlexNVM
 * - 0101 - 64 KB of FlexNVM
 * - 0111 - 128 KB of FlexNVM
 * - 1001 - 256 KB of FlexNVM
 * - 1011 - 512 KB of FlexNVM
 * - 1111 - 512 KB of FlexNVM
 */
/*@{*/
#define BP_SIM_FCFG1_NVMSIZE (28U)         /*!< Bit position for SIM_FCFG1_NVMSIZE. */
#define BM_SIM_FCFG1_NVMSIZE (0xF0000000U) /*!< Bit mask for SIM_FCFG1_NVMSIZE. */
#define BS_SIM_FCFG1_NVMSIZE (4U)          /*!< Bit field size in bits for SIM_FCFG1_NVMSIZE. */

/*! @brief Read current value of the SIM_FCFG1_NVMSIZE field. */
#define BR_SIM_FCFG1_NVMSIZE(x) (HW_SIM_FCFG1(x).B.NVMSIZE)
/*@}*/

/*******************************************************************************
 * HW_SIM_FCFG2 - Flash Configuration Register 2
 ******************************************************************************/

/*!
 * @brief HW_SIM_FCFG2 - Flash Configuration Register 2 (RO)
 *
 * Reset value: 0x7F7F0000U
 */
typedef union _hw_sim_fcfg2
{
    uint32_t U;
    struct _hw_sim_fcfg2_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t MAXADDR1 : 7;         /*!< [22:16] Max address block 1 */
        uint32_t PFLSH : 1;            /*!< [23] Program flash only */
        uint32_t MAXADDR0 : 7;         /*!< [30:24] Max address block 0 */
        uint32_t RESERVED1 : 1;        /*!< [31]  */
    } B;
} hw_sim_fcfg2_t;

/*!
 * @name Constants and macros for entire SIM_FCFG2 register
 */
/*@{*/
#define HW_SIM_FCFG2_ADDR(x)     ((uint32_t)(x) + 0x1050U)

#define HW_SIM_FCFG2(x)          (*(__I hw_sim_fcfg2_t *) HW_SIM_FCFG2_ADDR(x))
#define HW_SIM_FCFG2_RD(x)       (HW_SIM_FCFG2(x).U)
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG2 bitfields
 */

/*!
 * @name Register SIM_FCFG2, field MAXADDR1[22:16] (RO)
 *
 * For devices with FlexNVM: This field concatenated with 13 trailing zeros plus
 * the FlexNVM base address indicates the first invalid address of the FlexNVM
 * flash block. For example, if MAXADDR1 = 0x20 the first invalid address of
 * FlexNVM flash block is 0x4_0000 + 0x1000_0000 . This would be the MAXADDR1 value
 * for a device with 256 KB FlexNVM. For devices with program flash only: This
 * field equals zero if there is only one program flash block, otherwise it equals
 * the value of the MAXADDR0 field. For example, with MAXADDR0 = MAXADDR1 = 0x20
 * the first invalid address of flash block 1 is 0x4_0000 + 0x4_0000. This would be
 * the MAXADDR1 value for a device with 512 KB program flash memory across two
 * flash blocks and no FlexNVM.
 */
/*@{*/
#define BP_SIM_FCFG2_MAXADDR1 (16U)        /*!< Bit position for SIM_FCFG2_MAXADDR1. */
#define BM_SIM_FCFG2_MAXADDR1 (0x007F0000U) /*!< Bit mask for SIM_FCFG2_MAXADDR1. */
#define BS_SIM_FCFG2_MAXADDR1 (7U)         /*!< Bit field size in bits for SIM_FCFG2_MAXADDR1. */

/*! @brief Read current value of the SIM_FCFG2_MAXADDR1 field. */
#define BR_SIM_FCFG2_MAXADDR1(x) (HW_SIM_FCFG2(x).B.MAXADDR1)
/*@}*/

/*!
 * @name Register SIM_FCFG2, field PFLSH[23] (RO)
 *
 * For devices with FlexNVM, this bit is always clear. For devices without
 * FlexNVM, this bit is always set.
 *
 * Values:
 * - 0 - Device supports FlexNVM
 * - 1 - Program Flash only, device does not support FlexNVM
 */
/*@{*/
#define BP_SIM_FCFG2_PFLSH   (23U)         /*!< Bit position for SIM_FCFG2_PFLSH. */
#define BM_SIM_FCFG2_PFLSH   (0x00800000U) /*!< Bit mask for SIM_FCFG2_PFLSH. */
#define BS_SIM_FCFG2_PFLSH   (1U)          /*!< Bit field size in bits for SIM_FCFG2_PFLSH. */

/*! @brief Read current value of the SIM_FCFG2_PFLSH field. */
#define BR_SIM_FCFG2_PFLSH(x) (BITBAND_ACCESS32(HW_SIM_FCFG2_ADDR(x), BP_SIM_FCFG2_PFLSH))
/*@}*/

/*!
 * @name Register SIM_FCFG2, field MAXADDR0[30:24] (RO)
 *
 * This field concatenated with 13 trailing zeros indicates the first invalid
 * address of each program flash block. For example, if MAXADDR0 = 0x20 the first
 * invalid address of flash block 0 is 0x0004_0000. This would be the MAXADDR0
 * value for a device with 256 KB program flash in flash block 0.
 */
/*@{*/
#define BP_SIM_FCFG2_MAXADDR0 (24U)        /*!< Bit position for SIM_FCFG2_MAXADDR0. */
#define BM_SIM_FCFG2_MAXADDR0 (0x7F000000U) /*!< Bit mask for SIM_FCFG2_MAXADDR0. */
#define BS_SIM_FCFG2_MAXADDR0 (7U)         /*!< Bit field size in bits for SIM_FCFG2_MAXADDR0. */

/*! @brief Read current value of the SIM_FCFG2_MAXADDR0 field. */
#define BR_SIM_FCFG2_MAXADDR0(x) (HW_SIM_FCFG2(x).B.MAXADDR0)
/*@}*/

/*******************************************************************************
 * HW_SIM_UIDH - Unique Identification Register High
 ******************************************************************************/

/*!
 * @brief HW_SIM_UIDH - Unique Identification Register High (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_uidh
{
    uint32_t U;
    struct _hw_sim_uidh_bitfields
    {
        uint32_t UID : 32;             /*!< [31:0] Unique Identification */
    } B;
} hw_sim_uidh_t;

/*!
 * @name Constants and macros for entire SIM_UIDH register
 */
/*@{*/
#define HW_SIM_UIDH_ADDR(x)      ((uint32_t)(x) + 0x1054U)

#define HW_SIM_UIDH(x)           (*(__I hw_sim_uidh_t *) HW_SIM_UIDH_ADDR(x))
#define HW_SIM_UIDH_RD(x)        (HW_SIM_UIDH(x).U)
/*@}*/

/*
 * Constants & macros for individual SIM_UIDH bitfields
 */

/*!
 * @name Register SIM_UIDH, field UID[31:0] (RO)
 *
 * Unique identification for the device.
 */
/*@{*/
#define BP_SIM_UIDH_UID      (0U)          /*!< Bit position for SIM_UIDH_UID. */
#define BM_SIM_UIDH_UID      (0xFFFFFFFFU) /*!< Bit mask for SIM_UIDH_UID. */
#define BS_SIM_UIDH_UID      (32U)         /*!< Bit field size in bits for SIM_UIDH_UID. */

/*! @brief Read current value of the SIM_UIDH_UID field. */
#define BR_SIM_UIDH_UID(x)   (HW_SIM_UIDH(x).U)
/*@}*/

/*******************************************************************************
 * HW_SIM_UIDMH - Unique Identification Register Mid-High
 ******************************************************************************/

/*!
 * @brief HW_SIM_UIDMH - Unique Identification Register Mid-High (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_uidmh
{
    uint32_t U;
    struct _hw_sim_uidmh_bitfields
    {
        uint32_t UID : 32;             /*!< [31:0] Unique Identification */
    } B;
} hw_sim_uidmh_t;

/*!
 * @name Constants and macros for entire SIM_UIDMH register
 */
/*@{*/
#define HW_SIM_UIDMH_ADDR(x)     ((uint32_t)(x) + 0x1058U)

#define HW_SIM_UIDMH(x)          (*(__I hw_sim_uidmh_t *) HW_SIM_UIDMH_ADDR(x))
#define HW_SIM_UIDMH_RD(x)       (HW_SIM_UIDMH(x).U)
/*@}*/

/*
 * Constants & macros for individual SIM_UIDMH bitfields
 */

/*!
 * @name Register SIM_UIDMH, field UID[31:0] (RO)
 *
 * Unique identification for the device.
 */
/*@{*/
#define BP_SIM_UIDMH_UID     (0U)          /*!< Bit position for SIM_UIDMH_UID. */
#define BM_SIM_UIDMH_UID     (0xFFFFFFFFU) /*!< Bit mask for SIM_UIDMH_UID. */
#define BS_SIM_UIDMH_UID     (32U)         /*!< Bit field size in bits for SIM_UIDMH_UID. */

/*! @brief Read current value of the SIM_UIDMH_UID field. */
#define BR_SIM_UIDMH_UID(x)  (HW_SIM_UIDMH(x).U)
/*@}*/

/*******************************************************************************
 * HW_SIM_UIDML - Unique Identification Register Mid Low
 ******************************************************************************/

/*!
 * @brief HW_SIM_UIDML - Unique Identification Register Mid Low (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_uidml
{
    uint32_t U;
    struct _hw_sim_uidml_bitfields
    {
        uint32_t UID : 32;             /*!< [31:0] Unique Identification */
    } B;
} hw_sim_uidml_t;

/*!
 * @name Constants and macros for entire SIM_UIDML register
 */
/*@{*/
#define HW_SIM_UIDML_ADDR(x)     ((uint32_t)(x) + 0x105CU)

#define HW_SIM_UIDML(x)          (*(__I hw_sim_uidml_t *) HW_SIM_UIDML_ADDR(x))
#define HW_SIM_UIDML_RD(x)       (HW_SIM_UIDML(x).U)
/*@}*/

/*
 * Constants & macros for individual SIM_UIDML bitfields
 */

/*!
 * @name Register SIM_UIDML, field UID[31:0] (RO)
 *
 * Unique identification for the device.
 */
/*@{*/
#define BP_SIM_UIDML_UID     (0U)          /*!< Bit position for SIM_UIDML_UID. */
#define BM_SIM_UIDML_UID     (0xFFFFFFFFU) /*!< Bit mask for SIM_UIDML_UID. */
#define BS_SIM_UIDML_UID     (32U)         /*!< Bit field size in bits for SIM_UIDML_UID. */

/*! @brief Read current value of the SIM_UIDML_UID field. */
#define BR_SIM_UIDML_UID(x)  (HW_SIM_UIDML(x).U)
/*@}*/

/*******************************************************************************
 * HW_SIM_UIDL - Unique Identification Register Low
 ******************************************************************************/

/*!
 * @brief HW_SIM_UIDL - Unique Identification Register Low (RO)
 *
 * Reset value: 0x00000000U
 */
typedef union _hw_sim_uidl
{
    uint32_t U;
    struct _hw_sim_uidl_bitfields
    {
        uint32_t UID : 32;             /*!< [31:0] Unique Identification */
    } B;
} hw_sim_uidl_t;

/*!
 * @name Constants and macros for entire SIM_UIDL register
 */
/*@{*/
#define HW_SIM_UIDL_ADDR(x)      ((uint32_t)(x) + 0x1060U)

#define HW_SIM_UIDL(x)           (*(__I hw_sim_uidl_t *) HW_SIM_UIDL_ADDR(x))
#define HW_SIM_UIDL_RD(x)        (HW_SIM_UIDL(x).U)
/*@}*/

/*
 * Constants & macros for individual SIM_UIDL bitfields
 */

/*!
 * @name Register SIM_UIDL, field UID[31:0] (RO)
 *
 * Unique identification for the device.
 */
/*@{*/
#define BP_SIM_UIDL_UID      (0U)          /*!< Bit position for SIM_UIDL_UID. */
#define BM_SIM_UIDL_UID      (0xFFFFFFFFU) /*!< Bit mask for SIM_UIDL_UID. */
#define BS_SIM_UIDL_UID      (32U)         /*!< Bit field size in bits for SIM_UIDL_UID. */

/*! @brief Read current value of the SIM_UIDL_UID field. */
#define BR_SIM_UIDL_UID(x)   (HW_SIM_UIDL(x).U)
/*@}*/

/*******************************************************************************
 * hw_sim_t - module struct
 ******************************************************************************/
/*!
 * @brief All SIM module registers.
 */
#pragma pack(1)
typedef struct _hw_sim
{
    __IO hw_sim_sopt1_t SOPT1;             /*!< [0x0] System Options Register 1 */
    __IO hw_sim_sopt1cfg_t SOPT1CFG;       /*!< [0x4] SOPT1 Configuration Register */
    uint8_t _reserved0[4092];
    __IO hw_sim_sopt2_t SOPT2;             /*!< [0x1004] System Options Register 2 */
    uint8_t _reserved1[4];
    __IO hw_sim_sopt4_t SOPT4;             /*!< [0x100C] System Options Register 4 */
    __IO hw_sim_sopt5_t SOPT5;             /*!< [0x1010] System Options Register 5 */
    uint8_t _reserved2[4];
    __IO hw_sim_sopt7_t SOPT7;             /*!< [0x1018] System Options Register 7 */
    uint8_t _reserved3[8];
    __I hw_sim_sdid_t SDID;                /*!< [0x1024] System Device Identification Register */
    __IO hw_sim_scgc1_t SCGC1;             /*!< [0x1028] System Clock Gating Control Register 1 */
    __IO hw_sim_scgc2_t SCGC2;             /*!< [0x102C] System Clock Gating Control Register 2 */
    __IO hw_sim_scgc3_t SCGC3;             /*!< [0x1030] System Clock Gating Control Register 3 */
    __IO hw_sim_scgc4_t SCGC4;             /*!< [0x1034] System Clock Gating Control Register 4 */
    __IO hw_sim_scgc5_t SCGC5;             /*!< [0x1038] System Clock Gating Control Register 5 */
    __IO hw_sim_scgc6_t SCGC6;             /*!< [0x103C] System Clock Gating Control Register 6 */
    __IO hw_sim_scgc7_t SCGC7;             /*!< [0x1040] System Clock Gating Control Register 7 */
    __IO hw_sim_clkdiv1_t CLKDIV1;         /*!< [0x1044] System Clock Divider Register 1 */
    __IO hw_sim_clkdiv2_t CLKDIV2;         /*!< [0x1048] System Clock Divider Register 2 */
    __IO hw_sim_fcfg1_t FCFG1;             /*!< [0x104C] Flash Configuration Register 1 */
    __I hw_sim_fcfg2_t FCFG2;              /*!< [0x1050] Flash Configuration Register 2 */
    __I hw_sim_uidh_t UIDH;                /*!< [0x1054] Unique Identification Register High */
    __I hw_sim_uidmh_t UIDMH;              /*!< [0x1058] Unique Identification Register Mid-High */
    __I hw_sim_uidml_t UIDML;              /*!< [0x105C] Unique Identification Register Mid Low */
    __I hw_sim_uidl_t UIDL;                /*!< [0x1060] Unique Identification Register Low */
} hw_sim_t;
#pragma pack()

/*! @brief Macro to access all SIM registers. */
/*! @param x SIM module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_SIM_REGS(SIM_BASE)</code>. */
#define HW_SIM_REGS(x) (*(hw_sim_t *)(x))

/*
 * MK64F12 SMC
 *
 * System Mode Controller
 *
 * Registers defined in this header file:
 * - HW_SMC_PMPROT - Power Mode Protection register
 * - HW_SMC_PMCTRL - Power Mode Control register
 * - HW_SMC_VLLSCTRL - VLLS Control register
 * - HW_SMC_PMSTAT - Power Mode Status register
 *
 * - hw_smc_t - Struct containing all module registers.
 */

#define HW_SMC_INSTANCE_COUNT (1U) /*!< Number of instances of the SMC module. */
#define HW_SMC (0U) /*!< Instance number for SMC. */

/*******************************************************************************
 * HW_SMC_PMPROT - Power Mode Protection register
 ******************************************************************************/

/*!
 * @brief HW_SMC_PMPROT - Power Mode Protection register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides protection for entry into any low-power run or stop
 * mode. The enabling of the low-power run or stop mode occurs by configuring the
 * Power Mode Control register (PMCTRL). The PMPROT register can be written only
 * once after any system reset. If the MCU is configured for a disallowed or
 * reserved power mode, the MCU remains in its current power mode. For example, if the
 * MCU is in normal RUN mode and AVLP is 0, an attempt to enter VLPR mode using
 * PMCTRL[RUNM] is blocked and PMCTRL[RUNM] remains 00b, indicating the MCU is
 * still in Normal Run mode. This register is reset on Chip Reset not VLLS and by
 * reset types that trigger Chip Reset not VLLS. It is unaffected by reset types
 * that do not trigger Chip Reset not VLLS. See the Reset section details for more
 * information.
 */
typedef union _hw_smc_pmprot
{
    uint8_t U;
    struct _hw_smc_pmprot_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t AVLLS : 1;             /*!< [1] Allow Very-Low-Leakage Stop Mode */
        uint8_t RESERVED1 : 1;         /*!< [2]  */
        uint8_t ALLS : 1;              /*!< [3] Allow Low-Leakage Stop Mode */
        uint8_t RESERVED2 : 1;         /*!< [4]  */
        uint8_t AVLP : 1;              /*!< [5] Allow Very-Low-Power Modes */
        uint8_t RESERVED3 : 2;         /*!< [7:6]  */
    } B;
} hw_smc_pmprot_t;

/*!
 * @name Constants and macros for entire SMC_PMPROT register
 */
/*@{*/
#define HW_SMC_PMPROT_ADDR(x)    ((uint32_t)(x) + 0x0U)

#define HW_SMC_PMPROT(x)         (*(__IO hw_smc_pmprot_t *) HW_SMC_PMPROT_ADDR(x))
#define HW_SMC_PMPROT_RD(x)      (HW_SMC_PMPROT(x).U)
#define HW_SMC_PMPROT_WR(x, v)   (HW_SMC_PMPROT(x).U = (v))
#define HW_SMC_PMPROT_SET(x, v)  (HW_SMC_PMPROT_WR(x, HW_SMC_PMPROT_RD(x) |  (v)))
#define HW_SMC_PMPROT_CLR(x, v)  (HW_SMC_PMPROT_WR(x, HW_SMC_PMPROT_RD(x) & ~(v)))
#define HW_SMC_PMPROT_TOG(x, v)  (HW_SMC_PMPROT_WR(x, HW_SMC_PMPROT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMPROT bitfields
 */

/*!
 * @name Register SMC_PMPROT, field AVLLS[1] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write once
 * bit allows the MCU to enter any very-low-leakage stop mode (VLLSx).
 *
 * Values:
 * - 0 - Any VLLSx mode is not allowed
 * - 1 - Any VLLSx mode is allowed
 */
/*@{*/
#define BP_SMC_PMPROT_AVLLS  (1U)          /*!< Bit position for SMC_PMPROT_AVLLS. */
#define BM_SMC_PMPROT_AVLLS  (0x02U)       /*!< Bit mask for SMC_PMPROT_AVLLS. */
#define BS_SMC_PMPROT_AVLLS  (1U)          /*!< Bit field size in bits for SMC_PMPROT_AVLLS. */

/*! @brief Read current value of the SMC_PMPROT_AVLLS field. */
#define BR_SMC_PMPROT_AVLLS(x) (BITBAND_ACCESS8(HW_SMC_PMPROT_ADDR(x), BP_SMC_PMPROT_AVLLS))

/*! @brief Format value for bitfield SMC_PMPROT_AVLLS. */
#define BF_SMC_PMPROT_AVLLS(v) ((uint8_t)((uint8_t)(v) << BP_SMC_PMPROT_AVLLS) & BM_SMC_PMPROT_AVLLS)

/*! @brief Set the AVLLS field to a new value. */
#define BW_SMC_PMPROT_AVLLS(x, v) (BITBAND_ACCESS8(HW_SMC_PMPROT_ADDR(x), BP_SMC_PMPROT_AVLLS) = (v))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field ALLS[3] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any low-leakage stop mode (LLS).
 *
 * Values:
 * - 0 - LLS is not allowed
 * - 1 - LLS is allowed
 */
/*@{*/
#define BP_SMC_PMPROT_ALLS   (3U)          /*!< Bit position for SMC_PMPROT_ALLS. */
#define BM_SMC_PMPROT_ALLS   (0x08U)       /*!< Bit mask for SMC_PMPROT_ALLS. */
#define BS_SMC_PMPROT_ALLS   (1U)          /*!< Bit field size in bits for SMC_PMPROT_ALLS. */

/*! @brief Read current value of the SMC_PMPROT_ALLS field. */
#define BR_SMC_PMPROT_ALLS(x) (BITBAND_ACCESS8(HW_SMC_PMPROT_ADDR(x), BP_SMC_PMPROT_ALLS))

/*! @brief Format value for bitfield SMC_PMPROT_ALLS. */
#define BF_SMC_PMPROT_ALLS(v) ((uint8_t)((uint8_t)(v) << BP_SMC_PMPROT_ALLS) & BM_SMC_PMPROT_ALLS)

/*! @brief Set the ALLS field to a new value. */
#define BW_SMC_PMPROT_ALLS(x, v) (BITBAND_ACCESS8(HW_SMC_PMPROT_ADDR(x), BP_SMC_PMPROT_ALLS) = (v))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AVLP[5] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any very-low-power mode (VLPR, VLPW, and VLPS).
 *
 * Values:
 * - 0 - VLPR, VLPW, and VLPS are not allowed.
 * - 1 - VLPR, VLPW, and VLPS are allowed.
 */
/*@{*/
#define BP_SMC_PMPROT_AVLP   (5U)          /*!< Bit position for SMC_PMPROT_AVLP. */
#define BM_SMC_PMPROT_AVLP   (0x20U)       /*!< Bit mask for SMC_PMPROT_AVLP. */
#define BS_SMC_PMPROT_AVLP   (1U)          /*!< Bit field size in bits for SMC_PMPROT_AVLP. */

/*! @brief Read current value of the SMC_PMPROT_AVLP field. */
#define BR_SMC_PMPROT_AVLP(x) (BITBAND_ACCESS8(HW_SMC_PMPROT_ADDR(x), BP_SMC_PMPROT_AVLP))

/*! @brief Format value for bitfield SMC_PMPROT_AVLP. */
#define BF_SMC_PMPROT_AVLP(v) ((uint8_t)((uint8_t)(v) << BP_SMC_PMPROT_AVLP) & BM_SMC_PMPROT_AVLP)

/*! @brief Set the AVLP field to a new value. */
#define BW_SMC_PMPROT_AVLP(x, v) (BITBAND_ACCESS8(HW_SMC_PMPROT_ADDR(x), BP_SMC_PMPROT_AVLP) = (v))
/*@}*/

/*******************************************************************************
 * HW_SMC_PMCTRL - Power Mode Control register
 ******************************************************************************/

/*!
 * @brief HW_SMC_PMCTRL - Power Mode Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The PMCTRL register controls entry into low-power Run and Stop modes,
 * provided that the selected power mode is allowed via an appropriate setting of the
 * protection (PMPROT) register. This register is reset on Chip POR not VLLS and by
 * reset types that trigger Chip POR not VLLS. It is unaffected by reset types
 * that do not trigger Chip POR not VLLS. See the Reset section details for more
 * information.
 */
typedef union _hw_smc_pmctrl
{
    uint8_t U;
    struct _hw_smc_pmctrl_bitfields
    {
        uint8_t STOPM : 3;             /*!< [2:0] Stop Mode Control */
        uint8_t STOPA : 1;             /*!< [3] Stop Aborted */
        uint8_t RESERVED0 : 1;         /*!< [4]  */
        uint8_t RUNM : 2;              /*!< [6:5] Run Mode Control */
        uint8_t LPWUI : 1;             /*!< [7] Low-Power Wake Up On Interrupt */
    } B;
} hw_smc_pmctrl_t;

/*!
 * @name Constants and macros for entire SMC_PMCTRL register
 */
/*@{*/
#define HW_SMC_PMCTRL_ADDR(x)    ((uint32_t)(x) + 0x1U)

#define HW_SMC_PMCTRL(x)         (*(__IO hw_smc_pmctrl_t *) HW_SMC_PMCTRL_ADDR(x))
#define HW_SMC_PMCTRL_RD(x)      (HW_SMC_PMCTRL(x).U)
#define HW_SMC_PMCTRL_WR(x, v)   (HW_SMC_PMCTRL(x).U = (v))
#define HW_SMC_PMCTRL_SET(x, v)  (HW_SMC_PMCTRL_WR(x, HW_SMC_PMCTRL_RD(x) |  (v)))
#define HW_SMC_PMCTRL_CLR(x, v)  (HW_SMC_PMCTRL_WR(x, HW_SMC_PMCTRL_RD(x) & ~(v)))
#define HW_SMC_PMCTRL_TOG(x, v)  (HW_SMC_PMCTRL_WR(x, HW_SMC_PMCTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMCTRL bitfields
 */

/*!
 * @name Register SMC_PMCTRL, field STOPM[2:0] (RW)
 *
 * When written, controls entry into the selected stop mode when Sleep-Now or
 * Sleep-On-Exit mode is entered with SLEEPDEEP=1 . Writes to this field are
 * blocked if the protection level has not been enabled using the PMPROT register.
 * After any system reset, this field is cleared by hardware on any successful write
 * to the PMPROT register. When set to VLLSx, the VLLSM field in the VLLSCTRL
 * register is used to further select the particular VLLS submode which will be
 * entered.
 *
 * Values:
 * - 000 - Normal Stop (STOP)
 * - 001 - Reserved
 * - 010 - Very-Low-Power Stop (VLPS)
 * - 011 - Low-Leakage Stop (LLS)
 * - 100 - Very-Low-Leakage Stop (VLLSx)
 * - 101 - Reserved
 * - 110 - Reseved
 * - 111 - Reserved
 */
/*@{*/
#define BP_SMC_PMCTRL_STOPM  (0U)          /*!< Bit position for SMC_PMCTRL_STOPM. */
#define BM_SMC_PMCTRL_STOPM  (0x07U)       /*!< Bit mask for SMC_PMCTRL_STOPM. */
#define BS_SMC_PMCTRL_STOPM  (3U)          /*!< Bit field size in bits for SMC_PMCTRL_STOPM. */

/*! @brief Read current value of the SMC_PMCTRL_STOPM field. */
#define BR_SMC_PMCTRL_STOPM(x) (HW_SMC_PMCTRL(x).B.STOPM)

/*! @brief Format value for bitfield SMC_PMCTRL_STOPM. */
#define BF_SMC_PMCTRL_STOPM(v) ((uint8_t)((uint8_t)(v) << BP_SMC_PMCTRL_STOPM) & BM_SMC_PMCTRL_STOPM)

/*! @brief Set the STOPM field to a new value. */
#define BW_SMC_PMCTRL_STOPM(x, v) (HW_SMC_PMCTRL_WR(x, (HW_SMC_PMCTRL_RD(x) & ~BM_SMC_PMCTRL_STOPM) | BF_SMC_PMCTRL_STOPM(v)))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field STOPA[3] (RO)
 *
 * When set, this read-only status bit indicates an interrupt or reset occured
 * during the previous stop mode entry sequence, preventing the system from
 * entering that mode. This field is cleared by hardware at the beginning of any stop
 * mode entry sequence and is set if the sequence was aborted.
 *
 * Values:
 * - 0 - The previous stop mode entry was successsful.
 * - 1 - The previous stop mode entry was aborted.
 */
/*@{*/
#define BP_SMC_PMCTRL_STOPA  (3U)          /*!< Bit position for SMC_PMCTRL_STOPA. */
#define BM_SMC_PMCTRL_STOPA  (0x08U)       /*!< Bit mask for SMC_PMCTRL_STOPA. */
#define BS_SMC_PMCTRL_STOPA  (1U)          /*!< Bit field size in bits for SMC_PMCTRL_STOPA. */

/*! @brief Read current value of the SMC_PMCTRL_STOPA field. */
#define BR_SMC_PMCTRL_STOPA(x) (BITBAND_ACCESS8(HW_SMC_PMCTRL_ADDR(x), BP_SMC_PMCTRL_STOPA))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field RUNM[6:5] (RW)
 *
 * When written, causes entry into the selected run mode. Writes to this field
 * are blocked if the protection level has not been enabled using the PMPROT
 * register. RUNM may be set to VLPR only when PMSTAT=RUN. After being written to
 * VLPR, RUNM should not be written back to RUN until PMSTAT=VLPR.
 *
 * Values:
 * - 00 - Normal Run mode (RUN)
 * - 01 - Reserved
 * - 10 - Very-Low-Power Run mode (VLPR)
 * - 11 - Reserved
 */
/*@{*/
#define BP_SMC_PMCTRL_RUNM   (5U)          /*!< Bit position for SMC_PMCTRL_RUNM. */
#define BM_SMC_PMCTRL_RUNM   (0x60U)       /*!< Bit mask for SMC_PMCTRL_RUNM. */
#define BS_SMC_PMCTRL_RUNM   (2U)          /*!< Bit field size in bits for SMC_PMCTRL_RUNM. */

/*! @brief Read current value of the SMC_PMCTRL_RUNM field. */
#define BR_SMC_PMCTRL_RUNM(x) (HW_SMC_PMCTRL(x).B.RUNM)

/*! @brief Format value for bitfield SMC_PMCTRL_RUNM. */
#define BF_SMC_PMCTRL_RUNM(v) ((uint8_t)((uint8_t)(v) << BP_SMC_PMCTRL_RUNM) & BM_SMC_PMCTRL_RUNM)

/*! @brief Set the RUNM field to a new value. */
#define BW_SMC_PMCTRL_RUNM(x, v) (HW_SMC_PMCTRL_WR(x, (HW_SMC_PMCTRL_RD(x) & ~BM_SMC_PMCTRL_RUNM) | BF_SMC_PMCTRL_RUNM(v)))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field LPWUI[7] (RW)
 *
 * Causes the SMC to exit to normal RUN mode when any active MCU interrupt
 * occurs while in a VLP mode (VLPR, VLPW or VLPS). If VLPS mode was entered directly
 * from RUN mode, the SMC will always exit back to normal RUN mode regardless of
 * the LPWUI setting. LPWUI must be modified only while the system is in RUN
 * mode, that is, when PMSTAT=RUN.
 *
 * Values:
 * - 0 - The system remains in a VLP mode on an interrupt
 * - 1 - The system exits to Normal RUN mode on an interrupt
 */
/*@{*/
#define BP_SMC_PMCTRL_LPWUI  (7U)          /*!< Bit position for SMC_PMCTRL_LPWUI. */
#define BM_SMC_PMCTRL_LPWUI  (0x80U)       /*!< Bit mask for SMC_PMCTRL_LPWUI. */
#define BS_SMC_PMCTRL_LPWUI  (1U)          /*!< Bit field size in bits for SMC_PMCTRL_LPWUI. */

/*! @brief Read current value of the SMC_PMCTRL_LPWUI field. */
#define BR_SMC_PMCTRL_LPWUI(x) (BITBAND_ACCESS8(HW_SMC_PMCTRL_ADDR(x), BP_SMC_PMCTRL_LPWUI))

/*! @brief Format value for bitfield SMC_PMCTRL_LPWUI. */
#define BF_SMC_PMCTRL_LPWUI(v) ((uint8_t)((uint8_t)(v) << BP_SMC_PMCTRL_LPWUI) & BM_SMC_PMCTRL_LPWUI)

/*! @brief Set the LPWUI field to a new value. */
#define BW_SMC_PMCTRL_LPWUI(x, v) (BITBAND_ACCESS8(HW_SMC_PMCTRL_ADDR(x), BP_SMC_PMCTRL_LPWUI) = (v))
/*@}*/

/*******************************************************************************
 * HW_SMC_VLLSCTRL - VLLS Control register
 ******************************************************************************/

/*!
 * @brief HW_SMC_VLLSCTRL - VLLS Control register (RW)
 *
 * Reset value: 0x03U
 *
 * The VLLSCTRL register controls features related to VLLS modes. This register
 * is reset on Chip POR not VLLS and by reset types that trigger Chip POR not
 * VLLS. It is unaffected by reset types that do not trigger Chip POR not VLLS. See
 * the Reset section details for more information.
 */
typedef union _hw_smc_vllsctrl
{
    uint8_t U;
    struct _hw_smc_vllsctrl_bitfields
    {
        uint8_t VLLSM : 3;             /*!< [2:0] VLLS Mode Control */
        uint8_t RESERVED0 : 2;         /*!< [4:3]  */
        uint8_t PORPO : 1;             /*!< [5] POR Power Option */
        uint8_t RESERVED1 : 2;         /*!< [7:6]  */
    } B;
} hw_smc_vllsctrl_t;

/*!
 * @name Constants and macros for entire SMC_VLLSCTRL register
 */
/*@{*/
#define HW_SMC_VLLSCTRL_ADDR(x)  ((uint32_t)(x) + 0x2U)

#define HW_SMC_VLLSCTRL(x)       (*(__IO hw_smc_vllsctrl_t *) HW_SMC_VLLSCTRL_ADDR(x))
#define HW_SMC_VLLSCTRL_RD(x)    (HW_SMC_VLLSCTRL(x).U)
#define HW_SMC_VLLSCTRL_WR(x, v) (HW_SMC_VLLSCTRL(x).U = (v))
#define HW_SMC_VLLSCTRL_SET(x, v) (HW_SMC_VLLSCTRL_WR(x, HW_SMC_VLLSCTRL_RD(x) |  (v)))
#define HW_SMC_VLLSCTRL_CLR(x, v) (HW_SMC_VLLSCTRL_WR(x, HW_SMC_VLLSCTRL_RD(x) & ~(v)))
#define HW_SMC_VLLSCTRL_TOG(x, v) (HW_SMC_VLLSCTRL_WR(x, HW_SMC_VLLSCTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SMC_VLLSCTRL bitfields
 */

/*!
 * @name Register SMC_VLLSCTRL, field VLLSM[2:0] (RW)
 *
 * Controls which VLLS sub-mode to enter if STOPM=VLLS.
 *
 * Values:
 * - 000 - VLLS0
 * - 001 - VLLS1
 * - 010 - VLLS2
 * - 011 - VLLS3
 * - 100 - Reserved
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
#define BP_SMC_VLLSCTRL_VLLSM (0U)         /*!< Bit position for SMC_VLLSCTRL_VLLSM. */
#define BM_SMC_VLLSCTRL_VLLSM (0x07U)      /*!< Bit mask for SMC_VLLSCTRL_VLLSM. */
#define BS_SMC_VLLSCTRL_VLLSM (3U)         /*!< Bit field size in bits for SMC_VLLSCTRL_VLLSM. */

/*! @brief Read current value of the SMC_VLLSCTRL_VLLSM field. */
#define BR_SMC_VLLSCTRL_VLLSM(x) (HW_SMC_VLLSCTRL(x).B.VLLSM)

/*! @brief Format value for bitfield SMC_VLLSCTRL_VLLSM. */
#define BF_SMC_VLLSCTRL_VLLSM(v) ((uint8_t)((uint8_t)(v) << BP_SMC_VLLSCTRL_VLLSM) & BM_SMC_VLLSCTRL_VLLSM)

/*! @brief Set the VLLSM field to a new value. */
#define BW_SMC_VLLSCTRL_VLLSM(x, v) (HW_SMC_VLLSCTRL_WR(x, (HW_SMC_VLLSCTRL_RD(x) & ~BM_SMC_VLLSCTRL_VLLSM) | BF_SMC_VLLSCTRL_VLLSM(v)))
/*@}*/

/*!
 * @name Register SMC_VLLSCTRL, field PORPO[5] (RW)
 *
 * Controls whether the POR detect circuit (for brown-out detection) is enabled
 * in VLLS0 mode.
 *
 * Values:
 * - 0 - POR detect circuit is enabled in VLLS0.
 * - 1 - POR detect circuit is disabled in VLLS0.
 */
/*@{*/
#define BP_SMC_VLLSCTRL_PORPO (5U)         /*!< Bit position for SMC_VLLSCTRL_PORPO. */
#define BM_SMC_VLLSCTRL_PORPO (0x20U)      /*!< Bit mask for SMC_VLLSCTRL_PORPO. */
#define BS_SMC_VLLSCTRL_PORPO (1U)         /*!< Bit field size in bits for SMC_VLLSCTRL_PORPO. */

/*! @brief Read current value of the SMC_VLLSCTRL_PORPO field. */
#define BR_SMC_VLLSCTRL_PORPO(x) (BITBAND_ACCESS8(HW_SMC_VLLSCTRL_ADDR(x), BP_SMC_VLLSCTRL_PORPO))

/*! @brief Format value for bitfield SMC_VLLSCTRL_PORPO. */
#define BF_SMC_VLLSCTRL_PORPO(v) ((uint8_t)((uint8_t)(v) << BP_SMC_VLLSCTRL_PORPO) & BM_SMC_VLLSCTRL_PORPO)

/*! @brief Set the PORPO field to a new value. */
#define BW_SMC_VLLSCTRL_PORPO(x, v) (BITBAND_ACCESS8(HW_SMC_VLLSCTRL_ADDR(x), BP_SMC_VLLSCTRL_PORPO) = (v))
/*@}*/

/*******************************************************************************
 * HW_SMC_PMSTAT - Power Mode Status register
 ******************************************************************************/

/*!
 * @brief HW_SMC_PMSTAT - Power Mode Status register (RO)
 *
 * Reset value: 0x01U
 *
 * PMSTAT is a read-only, one-hot register which indicates the current power
 * mode of the system. This register is reset on Chip POR not VLLS and by reset
 * types that trigger Chip POR not VLLS. It is unaffected by reset types that do not
 * trigger Chip POR not VLLS. See the Reset section details for more information.
 */
typedef union _hw_smc_pmstat
{
    uint8_t U;
    struct _hw_smc_pmstat_bitfields
    {
        uint8_t PMSTAT : 7;            /*!< [6:0]  */
        uint8_t RESERVED0 : 1;         /*!< [7]  */
    } B;
} hw_smc_pmstat_t;

/*!
 * @name Constants and macros for entire SMC_PMSTAT register
 */
/*@{*/
#define HW_SMC_PMSTAT_ADDR(x)    ((uint32_t)(x) + 0x3U)

#define HW_SMC_PMSTAT(x)         (*(__I hw_smc_pmstat_t *) HW_SMC_PMSTAT_ADDR(x))
#define HW_SMC_PMSTAT_RD(x)      (HW_SMC_PMSTAT(x).U)
/*@}*/

/*
 * Constants & macros for individual SMC_PMSTAT bitfields
 */

/*!
 * @name Register SMC_PMSTAT, field PMSTAT[6:0] (RO)
 *
 * When debug is enabled, the PMSTAT will not update to STOP or VLPS
 */
/*@{*/
#define BP_SMC_PMSTAT_PMSTAT (0U)          /*!< Bit position for SMC_PMSTAT_PMSTAT. */
#define BM_SMC_PMSTAT_PMSTAT (0x7FU)       /*!< Bit mask for SMC_PMSTAT_PMSTAT. */
#define BS_SMC_PMSTAT_PMSTAT (7U)          /*!< Bit field size in bits for SMC_PMSTAT_PMSTAT. */

/*! @brief Read current value of the SMC_PMSTAT_PMSTAT field. */
#define BR_SMC_PMSTAT_PMSTAT(x) (HW_SMC_PMSTAT(x).B.PMSTAT)
/*@}*/

/*******************************************************************************
 * hw_smc_t - module struct
 ******************************************************************************/
/*!
 * @brief All SMC module registers.
 */
#pragma pack(1)
typedef struct _hw_smc
{
    __IO hw_smc_pmprot_t PMPROT;           /*!< [0x0] Power Mode Protection register */
    __IO hw_smc_pmctrl_t PMCTRL;           /*!< [0x1] Power Mode Control register */
    __IO hw_smc_vllsctrl_t VLLSCTRL;       /*!< [0x2] VLLS Control register */
    __I hw_smc_pmstat_t PMSTAT;            /*!< [0x3] Power Mode Status register */
} hw_smc_t;
#pragma pack()

/*! @brief Macro to access all SMC registers. */
/*! @param x SMC module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_SMC_REGS(SMC_BASE)</code>. */
#define HW_SMC_REGS(x) (*(hw_smc_t *)(x))

/*
 * MK64F12 SPI
 *
 * Serial Peripheral Interface
 *
 * Registers defined in this header file:
 * - HW_SPI_MCR - Module Configuration Register
 * - HW_SPI_TCR - Transfer Count Register
 * - HW_SPI_CTARn - Clock and Transfer Attributes Register (In Master Mode)
 * - HW_SPI_CTARn_SLAVE - Clock and Transfer Attributes Register (In Slave Mode)
 * - HW_SPI_SR - Status Register
 * - HW_SPI_RSER - DMA/Interrupt Request Select and Enable Register
 * - HW_SPI_PUSHR - PUSH TX FIFO Register In Master Mode
 * - HW_SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode
 * - HW_SPI_POPR - POP RX FIFO Register
 * - HW_SPI_TXFRn - Transmit FIFO Registers
 * - HW_SPI_RXFRn - Receive FIFO Registers
 *
 * - hw_spi_t - Struct containing all module registers.
 */

#define HW_SPI_INSTANCE_COUNT (3U) /*!< Number of instances of the SPI module. */
#define HW_SPI0 (0U) /*!< Instance number for SPI0. */
#define HW_SPI1 (1U) /*!< Instance number for SPI1. */
#define HW_SPI2 (2U) /*!< Instance number for SPI2. */

/*******************************************************************************
 * HW_SPI_MCR - Module Configuration Register
 ******************************************************************************/

/*!
 * @brief HW_SPI_MCR - Module Configuration Register (RW)
 *
 * Reset value: 0x00004001U
 *
 * Contains bits to configure various attributes associated with the module
 * operations. The HALT and MDIS bits can be changed at any time, but the effect
 * takes place only on the next frame boundary. Only the HALT and MDIS bits in the
 * MCR can be changed, while the module is in the Running state.
 */
typedef union _hw_spi_mcr
{
    uint32_t U;
    struct _hw_spi_mcr_bitfields
    {
        uint32_t HALT : 1;             /*!< [0] Halt */
        uint32_t RESERVED0 : 7;        /*!< [7:1]  */
        uint32_t SMPL_PT : 2;          /*!< [9:8] Sample Point */
        uint32_t CLR_RXF : 1;          /*!< [10]  */
        uint32_t CLR_TXF : 1;          /*!< [11] Clear TX FIFO */
        uint32_t DIS_RXF : 1;          /*!< [12] Disable Receive FIFO */
        uint32_t DIS_TXF : 1;          /*!< [13] Disable Transmit FIFO */
        uint32_t MDIS : 1;             /*!< [14] Module Disable */
        uint32_t DOZE : 1;             /*!< [15] Doze Enable */
        uint32_t PCSIS : 6;            /*!< [21:16] Peripheral Chip Select x Inactive
                                        * State */
        uint32_t RESERVED1 : 2;        /*!< [23:22]  */
        uint32_t ROOE : 1;             /*!< [24] Receive FIFO Overflow Overwrite Enable */
        uint32_t PCSSE : 1;            /*!< [25] Peripheral Chip Select Strobe Enable */
        uint32_t MTFE : 1;             /*!< [26] Modified Timing Format Enable */
        uint32_t FRZ : 1;              /*!< [27] Freeze */
        uint32_t DCONF : 2;            /*!< [29:28] SPI Configuration. */
        uint32_t CONT_SCKE : 1;        /*!< [30] Continuous SCK Enable */
        uint32_t MSTR : 1;             /*!< [31] Master/Slave Mode Select */
    } B;
} hw_spi_mcr_t;

/*!
 * @name Constants and macros for entire SPI_MCR register
 */
/*@{*/
#define HW_SPI_MCR_ADDR(x)       ((uint32_t)(x) + 0x0U)

#define HW_SPI_MCR(x)            (*(__IO hw_spi_mcr_t *) HW_SPI_MCR_ADDR(x))
#define HW_SPI_MCR_RD(x)         (HW_SPI_MCR(x).U)
#define HW_SPI_MCR_WR(x, v)      (HW_SPI_MCR(x).U = (v))
#define HW_SPI_MCR_SET(x, v)     (HW_SPI_MCR_WR(x, HW_SPI_MCR_RD(x) |  (v)))
#define HW_SPI_MCR_CLR(x, v)     (HW_SPI_MCR_WR(x, HW_SPI_MCR_RD(x) & ~(v)))
#define HW_SPI_MCR_TOG(x, v)     (HW_SPI_MCR_WR(x, HW_SPI_MCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SPI_MCR bitfields
 */

/*!
 * @name Register SPI_MCR, field HALT[0] (RW)
 *
 * The HALT bit starts and stops frame transfers. See Start and Stop of Module
 * transfers
 *
 * Values:
 * - 0 - Start transfers.
 * - 1 - Stop transfers.
 */
/*@{*/
#define BP_SPI_MCR_HALT      (0U)          /*!< Bit position for SPI_MCR_HALT. */
#define BM_SPI_MCR_HALT      (0x00000001U) /*!< Bit mask for SPI_MCR_HALT. */
#define BS_SPI_MCR_HALT      (1U)          /*!< Bit field size in bits for SPI_MCR_HALT. */

/*! @brief Read current value of the SPI_MCR_HALT field. */
#define BR_SPI_MCR_HALT(x)   (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_HALT))

/*! @brief Format value for bitfield SPI_MCR_HALT. */
#define BF_SPI_MCR_HALT(v)   ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_HALT) & BM_SPI_MCR_HALT)

/*! @brief Set the HALT field to a new value. */
#define BW_SPI_MCR_HALT(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_HALT) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field SMPL_PT[9:8] (RW)
 *
 * Controls when the module master samples SIN in Modified Transfer Format. This
 * field is valid only when CPHA bit in CTARn[CPHA] is 0.
 *
 * Values:
 * - 00 - 0 protocol clock cycles between SCK edge and SIN sample
 * - 01 - 1 protocol clock cycle between SCK edge and SIN sample
 * - 10 - 2 protocol clock cycles between SCK edge and SIN sample
 * - 11 - Reserved
 */
/*@{*/
#define BP_SPI_MCR_SMPL_PT   (8U)          /*!< Bit position for SPI_MCR_SMPL_PT. */
#define BM_SPI_MCR_SMPL_PT   (0x00000300U) /*!< Bit mask for SPI_MCR_SMPL_PT. */
#define BS_SPI_MCR_SMPL_PT   (2U)          /*!< Bit field size in bits for SPI_MCR_SMPL_PT. */

/*! @brief Read current value of the SPI_MCR_SMPL_PT field. */
#define BR_SPI_MCR_SMPL_PT(x) (HW_SPI_MCR(x).B.SMPL_PT)

/*! @brief Format value for bitfield SPI_MCR_SMPL_PT. */
#define BF_SPI_MCR_SMPL_PT(v) ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_SMPL_PT) & BM_SPI_MCR_SMPL_PT)

/*! @brief Set the SMPL_PT field to a new value. */
#define BW_SPI_MCR_SMPL_PT(x, v) (HW_SPI_MCR_WR(x, (HW_SPI_MCR_RD(x) & ~BM_SPI_MCR_SMPL_PT) | BF_SPI_MCR_SMPL_PT(v)))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_RXF[10] (WORZ)
 *
 * Flushes the RX FIFO. Writing a 1 to CLR_RXF clears the RX Counter. The
 * CLR_RXF bit is always read as zero.
 *
 * Values:
 * - 0 - Do not clear the RX FIFO counter.
 * - 1 - Clear the RX FIFO counter.
 */
/*@{*/
#define BP_SPI_MCR_CLR_RXF   (10U)         /*!< Bit position for SPI_MCR_CLR_RXF. */
#define BM_SPI_MCR_CLR_RXF   (0x00000400U) /*!< Bit mask for SPI_MCR_CLR_RXF. */
#define BS_SPI_MCR_CLR_RXF   (1U)          /*!< Bit field size in bits for SPI_MCR_CLR_RXF. */

/*! @brief Format value for bitfield SPI_MCR_CLR_RXF. */
#define BF_SPI_MCR_CLR_RXF(v) ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_CLR_RXF) & BM_SPI_MCR_CLR_RXF)

/*! @brief Set the CLR_RXF field to a new value. */
#define BW_SPI_MCR_CLR_RXF(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_CLR_RXF) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_TXF[11] (WORZ)
 *
 * Flushes the TX FIFO. Writing a 1 to CLR_TXF clears the TX FIFO Counter. The
 * CLR_TXF bit is always read as zero.
 *
 * Values:
 * - 0 - Do not clear the TX FIFO counter.
 * - 1 - Clear the TX FIFO counter.
 */
/*@{*/
#define BP_SPI_MCR_CLR_TXF   (11U)         /*!< Bit position for SPI_MCR_CLR_TXF. */
#define BM_SPI_MCR_CLR_TXF   (0x00000800U) /*!< Bit mask for SPI_MCR_CLR_TXF. */
#define BS_SPI_MCR_CLR_TXF   (1U)          /*!< Bit field size in bits for SPI_MCR_CLR_TXF. */

/*! @brief Format value for bitfield SPI_MCR_CLR_TXF. */
#define BF_SPI_MCR_CLR_TXF(v) ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_CLR_TXF) & BM_SPI_MCR_CLR_TXF)

/*! @brief Set the CLR_TXF field to a new value. */
#define BW_SPI_MCR_CLR_TXF(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_CLR_TXF) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_RXF[12] (RW)
 *
 * When the RX FIFO is disabled, the receive part of the module operates as a
 * simplified double-buffered SPI. This bit can only be written when the MDIS bit
 * is cleared.
 *
 * Values:
 * - 0 - RX FIFO is enabled.
 * - 1 - RX FIFO is disabled.
 */
/*@{*/
#define BP_SPI_MCR_DIS_RXF   (12U)         /*!< Bit position for SPI_MCR_DIS_RXF. */
#define BM_SPI_MCR_DIS_RXF   (0x00001000U) /*!< Bit mask for SPI_MCR_DIS_RXF. */
#define BS_SPI_MCR_DIS_RXF   (1U)          /*!< Bit field size in bits for SPI_MCR_DIS_RXF. */

/*! @brief Read current value of the SPI_MCR_DIS_RXF field. */
#define BR_SPI_MCR_DIS_RXF(x) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_DIS_RXF))

/*! @brief Format value for bitfield SPI_MCR_DIS_RXF. */
#define BF_SPI_MCR_DIS_RXF(v) ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_DIS_RXF) & BM_SPI_MCR_DIS_RXF)

/*! @brief Set the DIS_RXF field to a new value. */
#define BW_SPI_MCR_DIS_RXF(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_DIS_RXF) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_TXF[13] (RW)
 *
 * When the TX FIFO is disabled, the transmit part of the module operates as a
 * simplified double-buffered SPI. This bit can be written only when the MDIS bit
 * is cleared.
 *
 * Values:
 * - 0 - TX FIFO is enabled.
 * - 1 - TX FIFO is disabled.
 */
/*@{*/
#define BP_SPI_MCR_DIS_TXF   (13U)         /*!< Bit position for SPI_MCR_DIS_TXF. */
#define BM_SPI_MCR_DIS_TXF   (0x00002000U) /*!< Bit mask for SPI_MCR_DIS_TXF. */
#define BS_SPI_MCR_DIS_TXF   (1U)          /*!< Bit field size in bits for SPI_MCR_DIS_TXF. */

/*! @brief Read current value of the SPI_MCR_DIS_TXF field. */
#define BR_SPI_MCR_DIS_TXF(x) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_DIS_TXF))

/*! @brief Format value for bitfield SPI_MCR_DIS_TXF. */
#define BF_SPI_MCR_DIS_TXF(v) ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_DIS_TXF) & BM_SPI_MCR_DIS_TXF)

/*! @brief Set the DIS_TXF field to a new value. */
#define BW_SPI_MCR_DIS_TXF(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_DIS_TXF) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field MDIS[14] (RW)
 *
 * Allows the clock to be stopped to the non-memory mapped logic in the module
 * effectively putting it in a software-controlled power-saving state. The reset
 * value of the MDIS bit is parameterized, with a default reset value of 0. When
 * the module is used in Slave Mode, we recommend leaving this bit 0, because a
 * slave doesn't have control over master transactions.
 *
 * Values:
 * - 0 - Enables the module clocks.
 * - 1 - Allows external logic to disable the module clocks.
 */
/*@{*/
#define BP_SPI_MCR_MDIS      (14U)         /*!< Bit position for SPI_MCR_MDIS. */
#define BM_SPI_MCR_MDIS      (0x00004000U) /*!< Bit mask for SPI_MCR_MDIS. */
#define BS_SPI_MCR_MDIS      (1U)          /*!< Bit field size in bits for SPI_MCR_MDIS. */

/*! @brief Read current value of the SPI_MCR_MDIS field. */
#define BR_SPI_MCR_MDIS(x)   (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_MDIS))

/*! @brief Format value for bitfield SPI_MCR_MDIS. */
#define BF_SPI_MCR_MDIS(v)   ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_MDIS) & BM_SPI_MCR_MDIS)

/*! @brief Set the MDIS field to a new value. */
#define BW_SPI_MCR_MDIS(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_MDIS) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field DOZE[15] (RW)
 *
 * Provides support for an externally controlled Doze mode power-saving
 * mechanism.
 *
 * Values:
 * - 0 - Doze mode has no effect on the module.
 * - 1 - Doze mode disables the module.
 */
/*@{*/
#define BP_SPI_MCR_DOZE      (15U)         /*!< Bit position for SPI_MCR_DOZE. */
#define BM_SPI_MCR_DOZE      (0x00008000U) /*!< Bit mask for SPI_MCR_DOZE. */
#define BS_SPI_MCR_DOZE      (1U)          /*!< Bit field size in bits for SPI_MCR_DOZE. */

/*! @brief Read current value of the SPI_MCR_DOZE field. */
#define BR_SPI_MCR_DOZE(x)   (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_DOZE))

/*! @brief Format value for bitfield SPI_MCR_DOZE. */
#define BF_SPI_MCR_DOZE(v)   ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_DOZE) & BM_SPI_MCR_DOZE)

/*! @brief Set the DOZE field to a new value. */
#define BW_SPI_MCR_DOZE(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_DOZE) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field PCSIS[21:16] (RW)
 *
 * Determines the inactive state of PCSx.
 *
 * Values:
 * - 0 - The inactive state of PCSx is low.
 * - 1 - The inactive state of PCSx is high.
 */
/*@{*/
#define BP_SPI_MCR_PCSIS     (16U)         /*!< Bit position for SPI_MCR_PCSIS. */
#define BM_SPI_MCR_PCSIS     (0x003F0000U) /*!< Bit mask for SPI_MCR_PCSIS. */
#define BS_SPI_MCR_PCSIS     (6U)          /*!< Bit field size in bits for SPI_MCR_PCSIS. */

/*! @brief Read current value of the SPI_MCR_PCSIS field. */
#define BR_SPI_MCR_PCSIS(x)  (HW_SPI_MCR(x).B.PCSIS)

/*! @brief Format value for bitfield SPI_MCR_PCSIS. */
#define BF_SPI_MCR_PCSIS(v)  ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_PCSIS) & BM_SPI_MCR_PCSIS)

/*! @brief Set the PCSIS field to a new value. */
#define BW_SPI_MCR_PCSIS(x, v) (HW_SPI_MCR_WR(x, (HW_SPI_MCR_RD(x) & ~BM_SPI_MCR_PCSIS) | BF_SPI_MCR_PCSIS(v)))
/*@}*/

/*!
 * @name Register SPI_MCR, field ROOE[24] (RW)
 *
 * In the RX FIFO overflow condition, configures the module to ignore the
 * incoming serial data or overwrite existing data. If the RX FIFO is full and new data
 * is received, the data from the transfer, generating the overflow, is ignored
 * or shifted into the shift register.
 *
 * Values:
 * - 0 - Incoming data is ignored.
 * - 1 - Incoming data is shifted into the shift register.
 */
/*@{*/
#define BP_SPI_MCR_ROOE      (24U)         /*!< Bit position for SPI_MCR_ROOE. */
#define BM_SPI_MCR_ROOE      (0x01000000U) /*!< Bit mask for SPI_MCR_ROOE. */
#define BS_SPI_MCR_ROOE      (1U)          /*!< Bit field size in bits for SPI_MCR_ROOE. */

/*! @brief Read current value of the SPI_MCR_ROOE field. */
#define BR_SPI_MCR_ROOE(x)   (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_ROOE))

/*! @brief Format value for bitfield SPI_MCR_ROOE. */
#define BF_SPI_MCR_ROOE(v)   ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_ROOE) & BM_SPI_MCR_ROOE)

/*! @brief Set the ROOE field to a new value. */
#define BW_SPI_MCR_ROOE(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_ROOE) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field PCSSE[25] (RW)
 *
 * Enables the PCS5/ PCSS to operate as a PCS Strobe output signal.
 *
 * Values:
 * - 0 - PCS5/ PCSS is used as the Peripheral Chip Select[5] signal.
 * - 1 - PCS5/ PCSS is used as an active-low PCS Strobe signal.
 */
/*@{*/
#define BP_SPI_MCR_PCSSE     (25U)         /*!< Bit position for SPI_MCR_PCSSE. */
#define BM_SPI_MCR_PCSSE     (0x02000000U) /*!< Bit mask for SPI_MCR_PCSSE. */
#define BS_SPI_MCR_PCSSE     (1U)          /*!< Bit field size in bits for SPI_MCR_PCSSE. */

/*! @brief Read current value of the SPI_MCR_PCSSE field. */
#define BR_SPI_MCR_PCSSE(x)  (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_PCSSE))

/*! @brief Format value for bitfield SPI_MCR_PCSSE. */
#define BF_SPI_MCR_PCSSE(v)  ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_PCSSE) & BM_SPI_MCR_PCSSE)

/*! @brief Set the PCSSE field to a new value. */
#define BW_SPI_MCR_PCSSE(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_PCSSE) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field MTFE[26] (RW)
 *
 * Enables a modified transfer format to be used.
 *
 * Values:
 * - 0 - Modified SPI transfer format disabled.
 * - 1 - Modified SPI transfer format enabled.
 */
/*@{*/
#define BP_SPI_MCR_MTFE      (26U)         /*!< Bit position for SPI_MCR_MTFE. */
#define BM_SPI_MCR_MTFE      (0x04000000U) /*!< Bit mask for SPI_MCR_MTFE. */
#define BS_SPI_MCR_MTFE      (1U)          /*!< Bit field size in bits for SPI_MCR_MTFE. */

/*! @brief Read current value of the SPI_MCR_MTFE field. */
#define BR_SPI_MCR_MTFE(x)   (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_MTFE))

/*! @brief Format value for bitfield SPI_MCR_MTFE. */
#define BF_SPI_MCR_MTFE(v)   ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_MTFE) & BM_SPI_MCR_MTFE)

/*! @brief Set the MTFE field to a new value. */
#define BW_SPI_MCR_MTFE(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_MTFE) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field FRZ[27] (RW)
 *
 * Enables transfers to be stopped on the next frame boundary when the device
 * enters Debug mode.
 *
 * Values:
 * - 0 - Do not halt serial transfers in Debug mode.
 * - 1 - Halt serial transfers in Debug mode.
 */
/*@{*/
#define BP_SPI_MCR_FRZ       (27U)         /*!< Bit position for SPI_MCR_FRZ. */
#define BM_SPI_MCR_FRZ       (0x08000000U) /*!< Bit mask for SPI_MCR_FRZ. */
#define BS_SPI_MCR_FRZ       (1U)          /*!< Bit field size in bits for SPI_MCR_FRZ. */

/*! @brief Read current value of the SPI_MCR_FRZ field. */
#define BR_SPI_MCR_FRZ(x)    (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_FRZ))

/*! @brief Format value for bitfield SPI_MCR_FRZ. */
#define BF_SPI_MCR_FRZ(v)    ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_FRZ) & BM_SPI_MCR_FRZ)

/*! @brief Set the FRZ field to a new value. */
#define BW_SPI_MCR_FRZ(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_FRZ) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field DCONF[29:28] (RO)
 *
 * Selects among the different configurations of the module.
 *
 * Values:
 * - 00 - SPI
 * - 01 - Reserved
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
#define BP_SPI_MCR_DCONF     (28U)         /*!< Bit position for SPI_MCR_DCONF. */
#define BM_SPI_MCR_DCONF     (0x30000000U) /*!< Bit mask for SPI_MCR_DCONF. */
#define BS_SPI_MCR_DCONF     (2U)          /*!< Bit field size in bits for SPI_MCR_DCONF. */

/*! @brief Read current value of the SPI_MCR_DCONF field. */
#define BR_SPI_MCR_DCONF(x)  (HW_SPI_MCR(x).B.DCONF)
/*@}*/

/*!
 * @name Register SPI_MCR, field CONT_SCKE[30] (RW)
 *
 * Enables the Serial Communication Clock (SCK) to run continuously.
 *
 * Values:
 * - 0 - Continuous SCK disabled.
 * - 1 - Continuous SCK enabled.
 */
/*@{*/
#define BP_SPI_MCR_CONT_SCKE (30U)         /*!< Bit position for SPI_MCR_CONT_SCKE. */
#define BM_SPI_MCR_CONT_SCKE (0x40000000U) /*!< Bit mask for SPI_MCR_CONT_SCKE. */
#define BS_SPI_MCR_CONT_SCKE (1U)          /*!< Bit field size in bits for SPI_MCR_CONT_SCKE. */

/*! @brief Read current value of the SPI_MCR_CONT_SCKE field. */
#define BR_SPI_MCR_CONT_SCKE(x) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_CONT_SCKE))

/*! @brief Format value for bitfield SPI_MCR_CONT_SCKE. */
#define BF_SPI_MCR_CONT_SCKE(v) ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_CONT_SCKE) & BM_SPI_MCR_CONT_SCKE)

/*! @brief Set the CONT_SCKE field to a new value. */
#define BW_SPI_MCR_CONT_SCKE(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_CONT_SCKE) = (v))
/*@}*/

/*!
 * @name Register SPI_MCR, field MSTR[31] (RW)
 *
 * Enables either Master mode (if supported) or Slave mode (if supported)
 * operation.
 *
 * Values:
 * - 0 - Enables Slave mode
 * - 1 - Enables Master mode
 */
/*@{*/
#define BP_SPI_MCR_MSTR      (31U)         /*!< Bit position for SPI_MCR_MSTR. */
#define BM_SPI_MCR_MSTR      (0x80000000U) /*!< Bit mask for SPI_MCR_MSTR. */
#define BS_SPI_MCR_MSTR      (1U)          /*!< Bit field size in bits for SPI_MCR_MSTR. */

/*! @brief Read current value of the SPI_MCR_MSTR field. */
#define BR_SPI_MCR_MSTR(x)   (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_MSTR))

/*! @brief Format value for bitfield SPI_MCR_MSTR. */
#define BF_SPI_MCR_MSTR(v)   ((uint32_t)((uint32_t)(v) << BP_SPI_MCR_MSTR) & BM_SPI_MCR_MSTR)

/*! @brief Set the MSTR field to a new value. */
#define BW_SPI_MCR_MSTR(x, v) (BITBAND_ACCESS32(HW_SPI_MCR_ADDR(x), BP_SPI_MCR_MSTR) = (v))
/*@}*/

/*******************************************************************************
 * HW_SPI_TCR - Transfer Count Register
 ******************************************************************************/

/*!
 * @brief HW_SPI_TCR - Transfer Count Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TCR contains a counter that indicates the number of SPI transfers made. The
 * transfer counter is intended to assist in queue management. Do not write the
 * TCR when the module is in the Running state.
 */
typedef union _hw_spi_tcr
{
    uint32_t U;
    struct _hw_spi_tcr_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t SPI_TCNT : 16;        /*!< [31:16] SPI Transfer Counter */
    } B;
} hw_spi_tcr_t;

/*!
 * @name Constants and macros for entire SPI_TCR register
 */
/*@{*/
#define HW_SPI_TCR_ADDR(x)       ((uint32_t)(x) + 0x8U)

#define HW_SPI_TCR(x)            (*(__IO hw_spi_tcr_t *) HW_SPI_TCR_ADDR(x))
#define HW_SPI_TCR_RD(x)         (HW_SPI_TCR(x).U)
#define HW_SPI_TCR_WR(x, v)      (HW_SPI_TCR(x).U = (v))
#define HW_SPI_TCR_SET(x, v)     (HW_SPI_TCR_WR(x, HW_SPI_TCR_RD(x) |  (v)))
#define HW_SPI_TCR_CLR(x, v)     (HW_SPI_TCR_WR(x, HW_SPI_TCR_RD(x) & ~(v)))
#define HW_SPI_TCR_TOG(x, v)     (HW_SPI_TCR_WR(x, HW_SPI_TCR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SPI_TCR bitfields
 */

/*!
 * @name Register SPI_TCR, field SPI_TCNT[31:16] (RW)
 *
 * Counts the number of SPI transfers the module makes. The SPI_TCNT field
 * increments every time the last bit of an SPI frame is transmitted. A value written
 * to SPI_TCNT presets the counter to that value. SPI_TCNT is reset to zero at
 * the beginning of the frame when the CTCNT field is set in the executing SPI
 * command. The Transfer Counter wraps around; incrementing the counter past 65535
 * resets the counter to zero.
 */
/*@{*/
#define BP_SPI_TCR_SPI_TCNT  (16U)         /*!< Bit position for SPI_TCR_SPI_TCNT. */
#define BM_SPI_TCR_SPI_TCNT  (0xFFFF0000U) /*!< Bit mask for SPI_TCR_SPI_TCNT. */
#define BS_SPI_TCR_SPI_TCNT  (16U)         /*!< Bit field size in bits for SPI_TCR_SPI_TCNT. */

/*! @brief Read current value of the SPI_TCR_SPI_TCNT field. */
#define BR_SPI_TCR_SPI_TCNT(x) (HW_SPI_TCR(x).B.SPI_TCNT)

/*! @brief Format value for bitfield SPI_TCR_SPI_TCNT. */
#define BF_SPI_TCR_SPI_TCNT(v) ((uint32_t)((uint32_t)(v) << BP_SPI_TCR_SPI_TCNT) & BM_SPI_TCR_SPI_TCNT)

/*! @brief Set the SPI_TCNT field to a new value. */
#define BW_SPI_TCR_SPI_TCNT(x, v) (HW_SPI_TCR_WR(x, (HW_SPI_TCR_RD(x) & ~BM_SPI_TCR_SPI_TCNT) | BF_SPI_TCR_SPI_TCNT(v)))
/*@}*/

/*******************************************************************************
 * HW_SPI_CTARn - Clock and Transfer Attributes Register (In Master Mode)
 ******************************************************************************/

/*!
 * @brief HW_SPI_CTARn - Clock and Transfer Attributes Register (In Master Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * CTAR registers are used to define different transfer attributes. Do not write
 * to the CTAR registers while the module is in the Running state. In Master
 * mode, the CTAR registers define combinations of transfer attributes such as frame
 * size, clock phase and polarity, data bit ordering, baud rate, and various
 * delays. In slave mode, a subset of the bitfields in CTAR0 are used to set the
 * slave transfer attributes. When the module is configured as an SPI master, the
 * CTAS field in the command portion of the TX FIFO entry selects which of the CTAR
 * registers is used. When the module is configured as an SPI bus slave, it uses
 * the CTAR0 register.
 */
typedef union _hw_spi_ctarn
{
    uint32_t U;
    struct _hw_spi_ctarn_bitfields
    {
        uint32_t BR : 4;               /*!< [3:0] Baud Rate Scaler */
        uint32_t DT : 4;               /*!< [7:4] Delay After Transfer Scaler */
        uint32_t ASC : 4;              /*!< [11:8] After SCK Delay Scaler */
        uint32_t CSSCK : 4;            /*!< [15:12] PCS to SCK Delay Scaler */
        uint32_t PBR : 2;              /*!< [17:16] Baud Rate Prescaler */
        uint32_t PDT : 2;              /*!< [19:18] Delay after Transfer Prescaler */
        uint32_t PASC : 2;             /*!< [21:20] After SCK Delay Prescaler */
        uint32_t PCSSCK : 2;           /*!< [23:22] PCS to SCK Delay Prescaler */
        uint32_t LSBFE : 1;            /*!< [24] LSB First */
        uint32_t CPHA : 1;             /*!< [25] Clock Phase */
        uint32_t CPOL : 1;             /*!< [26] Clock Polarity */
        uint32_t FMSZ : 4;             /*!< [30:27] Frame Size */
        uint32_t DBR : 1;              /*!< [31] Double Baud Rate */
    } B;
} hw_spi_ctarn_t;

/*!
 * @name Constants and macros for entire SPI_CTARn register
 */
/*@{*/
#define HW_SPI_CTARn_COUNT (2U)

#define HW_SPI_CTARn_ADDR(x, n)  ((uint32_t)(x) + 0xCU + (0x4U * (n)))

#define HW_SPI_CTARn(x, n)       (*(__IO hw_spi_ctarn_t *) HW_SPI_CTARn_ADDR(x, n))
#define HW_SPI_CTARn_RD(x, n)    (HW_SPI_CTARn(x, n).U)
#define HW_SPI_CTARn_WR(x, n, v) (HW_SPI_CTARn(x, n).U = (v))
#define HW_SPI_CTARn_SET(x, n, v) (HW_SPI_CTARn_WR(x, n, HW_SPI_CTARn_RD(x, n) |  (v)))
#define HW_SPI_CTARn_CLR(x, n, v) (HW_SPI_CTARn_WR(x, n, HW_SPI_CTARn_RD(x, n) & ~(v)))
#define HW_SPI_CTARn_TOG(x, n, v) (HW_SPI_CTARn_WR(x, n, HW_SPI_CTARn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTARn bitfields
 */

/*!
 * @name Register SPI_CTARn, field BR[3:0] (RW)
 *
 * Selects the scaler value for the baud rate. This field is used only in master
 * mode. The prescaled protocol clock is divided by the Baud Rate Scaler to
 * generate the frequency of the SCK. The baud rate is computed according to the
 * following equation: SCK baud rate = (fP /PBR) x [(1+DBR)/BR] The following table
 * lists the baud rate scaler values. Baud Rate Scaler CTARn[BR] Baud Rate Scaler
 * Value 0000 2 0001 4 0010 6 0011 8 0100 16 0101 32 0110 64 0111 128 1000 256
 * 1001 512 1010 1024 1011 2048 1100 4096 1101 8192 1110 16384 1111 32768
 */
/*@{*/
#define BP_SPI_CTARn_BR      (0U)          /*!< Bit position for SPI_CTARn_BR. */
#define BM_SPI_CTARn_BR      (0x0000000FU) /*!< Bit mask for SPI_CTARn_BR. */
#define BS_SPI_CTARn_BR      (4U)          /*!< Bit field size in bits for SPI_CTARn_BR. */

/*! @brief Read current value of the SPI_CTARn_BR field. */
#define BR_SPI_CTARn_BR(x, n) (HW_SPI_CTARn(x, n).B.BR)

/*! @brief Format value for bitfield SPI_CTARn_BR. */
#define BF_SPI_CTARn_BR(v)   ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_BR) & BM_SPI_CTARn_BR)

/*! @brief Set the BR field to a new value. */
#define BW_SPI_CTARn_BR(x, n, v) (HW_SPI_CTARn_WR(x, n, (HW_SPI_CTARn_RD(x, n) & ~BM_SPI_CTARn_BR) | BF_SPI_CTARn_BR(v)))
/*@}*/

/*!
 * @name Register SPI_CTARn, field DT[7:4] (RW)
 *
 * Selects the Delay after Transfer Scaler. This field is used only in master
 * mode. The Delay after Transfer is the time between the negation of the PCS
 * signal at the end of a frame and the assertion of PCS at the beginning of the next
 * frame. In the Continuous Serial Communications Clock operation, the DT value
 * is fixed to one SCK clock period, The Delay after Transfer is a multiple of the
 * protocol clock period, and it is computed according to the following
 * equation: tDT = (1/fP ) x PDT x DT See Delay Scaler Encoding table in CTARn[CSSCK] bit
 * field description for scaler values.
 */
/*@{*/
#define BP_SPI_CTARn_DT      (4U)          /*!< Bit position for SPI_CTARn_DT. */
#define BM_SPI_CTARn_DT      (0x000000F0U) /*!< Bit mask for SPI_CTARn_DT. */
#define BS_SPI_CTARn_DT      (4U)          /*!< Bit field size in bits for SPI_CTARn_DT. */

/*! @brief Read current value of the SPI_CTARn_DT field. */
#define BR_SPI_CTARn_DT(x, n) (HW_SPI_CTARn(x, n).B.DT)

/*! @brief Format value for bitfield SPI_CTARn_DT. */
#define BF_SPI_CTARn_DT(v)   ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_DT) & BM_SPI_CTARn_DT)

/*! @brief Set the DT field to a new value. */
#define BW_SPI_CTARn_DT(x, n, v) (HW_SPI_CTARn_WR(x, n, (HW_SPI_CTARn_RD(x, n) & ~BM_SPI_CTARn_DT) | BF_SPI_CTARn_DT(v)))
/*@}*/

/*!
 * @name Register SPI_CTARn, field ASC[11:8] (RW)
 *
 * Selects the scaler value for the After SCK Delay. This field is used only in
 * master mode. The After SCK Delay is the delay between the last edge of SCK and
 * the negation of PCS. The delay is a multiple of the protocol clock period,
 * and it is computed according to the following equation: t ASC = (1/fP) x PASC x
 * ASC See Delay Scaler Encoding table in CTARn[CSSCK] bit field description for
 * scaler values. Refer After SCK Delay (tASC ) for more details.
 */
/*@{*/
#define BP_SPI_CTARn_ASC     (8U)          /*!< Bit position for SPI_CTARn_ASC. */
#define BM_SPI_CTARn_ASC     (0x00000F00U) /*!< Bit mask for SPI_CTARn_ASC. */
#define BS_SPI_CTARn_ASC     (4U)          /*!< Bit field size in bits for SPI_CTARn_ASC. */

/*! @brief Read current value of the SPI_CTARn_ASC field. */
#define BR_SPI_CTARn_ASC(x, n) (HW_SPI_CTARn(x, n).B.ASC)

/*! @brief Format value for bitfield SPI_CTARn_ASC. */
#define BF_SPI_CTARn_ASC(v)  ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_ASC) & BM_SPI_CTARn_ASC)

/*! @brief Set the ASC field to a new value. */
#define BW_SPI_CTARn_ASC(x, n, v) (HW_SPI_CTARn_WR(x, n, (HW_SPI_CTARn_RD(x, n) & ~BM_SPI_CTARn_ASC) | BF_SPI_CTARn_ASC(v)))
/*@}*/

/*!
 * @name Register SPI_CTARn, field CSSCK[15:12] (RW)
 *
 * Selects the scaler value for the PCS to SCK delay. This field is used only in
 * master mode. The PCS to SCK Delay is the delay between the assertion of PCS
 * and the first edge of the SCK. The delay is a multiple of the protocol clock
 * period, and it is computed according to the following equation: t CSC = (1/fP )
 * x PCSSCK x CSSCK. The following table lists the delay scaler values. Delay
 * Scaler Encoding Field Value Delay Scaler Value 0000 2 0001 4 0010 8 0011 16 0100
 * 32 0101 64 0110 128 0111 256 1000 512 1001 1024 1010 2048 1011 4096 1100 8192
 * 1101 16384 1110 32768 1111 65536 Refer PCS to SCK Delay (tCSC ) for more
 * details.
 */
/*@{*/
#define BP_SPI_CTARn_CSSCK   (12U)         /*!< Bit position for SPI_CTARn_CSSCK. */
#define BM_SPI_CTARn_CSSCK   (0x0000F000U) /*!< Bit mask for SPI_CTARn_CSSCK. */
#define BS_SPI_CTARn_CSSCK   (4U)          /*!< Bit field size in bits for SPI_CTARn_CSSCK. */

/*! @brief Read current value of the SPI_CTARn_CSSCK field. */
#define BR_SPI_CTARn_CSSCK(x, n) (HW_SPI_CTARn(x, n).B.CSSCK)

/*! @brief Format value for bitfield SPI_CTARn_CSSCK. */
#define BF_SPI_CTARn_CSSCK(v) ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_CSSCK) & BM_SPI_CTARn_CSSCK)

/*! @brief Set the CSSCK field to a new value. */
#define BW_SPI_CTARn_CSSCK(x, n, v) (HW_SPI_CTARn_WR(x, n, (HW_SPI_CTARn_RD(x, n) & ~BM_SPI_CTARn_CSSCK) | BF_SPI_CTARn_CSSCK(v)))
/*@}*/

/*!
 * @name Register SPI_CTARn, field PBR[17:16] (RW)
 *
 * Selects the prescaler value for the baud rate. This field is used only in
 * master mode. The baud rate is the frequency of the SCK. The protocol clock is
 * divided by the prescaler value before the baud rate selection takes place. See
 * the BR field description for details on how to compute the baud rate.
 *
 * Values:
 * - 00 - Baud Rate Prescaler value is 2.
 * - 01 - Baud Rate Prescaler value is 3.
 * - 10 - Baud Rate Prescaler value is 5.
 * - 11 - Baud Rate Prescaler value is 7.
 */
/*@{*/
#define BP_SPI_CTARn_PBR     (16U)         /*!< Bit position for SPI_CTARn_PBR. */
#define BM_SPI_CTARn_PBR     (0x00030000U) /*!< Bit mask for SPI_CTARn_PBR. */
#define BS_SPI_CTARn_PBR     (2U)          /*!< Bit field size in bits for SPI_CTARn_PBR. */

/*! @brief Read current value of the SPI_CTARn_PBR field. */
#define BR_SPI_CTARn_PBR(x, n) (HW_SPI_CTARn(x, n).B.PBR)

/*! @brief Format value for bitfield SPI_CTARn_PBR. */
#define BF_SPI_CTARn_PBR(v)  ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_PBR) & BM_SPI_CTARn_PBR)

/*! @brief Set the PBR field to a new value. */
#define BW_SPI_CTARn_PBR(x, n, v) (HW_SPI_CTARn_WR(x, n, (HW_SPI_CTARn_RD(x, n) & ~BM_SPI_CTARn_PBR) | BF_SPI_CTARn_PBR(v)))
/*@}*/

/*!
 * @name Register SPI_CTARn, field PDT[19:18] (RW)
 *
 * Selects the prescaler value for the delay between the negation of the PCS
 * signal at the end of a frame and the assertion of PCS at the beginning of the
 * next frame. The PDT field is only used in master mode. See the DT field
 * description for details on how to compute the Delay after Transfer. Refer Delay after
 * Transfer (tDT ) for more details.
 *
 * Values:
 * - 00 - Delay after Transfer Prescaler value is 1.
 * - 01 - Delay after Transfer Prescaler value is 3.
 * - 10 - Delay after Transfer Prescaler value is 5.
 * - 11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
#define BP_SPI_CTARn_PDT     (18U)         /*!< Bit position for SPI_CTARn_PDT. */
#define BM_SPI_CTARn_PDT     (0x000C0000U) /*!< Bit mask for SPI_CTARn_PDT. */
#define BS_SPI_CTARn_PDT     (2U)          /*!< Bit field size in bits for SPI_CTARn_PDT. */

/*! @brief Read current value of the SPI_CTARn_PDT field. */
#define BR_SPI_CTARn_PDT(x, n) (HW_SPI_CTARn(x, n).B.PDT)

/*! @brief Format value for bitfield SPI_CTARn_PDT. */
#define BF_SPI_CTARn_PDT(v)  ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_PDT) & BM_SPI_CTARn_PDT)

/*! @brief Set the PDT field to a new value. */
#define BW_SPI_CTARn_PDT(x, n, v) (HW_SPI_CTARn_WR(x, n, (HW_SPI_CTARn_RD(x, n) & ~BM_SPI_CTARn_PDT) | BF_SPI_CTARn_PDT(v)))
/*@}*/

/*!
 * @name Register SPI_CTARn, field PASC[21:20] (RW)
 *
 * Selects the prescaler value for the delay between the last edge of SCK and
 * the negation of PCS. See the ASC field description for information on how to
 * compute the After SCK Delay. Refer After SCK Delay (tASC ) for more details.
 *
 * Values:
 * - 00 - Delay after Transfer Prescaler value is 1.
 * - 01 - Delay after Transfer Prescaler value is 3.
 * - 10 - Delay after Transfer Prescaler value is 5.
 * - 11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
#define BP_SPI_CTARn_PASC    (20U)         /*!< Bit position for SPI_CTARn_PASC. */
#define BM_SPI_CTARn_PASC    (0x00300000U) /*!< Bit mask for SPI_CTARn_PASC. */
#define BS_SPI_CTARn_PASC    (2U)          /*!< Bit field size in bits for SPI_CTARn_PASC. */

/*! @brief Read current value of the SPI_CTARn_PASC field. */
#define BR_SPI_CTARn_PASC(x, n) (HW_SPI_CTARn(x, n).B.PASC)

/*! @brief Format value for bitfield SPI_CTARn_PASC. */
#define BF_SPI_CTARn_PASC(v) ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_PASC) & BM_SPI_CTARn_PASC)

/*! @brief Set the PASC field to a new value. */
#define BW_SPI_CTARn_PASC(x, n, v) (HW_SPI_CTARn_WR(x, n, (HW_SPI_CTARn_RD(x, n) & ~BM_SPI_CTARn_PASC) | BF_SPI_CTARn_PASC(v)))
/*@}*/

/*!
 * @name Register SPI_CTARn, field PCSSCK[23:22] (RW)
 *
 * Selects the prescaler value for the delay between assertion of PCS and the
 * first edge of the SCK. See the CSSCK field description for information on how to
 * compute the PCS to SCK Delay. Refer PCS to SCK Delay (tCSC ) for more details.
 *
 * Values:
 * - 00 - PCS to SCK Prescaler value is 1.
 * - 01 - PCS to SCK Prescaler value is 3.
 * - 10 - PCS to SCK Prescaler value is 5.
 * - 11 - PCS to SCK Prescaler value is 7.
 */
/*@{*/
#define BP_SPI_CTARn_PCSSCK  (22U)         /*!< Bit position for SPI_CTARn_PCSSCK. */
#define BM_SPI_CTARn_PCSSCK  (0x00C00000U) /*!< Bit mask for SPI_CTARn_PCSSCK. */
#define BS_SPI_CTARn_PCSSCK  (2U)          /*!< Bit field size in bits for SPI_CTARn_PCSSCK. */

/*! @brief Read current value of the SPI_CTARn_PCSSCK field. */
#define BR_SPI_CTARn_PCSSCK(x, n) (HW_SPI_CTARn(x, n).B.PCSSCK)

/*! @brief Format value for bitfield SPI_CTARn_PCSSCK. */
#define BF_SPI_CTARn_PCSSCK(v) ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_PCSSCK) & BM_SPI_CTARn_PCSSCK)

/*! @brief Set the PCSSCK field to a new value. */
#define BW_SPI_CTARn_PCSSCK(x, n, v) (HW_SPI_CTARn_WR(x, n, (HW_SPI_CTARn_RD(x, n) & ~BM_SPI_CTARn_PCSSCK) | BF_SPI_CTARn_PCSSCK(v)))
/*@}*/

/*!
 * @name Register SPI_CTARn, field LSBFE[24] (RW)
 *
 * Specifies whether the LSB or MSB of the frame is transferred first.
 *
 * Values:
 * - 0 - Data is transferred MSB first.
 * - 1 - Data is transferred LSB first.
 */
/*@{*/
#define BP_SPI_CTARn_LSBFE   (24U)         /*!< Bit position for SPI_CTARn_LSBFE. */
#define BM_SPI_CTARn_LSBFE   (0x01000000U) /*!< Bit mask for SPI_CTARn_LSBFE. */
#define BS_SPI_CTARn_LSBFE   (1U)          /*!< Bit field size in bits for SPI_CTARn_LSBFE. */

/*! @brief Read current value of the SPI_CTARn_LSBFE field. */
#define BR_SPI_CTARn_LSBFE(x, n) (BITBAND_ACCESS32(HW_SPI_CTARn_ADDR(x, n), BP_SPI_CTARn_LSBFE))

/*! @brief Format value for bitfield SPI_CTARn_LSBFE. */
#define BF_SPI_CTARn_LSBFE(v) ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_LSBFE) & BM_SPI_CTARn_LSBFE)

/*! @brief Set the LSBFE field to a new value. */
#define BW_SPI_CTARn_LSBFE(x, n, v) (BITBAND_ACCESS32(HW_SPI_CTARn_ADDR(x, n), BP_SPI_CTARn_LSBFE) = (v))
/*@}*/

/*!
 * @name Register SPI_CTARn, field CPHA[25] (RW)
 *
 * Selects which edge of SCK causes data to change and which edge causes data to
 * be captured. This bit is used in both master and slave mode. For successful
 * communication between serial devices, the devices must have identical clock
 * phase settings. In Continuous SCK mode, the bit value is ignored and the
 * transfers are done as if the CPHA bit is set to 1.
 *
 * Values:
 * - 0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
#define BP_SPI_CTARn_CPHA    (25U)         /*!< Bit position for SPI_CTARn_CPHA. */
#define BM_SPI_CTARn_CPHA    (0x02000000U) /*!< Bit mask for SPI_CTARn_CPHA. */
#define BS_SPI_CTARn_CPHA    (1U)          /*!< Bit field size in bits for SPI_CTARn_CPHA. */

/*! @brief Read current value of the SPI_CTARn_CPHA field. */
#define BR_SPI_CTARn_CPHA(x, n) (BITBAND_ACCESS32(HW_SPI_CTARn_ADDR(x, n), BP_SPI_CTARn_CPHA))

/*! @brief Format value for bitfield SPI_CTARn_CPHA. */
#define BF_SPI_CTARn_CPHA(v) ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_CPHA) & BM_SPI_CTARn_CPHA)

/*! @brief Set the CPHA field to a new value. */
#define BW_SPI_CTARn_CPHA(x, n, v) (BITBAND_ACCESS32(HW_SPI_CTARn_ADDR(x, n), BP_SPI_CTARn_CPHA) = (v))
/*@}*/

/*!
 * @name Register SPI_CTARn, field CPOL[26] (RW)
 *
 * Selects the inactive state of the Serial Communications Clock (SCK). This bit
 * is used in both master and slave mode. For successful communication between
 * serial devices, the devices must have identical clock polarities. When the
 * Continuous Selection Format is selected, switching between clock polarities
 * without stopping the module can cause errors in the transfer due to the peripheral
 * device interpreting the switch of clock polarity as a valid clock edge. In case
 * of continous sck mode, when the module goes in low power mode(disabled),
 * inactive state of sck is not guaranted.
 *
 * Values:
 * - 0 - The inactive state value of SCK is low.
 * - 1 - The inactive state value of SCK is high.
 */
/*@{*/
#define BP_SPI_CTARn_CPOL    (26U)         /*!< Bit position for SPI_CTARn_CPOL. */
#define BM_SPI_CTARn_CPOL    (0x04000000U) /*!< Bit mask for SPI_CTARn_CPOL. */
#define BS_SPI_CTARn_CPOL    (1U)          /*!< Bit field size in bits for SPI_CTARn_CPOL. */

/*! @brief Read current value of the SPI_CTARn_CPOL field. */
#define BR_SPI_CTARn_CPOL(x, n) (BITBAND_ACCESS32(HW_SPI_CTARn_ADDR(x, n), BP_SPI_CTARn_CPOL))

/*! @brief Format value for bitfield SPI_CTARn_CPOL. */
#define BF_SPI_CTARn_CPOL(v) ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_CPOL) & BM_SPI_CTARn_CPOL)

/*! @brief Set the CPOL field to a new value. */
#define BW_SPI_CTARn_CPOL(x, n, v) (BITBAND_ACCESS32(HW_SPI_CTARn_ADDR(x, n), BP_SPI_CTARn_CPOL) = (v))
/*@}*/

/*!
 * @name Register SPI_CTARn, field FMSZ[30:27] (RW)
 *
 * The number of bits transferred per frame is equal to the FMSZ value plus 1.
 * Regardless of the transmission mode, the minimum valid frame size value is 4.
 */
/*@{*/
#define BP_SPI_CTARn_FMSZ    (27U)         /*!< Bit position for SPI_CTARn_FMSZ. */
#define BM_SPI_CTARn_FMSZ    (0x78000000U) /*!< Bit mask for SPI_CTARn_FMSZ. */
#define BS_SPI_CTARn_FMSZ    (4U)          /*!< Bit field size in bits for SPI_CTARn_FMSZ. */

/*! @brief Read current value of the SPI_CTARn_FMSZ field. */
#define BR_SPI_CTARn_FMSZ(x, n) (HW_SPI_CTARn(x, n).B.FMSZ)

/*! @brief Format value for bitfield SPI_CTARn_FMSZ. */
#define BF_SPI_CTARn_FMSZ(v) ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_FMSZ) & BM_SPI_CTARn_FMSZ)

/*! @brief Set the FMSZ field to a new value. */
#define BW_SPI_CTARn_FMSZ(x, n, v) (HW_SPI_CTARn_WR(x, n, (HW_SPI_CTARn_RD(x, n) & ~BM_SPI_CTARn_FMSZ) | BF_SPI_CTARn_FMSZ(v)))
/*@}*/

/*!
 * @name Register SPI_CTARn, field DBR[31] (RW)
 *
 * Doubles the effective baud rate of the Serial Communications Clock (SCK).
 * This field is used only in master mode. It effectively halves the Baud Rate
 * division ratio, supporting faster frequencies, and odd division ratios for the
 * Serial Communications Clock (SCK). When the DBR bit is set, the duty cycle of the
 * Serial Communications Clock (SCK) depends on the value in the Baud Rate
 * Prescaler and the Clock Phase bit as listed in the following table. See the BR field
 * description for details on how to compute the baud rate. SPI SCK Duty Cycle
 * DBR CPHA PBR SCK Duty Cycle 0 any any 50/50 1 0 00 50/50 1 0 01 33/66 1 0 10
 * 40/60 1 0 11 43/57 1 1 00 50/50 1 1 01 66/33 1 1 10 60/40 1 1 11 57/43
 *
 * Values:
 * - 0 - The baud rate is computed normally with a 50/50 duty cycle.
 * - 1 - The baud rate is doubled with the duty cycle depending on the Baud Rate
 *     Prescaler.
 */
/*@{*/
#define BP_SPI_CTARn_DBR     (31U)         /*!< Bit position for SPI_CTARn_DBR. */
#define BM_SPI_CTARn_DBR     (0x80000000U) /*!< Bit mask for SPI_CTARn_DBR. */
#define BS_SPI_CTARn_DBR     (1U)          /*!< Bit field size in bits for SPI_CTARn_DBR. */

/*! @brief Read current value of the SPI_CTARn_DBR field. */
#define BR_SPI_CTARn_DBR(x, n) (BITBAND_ACCESS32(HW_SPI_CTARn_ADDR(x, n), BP_SPI_CTARn_DBR))

/*! @brief Format value for bitfield SPI_CTARn_DBR. */
#define BF_SPI_CTARn_DBR(v)  ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_DBR) & BM_SPI_CTARn_DBR)

/*! @brief Set the DBR field to a new value. */
#define BW_SPI_CTARn_DBR(x, n, v) (BITBAND_ACCESS32(HW_SPI_CTARn_ADDR(x, n), BP_SPI_CTARn_DBR) = (v))
/*@}*/
/*******************************************************************************
 * HW_SPI_CTARn_SLAVE - Clock and Transfer Attributes Register (In Slave Mode)
 ******************************************************************************/

/*!
 * @brief HW_SPI_CTARn_SLAVE - Clock and Transfer Attributes Register (In Slave Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * When the module is configured as an SPI bus slave, the CTAR0 register is used.
 */
typedef union _hw_spi_ctarn_slave
{
    uint32_t U;
    struct _hw_spi_ctarn_slave_bitfields
    {
        uint32_t RESERVED0 : 25;       /*!< [24:0]  */
        uint32_t CPHA : 1;             /*!< [25] Clock Phase */
        uint32_t CPOL : 1;             /*!< [26] Clock Polarity */
        uint32_t FMSZ : 5;             /*!< [31:27] Frame Size */
    } B;
} hw_spi_ctarn_slave_t;

/*!
 * @name Constants and macros for entire SPI_CTARn_SLAVE register
 */
/*@{*/
#define HW_SPI_CTARn_SLAVE_COUNT (1U)

#define HW_SPI_CTARn_SLAVE_ADDR(x, n) ((uint32_t)(x) + 0xCU + (0x4U * (n)))

#define HW_SPI_CTARn_SLAVE(x, n) (*(__IO hw_spi_ctarn_slave_t *) HW_SPI_CTARn_SLAVE_ADDR(x, n))
#define HW_SPI_CTARn_SLAVE_RD(x, n) (HW_SPI_CTARn_SLAVE(x, n).U)
#define HW_SPI_CTARn_SLAVE_WR(x, n, v) (HW_SPI_CTARn_SLAVE(x, n).U = (v))
#define HW_SPI_CTARn_SLAVE_SET(x, n, v) (HW_SPI_CTARn_SLAVE_WR(x, n, HW_SPI_CTARn_SLAVE_RD(x, n) |  (v)))
#define HW_SPI_CTARn_SLAVE_CLR(x, n, v) (HW_SPI_CTARn_SLAVE_WR(x, n, HW_SPI_CTARn_SLAVE_RD(x, n) & ~(v)))
#define HW_SPI_CTARn_SLAVE_TOG(x, n, v) (HW_SPI_CTARn_SLAVE_WR(x, n, HW_SPI_CTARn_SLAVE_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTARn_SLAVE bitfields
 */

/*!
 * @name Register SPI_CTARn_SLAVE, field CPHA[25] (RW)
 *
 * Selects which edge of SCK causes data to change and which edge causes data to
 * be captured. This bit is used in both master and slave mode. For successful
 * communication between serial devices, the devices must have identical clock
 * phase settings. In Continuous SCK mode, the bit value is ignored and the
 * transfers are done as if the CPHA bit is set to 1.
 *
 * Values:
 * - 0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
#define BP_SPI_CTARn_SLAVE_CPHA (25U)      /*!< Bit position for SPI_CTARn_SLAVE_CPHA. */
#define BM_SPI_CTARn_SLAVE_CPHA (0x02000000U) /*!< Bit mask for SPI_CTARn_SLAVE_CPHA. */
#define BS_SPI_CTARn_SLAVE_CPHA (1U)       /*!< Bit field size in bits for SPI_CTARn_SLAVE_CPHA. */

/*! @brief Read current value of the SPI_CTARn_SLAVE_CPHA field. */
#define BR_SPI_CTARn_SLAVE_CPHA(x, n) (BITBAND_ACCESS32(HW_SPI_CTARn_SLAVE_ADDR(x, n), BP_SPI_CTARn_SLAVE_CPHA))

/*! @brief Format value for bitfield SPI_CTARn_SLAVE_CPHA. */
#define BF_SPI_CTARn_SLAVE_CPHA(v) ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_SLAVE_CPHA) & BM_SPI_CTARn_SLAVE_CPHA)

/*! @brief Set the CPHA field to a new value. */
#define BW_SPI_CTARn_SLAVE_CPHA(x, n, v) (BITBAND_ACCESS32(HW_SPI_CTARn_SLAVE_ADDR(x, n), BP_SPI_CTARn_SLAVE_CPHA) = (v))
/*@}*/

/*!
 * @name Register SPI_CTARn_SLAVE, field CPOL[26] (RW)
 *
 * Selects the inactive state of the Serial Communications Clock (SCK). In case
 * of continous sck mode, when the module goes in low power mode(disabled),
 * inactive state of sck is not guaranted.
 *
 * Values:
 * - 0 - The inactive state value of SCK is low.
 * - 1 - The inactive state value of SCK is high.
 */
/*@{*/
#define BP_SPI_CTARn_SLAVE_CPOL (26U)      /*!< Bit position for SPI_CTARn_SLAVE_CPOL. */
#define BM_SPI_CTARn_SLAVE_CPOL (0x04000000U) /*!< Bit mask for SPI_CTARn_SLAVE_CPOL. */
#define BS_SPI_CTARn_SLAVE_CPOL (1U)       /*!< Bit field size in bits for SPI_CTARn_SLAVE_CPOL. */

/*! @brief Read current value of the SPI_CTARn_SLAVE_CPOL field. */
#define BR_SPI_CTARn_SLAVE_CPOL(x, n) (BITBAND_ACCESS32(HW_SPI_CTARn_SLAVE_ADDR(x, n), BP_SPI_CTARn_SLAVE_CPOL))

/*! @brief Format value for bitfield SPI_CTARn_SLAVE_CPOL. */
#define BF_SPI_CTARn_SLAVE_CPOL(v) ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_SLAVE_CPOL) & BM_SPI_CTARn_SLAVE_CPOL)

/*! @brief Set the CPOL field to a new value. */
#define BW_SPI_CTARn_SLAVE_CPOL(x, n, v) (BITBAND_ACCESS32(HW_SPI_CTARn_SLAVE_ADDR(x, n), BP_SPI_CTARn_SLAVE_CPOL) = (v))
/*@}*/

/*!
 * @name Register SPI_CTARn_SLAVE, field FMSZ[31:27] (RW)
 *
 * The number of bits transfered per frame is equal to the FMSZ field value plus
 * 1. Note that the minimum valid value of frame size is 4.
 */
/*@{*/
#define BP_SPI_CTARn_SLAVE_FMSZ (27U)      /*!< Bit position for SPI_CTARn_SLAVE_FMSZ. */
#define BM_SPI_CTARn_SLAVE_FMSZ (0xF8000000U) /*!< Bit mask for SPI_CTARn_SLAVE_FMSZ. */
#define BS_SPI_CTARn_SLAVE_FMSZ (5U)       /*!< Bit field size in bits for SPI_CTARn_SLAVE_FMSZ. */

/*! @brief Read current value of the SPI_CTARn_SLAVE_FMSZ field. */
#define BR_SPI_CTARn_SLAVE_FMSZ(x, n) (HW_SPI_CTARn_SLAVE(x, n).B.FMSZ)

/*! @brief Format value for bitfield SPI_CTARn_SLAVE_FMSZ. */
#define BF_SPI_CTARn_SLAVE_FMSZ(v) ((uint32_t)((uint32_t)(v) << BP_SPI_CTARn_SLAVE_FMSZ) & BM_SPI_CTARn_SLAVE_FMSZ)

/*! @brief Set the FMSZ field to a new value. */
#define BW_SPI_CTARn_SLAVE_FMSZ(x, n, v) (HW_SPI_CTARn_SLAVE_WR(x, n, (HW_SPI_CTARn_SLAVE_RD(x, n) & ~BM_SPI_CTARn_SLAVE_FMSZ) | BF_SPI_CTARn_SLAVE_FMSZ(v)))
/*@}*/

/*******************************************************************************
 * HW_SPI_SR - Status Register
 ******************************************************************************/

/*!
 * @brief HW_SPI_SR - Status Register (RW)
 *
 * Reset value: 0x02000000U
 *
 * SR contains status and flag bits. The bits reflect the status of the module
 * and indicate the occurrence of events that can generate interrupt or DMA
 * requests. Software can clear flag bits in the SR by writing a 1 to them. Writing a 0
 * to a flag bit has no effect. This register may not be writable in Module
 * Disable mode due to the use of power saving mechanisms.
 */
typedef union _hw_spi_sr
{
    uint32_t U;
    struct _hw_spi_sr_bitfields
    {
        uint32_t POPNXTPTR : 4;        /*!< [3:0] Pop Next Pointer */
        uint32_t RXCTR : 4;            /*!< [7:4] RX FIFO Counter */
        uint32_t TXNXTPTR : 4;         /*!< [11:8] Transmit Next Pointer */
        uint32_t TXCTR : 4;            /*!< [15:12] TX FIFO Counter */
        uint32_t RESERVED0 : 1;        /*!< [16]  */
        uint32_t RFDF : 1;             /*!< [17] Receive FIFO Drain Flag */
        uint32_t RESERVED1 : 1;        /*!< [18]  */
        uint32_t RFOF : 1;             /*!< [19] Receive FIFO Overflow Flag */
        uint32_t RESERVED2 : 5;        /*!< [24:20]  */
        uint32_t TFFF : 1;             /*!< [25] Transmit FIFO Fill Flag */
        uint32_t RESERVED3 : 1;        /*!< [26]  */
        uint32_t TFUF : 1;             /*!< [27] Transmit FIFO Underflow Flag */
        uint32_t EOQF : 1;             /*!< [28] End of Queue Flag */
        uint32_t RESERVED4 : 1;        /*!< [29]  */
        uint32_t TXRXS : 1;            /*!< [30] TX and RX Status */
        uint32_t TCF : 1;              /*!< [31] Transfer Complete Flag */
    } B;
} hw_spi_sr_t;

/*!
 * @name Constants and macros for entire SPI_SR register
 */
/*@{*/
#define HW_SPI_SR_ADDR(x)        ((uint32_t)(x) + 0x2CU)

#define HW_SPI_SR(x)             (*(__IO hw_spi_sr_t *) HW_SPI_SR_ADDR(x))
#define HW_SPI_SR_RD(x)          (HW_SPI_SR(x).U)
#define HW_SPI_SR_WR(x, v)       (HW_SPI_SR(x).U = (v))
#define HW_SPI_SR_SET(x, v)      (HW_SPI_SR_WR(x, HW_SPI_SR_RD(x) |  (v)))
#define HW_SPI_SR_CLR(x, v)      (HW_SPI_SR_WR(x, HW_SPI_SR_RD(x) & ~(v)))
#define HW_SPI_SR_TOG(x, v)      (HW_SPI_SR_WR(x, HW_SPI_SR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SPI_SR bitfields
 */

/*!
 * @name Register SPI_SR, field POPNXTPTR[3:0] (RO)
 *
 * Contains a pointer to the RX FIFO entry to be returned when the POPR is read.
 * The POPNXTPTR is updated when the POPR is read.
 */
/*@{*/
#define BP_SPI_SR_POPNXTPTR  (0U)          /*!< Bit position for SPI_SR_POPNXTPTR. */
#define BM_SPI_SR_POPNXTPTR  (0x0000000FU) /*!< Bit mask for SPI_SR_POPNXTPTR. */
#define BS_SPI_SR_POPNXTPTR  (4U)          /*!< Bit field size in bits for SPI_SR_POPNXTPTR. */

/*! @brief Read current value of the SPI_SR_POPNXTPTR field. */
#define BR_SPI_SR_POPNXTPTR(x) (HW_SPI_SR(x).B.POPNXTPTR)
/*@}*/

/*!
 * @name Register SPI_SR, field RXCTR[7:4] (RO)
 *
 * Indicates the number of entries in the RX FIFO. The RXCTR is decremented
 * every time the POPR is read. The RXCTR is incremented every time data is
 * transferred from the shift register to the RX FIFO.
 */
/*@{*/
#define BP_SPI_SR_RXCTR      (4U)          /*!< Bit position for SPI_SR_RXCTR. */
#define BM_SPI_SR_RXCTR      (0x000000F0U) /*!< Bit mask for SPI_SR_RXCTR. */
#define BS_SPI_SR_RXCTR      (4U)          /*!< Bit field size in bits for SPI_SR_RXCTR. */

/*! @brief Read current value of the SPI_SR_RXCTR field. */
#define BR_SPI_SR_RXCTR(x)   (HW_SPI_SR(x).B.RXCTR)
/*@}*/

/*!
 * @name Register SPI_SR, field TXNXTPTR[11:8] (RO)
 *
 * Indicates which TX FIFO entry is transmitted during the next transfer. The
 * TXNXTPTR field is updated every time SPI data is transferred from the TX FIFO to
 * the shift register.
 */
/*@{*/
#define BP_SPI_SR_TXNXTPTR   (8U)          /*!< Bit position for SPI_SR_TXNXTPTR. */
#define BM_SPI_SR_TXNXTPTR   (0x00000F00U) /*!< Bit mask for SPI_SR_TXNXTPTR. */
#define BS_SPI_SR_TXNXTPTR   (4U)          /*!< Bit field size in bits for SPI_SR_TXNXTPTR. */

/*! @brief Read current value of the SPI_SR_TXNXTPTR field. */
#define BR_SPI_SR_TXNXTPTR(x) (HW_SPI_SR(x).B.TXNXTPTR)
/*@}*/

/*!
 * @name Register SPI_SR, field TXCTR[15:12] (RO)
 *
 * Indicates the number of valid entries in the TX FIFO. The TXCTR is
 * incremented every time the PUSHR is written. The TXCTR is decremented every time an SPI
 * command is executed and the SPI data is transferred to the shift register.
 */
/*@{*/
#define BP_SPI_SR_TXCTR      (12U)         /*!< Bit position for SPI_SR_TXCTR. */
#define BM_SPI_SR_TXCTR      (0x0000F000U) /*!< Bit mask for SPI_SR_TXCTR. */
#define BS_SPI_SR_TXCTR      (4U)          /*!< Bit field size in bits for SPI_SR_TXCTR. */

/*! @brief Read current value of the SPI_SR_TXCTR field. */
#define BR_SPI_SR_TXCTR(x)   (HW_SPI_SR(x).B.TXCTR)
/*@}*/

/*!
 * @name Register SPI_SR, field RFDF[17] (W1C)
 *
 * Provides a method for the module to request that entries be removed from the
 * RX FIFO. The bit is set while the RX FIFO is not empty. The RFDF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller when
 * the RX FIFO is empty.
 *
 * Values:
 * - 0 - RX FIFO is empty.
 * - 1 - RX FIFO is not empty.
 */
/*@{*/
#define BP_SPI_SR_RFDF       (17U)         /*!< Bit position for SPI_SR_RFDF. */
#define BM_SPI_SR_RFDF       (0x00020000U) /*!< Bit mask for SPI_SR_RFDF. */
#define BS_SPI_SR_RFDF       (1U)          /*!< Bit field size in bits for SPI_SR_RFDF. */

/*! @brief Read current value of the SPI_SR_RFDF field. */
#define BR_SPI_SR_RFDF(x)    (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_RFDF))

/*! @brief Format value for bitfield SPI_SR_RFDF. */
#define BF_SPI_SR_RFDF(v)    ((uint32_t)((uint32_t)(v) << BP_SPI_SR_RFDF) & BM_SPI_SR_RFDF)

/*! @brief Set the RFDF field to a new value. */
#define BW_SPI_SR_RFDF(x, v) (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_RFDF) = (v))
/*@}*/

/*!
 * @name Register SPI_SR, field RFOF[19] (W1C)
 *
 * Indicates an overflow condition in the RX FIFO. The field is set when the RX
 * FIFO and shift register are full and a transfer is initiated. The bit remains
 * set until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No Rx FIFO overflow.
 * - 1 - Rx FIFO overflow has occurred.
 */
/*@{*/
#define BP_SPI_SR_RFOF       (19U)         /*!< Bit position for SPI_SR_RFOF. */
#define BM_SPI_SR_RFOF       (0x00080000U) /*!< Bit mask for SPI_SR_RFOF. */
#define BS_SPI_SR_RFOF       (1U)          /*!< Bit field size in bits for SPI_SR_RFOF. */

/*! @brief Read current value of the SPI_SR_RFOF field. */
#define BR_SPI_SR_RFOF(x)    (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_RFOF))

/*! @brief Format value for bitfield SPI_SR_RFOF. */
#define BF_SPI_SR_RFOF(v)    ((uint32_t)((uint32_t)(v) << BP_SPI_SR_RFOF) & BM_SPI_SR_RFOF)

/*! @brief Set the RFOF field to a new value. */
#define BW_SPI_SR_RFOF(x, v) (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_RFOF) = (v))
/*@}*/

/*!
 * @name Register SPI_SR, field TFFF[25] (W1C)
 *
 * Provides a method for the module to request more entries to be added to the
 * TX FIFO. The TFFF bit is set while the TX FIFO is not full. The TFFF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller to
 * the TX FIFO full request.
 *
 * Values:
 * - 0 - TX FIFO is full.
 * - 1 - TX FIFO is not full.
 */
/*@{*/
#define BP_SPI_SR_TFFF       (25U)         /*!< Bit position for SPI_SR_TFFF. */
#define BM_SPI_SR_TFFF       (0x02000000U) /*!< Bit mask for SPI_SR_TFFF. */
#define BS_SPI_SR_TFFF       (1U)          /*!< Bit field size in bits for SPI_SR_TFFF. */

/*! @brief Read current value of the SPI_SR_TFFF field. */
#define BR_SPI_SR_TFFF(x)    (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_TFFF))

/*! @brief Format value for bitfield SPI_SR_TFFF. */
#define BF_SPI_SR_TFFF(v)    ((uint32_t)((uint32_t)(v) << BP_SPI_SR_TFFF) & BM_SPI_SR_TFFF)

/*! @brief Set the TFFF field to a new value. */
#define BW_SPI_SR_TFFF(x, v) (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_TFFF) = (v))
/*@}*/

/*!
 * @name Register SPI_SR, field TFUF[27] (W1C)
 *
 * Indicates an underflow condition in the TX FIFO. The transmit underflow
 * condition is detected only for SPI blocks operating in Slave mode and SPI
 * configuration. TFUF is set when the TX FIFO of the module operating in SPI Slave mode
 * is empty and an external SPI master initiates a transfer. The TFUF bit remains
 * set until cleared by writing 1 to it.
 *
 * Values:
 * - 0 - No TX FIFO underflow.
 * - 1 - TX FIFO underflow has occurred.
 */
/*@{*/
#define BP_SPI_SR_TFUF       (27U)         /*!< Bit position for SPI_SR_TFUF. */
#define BM_SPI_SR_TFUF       (0x08000000U) /*!< Bit mask for SPI_SR_TFUF. */
#define BS_SPI_SR_TFUF       (1U)          /*!< Bit field size in bits for SPI_SR_TFUF. */

/*! @brief Read current value of the SPI_SR_TFUF field. */
#define BR_SPI_SR_TFUF(x)    (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_TFUF))

/*! @brief Format value for bitfield SPI_SR_TFUF. */
#define BF_SPI_SR_TFUF(v)    ((uint32_t)((uint32_t)(v) << BP_SPI_SR_TFUF) & BM_SPI_SR_TFUF)

/*! @brief Set the TFUF field to a new value. */
#define BW_SPI_SR_TFUF(x, v) (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_TFUF) = (v))
/*@}*/

/*!
 * @name Register SPI_SR, field EOQF[28] (W1C)
 *
 * Indicates that the last entry in a queue has been transmitted when the module
 * is in Master mode. The EOQF bit is set when the TX FIFO entry has the EOQ bit
 * set in the command halfword and the end of the transfer is reached. The EOQF
 * bit remains set until cleared by writing a 1 to it. When the EOQF bit is set,
 * the TXRXS bit is automatically cleared.
 *
 * Values:
 * - 0 - EOQ is not set in the executing command.
 * - 1 - EOQ is set in the executing SPI command.
 */
/*@{*/
#define BP_SPI_SR_EOQF       (28U)         /*!< Bit position for SPI_SR_EOQF. */
#define BM_SPI_SR_EOQF       (0x10000000U) /*!< Bit mask for SPI_SR_EOQF. */
#define BS_SPI_SR_EOQF       (1U)          /*!< Bit field size in bits for SPI_SR_EOQF. */

/*! @brief Read current value of the SPI_SR_EOQF field. */
#define BR_SPI_SR_EOQF(x)    (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_EOQF))

/*! @brief Format value for bitfield SPI_SR_EOQF. */
#define BF_SPI_SR_EOQF(v)    ((uint32_t)((uint32_t)(v) << BP_SPI_SR_EOQF) & BM_SPI_SR_EOQF)

/*! @brief Set the EOQF field to a new value. */
#define BW_SPI_SR_EOQF(x, v) (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_EOQF) = (v))
/*@}*/

/*!
 * @name Register SPI_SR, field TXRXS[30] (W1C)
 *
 * Reflects the run status of the module.
 *
 * Values:
 * - 0 - Transmit and receive operations are disabled (The module is in Stopped
 *     state).
 * - 1 - Transmit and receive operations are enabled (The module is in Running
 *     state).
 */
/*@{*/
#define BP_SPI_SR_TXRXS      (30U)         /*!< Bit position for SPI_SR_TXRXS. */
#define BM_SPI_SR_TXRXS      (0x40000000U) /*!< Bit mask for SPI_SR_TXRXS. */
#define BS_SPI_SR_TXRXS      (1U)          /*!< Bit field size in bits for SPI_SR_TXRXS. */

/*! @brief Read current value of the SPI_SR_TXRXS field. */
#define BR_SPI_SR_TXRXS(x)   (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_TXRXS))

/*! @brief Format value for bitfield SPI_SR_TXRXS. */
#define BF_SPI_SR_TXRXS(v)   ((uint32_t)((uint32_t)(v) << BP_SPI_SR_TXRXS) & BM_SPI_SR_TXRXS)

/*! @brief Set the TXRXS field to a new value. */
#define BW_SPI_SR_TXRXS(x, v) (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_TXRXS) = (v))
/*@}*/

/*!
 * @name Register SPI_SR, field TCF[31] (W1C)
 *
 * Indicates that all bits in a frame have been shifted out. TCF remains set
 * until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - Transfer not complete.
 * - 1 - Transfer complete.
 */
/*@{*/
#define BP_SPI_SR_TCF        (31U)         /*!< Bit position for SPI_SR_TCF. */
#define BM_SPI_SR_TCF        (0x80000000U) /*!< Bit mask for SPI_SR_TCF. */
#define BS_SPI_SR_TCF        (1U)          /*!< Bit field size in bits for SPI_SR_TCF. */

/*! @brief Read current value of the SPI_SR_TCF field. */
#define BR_SPI_SR_TCF(x)     (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_TCF))

/*! @brief Format value for bitfield SPI_SR_TCF. */
#define BF_SPI_SR_TCF(v)     ((uint32_t)((uint32_t)(v) << BP_SPI_SR_TCF) & BM_SPI_SR_TCF)

/*! @brief Set the TCF field to a new value. */
#define BW_SPI_SR_TCF(x, v)  (BITBAND_ACCESS32(HW_SPI_SR_ADDR(x), BP_SPI_SR_TCF) = (v))
/*@}*/

/*******************************************************************************
 * HW_SPI_RSER - DMA/Interrupt Request Select and Enable Register
 ******************************************************************************/

/*!
 * @brief HW_SPI_RSER - DMA/Interrupt Request Select and Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * RSER controls DMA and interrupt requests. Do not write to the RSER while the
 * module is in the Running state.
 */
typedef union _hw_spi_rser
{
    uint32_t U;
    struct _hw_spi_rser_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t RFDF_DIRS : 1;        /*!< [16] Receive FIFO Drain DMA or Interrupt
                                        * Request Select */
        uint32_t RFDF_RE : 1;          /*!< [17] Receive FIFO Drain Request Enable */
        uint32_t RESERVED1 : 1;        /*!< [18]  */
        uint32_t RFOF_RE : 1;          /*!< [19] Receive FIFO Overflow Request Enable
                                        * */
        uint32_t RESERVED2 : 4;        /*!< [23:20]  */
        uint32_t TFFF_DIRS : 1;        /*!< [24] Transmit FIFO Fill DMA or Interrupt
                                        * Request Select */
        uint32_t TFFF_RE : 1;          /*!< [25] Transmit FIFO Fill Request Enable */
        uint32_t RESERVED3 : 1;        /*!< [26]  */
        uint32_t TFUF_RE : 1;          /*!< [27] Transmit FIFO Underflow Request
                                        * Enable */
        uint32_t EOQF_RE : 1;          /*!< [28] Finished Request Enable */
        uint32_t RESERVED4 : 2;        /*!< [30:29]  */
        uint32_t TCF_RE : 1;           /*!< [31] Transmission Complete Request Enable */
    } B;
} hw_spi_rser_t;

/*!
 * @name Constants and macros for entire SPI_RSER register
 */
/*@{*/
#define HW_SPI_RSER_ADDR(x)      ((uint32_t)(x) + 0x30U)

#define HW_SPI_RSER(x)           (*(__IO hw_spi_rser_t *) HW_SPI_RSER_ADDR(x))
#define HW_SPI_RSER_RD(x)        (HW_SPI_RSER(x).U)
#define HW_SPI_RSER_WR(x, v)     (HW_SPI_RSER(x).U = (v))
#define HW_SPI_RSER_SET(x, v)    (HW_SPI_RSER_WR(x, HW_SPI_RSER_RD(x) |  (v)))
#define HW_SPI_RSER_CLR(x, v)    (HW_SPI_RSER_WR(x, HW_SPI_RSER_RD(x) & ~(v)))
#define HW_SPI_RSER_TOG(x, v)    (HW_SPI_RSER_WR(x, HW_SPI_RSER_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SPI_RSER bitfields
 */

/*!
 * @name Register SPI_RSER, field RFDF_DIRS[16] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When the
 * RFDF flag bit in the SR is set, and the RFDF_RE bit in the RSER is set, the
 * RFDF_DIRS bit selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - Interrupt request.
 * - 1 - DMA request.
 */
/*@{*/
#define BP_SPI_RSER_RFDF_DIRS (16U)        /*!< Bit position for SPI_RSER_RFDF_DIRS. */
#define BM_SPI_RSER_RFDF_DIRS (0x00010000U) /*!< Bit mask for SPI_RSER_RFDF_DIRS. */
#define BS_SPI_RSER_RFDF_DIRS (1U)         /*!< Bit field size in bits for SPI_RSER_RFDF_DIRS. */

/*! @brief Read current value of the SPI_RSER_RFDF_DIRS field. */
#define BR_SPI_RSER_RFDF_DIRS(x) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_RFDF_DIRS))

/*! @brief Format value for bitfield SPI_RSER_RFDF_DIRS. */
#define BF_SPI_RSER_RFDF_DIRS(v) ((uint32_t)((uint32_t)(v) << BP_SPI_RSER_RFDF_DIRS) & BM_SPI_RSER_RFDF_DIRS)

/*! @brief Set the RFDF_DIRS field to a new value. */
#define BW_SPI_RSER_RFDF_DIRS(x, v) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_RFDF_DIRS) = (v))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFDF_RE[17] (RW)
 *
 * Enables the RFDF flag in the SR to generate a request. The RFDF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - RFDF interrupt or DMA requests are disabled.
 * - 1 - RFDF interrupt or DMA requests are enabled.
 */
/*@{*/
#define BP_SPI_RSER_RFDF_RE  (17U)         /*!< Bit position for SPI_RSER_RFDF_RE. */
#define BM_SPI_RSER_RFDF_RE  (0x00020000U) /*!< Bit mask for SPI_RSER_RFDF_RE. */
#define BS_SPI_RSER_RFDF_RE  (1U)          /*!< Bit field size in bits for SPI_RSER_RFDF_RE. */

/*! @brief Read current value of the SPI_RSER_RFDF_RE field. */
#define BR_SPI_RSER_RFDF_RE(x) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_RFDF_RE))

/*! @brief Format value for bitfield SPI_RSER_RFDF_RE. */
#define BF_SPI_RSER_RFDF_RE(v) ((uint32_t)((uint32_t)(v) << BP_SPI_RSER_RFDF_RE) & BM_SPI_RSER_RFDF_RE)

/*! @brief Set the RFDF_RE field to a new value. */
#define BW_SPI_RSER_RFDF_RE(x, v) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_RFDF_RE) = (v))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFOF_RE[19] (RW)
 *
 * Enables the RFOF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - RFOF interrupt requests are disabled.
 * - 1 - RFOF interrupt requests are enabled.
 */
/*@{*/
#define BP_SPI_RSER_RFOF_RE  (19U)         /*!< Bit position for SPI_RSER_RFOF_RE. */
#define BM_SPI_RSER_RFOF_RE  (0x00080000U) /*!< Bit mask for SPI_RSER_RFOF_RE. */
#define BS_SPI_RSER_RFOF_RE  (1U)          /*!< Bit field size in bits for SPI_RSER_RFOF_RE. */

/*! @brief Read current value of the SPI_RSER_RFOF_RE field. */
#define BR_SPI_RSER_RFOF_RE(x) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_RFOF_RE))

/*! @brief Format value for bitfield SPI_RSER_RFOF_RE. */
#define BF_SPI_RSER_RFOF_RE(v) ((uint32_t)((uint32_t)(v) << BP_SPI_RSER_RFOF_RE) & BM_SPI_RSER_RFOF_RE)

/*! @brief Set the RFOF_RE field to a new value. */
#define BW_SPI_RSER_RFOF_RE(x, v) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_RFOF_RE) = (v))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_DIRS[24] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When
 * SR[TFFF] and RSER[TFFF_RE] are set, this field selects between generating an
 * interrupt request or a DMA request.
 *
 * Values:
 * - 0 - TFFF flag generates interrupt requests.
 * - 1 - TFFF flag generates DMA requests.
 */
/*@{*/
#define BP_SPI_RSER_TFFF_DIRS (24U)        /*!< Bit position for SPI_RSER_TFFF_DIRS. */
#define BM_SPI_RSER_TFFF_DIRS (0x01000000U) /*!< Bit mask for SPI_RSER_TFFF_DIRS. */
#define BS_SPI_RSER_TFFF_DIRS (1U)         /*!< Bit field size in bits for SPI_RSER_TFFF_DIRS. */

/*! @brief Read current value of the SPI_RSER_TFFF_DIRS field. */
#define BR_SPI_RSER_TFFF_DIRS(x) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_TFFF_DIRS))

/*! @brief Format value for bitfield SPI_RSER_TFFF_DIRS. */
#define BF_SPI_RSER_TFFF_DIRS(v) ((uint32_t)((uint32_t)(v) << BP_SPI_RSER_TFFF_DIRS) & BM_SPI_RSER_TFFF_DIRS)

/*! @brief Set the TFFF_DIRS field to a new value. */
#define BW_SPI_RSER_TFFF_DIRS(x, v) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_TFFF_DIRS) = (v))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_RE[25] (RW)
 *
 * Enables the TFFF flag in the SR to generate a request. The TFFF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - TFFF interrupts or DMA requests are disabled.
 * - 1 - TFFF interrupts or DMA requests are enabled.
 */
/*@{*/
#define BP_SPI_RSER_TFFF_RE  (25U)         /*!< Bit position for SPI_RSER_TFFF_RE. */
#define BM_SPI_RSER_TFFF_RE  (0x02000000U) /*!< Bit mask for SPI_RSER_TFFF_RE. */
#define BS_SPI_RSER_TFFF_RE  (1U)          /*!< Bit field size in bits for SPI_RSER_TFFF_RE. */

/*! @brief Read current value of the SPI_RSER_TFFF_RE field. */
#define BR_SPI_RSER_TFFF_RE(x) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_TFFF_RE))

/*! @brief Format value for bitfield SPI_RSER_TFFF_RE. */
#define BF_SPI_RSER_TFFF_RE(v) ((uint32_t)((uint32_t)(v) << BP_SPI_RSER_TFFF_RE) & BM_SPI_RSER_TFFF_RE)

/*! @brief Set the TFFF_RE field to a new value. */
#define BW_SPI_RSER_TFFF_RE(x, v) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_TFFF_RE) = (v))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFUF_RE[27] (RW)
 *
 * Enables the TFUF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - TFUF interrupt requests are disabled.
 * - 1 - TFUF interrupt requests are enabled.
 */
/*@{*/
#define BP_SPI_RSER_TFUF_RE  (27U)         /*!< Bit position for SPI_RSER_TFUF_RE. */
#define BM_SPI_RSER_TFUF_RE  (0x08000000U) /*!< Bit mask for SPI_RSER_TFUF_RE. */
#define BS_SPI_RSER_TFUF_RE  (1U)          /*!< Bit field size in bits for SPI_RSER_TFUF_RE. */

/*! @brief Read current value of the SPI_RSER_TFUF_RE field. */
#define BR_SPI_RSER_TFUF_RE(x) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_TFUF_RE))

/*! @brief Format value for bitfield SPI_RSER_TFUF_RE. */
#define BF_SPI_RSER_TFUF_RE(v) ((uint32_t)((uint32_t)(v) << BP_SPI_RSER_TFUF_RE) & BM_SPI_RSER_TFUF_RE)

/*! @brief Set the TFUF_RE field to a new value. */
#define BW_SPI_RSER_TFUF_RE(x, v) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_TFUF_RE) = (v))
/*@}*/

/*!
 * @name Register SPI_RSER, field EOQF_RE[28] (RW)
 *
 * Enables the EOQF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - EOQF interrupt requests are disabled.
 * - 1 - EOQF interrupt requests are enabled.
 */
/*@{*/
#define BP_SPI_RSER_EOQF_RE  (28U)         /*!< Bit position for SPI_RSER_EOQF_RE. */
#define BM_SPI_RSER_EOQF_RE  (0x10000000U) /*!< Bit mask for SPI_RSER_EOQF_RE. */
#define BS_SPI_RSER_EOQF_RE  (1U)          /*!< Bit field size in bits for SPI_RSER_EOQF_RE. */

/*! @brief Read current value of the SPI_RSER_EOQF_RE field. */
#define BR_SPI_RSER_EOQF_RE(x) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_EOQF_RE))

/*! @brief Format value for bitfield SPI_RSER_EOQF_RE. */
#define BF_SPI_RSER_EOQF_RE(v) ((uint32_t)((uint32_t)(v) << BP_SPI_RSER_EOQF_RE) & BM_SPI_RSER_EOQF_RE)

/*! @brief Set the EOQF_RE field to a new value. */
#define BW_SPI_RSER_EOQF_RE(x, v) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_EOQF_RE) = (v))
/*@}*/

/*!
 * @name Register SPI_RSER, field TCF_RE[31] (RW)
 *
 * Enables TCF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - TCF interrupt requests are disabled.
 * - 1 - TCF interrupt requests are enabled.
 */
/*@{*/
#define BP_SPI_RSER_TCF_RE   (31U)         /*!< Bit position for SPI_RSER_TCF_RE. */
#define BM_SPI_RSER_TCF_RE   (0x80000000U) /*!< Bit mask for SPI_RSER_TCF_RE. */
#define BS_SPI_RSER_TCF_RE   (1U)          /*!< Bit field size in bits for SPI_RSER_TCF_RE. */

/*! @brief Read current value of the SPI_RSER_TCF_RE field. */
#define BR_SPI_RSER_TCF_RE(x) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_TCF_RE))

/*! @brief Format value for bitfield SPI_RSER_TCF_RE. */
#define BF_SPI_RSER_TCF_RE(v) ((uint32_t)((uint32_t)(v) << BP_SPI_RSER_TCF_RE) & BM_SPI_RSER_TCF_RE)

/*! @brief Set the TCF_RE field to a new value. */
#define BW_SPI_RSER_TCF_RE(x, v) (BITBAND_ACCESS32(HW_SPI_RSER_ADDR(x), BP_SPI_RSER_TCF_RE) = (v))
/*@}*/

/*******************************************************************************
 * HW_SPI_PUSHR - PUSH TX FIFO Register In Master Mode
 ******************************************************************************/

/*!
 * @brief HW_SPI_PUSHR - PUSH TX FIFO Register In Master Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies data to be transferred to the TX FIFO. An 8- or 16-bit write access
 * transfers all 32 bits to the TX FIFO. In Master mode, the register transfers
 * 16 bits of data and 16 bits of command information. In Slave mode, all 32 bits
 * can be used as data, supporting up to 32-bit frame operation. A read access
 * of PUSHR returns the topmost TX FIFO entry. When the module is disabled,
 * writing to this register does not update the FIFO. Therefore, any reads performed
 * while the module is disabled return the last PUSHR write performed while the
 * module was still enabled.
 */
typedef union _hw_spi_pushr
{
    uint32_t U;
    struct _hw_spi_pushr_bitfields
    {
        uint32_t TXDATA : 16;          /*!< [15:0] Transmit Data */
        uint32_t PCS : 6;              /*!< [21:16]  */
        uint32_t RESERVED0 : 4;        /*!< [25:22]  */
        uint32_t CTCNT : 1;            /*!< [26] Clear Transfer Counter */
        uint32_t EOQ : 1;              /*!< [27] End Of Queue */
        uint32_t CTAS : 3;             /*!< [30:28] Clock and Transfer Attributes Select
                                        * */
        uint32_t CONT : 1;             /*!< [31] Continuous Peripheral Chip Select Enable
                                        * */
    } B;
} hw_spi_pushr_t;

/*!
 * @name Constants and macros for entire SPI_PUSHR register
 */
/*@{*/
#define HW_SPI_PUSHR_ADDR(x)     ((uint32_t)(x) + 0x34U)

#define HW_SPI_PUSHR(x)          (*(__IO hw_spi_pushr_t *) HW_SPI_PUSHR_ADDR(x))
#define HW_SPI_PUSHR_RD(x)       (HW_SPI_PUSHR(x).U)
#define HW_SPI_PUSHR_WR(x, v)    (HW_SPI_PUSHR(x).U = (v))
#define HW_SPI_PUSHR_SET(x, v)   (HW_SPI_PUSHR_WR(x, HW_SPI_PUSHR_RD(x) |  (v)))
#define HW_SPI_PUSHR_CLR(x, v)   (HW_SPI_PUSHR_WR(x, HW_SPI_PUSHR_RD(x) & ~(v)))
#define HW_SPI_PUSHR_TOG(x, v)   (HW_SPI_PUSHR_WR(x, HW_SPI_PUSHR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SPI_PUSHR bitfields
 */

/*!
 * @name Register SPI_PUSHR, field TXDATA[15:0] (RW)
 *
 * Holds SPI data to be transferred according to the associated SPI command.
 */
/*@{*/
#define BP_SPI_PUSHR_TXDATA  (0U)          /*!< Bit position for SPI_PUSHR_TXDATA. */
#define BM_SPI_PUSHR_TXDATA  (0x0000FFFFU) /*!< Bit mask for SPI_PUSHR_TXDATA. */
#define BS_SPI_PUSHR_TXDATA  (16U)         /*!< Bit field size in bits for SPI_PUSHR_TXDATA. */

/*! @brief Read current value of the SPI_PUSHR_TXDATA field. */
#define BR_SPI_PUSHR_TXDATA(x) (HW_SPI_PUSHR(x).B.TXDATA)

/*! @brief Format value for bitfield SPI_PUSHR_TXDATA. */
#define BF_SPI_PUSHR_TXDATA(v) ((uint32_t)((uint32_t)(v) << BP_SPI_PUSHR_TXDATA) & BM_SPI_PUSHR_TXDATA)

/*! @brief Set the TXDATA field to a new value. */
#define BW_SPI_PUSHR_TXDATA(x, v) (HW_SPI_PUSHR_WR(x, (HW_SPI_PUSHR_RD(x) & ~BM_SPI_PUSHR_TXDATA) | BF_SPI_PUSHR_TXDATA(v)))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field PCS[21:16] (RW)
 *
 * Select which PCS signals are to be asserted for the transfer. Refer to the
 * chip configuration details for the number of PCS signals used in this MCU.
 *
 * Values:
 * - 0 - Negate the PCS[x] signal.
 * - 1 - Assert the PCS[x] signal.
 */
/*@{*/
#define BP_SPI_PUSHR_PCS     (16U)         /*!< Bit position for SPI_PUSHR_PCS. */
#define BM_SPI_PUSHR_PCS     (0x003F0000U) /*!< Bit mask for SPI_PUSHR_PCS. */
#define BS_SPI_PUSHR_PCS     (6U)          /*!< Bit field size in bits for SPI_PUSHR_PCS. */

/*! @brief Read current value of the SPI_PUSHR_PCS field. */
#define BR_SPI_PUSHR_PCS(x)  (HW_SPI_PUSHR(x).B.PCS)

/*! @brief Format value for bitfield SPI_PUSHR_PCS. */
#define BF_SPI_PUSHR_PCS(v)  ((uint32_t)((uint32_t)(v) << BP_SPI_PUSHR_PCS) & BM_SPI_PUSHR_PCS)

/*! @brief Set the PCS field to a new value. */
#define BW_SPI_PUSHR_PCS(x, v) (HW_SPI_PUSHR_WR(x, (HW_SPI_PUSHR_RD(x) & ~BM_SPI_PUSHR_PCS) | BF_SPI_PUSHR_PCS(v)))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTCNT[26] (RW)
 *
 * Clears the TCNT field in the TCR register. The TCNT field is cleared before
 * the module starts transmitting the current SPI frame.
 *
 * Values:
 * - 0 - Do not clear the TCR[TCNT] field.
 * - 1 - Clear the TCR[TCNT] field.
 */
/*@{*/
#define BP_SPI_PUSHR_CTCNT   (26U)         /*!< Bit position for SPI_PUSHR_CTCNT. */
#define BM_SPI_PUSHR_CTCNT   (0x04000000U) /*!< Bit mask for SPI_PUSHR_CTCNT. */
#define BS_SPI_PUSHR_CTCNT   (1U)          /*!< Bit field size in bits for SPI_PUSHR_CTCNT. */

/*! @brief Read current value of the SPI_PUSHR_CTCNT field. */
#define BR_SPI_PUSHR_CTCNT(x) (BITBAND_ACCESS32(HW_SPI_PUSHR_ADDR(x), BP_SPI_PUSHR_CTCNT))

/*! @brief Format value for bitfield SPI_PUSHR_CTCNT. */
#define BF_SPI_PUSHR_CTCNT(v) ((uint32_t)((uint32_t)(v) << BP_SPI_PUSHR_CTCNT) & BM_SPI_PUSHR_CTCNT)

/*! @brief Set the CTCNT field to a new value. */
#define BW_SPI_PUSHR_CTCNT(x, v) (BITBAND_ACCESS32(HW_SPI_PUSHR_ADDR(x), BP_SPI_PUSHR_CTCNT) = (v))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field EOQ[27] (RW)
 *
 * Host software uses this bit to signal to the module that the current SPI
 * transfer is the last in a queue. At the end of the transfer, the EOQF bit in the
 * SR is set.
 *
 * Values:
 * - 0 - The SPI data is not the last data to transfer.
 * - 1 - The SPI data is the last data to transfer.
 */
/*@{*/
#define BP_SPI_PUSHR_EOQ     (27U)         /*!< Bit position for SPI_PUSHR_EOQ. */
#define BM_SPI_PUSHR_EOQ     (0x08000000U) /*!< Bit mask for SPI_PUSHR_EOQ. */
#define BS_SPI_PUSHR_EOQ     (1U)          /*!< Bit field size in bits for SPI_PUSHR_EOQ. */

/*! @brief Read current value of the SPI_PUSHR_EOQ field. */
#define BR_SPI_PUSHR_EOQ(x)  (BITBAND_ACCESS32(HW_SPI_PUSHR_ADDR(x), BP_SPI_PUSHR_EOQ))

/*! @brief Format value for bitfield SPI_PUSHR_EOQ. */
#define BF_SPI_PUSHR_EOQ(v)  ((uint32_t)((uint32_t)(v) << BP_SPI_PUSHR_EOQ) & BM_SPI_PUSHR_EOQ)

/*! @brief Set the EOQ field to a new value. */
#define BW_SPI_PUSHR_EOQ(x, v) (BITBAND_ACCESS32(HW_SPI_PUSHR_ADDR(x), BP_SPI_PUSHR_EOQ) = (v))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTAS[30:28] (RW)
 *
 * Selects which CTAR to use in master mode to specify the transfer attributes
 * for the associated SPI frame. In SPI Slave mode, CTAR0 is used. See the chip
 * configuration details to determine how many CTARs this device has. You should
 * not program a value in this field for a register that is not present.
 *
 * Values:
 * - 000 - CTAR0
 * - 001 - CTAR1
 * - 010 - Reserved
 * - 011 - Reserved
 * - 100 - Reserved
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
#define BP_SPI_PUSHR_CTAS    (28U)         /*!< Bit position for SPI_PUSHR_CTAS. */
#define BM_SPI_PUSHR_CTAS    (0x70000000U) /*!< Bit mask for SPI_PUSHR_CTAS. */
#define BS_SPI_PUSHR_CTAS    (3U)          /*!< Bit field size in bits for SPI_PUSHR_CTAS. */

/*! @brief Read current value of the SPI_PUSHR_CTAS field. */
#define BR_SPI_PUSHR_CTAS(x) (HW_SPI_PUSHR(x).B.CTAS)

/*! @brief Format value for bitfield SPI_PUSHR_CTAS. */
#define BF_SPI_PUSHR_CTAS(v) ((uint32_t)((uint32_t)(v) << BP_SPI_PUSHR_CTAS) & BM_SPI_PUSHR_CTAS)

/*! @brief Set the CTAS field to a new value. */
#define BW_SPI_PUSHR_CTAS(x, v) (HW_SPI_PUSHR_WR(x, (HW_SPI_PUSHR_RD(x) & ~BM_SPI_PUSHR_CTAS) | BF_SPI_PUSHR_CTAS(v)))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CONT[31] (RW)
 *
 * Selects a continuous selection format. The bit is used in SPI Master mode.
 * The bit enables the selected PCS signals to remain asserted between transfers.
 *
 * Values:
 * - 0 - Return PCSn signals to their inactive state between transfers.
 * - 1 - Keep PCSn signals asserted between transfers.
 */
/*@{*/
#define BP_SPI_PUSHR_CONT    (31U)         /*!< Bit position for SPI_PUSHR_CONT. */
#define BM_SPI_PUSHR_CONT    (0x80000000U) /*!< Bit mask for SPI_PUSHR_CONT. */
#define BS_SPI_PUSHR_CONT    (1U)          /*!< Bit field size in bits for SPI_PUSHR_CONT. */

/*! @brief Read current value of the SPI_PUSHR_CONT field. */
#define BR_SPI_PUSHR_CONT(x) (BITBAND_ACCESS32(HW_SPI_PUSHR_ADDR(x), BP_SPI_PUSHR_CONT))

/*! @brief Format value for bitfield SPI_PUSHR_CONT. */
#define BF_SPI_PUSHR_CONT(v) ((uint32_t)((uint32_t)(v) << BP_SPI_PUSHR_CONT) & BM_SPI_PUSHR_CONT)

/*! @brief Set the CONT field to a new value. */
#define BW_SPI_PUSHR_CONT(x, v) (BITBAND_ACCESS32(HW_SPI_PUSHR_ADDR(x), BP_SPI_PUSHR_CONT) = (v))
/*@}*/
/*******************************************************************************
 * HW_SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode
 ******************************************************************************/

/*!
 * @brief HW_SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies data to be transferred to the TX FIFO. An 8- or 16-bit write access
 * to PUSHR transfers all 32 bits to the TX FIFO. In master mode, the register
 * transfers 16 bits of data and 16 bits of command information to the TX FIFO. In
 * slave mode, all 32 register bits can be used as data, supporting up to 32-bit
 * SPI Frame operation.
 */
typedef union _hw_spi_pushr_slave
{
    uint32_t U;
    struct _hw_spi_pushr_slave_bitfields
    {
        uint32_t TXDATA : 32;          /*!< [31:0] Transmit Data */
    } B;
} hw_spi_pushr_slave_t;

/*!
 * @name Constants and macros for entire SPI_PUSHR_SLAVE register
 */
/*@{*/
#define HW_SPI_PUSHR_SLAVE_ADDR(x) ((uint32_t)(x) + 0x34U)

#define HW_SPI_PUSHR_SLAVE(x)    (*(__IO hw_spi_pushr_slave_t *) HW_SPI_PUSHR_SLAVE_ADDR(x))
#define HW_SPI_PUSHR_SLAVE_RD(x) (HW_SPI_PUSHR_SLAVE(x).U)
#define HW_SPI_PUSHR_SLAVE_WR(x, v) (HW_SPI_PUSHR_SLAVE(x).U = (v))
#define HW_SPI_PUSHR_SLAVE_SET(x, v) (HW_SPI_PUSHR_SLAVE_WR(x, HW_SPI_PUSHR_SLAVE_RD(x) |  (v)))
#define HW_SPI_PUSHR_SLAVE_CLR(x, v) (HW_SPI_PUSHR_SLAVE_WR(x, HW_SPI_PUSHR_SLAVE_RD(x) & ~(v)))
#define HW_SPI_PUSHR_SLAVE_TOG(x, v) (HW_SPI_PUSHR_SLAVE_WR(x, HW_SPI_PUSHR_SLAVE_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual SPI_PUSHR_SLAVE bitfields
 */

/*!
 * @name Register SPI_PUSHR_SLAVE, field TXDATA[31:0] (RW)
 *
 * Holds SPI data to be transferred according to the associated SPI command.
 */
/*@{*/
#define BP_SPI_PUSHR_SLAVE_TXDATA (0U)     /*!< Bit position for SPI_PUSHR_SLAVE_TXDATA. */
#define BM_SPI_PUSHR_SLAVE_TXDATA (0xFFFFFFFFU) /*!< Bit mask for SPI_PUSHR_SLAVE_TXDATA. */
#define BS_SPI_PUSHR_SLAVE_TXDATA (32U)    /*!< Bit field size in bits for SPI_PUSHR_SLAVE_TXDATA. */

/*! @brief Read current value of the SPI_PUSHR_SLAVE_TXDATA field. */
#define BR_SPI_PUSHR_SLAVE_TXDATA(x) (HW_SPI_PUSHR_SLAVE(x).U)

/*! @brief Format value for bitfield SPI_PUSHR_SLAVE_TXDATA. */
#define BF_SPI_PUSHR_SLAVE_TXDATA(v) ((uint32_t)((uint32_t)(v) << BP_SPI_PUSHR_SLAVE_TXDATA) & BM_SPI_PUSHR_SLAVE_TXDATA)

/*! @brief Set the TXDATA field to a new value. */
#define BW_SPI_PUSHR_SLAVE_TXDATA(x, v) (HW_SPI_PUSHR_SLAVE_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_SPI_POPR - POP RX FIFO Register
 ******************************************************************************/

/*!
 * @brief HW_SPI_POPR - POP RX FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * POPR is used to read the RX FIFO. Eight- or sixteen-bit read accesses to the
 * POPR have the same effect on the RX FIFO as 32-bit read accesses. A write to
 * this register will generate a Transfer Error.
 */
typedef union _hw_spi_popr
{
    uint32_t U;
    struct _hw_spi_popr_bitfields
    {
        uint32_t RXDATA : 32;          /*!< [31:0] Received Data */
    } B;
} hw_spi_popr_t;

/*!
 * @name Constants and macros for entire SPI_POPR register
 */
/*@{*/
#define HW_SPI_POPR_ADDR(x)      ((uint32_t)(x) + 0x38U)

#define HW_SPI_POPR(x)           (*(__I hw_spi_popr_t *) HW_SPI_POPR_ADDR(x))
#define HW_SPI_POPR_RD(x)        (HW_SPI_POPR(x).U)
/*@}*/

/*
 * Constants & macros for individual SPI_POPR bitfields
 */

/*!
 * @name Register SPI_POPR, field RXDATA[31:0] (RO)
 *
 * Contains the SPI data from the RX FIFO entry to which the Pop Next Data
 * Pointer points.
 */
/*@{*/
#define BP_SPI_POPR_RXDATA   (0U)          /*!< Bit position for SPI_POPR_RXDATA. */
#define BM_SPI_POPR_RXDATA   (0xFFFFFFFFU) /*!< Bit mask for SPI_POPR_RXDATA. */
#define BS_SPI_POPR_RXDATA   (32U)         /*!< Bit field size in bits for SPI_POPR_RXDATA. */

/*! @brief Read current value of the SPI_POPR_RXDATA field. */
#define BR_SPI_POPR_RXDATA(x) (HW_SPI_POPR(x).U)
/*@}*/

/*******************************************************************************
 * HW_SPI_TXFRn - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief HW_SPI_TXFRn - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
typedef union _hw_spi_txfrn
{
    uint32_t U;
    struct _hw_spi_txfrn_bitfields
    {
        uint32_t TXDATA : 16;          /*!< [15:0] Transmit Data */
        uint32_t TXCMD_TXDATA : 16;    /*!< [31:16] Transmit Command or Transmit
                                        * Data */
    } B;
} hw_spi_txfrn_t;

/*!
 * @name Constants and macros for entire SPI_TXFRn register
 */
/*@{*/
#define HW_SPI_TXFRn_COUNT (4U)

#define HW_SPI_TXFRn_ADDR(x, n)  ((uint32_t)(x) + 0x3CU + (0x4U * (n)))

#define HW_SPI_TXFRn(x, n)       (*(__I hw_spi_txfrn_t *) HW_SPI_TXFRn_ADDR(x, n))
#define HW_SPI_TXFRn_RD(x, n)    (HW_SPI_TXFRn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual SPI_TXFRn bitfields
 */

/*!
 * @name Register SPI_TXFRn, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
#define BP_SPI_TXFRn_TXDATA  (0U)          /*!< Bit position for SPI_TXFRn_TXDATA. */
#define BM_SPI_TXFRn_TXDATA  (0x0000FFFFU) /*!< Bit mask for SPI_TXFRn_TXDATA. */
#define BS_SPI_TXFRn_TXDATA  (16U)         /*!< Bit field size in bits for SPI_TXFRn_TXDATA. */

/*! @brief Read current value of the SPI_TXFRn_TXDATA field. */
#define BR_SPI_TXFRn_TXDATA(x, n) (HW_SPI_TXFRn(x, n).B.TXDATA)
/*@}*/

/*!
 * @name Register SPI_TXFRn, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, the TXDATA contains 16 MSB bits of
 * the SPI data to be shifted out.
 */
/*@{*/
#define BP_SPI_TXFRn_TXCMD_TXDATA (16U)    /*!< Bit position for SPI_TXFRn_TXCMD_TXDATA. */
#define BM_SPI_TXFRn_TXCMD_TXDATA (0xFFFF0000U) /*!< Bit mask for SPI_TXFRn_TXCMD_TXDATA. */
#define BS_SPI_TXFRn_TXCMD_TXDATA (16U)    /*!< Bit field size in bits for SPI_TXFRn_TXCMD_TXDATA. */

/*! @brief Read current value of the SPI_TXFRn_TXCMD_TXDATA field. */
#define BR_SPI_TXFRn_TXCMD_TXDATA(x, n) (HW_SPI_TXFRn(x, n).B.TXCMD_TXDATA)
/*@}*/

/*******************************************************************************
 * HW_SPI_RXFRn - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief HW_SPI_RXFRn - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
typedef union _hw_spi_rxfrn
{
    uint32_t U;
    struct _hw_spi_rxfrn_bitfields
    {
        uint32_t RXDATA : 32;          /*!< [31:0] Receive Data */
    } B;
} hw_spi_rxfrn_t;

/*!
 * @name Constants and macros for entire SPI_RXFRn register
 */
/*@{*/
#define HW_SPI_RXFRn_COUNT (4U)

#define HW_SPI_RXFRn_ADDR(x, n)  ((uint32_t)(x) + 0x7CU + (0x4U * (n)))

#define HW_SPI_RXFRn(x, n)       (*(__I hw_spi_rxfrn_t *) HW_SPI_RXFRn_ADDR(x, n))
#define HW_SPI_RXFRn_RD(x, n)    (HW_SPI_RXFRn(x, n).U)
/*@}*/

/*
 * Constants & macros for individual SPI_RXFRn bitfields
 */

/*!
 * @name Register SPI_RXFRn, field RXDATA[31:0] (RO)
 *
 * Contains the received SPI data.
 */
/*@{*/
#define BP_SPI_RXFRn_RXDATA  (0U)          /*!< Bit position for SPI_RXFRn_RXDATA. */
#define BM_SPI_RXFRn_RXDATA  (0xFFFFFFFFU) /*!< Bit mask for SPI_RXFRn_RXDATA. */
#define BS_SPI_RXFRn_RXDATA  (32U)         /*!< Bit field size in bits for SPI_RXFRn_RXDATA. */

/*! @brief Read current value of the SPI_RXFRn_RXDATA field. */
#define BR_SPI_RXFRn_RXDATA(x, n) (HW_SPI_RXFRn(x, n).U)
/*@}*/

/*
** Start of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma push
  #pragma anon_unions
#elif defined(__CWCC__)
  #pragma push
  #pragma cpp_extensions on
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=extended
#else
  #error Not supported compiler type
#endif

/*******************************************************************************
 * hw_spi_t - module struct
 ******************************************************************************/
/*!
 * @brief All SPI module registers.
 */
#pragma pack(1)
typedef struct _hw_spi
{
    __IO hw_spi_mcr_t MCR;                 /*!< [0x0] Module Configuration Register */
    uint8_t _reserved0[4];
    __IO hw_spi_tcr_t TCR;                 /*!< [0x8] Transfer Count Register */
    union {
        __IO hw_spi_ctarn_t CTARn[2];      /*!< [0xC] Clock and Transfer Attributes Register (In Master Mode) */
        __IO hw_spi_ctarn_slave_t CTARn_SLAVE[1]; /*!< [0xC] Clock and Transfer Attributes Register (In Slave Mode) */
    };
    uint8_t _reserved1[24];
    __IO hw_spi_sr_t SR;                   /*!< [0x2C] Status Register */
    __IO hw_spi_rser_t RSER;               /*!< [0x30] DMA/Interrupt Request Select and Enable Register */
    union {
        __IO hw_spi_pushr_t PUSHR;         /*!< [0x34] PUSH TX FIFO Register In Master Mode */
        __IO hw_spi_pushr_slave_t PUSHR_SLAVE; /*!< [0x34] PUSH TX FIFO Register In Slave Mode */
    };
    __I hw_spi_popr_t POPR;                /*!< [0x38] POP RX FIFO Register */
    __I hw_spi_txfrn_t TXFRn[4];           /*!< [0x3C] Transmit FIFO Registers */
    uint8_t _reserved2[48];
    __I hw_spi_rxfrn_t RXFRn[4];           /*!< [0x7C] Receive FIFO Registers */
} hw_spi_t;
#pragma pack()

/*! @brief Macro to access all SPI registers. */
/*! @param x SPI module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_SPI_REGS(SPI0_BASE)</code>. */
#define HW_SPI_REGS(x) (*(hw_spi_t *)(x))

/*
** End of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma pop
#elif defined(__CWCC__)
  #pragma pop
#elif defined(__GNUC__)
  /* leave anonymous unions enabled */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=default
#else
  #error Not supported compiler type
#endif

/*
 * MK64F12 UART
 *
 * Serial Communication Interface
 *
 * Registers defined in this header file:
 * - HW_UART_BDH - UART Baud Rate Registers: High
 * - HW_UART_BDL - UART Baud Rate Registers: Low
 * - HW_UART_C1 - UART Control Register 1
 * - HW_UART_C2 - UART Control Register 2
 * - HW_UART_S1 - UART Status Register 1
 * - HW_UART_S2 - UART Status Register 2
 * - HW_UART_C3 - UART Control Register 3
 * - HW_UART_D - UART Data Register
 * - HW_UART_MA1 - UART Match Address Registers 1
 * - HW_UART_MA2 - UART Match Address Registers 2
 * - HW_UART_C4 - UART Control Register 4
 * - HW_UART_C5 - UART Control Register 5
 * - HW_UART_ED - UART Extended Data Register
 * - HW_UART_MODEM - UART Modem Register
 * - HW_UART_IR - UART Infrared Register
 * - HW_UART_PFIFO - UART FIFO Parameters
 * - HW_UART_CFIFO - UART FIFO Control Register
 * - HW_UART_SFIFO - UART FIFO Status Register
 * - HW_UART_TWFIFO - UART FIFO Transmit Watermark
 * - HW_UART_TCFIFO - UART FIFO Transmit Count
 * - HW_UART_RWFIFO - UART FIFO Receive Watermark
 * - HW_UART_RCFIFO - UART FIFO Receive Count
 * - HW_UART_C7816 - UART 7816 Control Register
 * - HW_UART_IE7816 - UART 7816 Interrupt Enable Register
 * - HW_UART_IS7816 - UART 7816 Interrupt Status Register
 * - HW_UART_WP7816T0 - UART 7816 Wait Parameter Register
 * - HW_UART_WP7816T1 - UART 7816 Wait Parameter Register
 * - HW_UART_WN7816 - UART 7816 Wait N Register
 * - HW_UART_WF7816 - UART 7816 Wait FD Register
 * - HW_UART_ET7816 - UART 7816 Error Threshold Register
 * - HW_UART_TL7816 - UART 7816 Transmit Length Register
 *
 * - hw_uart_t - Struct containing all module registers.
 */

#define HW_UART_INSTANCE_COUNT (6U) /*!< Number of instances of the UART module. */
#define HW_UART0 (0U) /*!< Instance number for UART0. */
#define HW_UART1 (1U) /*!< Instance number for UART1. */
#define HW_UART2 (2U) /*!< Instance number for UART2. */
#define HW_UART3 (3U) /*!< Instance number for UART3. */
#define HW_UART4 (4U) /*!< Instance number for UART4. */
#define HW_UART5 (5U) /*!< Instance number for UART5. */

/*******************************************************************************
 * HW_UART_BDH - UART Baud Rate Registers: High
 ******************************************************************************/

/*!
 * @brief HW_UART_BDH - UART Baud Rate Registers: High (RW)
 *
 * Reset value: 0x00U
 *
 * This register, along with the BDL register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting
 * (SBR[12:0]), first write to BDH to buffer the high half of the new value and then write
 * to BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is,
 * when C2[RE] or C2[TE] is set.
 */
typedef union _hw_uart_bdh
{
    uint8_t U;
    struct _hw_uart_bdh_bitfields
    {
        uint8_t SBR : 5;               /*!< [4:0] UART Baud Rate Bits */
        uint8_t SBNS : 1;              /*!< [5] Stop Bit Number Select */
        uint8_t RXEDGIE : 1;           /*!< [6] RxD Input Active Edge Interrupt Enable
                                        * */
        uint8_t LBKDIE : 1;            /*!< [7] LIN Break Detect Interrupt or DMA
                                        * Request Enable */
    } B;
} hw_uart_bdh_t;

/*!
 * @name Constants and macros for entire UART_BDH register
 */
/*@{*/
#define HW_UART_BDH_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_UART_BDH(x)           (*(__IO hw_uart_bdh_t *) HW_UART_BDH_ADDR(x))
#define HW_UART_BDH_RD(x)        (HW_UART_BDH(x).U)
#define HW_UART_BDH_WR(x, v)     (HW_UART_BDH(x).U = (v))
#define HW_UART_BDH_SET(x, v)    (HW_UART_BDH_WR(x, HW_UART_BDH_RD(x) |  (v)))
#define HW_UART_BDH_CLR(x, v)    (HW_UART_BDH_WR(x, HW_UART_BDH_RD(x) & ~(v)))
#define HW_UART_BDH_TOG(x, v)    (HW_UART_BDH_WR(x, HW_UART_BDH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_BDH bitfields
 */

/*!
 * @name Register UART_BDH, field SBR[4:0] (RW)
 *
 * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate
 * generation for details. The baud rate generator is disabled until C2[TE] or
 * C2[RE] is set for the first time after reset.The baud rate generator is disabled
 * when SBR = 0. Writing to BDH has no effect without writing to BDL, because
 * writing to BDH puts the data in a temporary location until BDL is written.
 */
/*@{*/
#define BP_UART_BDH_SBR      (0U)          /*!< Bit position for UART_BDH_SBR. */
#define BM_UART_BDH_SBR      (0x1FU)       /*!< Bit mask for UART_BDH_SBR. */
#define BS_UART_BDH_SBR      (5U)          /*!< Bit field size in bits for UART_BDH_SBR. */

/*! @brief Read current value of the UART_BDH_SBR field. */
#define BR_UART_BDH_SBR(x)   (HW_UART_BDH(x).B.SBR)

/*! @brief Format value for bitfield UART_BDH_SBR. */
#define BF_UART_BDH_SBR(v)   ((uint8_t)((uint8_t)(v) << BP_UART_BDH_SBR) & BM_UART_BDH_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART_BDH_SBR(x, v) (HW_UART_BDH_WR(x, (HW_UART_BDH_RD(x) & ~BM_UART_BDH_SBR) | BF_UART_BDH_SBR(v)))
/*@}*/

/*!
 * @name Register UART_BDH, field SBNS[5] (RW)
 *
 * SBNS selects the number of stop bits present in a data frame. This field
 * valid for all 8, 9 and 10 bit data formats available. This field is not valid when
 * C7816[ISO7816E] is enabled.
 *
 * Values:
 * - 0 - Data frame consists of a single stop bit.
 * - 1 - Data frame consists of two stop bits.
 */
/*@{*/
#define BP_UART_BDH_SBNS     (5U)          /*!< Bit position for UART_BDH_SBNS. */
#define BM_UART_BDH_SBNS     (0x20U)       /*!< Bit mask for UART_BDH_SBNS. */
#define BS_UART_BDH_SBNS     (1U)          /*!< Bit field size in bits for UART_BDH_SBNS. */

/*! @brief Read current value of the UART_BDH_SBNS field. */
#define BR_UART_BDH_SBNS(x)  (BITBAND_ACCESS8(HW_UART_BDH_ADDR(x), BP_UART_BDH_SBNS))

/*! @brief Format value for bitfield UART_BDH_SBNS. */
#define BF_UART_BDH_SBNS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_BDH_SBNS) & BM_UART_BDH_SBNS)

/*! @brief Set the SBNS field to a new value. */
#define BW_UART_BDH_SBNS(x, v) (BITBAND_ACCESS8(HW_UART_BDH_ADDR(x), BP_UART_BDH_SBNS) = (v))
/*@}*/

/*!
 * @name Register UART_BDH, field RXEDGIE[6] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - Hardware interrupts from RXEDGIF disabled using polling.
 * - 1 - RXEDGIF interrupt request enabled.
 */
/*@{*/
#define BP_UART_BDH_RXEDGIE  (6U)          /*!< Bit position for UART_BDH_RXEDGIE. */
#define BM_UART_BDH_RXEDGIE  (0x40U)       /*!< Bit mask for UART_BDH_RXEDGIE. */
#define BS_UART_BDH_RXEDGIE  (1U)          /*!< Bit field size in bits for UART_BDH_RXEDGIE. */

/*! @brief Read current value of the UART_BDH_RXEDGIE field. */
#define BR_UART_BDH_RXEDGIE(x) (BITBAND_ACCESS8(HW_UART_BDH_ADDR(x), BP_UART_BDH_RXEDGIE))

/*! @brief Format value for bitfield UART_BDH_RXEDGIE. */
#define BF_UART_BDH_RXEDGIE(v) ((uint8_t)((uint8_t)(v) << BP_UART_BDH_RXEDGIE) & BM_UART_BDH_RXEDGIE)

/*! @brief Set the RXEDGIE field to a new value. */
#define BW_UART_BDH_RXEDGIE(x, v) (BITBAND_ACCESS8(HW_UART_BDH_ADDR(x), BP_UART_BDH_RXEDGIE) = (v))
/*@}*/

/*!
 * @name Register UART_BDH, field LBKDIE[7] (RW)
 *
 * Enables the LIN break detect flag, LBKDIF, to generate interrupt requests
 * based on the state of LBKDDMAS. or DMA transfer requests,
 *
 * Values:
 * - 0 - LBKDIF interrupt and DMA transfer requests disabled.
 * - 1 - LBKDIF interrupt or DMA transfer requests enabled.
 */
/*@{*/
#define BP_UART_BDH_LBKDIE   (7U)          /*!< Bit position for UART_BDH_LBKDIE. */
#define BM_UART_BDH_LBKDIE   (0x80U)       /*!< Bit mask for UART_BDH_LBKDIE. */
#define BS_UART_BDH_LBKDIE   (1U)          /*!< Bit field size in bits for UART_BDH_LBKDIE. */

/*! @brief Read current value of the UART_BDH_LBKDIE field. */
#define BR_UART_BDH_LBKDIE(x) (BITBAND_ACCESS8(HW_UART_BDH_ADDR(x), BP_UART_BDH_LBKDIE))

/*! @brief Format value for bitfield UART_BDH_LBKDIE. */
#define BF_UART_BDH_LBKDIE(v) ((uint8_t)((uint8_t)(v) << BP_UART_BDH_LBKDIE) & BM_UART_BDH_LBKDIE)

/*! @brief Set the LBKDIE field to a new value. */
#define BW_UART_BDH_LBKDIE(x, v) (BITBAND_ACCESS8(HW_UART_BDH_ADDR(x), BP_UART_BDH_LBKDIE) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_BDL - UART Baud Rate Registers: Low
 ******************************************************************************/

/*!
 * @brief HW_UART_BDL - UART Baud Rate Registers: Low (RW)
 *
 * Reset value: 0x04U
 *
 * This register, along with the BDH register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting, SBR[12:0],
 * first write to BDH to buffer the high half of the new value and then write to
 * BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is, when
 * C2[RE] or C2[TE] is set.
 */
typedef union _hw_uart_bdl
{
    uint8_t U;
    struct _hw_uart_bdl_bitfields
    {
        uint8_t SBR : 8;               /*!< [7:0] UART Baud Rate Bits */
    } B;
} hw_uart_bdl_t;

/*!
 * @name Constants and macros for entire UART_BDL register
 */
/*@{*/
#define HW_UART_BDL_ADDR(x)      ((uint32_t)(x) + 0x1U)

#define HW_UART_BDL(x)           (*(__IO hw_uart_bdl_t *) HW_UART_BDL_ADDR(x))
#define HW_UART_BDL_RD(x)        (HW_UART_BDL(x).U)
#define HW_UART_BDL_WR(x, v)     (HW_UART_BDL(x).U = (v))
#define HW_UART_BDL_SET(x, v)    (HW_UART_BDL_WR(x, HW_UART_BDL_RD(x) |  (v)))
#define HW_UART_BDL_CLR(x, v)    (HW_UART_BDL_WR(x, HW_UART_BDL_RD(x) & ~(v)))
#define HW_UART_BDL_TOG(x, v)    (HW_UART_BDL_WR(x, HW_UART_BDL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_BDL bitfields
 */

/*!
 * @name Register UART_BDL, field SBR[7:0] (RW)
 *
 * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate
 * generation for details. The baud rate generator is disabled until C2[TE] or
 * C2[RE] is set for the first time after reset.The baud rate generator is disabled
 * when SBR = 0. Writing to BDH has no effect without writing to BDL, because
 * writing to BDH puts the data in a temporary location until BDL is written. When
 * the 1/32 narrow pulse width is selected for infrared (IrDA), the baud rate
 * fields must be even, the least significant bit is 0. See MODEM register for more
 * details.
 */
/*@{*/
#define BP_UART_BDL_SBR      (0U)          /*!< Bit position for UART_BDL_SBR. */
#define BM_UART_BDL_SBR      (0xFFU)       /*!< Bit mask for UART_BDL_SBR. */
#define BS_UART_BDL_SBR      (8U)          /*!< Bit field size in bits for UART_BDL_SBR. */

/*! @brief Read current value of the UART_BDL_SBR field. */
#define BR_UART_BDL_SBR(x)   (HW_UART_BDL(x).U)

/*! @brief Format value for bitfield UART_BDL_SBR. */
#define BF_UART_BDL_SBR(v)   ((uint8_t)((uint8_t)(v) << BP_UART_BDL_SBR) & BM_UART_BDL_SBR)

/*! @brief Set the SBR field to a new value. */
#define BW_UART_BDL_SBR(x, v) (HW_UART_BDL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_C1 - UART Control Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART_C1 - UART Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register controls various optional features of the UART
 * system.
 */
typedef union _hw_uart_c1
{
    uint8_t U;
    struct _hw_uart_c1_bitfields
    {
        uint8_t PT : 1;                /*!< [0] Parity Type */
        uint8_t PE : 1;                /*!< [1] Parity Enable */
        uint8_t ILT : 1;               /*!< [2] Idle Line Type Select */
        uint8_t WAKE : 1;              /*!< [3] Receiver Wakeup Method Select */
        uint8_t M : 1;                 /*!< [4] 9-bit or 8-bit Mode Select */
        uint8_t RSRC : 1;              /*!< [5] Receiver Source Select */
        uint8_t UARTSWAI : 1;          /*!< [6] UART Stops in Wait Mode */
        uint8_t LOOPS : 1;             /*!< [7] Loop Mode Select */
    } B;
} hw_uart_c1_t;

/*!
 * @name Constants and macros for entire UART_C1 register
 */
/*@{*/
#define HW_UART_C1_ADDR(x)       ((uint32_t)(x) + 0x2U)

#define HW_UART_C1(x)            (*(__IO hw_uart_c1_t *) HW_UART_C1_ADDR(x))
#define HW_UART_C1_RD(x)         (HW_UART_C1(x).U)
#define HW_UART_C1_WR(x, v)      (HW_UART_C1(x).U = (v))
#define HW_UART_C1_SET(x, v)     (HW_UART_C1_WR(x, HW_UART_C1_RD(x) |  (v)))
#define HW_UART_C1_CLR(x, v)     (HW_UART_C1_WR(x, HW_UART_C1_RD(x) & ~(v)))
#define HW_UART_C1_TOG(x, v)     (HW_UART_C1_WR(x, HW_UART_C1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C1 bitfields
 */

/*!
 * @name Register UART_C1, field PT[0] (RW)
 *
 * Determines whether the UART generates and checks for even parity or odd
 * parity. With even parity, an even number of 1s clears the parity bit and an odd
 * number of 1s sets the parity bit. With odd parity, an odd number of 1s clears the
 * parity bit and an even number of 1s sets the parity bit. This field must be
 * cleared when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Even parity.
 * - 1 - Odd parity.
 */
/*@{*/
#define BP_UART_C1_PT        (0U)          /*!< Bit position for UART_C1_PT. */
#define BM_UART_C1_PT        (0x01U)       /*!< Bit mask for UART_C1_PT. */
#define BS_UART_C1_PT        (1U)          /*!< Bit field size in bits for UART_C1_PT. */

/*! @brief Read current value of the UART_C1_PT field. */
#define BR_UART_C1_PT(x)     (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_PT))

/*! @brief Format value for bitfield UART_C1_PT. */
#define BF_UART_C1_PT(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C1_PT) & BM_UART_C1_PT)

/*! @brief Set the PT field to a new value. */
#define BW_UART_C1_PT(x, v)  (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_PT) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field PE[1] (RW)
 *
 * Enables the parity function. When parity is enabled, parity function inserts
 * a parity bit in the bit position immediately preceding the stop bit. This
 * field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Parity function disabled.
 * - 1 - Parity function enabled.
 */
/*@{*/
#define BP_UART_C1_PE        (1U)          /*!< Bit position for UART_C1_PE. */
#define BM_UART_C1_PE        (0x02U)       /*!< Bit mask for UART_C1_PE. */
#define BS_UART_C1_PE        (1U)          /*!< Bit field size in bits for UART_C1_PE. */

/*! @brief Read current value of the UART_C1_PE field. */
#define BR_UART_C1_PE(x)     (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_PE))

/*! @brief Format value for bitfield UART_C1_PE. */
#define BF_UART_C1_PE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C1_PE) & BM_UART_C1_PE)

/*! @brief Set the PE field to a new value. */
#define BW_UART_C1_PE(x, v)  (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_PE) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the UART is programmed with ILT = 1, a
 * logic of 1'b0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count. In case the UART is programmed for IDLE line wakeup
 * (RWU = 1 and WAKE = 0), ILT has no effect on when the receiver starts counting
 * logic 1s as idle character bits. In idle line wakeup, an idle character is
 * recognized at anytime the receiver sees 10, 11, or 12 1s depending on the M, PE,
 * and C4[M10] fields.
 *
 * Values:
 * - 0 - Idle character bit count starts after start bit.
 * - 1 - Idle character bit count starts after stop bit.
 */
/*@{*/
#define BP_UART_C1_ILT       (2U)          /*!< Bit position for UART_C1_ILT. */
#define BM_UART_C1_ILT       (0x04U)       /*!< Bit mask for UART_C1_ILT. */
#define BS_UART_C1_ILT       (1U)          /*!< Bit field size in bits for UART_C1_ILT. */

/*! @brief Read current value of the UART_C1_ILT field. */
#define BR_UART_C1_ILT(x)    (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_ILT))

/*! @brief Format value for bitfield UART_C1_ILT. */
#define BF_UART_C1_ILT(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C1_ILT) & BM_UART_C1_ILT)

/*! @brief Set the ILT field to a new value. */
#define BW_UART_C1_ILT(x, v) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_ILT) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field WAKE[3] (RW)
 *
 * Determines which condition wakes the UART: Address mark in the most
 * significant bit position of a received data character, or An idle condition on the
 * receive pin input signal.
 *
 * Values:
 * - 0 - Idle line wakeup.
 * - 1 - Address mark wakeup.
 */
/*@{*/
#define BP_UART_C1_WAKE      (3U)          /*!< Bit position for UART_C1_WAKE. */
#define BM_UART_C1_WAKE      (0x08U)       /*!< Bit mask for UART_C1_WAKE. */
#define BS_UART_C1_WAKE      (1U)          /*!< Bit field size in bits for UART_C1_WAKE. */

/*! @brief Read current value of the UART_C1_WAKE field. */
#define BR_UART_C1_WAKE(x)   (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_WAKE))

/*! @brief Format value for bitfield UART_C1_WAKE. */
#define BF_UART_C1_WAKE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C1_WAKE) & BM_UART_C1_WAKE)

/*! @brief Set the WAKE field to a new value. */
#define BW_UART_C1_WAKE(x, v) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_WAKE) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field M[4] (RW)
 *
 * This field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
 * - 1 - Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.
 */
/*@{*/
#define BP_UART_C1_M         (4U)          /*!< Bit position for UART_C1_M. */
#define BM_UART_C1_M         (0x10U)       /*!< Bit mask for UART_C1_M. */
#define BS_UART_C1_M         (1U)          /*!< Bit field size in bits for UART_C1_M. */

/*! @brief Read current value of the UART_C1_M field. */
#define BR_UART_C1_M(x)      (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_M))

/*! @brief Format value for bitfield UART_C1_M. */
#define BF_UART_C1_M(v)      ((uint8_t)((uint8_t)(v) << BP_UART_C1_M) & BM_UART_C1_M)

/*! @brief Set the M field to a new value. */
#define BW_UART_C1_M(x, v)   (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_M) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0 - Selects internal loop back mode. The receiver input is internally
 *     connected to transmitter output.
 * - 1 - Single wire UART mode where the receiver input is connected to the
 *     transmit pin input signal.
 */
/*@{*/
#define BP_UART_C1_RSRC      (5U)          /*!< Bit position for UART_C1_RSRC. */
#define BM_UART_C1_RSRC      (0x20U)       /*!< Bit mask for UART_C1_RSRC. */
#define BS_UART_C1_RSRC      (1U)          /*!< Bit field size in bits for UART_C1_RSRC. */

/*! @brief Read current value of the UART_C1_RSRC field. */
#define BR_UART_C1_RSRC(x)   (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_RSRC))

/*! @brief Format value for bitfield UART_C1_RSRC. */
#define BF_UART_C1_RSRC(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C1_RSRC) & BM_UART_C1_RSRC)

/*! @brief Set the RSRC field to a new value. */
#define BW_UART_C1_RSRC(x, v) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_RSRC) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field UARTSWAI[6] (RW)
 *
 * Values:
 * - 0 - UART clock continues to run in Wait mode.
 * - 1 - UART clock freezes while CPU is in Wait mode.
 */
/*@{*/
#define BP_UART_C1_UARTSWAI  (6U)          /*!< Bit position for UART_C1_UARTSWAI. */
#define BM_UART_C1_UARTSWAI  (0x40U)       /*!< Bit mask for UART_C1_UARTSWAI. */
#define BS_UART_C1_UARTSWAI  (1U)          /*!< Bit field size in bits for UART_C1_UARTSWAI. */

/*! @brief Read current value of the UART_C1_UARTSWAI field. */
#define BR_UART_C1_UARTSWAI(x) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_UARTSWAI))

/*! @brief Format value for bitfield UART_C1_UARTSWAI. */
#define BF_UART_C1_UARTSWAI(v) ((uint8_t)((uint8_t)(v) << BP_UART_C1_UARTSWAI) & BM_UART_C1_UARTSWAI)

/*! @brief Set the UARTSWAI field to a new value. */
#define BW_UART_C1_UARTSWAI(x, v) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_UARTSWAI) = (v))
/*@}*/

/*!
 * @name Register UART_C1, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the RxD pin is disconnected from the UART and the
 * transmitter output is internally connected to the receiver input. The transmitter and
 * the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - Loop mode where transmitter output is internally connected to receiver
 *     input. The receiver input is determined by RSRC.
 */
/*@{*/
#define BP_UART_C1_LOOPS     (7U)          /*!< Bit position for UART_C1_LOOPS. */
#define BM_UART_C1_LOOPS     (0x80U)       /*!< Bit mask for UART_C1_LOOPS. */
#define BS_UART_C1_LOOPS     (1U)          /*!< Bit field size in bits for UART_C1_LOOPS. */

/*! @brief Read current value of the UART_C1_LOOPS field. */
#define BR_UART_C1_LOOPS(x)  (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_LOOPS))

/*! @brief Format value for bitfield UART_C1_LOOPS. */
#define BF_UART_C1_LOOPS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C1_LOOPS) & BM_UART_C1_LOOPS)

/*! @brief Set the LOOPS field to a new value. */
#define BW_UART_C1_LOOPS(x, v) (BITBAND_ACCESS8(HW_UART_C1_ADDR(x), BP_UART_C1_LOOPS) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_C2 - UART Control Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART_C2 - UART Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register can be read or written at any time.
 */
typedef union _hw_uart_c2
{
    uint8_t U;
    struct _hw_uart_c2_bitfields
    {
        uint8_t SBK : 1;               /*!< [0] Send Break */
        uint8_t RWU : 1;               /*!< [1] Receiver Wakeup Control */
        uint8_t RE : 1;                /*!< [2] Receiver Enable */
        uint8_t TE : 1;                /*!< [3] Transmitter Enable */
        uint8_t ILIE : 1;              /*!< [4] Idle Line Interrupt DMA Transfer Enable */
        uint8_t RIE : 1;               /*!< [5] Receiver Full Interrupt or DMA Transfer
                                        * Enable */
        uint8_t TCIE : 1;              /*!< [6] Transmission Complete Interrupt or DMA
                                        * Transfer Enable */
        uint8_t TIE : 1;               /*!< [7] Transmitter Interrupt or DMA Transfer
                                        * Enable. */
    } B;
} hw_uart_c2_t;

/*!
 * @name Constants and macros for entire UART_C2 register
 */
/*@{*/
#define HW_UART_C2_ADDR(x)       ((uint32_t)(x) + 0x3U)

#define HW_UART_C2(x)            (*(__IO hw_uart_c2_t *) HW_UART_C2_ADDR(x))
#define HW_UART_C2_RD(x)         (HW_UART_C2(x).U)
#define HW_UART_C2_WR(x, v)      (HW_UART_C2(x).U = (v))
#define HW_UART_C2_SET(x, v)     (HW_UART_C2_WR(x, HW_UART_C2_RD(x) |  (v)))
#define HW_UART_C2_CLR(x, v)     (HW_UART_C2_WR(x, HW_UART_C2_RD(x) & ~(v)))
#define HW_UART_C2_TOG(x, v)     (HW_UART_C2_WR(x, HW_UART_C2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C2 bitfields
 */

/*!
 * @name Register UART_C2, field SBK[0] (RW)
 *
 * Toggling SBK sends one break character from the following: See Transmitting
 * break characters for the number of logic 0s for the different configurations.
 * Toggling implies clearing the SBK field before the break character has finished
 * transmitting. As long as SBK is set, the transmitter continues to send
 * complete break characters (10, 11, or 12 bits, or 13 or 14 bits, or 15 or 16 bits).
 * Ensure that C2[TE] is asserted atleast 1 clock before assertion of this bit.
 * 10, 11, or 12 logic 0s if S2[BRK13] is cleared 13 or 14 logic 0s if S2[BRK13]
 * is set. 15 or 16 logic 0s if BDH[SBNS] is set. This field must be cleared when
 * C7816[ISO_7816E] is set.
 *
 * Values:
 * - 0 - Normal transmitter operation.
 * - 1 - Queue break characters to be sent.
 */
/*@{*/
#define BP_UART_C2_SBK       (0U)          /*!< Bit position for UART_C2_SBK. */
#define BM_UART_C2_SBK       (0x01U)       /*!< Bit mask for UART_C2_SBK. */
#define BS_UART_C2_SBK       (1U)          /*!< Bit field size in bits for UART_C2_SBK. */

/*! @brief Read current value of the UART_C2_SBK field. */
#define BR_UART_C2_SBK(x)    (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_SBK))

/*! @brief Format value for bitfield UART_C2_SBK. */
#define BF_UART_C2_SBK(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_SBK) & BM_UART_C2_SBK)

/*! @brief Set the SBK field to a new value. */
#define BW_UART_C2_SBK(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_SBK) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field RWU[1] (RW)
 *
 * This field can be set to place the UART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * C1[WAKE] is clear or an address match when C1[WAKE] is set. This field must be
 * cleared when C7816[ISO_7816E] is set. RWU must be set only with C1[WAKE] = 0 (wakeup
 * on idle) if the channel is currently not idle. This can be determined by
 * S2[RAF]. If the flag is set to wake up an IDLE event and the channel is already
 * idle, it is possible that the UART will discard data. This is because the data
 * must be received or a LIN break detected after an IDLE is detected before IDLE
 * is allowed to reasserted.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - RWU enables the wakeup function and inhibits further receiver interrupt
 *     requests. Normally, hardware wakes the receiver by automatically clearing
 *     RWU.
 */
/*@{*/
#define BP_UART_C2_RWU       (1U)          /*!< Bit position for UART_C2_RWU. */
#define BM_UART_C2_RWU       (0x02U)       /*!< Bit mask for UART_C2_RWU. */
#define BS_UART_C2_RWU       (1U)          /*!< Bit field size in bits for UART_C2_RWU. */

/*! @brief Read current value of the UART_C2_RWU field. */
#define BR_UART_C2_RWU(x)    (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RWU))

/*! @brief Format value for bitfield UART_C2_RWU. */
#define BF_UART_C2_RWU(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_RWU) & BM_UART_C2_RWU)

/*! @brief Set the RWU field to a new value. */
#define BW_UART_C2_RWU(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RWU) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field RE[2] (RW)
 *
 * Enables the UART receiver.
 *
 * Values:
 * - 0 - Receiver off.
 * - 1 - Receiver on.
 */
/*@{*/
#define BP_UART_C2_RE        (2U)          /*!< Bit position for UART_C2_RE. */
#define BM_UART_C2_RE        (0x04U)       /*!< Bit mask for UART_C2_RE. */
#define BS_UART_C2_RE        (1U)          /*!< Bit field size in bits for UART_C2_RE. */

/*! @brief Read current value of the UART_C2_RE field. */
#define BR_UART_C2_RE(x)     (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RE))

/*! @brief Format value for bitfield UART_C2_RE. */
#define BF_UART_C2_RE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C2_RE) & BM_UART_C2_RE)

/*! @brief Set the RE field to a new value. */
#define BW_UART_C2_RE(x, v)  (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RE) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field TE[3] (RW)
 *
 * Enables the UART transmitter. TE can be used to queue an idle preamble by
 * clearing and then setting TE. When C7816[ISO_7816E] is set/enabled and
 * C7816[TTYPE] = 1, this field is automatically cleared after the requested block has been
 * transmitted. This condition is detected when TL7816[TLEN] = 0 and four
 * additional characters are transmitted.
 *
 * Values:
 * - 0 - Transmitter off.
 * - 1 - Transmitter on.
 */
/*@{*/
#define BP_UART_C2_TE        (3U)          /*!< Bit position for UART_C2_TE. */
#define BM_UART_C2_TE        (0x08U)       /*!< Bit mask for UART_C2_TE. */
#define BS_UART_C2_TE        (1U)          /*!< Bit field size in bits for UART_C2_TE. */

/*! @brief Read current value of the UART_C2_TE field. */
#define BR_UART_C2_TE(x)     (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TE))

/*! @brief Format value for bitfield UART_C2_TE. */
#define BF_UART_C2_TE(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C2_TE) & BM_UART_C2_TE)

/*! @brief Set the TE field to a new value. */
#define BW_UART_C2_TE(x, v)  (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TE) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field ILIE[4] (RW)
 *
 * Enables the idle line flag, S1[IDLE], to generate interrupt requestsor DMA
 * transfer requests based on the state of C5[ILDMAS].
 *
 * Values:
 * - 0 - IDLE interrupt requests disabled. and DMA transfer
 * - 1 - IDLE interrupt requests enabled. or DMA transfer
 */
/*@{*/
#define BP_UART_C2_ILIE      (4U)          /*!< Bit position for UART_C2_ILIE. */
#define BM_UART_C2_ILIE      (0x10U)       /*!< Bit mask for UART_C2_ILIE. */
#define BS_UART_C2_ILIE      (1U)          /*!< Bit field size in bits for UART_C2_ILIE. */

/*! @brief Read current value of the UART_C2_ILIE field. */
#define BR_UART_C2_ILIE(x)   (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_ILIE))

/*! @brief Format value for bitfield UART_C2_ILIE. */
#define BF_UART_C2_ILIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C2_ILIE) & BM_UART_C2_ILIE)

/*! @brief Set the ILIE field to a new value. */
#define BW_UART_C2_ILIE(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_ILIE) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field RIE[5] (RW)
 *
 * Enables S1[RDRF] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[RDMAS].
 *
 * Values:
 * - 0 - RDRF interrupt and DMA transfer requests disabled.
 * - 1 - RDRF interrupt or DMA transfer requests enabled.
 */
/*@{*/
#define BP_UART_C2_RIE       (5U)          /*!< Bit position for UART_C2_RIE. */
#define BM_UART_C2_RIE       (0x20U)       /*!< Bit mask for UART_C2_RIE. */
#define BS_UART_C2_RIE       (1U)          /*!< Bit field size in bits for UART_C2_RIE. */

/*! @brief Read current value of the UART_C2_RIE field. */
#define BR_UART_C2_RIE(x)    (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RIE))

/*! @brief Format value for bitfield UART_C2_RIE. */
#define BF_UART_C2_RIE(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_RIE) & BM_UART_C2_RIE)

/*! @brief Set the RIE field to a new value. */
#define BW_UART_C2_RIE(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_RIE) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field TCIE[6] (RW)
 *
 * Enables the transmission complete flag, S1[TC], to generate interrupt
 * requests . or DMA transfer requests based on the state of C5[TCDMAS] If C2[TCIE] and
 * C5[TCDMAS] are both set, then TIE must be cleared, and D[D] must not be
 * written unless servicing a DMA request.
 *
 * Values:
 * - 0 - TC interrupt and DMA transfer requests disabled.
 * - 1 - TC interrupt or DMA transfer requests enabled.
 */
/*@{*/
#define BP_UART_C2_TCIE      (6U)          /*!< Bit position for UART_C2_TCIE. */
#define BM_UART_C2_TCIE      (0x40U)       /*!< Bit mask for UART_C2_TCIE. */
#define BS_UART_C2_TCIE      (1U)          /*!< Bit field size in bits for UART_C2_TCIE. */

/*! @brief Read current value of the UART_C2_TCIE field. */
#define BR_UART_C2_TCIE(x)   (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TCIE))

/*! @brief Format value for bitfield UART_C2_TCIE. */
#define BF_UART_C2_TCIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C2_TCIE) & BM_UART_C2_TCIE)

/*! @brief Set the TCIE field to a new value. */
#define BW_UART_C2_TCIE(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TCIE) = (v))
/*@}*/

/*!
 * @name Register UART_C2, field TIE[7] (RW)
 *
 * Enables S1[TDRE] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[TDMAS]. If C2[TIE] and C5[TDMAS] are both set, then TCIE
 * must be cleared, and D[D] must not be written unless servicing a DMA request.
 *
 * Values:
 * - 0 - TDRE interrupt and DMA transfer requests disabled.
 * - 1 - TDRE interrupt or DMA transfer requests enabled.
 */
/*@{*/
#define BP_UART_C2_TIE       (7U)          /*!< Bit position for UART_C2_TIE. */
#define BM_UART_C2_TIE       (0x80U)       /*!< Bit mask for UART_C2_TIE. */
#define BS_UART_C2_TIE       (1U)          /*!< Bit field size in bits for UART_C2_TIE. */

/*! @brief Read current value of the UART_C2_TIE field. */
#define BR_UART_C2_TIE(x)    (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TIE))

/*! @brief Format value for bitfield UART_C2_TIE. */
#define BF_UART_C2_TIE(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C2_TIE) & BM_UART_C2_TIE)

/*! @brief Set the TIE field to a new value. */
#define BW_UART_C2_TIE(x, v) (BITBAND_ACCESS8(HW_UART_C2_ADDR(x), BP_UART_C2_TIE) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_S1 - UART Status Register 1
 ******************************************************************************/

/*!
 * @brief HW_UART_S1 - UART Status Register 1 (RO)
 *
 * Reset value: 0xC0U
 *
 * The S1 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. This register can also be polled by the MCU to check the
 * status of its fields. To clear a flag, the status register should be read followed
 * by a read or write to D register, depending on the interrupt flag type. Other
 * instructions can be executed between the two steps as long the handling of
 * I/O is not compromised, but the order of operations is important for flag
 * clearing. When a flag is configured to trigger a DMA request, assertion of the
 * associated DMA done signal from the DMA controller clears the flag. If the
 * condition that results in the assertion of the flag, interrupt, or DMA request is not
 * resolved prior to clearing the flag, the flag, and interrupt/DMA request,
 * reasserts. For example, if the DMA or interrupt service routine fails to write
 * sufficient data to the transmit buffer to raise it above the watermark level, the
 * flag reasserts and generates another interrupt or DMA request. Reading an
 * empty data register to clear one of the flags of the S1 register causes the FIFO
 * pointers to become misaligned. A receive FIFO flush reinitializes the
 * pointers. A better way to prevent this situation is to always leave one byte in FIFO
 * and this byte will be read eventually in clearing the flag bit.
 */
typedef union _hw_uart_s1
{
    uint8_t U;
    struct _hw_uart_s1_bitfields
    {
        uint8_t PF : 1;                /*!< [0] Parity Error Flag */
        uint8_t FE : 1;                /*!< [1] Framing Error Flag */
        uint8_t NF : 1;                /*!< [2] Noise Flag */
        uint8_t OR : 1;                /*!< [3] Receiver Overrun Flag */
        uint8_t IDLE : 1;              /*!< [4] Idle Line Flag */
        uint8_t RDRF : 1;              /*!< [5] Receive Data Register Full Flag */
        uint8_t TC : 1;                /*!< [6] Transmit Complete Flag */
        uint8_t TDRE : 1;              /*!< [7] Transmit Data Register Empty Flag */
    } B;
} hw_uart_s1_t;

/*!
 * @name Constants and macros for entire UART_S1 register
 */
/*@{*/
#define HW_UART_S1_ADDR(x)       ((uint32_t)(x) + 0x4U)

#define HW_UART_S1(x)            (*(__I hw_uart_s1_t *) HW_UART_S1_ADDR(x))
#define HW_UART_S1_RD(x)         (HW_UART_S1(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_S1 bitfields
 */

/*!
 * @name Register UART_S1, field PF[0] (RO)
 *
 * PF is set when PE is set and the parity of the received data does not match
 * its parity bit. The PF is not set in the case of an overrun condition. When PF
 * is set, it indicates only that a dataword was received with parity error since
 * the last time it was cleared. There is no guarantee that the first dataword
 * read from the receive buffer has a parity error or that there is only one
 * dataword in the buffer that was received with a parity error, unless the receive
 * buffer has a depth of one. To clear PF, read S1 and then read D., S2[LBKDE] is
 * disabled, Within the receive buffer structure the received dataword is tagged
 * if it is received with a parity error. This information is available by reading
 * the ED register prior to reading the D register.
 *
 * Values:
 * - 0 - No parity error detected since the last time this flag was cleared. If
 *     the receive buffer has a depth greater than 1, then there may be data in
 *     the receive buffer what was received with a parity error.
 * - 1 - At least one dataword was received with a parity error since the last
 *     time this flag was cleared.
 */
/*@{*/
#define BP_UART_S1_PF        (0U)          /*!< Bit position for UART_S1_PF. */
#define BM_UART_S1_PF        (0x01U)       /*!< Bit mask for UART_S1_PF. */
#define BS_UART_S1_PF        (1U)          /*!< Bit field size in bits for UART_S1_PF. */

/*! @brief Read current value of the UART_S1_PF field. */
#define BR_UART_S1_PF(x)     (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_PF))
/*@}*/

/*!
 * @name Register UART_S1, field FE[1] (RO)
 *
 * FE is set when a logic 0 is accepted as the stop bit. When BDH[SBNS] is set,
 * then FE will set when a logic 0 is accepted for either of the two stop bits.
 * FE does not set in the case of an overrun or while the LIN break detect feature
 * is enabled (S2[LBKDE] = 1). FE inhibits further data reception until it is
 * cleared. To clear FE, read S1 with FE set and then read D. The last data in the
 * receive buffer represents the data that was received with the frame error
 * enabled. Framing errors are not supported when 7816E is set/enabled. However, if
 * this flag is set, data is still not received in 7816 mode.
 *
 * Values:
 * - 0 - No framing error detected.
 * - 1 - Framing error.
 */
/*@{*/
#define BP_UART_S1_FE        (1U)          /*!< Bit position for UART_S1_FE. */
#define BM_UART_S1_FE        (0x02U)       /*!< Bit mask for UART_S1_FE. */
#define BS_UART_S1_FE        (1U)          /*!< Bit field size in bits for UART_S1_FE. */

/*! @brief Read current value of the UART_S1_FE field. */
#define BR_UART_S1_FE(x)     (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_FE))
/*@}*/

/*!
 * @name Register UART_S1, field NF[2] (RO)
 *
 * NF is set when the UART detects noise on the receiver input. NF does not
 * become set in the case of an overrun or while the LIN break detect feature is
 * enabled (S2[LBKDE] = 1). When NF is set, it indicates only that a dataword has
 * been received with noise since the last time it was cleared. There is no
 * guarantee that the first dataword read from the receive buffer has noise or that there
 * is only one dataword in the buffer that was received with noise unless the
 * receive buffer has a depth of one. To clear NF, read S1 and then read D.
 *
 * Values:
 * - 0 - No noise detected since the last time this flag was cleared. If the
 *     receive buffer has a depth greater than 1 then there may be data in the
 *     receiver buffer that was received with noise.
 * - 1 - At least one dataword was received with noise detected since the last
 *     time the flag was cleared.
 */
/*@{*/
#define BP_UART_S1_NF        (2U)          /*!< Bit position for UART_S1_NF. */
#define BM_UART_S1_NF        (0x04U)       /*!< Bit mask for UART_S1_NF. */
#define BS_UART_S1_NF        (1U)          /*!< Bit field size in bits for UART_S1_NF. */

/*! @brief Read current value of the UART_S1_NF field. */
#define BR_UART_S1_NF(x)     (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_NF))
/*@}*/

/*!
 * @name Register UART_S1, field OR[3] (RO)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the UART data registers is not
 * affected. If the OR flag is set, no data is stored in the data buffer even if
 * sufficient room exists. Additionally, while the OR flag is set, the RDRF and IDLE
 * flags are blocked from asserting, that is, transition from an inactive to an
 * active state. To clear OR, read S1 when OR is set and then read D. See
 * functional description for more details regarding the operation of the OR bit.If
 * LBKDE is enabled and a LIN Break is detected, the OR field asserts if S2[LBKDIF]
 * is not cleared before the next data character is received. In 7816 mode, it is
 * possible to configure a NACK to be returned by programing C7816[ONACK].
 *
 * Values:
 * - 0 - No overrun has occurred since the last time the flag was cleared.
 * - 1 - Overrun has occurred or the overrun flag has not been cleared since the
 *     last overrun occured.
 */
/*@{*/
#define BP_UART_S1_OR        (3U)          /*!< Bit position for UART_S1_OR. */
#define BM_UART_S1_OR        (0x08U)       /*!< Bit mask for UART_S1_OR. */
#define BS_UART_S1_OR        (1U)          /*!< Bit field size in bits for UART_S1_OR. */

/*! @brief Read current value of the UART_S1_OR field. */
#define BR_UART_S1_OR(x)     (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_OR))
/*@}*/

/*!
 * @name Register UART_S1, field IDLE[4] (RO)
 *
 * After the IDLE flag is cleared, a frame must be received (although not
 * necessarily stored in the data buffer, for example if C2[RWU] is set), or a LIN
 * break character must set the S2[LBKDIF] flag before an idle condition can set the
 * IDLE flag. To clear IDLE, read UART status S1 with IDLE set and then read D.
 * IDLE is set when either of the following appear on the receiver input: 10
 * consecutive logic 1s if C1[M] = 0 11 consecutive logic 1s if C1[M] = 1 and C4[M10]
 * = 0 12 consecutive logic 1s if C1[M] = 1, C4[M10] = 1, and C1[PE] = 1 Idle
 * detection is not supported when 7816E is set/enabled and hence this flag is
 * ignored. When RWU is set and WAKE is cleared, an idle line condition sets the IDLE
 * flag if RWUID is set, else the IDLE flag does not become set.
 *
 * Values:
 * - 0 - Receiver input is either active now or has never become active since
 *     the IDLE flag was last cleared.
 * - 1 - Receiver input has become idle or the flag has not been cleared since
 *     it last asserted.
 */
/*@{*/
#define BP_UART_S1_IDLE      (4U)          /*!< Bit position for UART_S1_IDLE. */
#define BM_UART_S1_IDLE      (0x10U)       /*!< Bit mask for UART_S1_IDLE. */
#define BS_UART_S1_IDLE      (1U)          /*!< Bit field size in bits for UART_S1_IDLE. */

/*! @brief Read current value of the UART_S1_IDLE field. */
#define BR_UART_S1_IDLE(x)   (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_IDLE))
/*@}*/

/*!
 * @name Register UART_S1, field RDRF[5] (RO)
 *
 * RDRF is set when the number of datawords in the receive buffer is equal to or
 * more than the number indicated by RWFIFO[RXWATER]. A dataword that is in the
 * process of being received is not included in the count. To clear RDRF, read S1
 * when RDRF is set and then read D. For more efficient interrupt and DMA
 * operation, read all data except the final value from the buffer, using D/C3[T8]/ED.
 * Then read S1 and the final data value, resulting in the clearing of the RDRF
 * flag. Even if RDRF is set, data will continue to be received until an overrun
 * condition occurs.RDRF is prevented from setting while S2[LBKDE] is set.
 * Additionally, when S2[LBKDE] is set, the received datawords are stored in the receive
 * buffer but over-write each other.
 *
 * Values:
 * - 0 - The number of datawords in the receive buffer is less than the number
 *     indicated by RXWATER.
 * - 1 - The number of datawords in the receive buffer is equal to or greater
 *     than the number indicated by RXWATER at some point in time since this flag
 *     was last cleared.
 */
/*@{*/
#define BP_UART_S1_RDRF      (5U)          /*!< Bit position for UART_S1_RDRF. */
#define BM_UART_S1_RDRF      (0x20U)       /*!< Bit mask for UART_S1_RDRF. */
#define BS_UART_S1_RDRF      (1U)          /*!< Bit field size in bits for UART_S1_RDRF. */

/*! @brief Read current value of the UART_S1_RDRF field. */
#define BR_UART_S1_RDRF(x)   (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_RDRF))
/*@}*/

/*!
 * @name Register UART_S1, field TC[6] (RO)
 *
 * TC is set when the transmit buffer is empty and no data, preamble, or break
 * character is being transmitted. When TC is set, the transmit data output signal
 * becomes idle (logic 1). TC is cleared by reading S1 with TC set and then
 * doing one of the following: When C7816[ISO_7816E] is set/enabled, this field is
 * set after any NACK signal has been received, but prior to any corresponding
 * guard times expiring. Writing to D to transmit new data. Queuing a preamble by
 * clearing and then setting C2[TE]. Queuing a break character by writing 1 to SBK
 * in C2.
 *
 * Values:
 * - 0 - Transmitter active (sending data, a preamble, or a break).
 * - 1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
#define BP_UART_S1_TC        (6U)          /*!< Bit position for UART_S1_TC. */
#define BM_UART_S1_TC        (0x40U)       /*!< Bit mask for UART_S1_TC. */
#define BS_UART_S1_TC        (1U)          /*!< Bit field size in bits for UART_S1_TC. */

/*! @brief Read current value of the UART_S1_TC field. */
#define BR_UART_S1_TC(x)     (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_TC))
/*@}*/

/*!
 * @name Register UART_S1, field TDRE[7] (RO)
 *
 * TDRE will set when the number of datawords in the transmit buffer (D and
 * C3[T8])is equal to or less than the number indicated by TWFIFO[TXWATER]. A
 * character that is in the process of being transmitted is not included in the count.
 * To clear TDRE, read S1 when TDRE is set and then write to the UART data
 * register (D). For more efficient interrupt servicing, all data except the final value
 * to be written to the buffer must be written to D/C3[T8]. Then S1 can be read
 * before writing the final data value, resulting in the clearing of the TRDE
 * flag. This is more efficient because the TDRE reasserts until the watermark has
 * been exceeded. So, attempting to clear the TDRE with every write will be
 * ineffective until sufficient data has been written.
 *
 * Values:
 * - 0 - The amount of data in the transmit buffer is greater than the value
 *     indicated by TWFIFO[TXWATER].
 * - 1 - The amount of data in the transmit buffer is less than or equal to the
 *     value indicated by TWFIFO[TXWATER] at some point in time since the flag
 *     has been cleared.
 */
/*@{*/
#define BP_UART_S1_TDRE      (7U)          /*!< Bit position for UART_S1_TDRE. */
#define BM_UART_S1_TDRE      (0x80U)       /*!< Bit mask for UART_S1_TDRE. */
#define BS_UART_S1_TDRE      (1U)          /*!< Bit field size in bits for UART_S1_TDRE. */

/*! @brief Read current value of the UART_S1_TDRE field. */
#define BR_UART_S1_TDRE(x)   (BITBAND_ACCESS8(HW_UART_S1_ADDR(x), BP_UART_S1_TDRE))
/*@}*/

/*******************************************************************************
 * HW_UART_S2 - UART Status Register 2
 ******************************************************************************/

/*!
 * @brief HW_UART_S2 - UART Status Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * The S2 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. Also, this register can be polled by the MCU to check the
 * status of these bits. This register can be read or written at any time, with the
 * exception of the MSBF and RXINV bits, which should be changed by the user only
 * between transmit and receive packets.
 */
typedef union _hw_uart_s2
{
    uint8_t U;
    struct _hw_uart_s2_bitfields
    {
        uint8_t RAF : 1;               /*!< [0] Receiver Active Flag */
        uint8_t LBKDE : 1;             /*!< [1] LIN Break Detection Enable */
        uint8_t BRK13 : 1;             /*!< [2] Break Transmit Character Length */
        uint8_t RWUID : 1;             /*!< [3] Receive Wakeup Idle Detect */
        uint8_t RXINV : 1;             /*!< [4] Receive Data Inversion */
        uint8_t MSBF : 1;              /*!< [5] Most Significant Bit First */
        uint8_t RXEDGIF : 1;           /*!< [6] RxD Pin Active Edge Interrupt Flag */
        uint8_t LBKDIF : 1;            /*!< [7] LIN Break Detect Interrupt Flag */
    } B;
} hw_uart_s2_t;

/*!
 * @name Constants and macros for entire UART_S2 register
 */
/*@{*/
#define HW_UART_S2_ADDR(x)       ((uint32_t)(x) + 0x5U)

#define HW_UART_S2(x)            (*(__IO hw_uart_s2_t *) HW_UART_S2_ADDR(x))
#define HW_UART_S2_RD(x)         (HW_UART_S2(x).U)
#define HW_UART_S2_WR(x, v)      (HW_UART_S2(x).U = (v))
#define HW_UART_S2_SET(x, v)     (HW_UART_S2_WR(x, HW_UART_S2_RD(x) |  (v)))
#define HW_UART_S2_CLR(x, v)     (HW_UART_S2_WR(x, HW_UART_S2_RD(x) & ~(v)))
#define HW_UART_S2_TOG(x, v)     (HW_UART_S2_WR(x, HW_UART_S2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_S2 bitfields
 */

/*!
 * @name Register UART_S2, field RAF[0] (RO)
 *
 * RAF is set when the UART receiver detects a logic 0 during the RT1 time
 * period of the start bit search. RAF is cleared when the receiver detects an idle
 * character when C7816[ISO7816E] is cleared/disabled. When C7816[ISO7816E] is
 * enabled, the RAF is cleared if the C7816[TTYPE] = 0 expires or the C7816[TTYPE] =
 * 1 expires.In case C7816[ISO7816E] is set and C7816[TTYPE] = 0, it is possible
 * to configure the guard time to 12. However, if a NACK is required to be
 * transmitted, the data transfer actually takes 13 ETU with the 13th ETU slot being a
 * inactive buffer. Therefore, in this situation, the RAF may deassert one ETU
 * prior to actually being inactive.
 *
 * Values:
 * - 0 - UART receiver idle/inactive waiting for a start bit.
 * - 1 - UART receiver active, RxD input not idle.
 */
/*@{*/
#define BP_UART_S2_RAF       (0U)          /*!< Bit position for UART_S2_RAF. */
#define BM_UART_S2_RAF       (0x01U)       /*!< Bit mask for UART_S2_RAF. */
#define BS_UART_S2_RAF       (1U)          /*!< Bit field size in bits for UART_S2_RAF. */

/*! @brief Read current value of the UART_S2_RAF field. */
#define BR_UART_S2_RAF(x)    (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RAF))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDE[1] (RW)
 *
 * Enables the LIN Break detection feature. While LBKDE is set, S1[RDRF],
 * S1[NF], S1[FE], and S1[PF] are prevented from setting. When LBKDE is set, see .
 * Overrun operation LBKDE must be cleared when C7816[ISO7816E] is set.
 *
 * Values:
 * - 0 - Break character detection is disabled.
 * - 1 - Break character is detected at length of 11 bit times if C1[M] = 0 or
 *     12 bits time if C1[M] = 1.
 */
/*@{*/
#define BP_UART_S2_LBKDE     (1U)          /*!< Bit position for UART_S2_LBKDE. */
#define BM_UART_S2_LBKDE     (0x02U)       /*!< Bit mask for UART_S2_LBKDE. */
#define BS_UART_S2_LBKDE     (1U)          /*!< Bit field size in bits for UART_S2_LBKDE. */

/*! @brief Read current value of the UART_S2_LBKDE field. */
#define BR_UART_S2_LBKDE(x)  (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_LBKDE))

/*! @brief Format value for bitfield UART_S2_LBKDE. */
#define BF_UART_S2_LBKDE(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_LBKDE) & BM_UART_S2_LBKDE)

/*! @brief Set the LBKDE field to a new value. */
#define BW_UART_S2_LBKDE(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_LBKDE) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field BRK13[2] (RW)
 *
 * Determines whether the transmit break character is 10, 11, or 12 bits long,
 * or 13 or 14 bits long. See for the length of the break character for the
 * different configurations. The detection of a framing error is not affected by this
 * field. Transmitting break characters
 *
 * Values:
 * - 0 - Break character is 10, 11, or 12 bits long.
 * - 1 - Break character is 13 or 14 bits long.
 */
/*@{*/
#define BP_UART_S2_BRK13     (2U)          /*!< Bit position for UART_S2_BRK13. */
#define BM_UART_S2_BRK13     (0x04U)       /*!< Bit mask for UART_S2_BRK13. */
#define BS_UART_S2_BRK13     (1U)          /*!< Bit field size in bits for UART_S2_BRK13. */

/*! @brief Read current value of the UART_S2_BRK13 field. */
#define BR_UART_S2_BRK13(x)  (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_BRK13))

/*! @brief Format value for bitfield UART_S2_BRK13. */
#define BF_UART_S2_BRK13(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_BRK13) & BM_UART_S2_BRK13)

/*! @brief Set the BRK13 field to a new value. */
#define BW_UART_S2_BRK13(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_BRK13) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field RWUID[3] (RW)
 *
 * When RWU is set and WAKE is cleared, this field controls whether the idle
 * character that wakes the receiver sets S1[IDLE]. This field must be cleared when
 * C7816[ISO7816E] is set/enabled.
 *
 * Values:
 * - 0 - S1[IDLE] is not set upon detection of an idle character.
 * - 1 - S1[IDLE] is set upon detection of an idle character.
 */
/*@{*/
#define BP_UART_S2_RWUID     (3U)          /*!< Bit position for UART_S2_RWUID. */
#define BM_UART_S2_RWUID     (0x08U)       /*!< Bit mask for UART_S2_RWUID. */
#define BS_UART_S2_RWUID     (1U)          /*!< Bit field size in bits for UART_S2_RWUID. */

/*! @brief Read current value of the UART_S2_RWUID field. */
#define BR_UART_S2_RWUID(x)  (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RWUID))

/*! @brief Format value for bitfield UART_S2_RWUID. */
#define BF_UART_S2_RWUID(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_RWUID) & BM_UART_S2_RWUID)

/*! @brief Set the RWUID field to a new value. */
#define BW_UART_S2_RWUID(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RWUID) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field RXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the received data input. In NRZ
 * format, a one is represented by a mark and a zero is represented by a space for
 * normal polarity, and the opposite for inverted polarity. In IrDA format, a
 * zero is represented by short high pulse in the middle of a bit time remaining
 * idle low for a one for normal polarity. A zero is represented by a short low
 * pulse in the middle of a bit time remaining idle high for a one for inverted
 * polarity. This field is automatically set when C7816[INIT] and C7816[ISO7816E] are
 * enabled and an initial character is detected in T = 0 protocol mode. Setting
 * RXINV inverts the RxD input for data bits, start and stop bits, break, and
 * idle. When C7816[ISO7816E] is set/enabled, only the data bits and the parity bit
 * are inverted.
 *
 * Values:
 * - 0 - Receive data is not inverted.
 * - 1 - Receive data is inverted.
 */
/*@{*/
#define BP_UART_S2_RXINV     (4U)          /*!< Bit position for UART_S2_RXINV. */
#define BM_UART_S2_RXINV     (0x10U)       /*!< Bit mask for UART_S2_RXINV. */
#define BS_UART_S2_RXINV     (1U)          /*!< Bit field size in bits for UART_S2_RXINV. */

/*! @brief Read current value of the UART_S2_RXINV field. */
#define BR_UART_S2_RXINV(x)  (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RXINV))

/*! @brief Format value for bitfield UART_S2_RXINV. */
#define BF_UART_S2_RXINV(v)  ((uint8_t)((uint8_t)(v) << BP_UART_S2_RXINV) & BM_UART_S2_RXINV)

/*! @brief Set the RXINV field to a new value. */
#define BW_UART_S2_RXINV(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RXINV) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field MSBF[5] (RW)
 *
 * Setting this field reverses the order of the bits that are transmitted and
 * received on the wire. This field does not affect the polarity of the bits, the
 * location of the parity bit, or the location of the start or stop bits. This
 * field is automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and
 * an initial character is detected in T = 0 protocol mode.
 *
 * Values:
 * - 0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 1 - MSB (bit8, bit7 or bit6) is the first bit that is transmitted following
 *     the start bit, depending on the setting of C1[M] and C1[PE]. Further, the
 *     first bit received after the start bit is identified as bit8, bit7, or
 *     bit6, depending on the setting of C1[M] and C1[PE].
 */
/*@{*/
#define BP_UART_S2_MSBF      (5U)          /*!< Bit position for UART_S2_MSBF. */
#define BM_UART_S2_MSBF      (0x20U)       /*!< Bit mask for UART_S2_MSBF. */
#define BS_UART_S2_MSBF      (1U)          /*!< Bit field size in bits for UART_S2_MSBF. */

/*! @brief Read current value of the UART_S2_MSBF field. */
#define BR_UART_S2_MSBF(x)   (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_MSBF))

/*! @brief Format value for bitfield UART_S2_MSBF. */
#define BF_UART_S2_MSBF(v)   ((uint8_t)((uint8_t)(v) << BP_UART_S2_MSBF) & BM_UART_S2_MSBF)

/*! @brief Set the MSBF field to a new value. */
#define BW_UART_S2_MSBF(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_MSBF) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field RXEDGIF[6] (W1C)
 *
 * RXEDGIF is set when an active edge occurs on the RxD pin. The active edge is
 * falling if RXINV = 0, and rising if RXINV=1. RXEDGIF is cleared by writing a 1
 * to it. See for additional details. RXEDGIF description The active edge is
 * detected only in two wire mode and on receiving data coming from the RxD pin.
 *
 * Values:
 * - 0 - No active edge on the receive pin has occurred.
 * - 1 - An active edge on the receive pin has occurred.
 */
/*@{*/
#define BP_UART_S2_RXEDGIF   (6U)          /*!< Bit position for UART_S2_RXEDGIF. */
#define BM_UART_S2_RXEDGIF   (0x40U)       /*!< Bit mask for UART_S2_RXEDGIF. */
#define BS_UART_S2_RXEDGIF   (1U)          /*!< Bit field size in bits for UART_S2_RXEDGIF. */

/*! @brief Read current value of the UART_S2_RXEDGIF field. */
#define BR_UART_S2_RXEDGIF(x) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RXEDGIF))

/*! @brief Format value for bitfield UART_S2_RXEDGIF. */
#define BF_UART_S2_RXEDGIF(v) ((uint8_t)((uint8_t)(v) << BP_UART_S2_RXEDGIF) & BM_UART_S2_RXEDGIF)

/*! @brief Set the RXEDGIF field to a new value. */
#define BW_UART_S2_RXEDGIF(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_RXEDGIF) = (v))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDIF[7] (W1C)
 *
 * LBKDIF is set when LBKDE is set and a LIN break character is detected on the
 * receiver input. The LIN break characters are 11 consecutive logic 0s if C1[M]
 * = 0 or 12 consecutive logic 0s if C1[M] = 1. LBKDIF is set after receiving the
 * last LIN break character. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No LIN break character detected.
 * - 1 - LIN break character detected.
 */
/*@{*/
#define BP_UART_S2_LBKDIF    (7U)          /*!< Bit position for UART_S2_LBKDIF. */
#define BM_UART_S2_LBKDIF    (0x80U)       /*!< Bit mask for UART_S2_LBKDIF. */
#define BS_UART_S2_LBKDIF    (1U)          /*!< Bit field size in bits for UART_S2_LBKDIF. */

/*! @brief Read current value of the UART_S2_LBKDIF field. */
#define BR_UART_S2_LBKDIF(x) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_LBKDIF))

/*! @brief Format value for bitfield UART_S2_LBKDIF. */
#define BF_UART_S2_LBKDIF(v) ((uint8_t)((uint8_t)(v) << BP_UART_S2_LBKDIF) & BM_UART_S2_LBKDIF)

/*! @brief Set the LBKDIF field to a new value. */
#define BW_UART_S2_LBKDIF(x, v) (BITBAND_ACCESS8(HW_UART_S2_ADDR(x), BP_UART_S2_LBKDIF) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_C3 - UART Control Register 3
 ******************************************************************************/

/*!
 * @brief HW_UART_C3 - UART Control Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Writing R8 does not have any effect. TXDIR and TXINV can be changed only
 * between transmit and receive packets.
 */
typedef union _hw_uart_c3
{
    uint8_t U;
    struct _hw_uart_c3_bitfields
    {
        uint8_t PEIE : 1;              /*!< [0] Parity Error Interrupt Enable */
        uint8_t FEIE : 1;              /*!< [1] Framing Error Interrupt Enable */
        uint8_t NEIE : 1;              /*!< [2] Noise Error Interrupt Enable */
        uint8_t ORIE : 1;              /*!< [3] Overrun Error Interrupt Enable */
        uint8_t TXINV : 1;             /*!< [4] Transmit Data Inversion. */
        uint8_t TXDIR : 1;             /*!< [5] Transmitter Pin Data Direction in
                                        * Single-Wire mode */
        uint8_t T8 : 1;                /*!< [6] Transmit Bit 8 */
        uint8_t R8 : 1;                /*!< [7] Received Bit 8 */
    } B;
} hw_uart_c3_t;

/*!
 * @name Constants and macros for entire UART_C3 register
 */
/*@{*/
#define HW_UART_C3_ADDR(x)       ((uint32_t)(x) + 0x6U)

#define HW_UART_C3(x)            (*(__IO hw_uart_c3_t *) HW_UART_C3_ADDR(x))
#define HW_UART_C3_RD(x)         (HW_UART_C3(x).U)
#define HW_UART_C3_WR(x, v)      (HW_UART_C3(x).U = (v))
#define HW_UART_C3_SET(x, v)     (HW_UART_C3_WR(x, HW_UART_C3_RD(x) |  (v)))
#define HW_UART_C3_CLR(x, v)     (HW_UART_C3_WR(x, HW_UART_C3_RD(x) & ~(v)))
#define HW_UART_C3_TOG(x, v)     (HW_UART_C3_WR(x, HW_UART_C3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C3 bitfields
 */

/*!
 * @name Register UART_C3, field PEIE[0] (RW)
 *
 * Enables the parity error flag, S1[PF], to generate interrupt requests.
 *
 * Values:
 * - 0 - PF interrupt requests are disabled.
 * - 1 - PF interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_PEIE      (0U)          /*!< Bit position for UART_C3_PEIE. */
#define BM_UART_C3_PEIE      (0x01U)       /*!< Bit mask for UART_C3_PEIE. */
#define BS_UART_C3_PEIE      (1U)          /*!< Bit field size in bits for UART_C3_PEIE. */

/*! @brief Read current value of the UART_C3_PEIE field. */
#define BR_UART_C3_PEIE(x)   (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_PEIE))

/*! @brief Format value for bitfield UART_C3_PEIE. */
#define BF_UART_C3_PEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_PEIE) & BM_UART_C3_PEIE)

/*! @brief Set the PEIE field to a new value. */
#define BW_UART_C3_PEIE(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_PEIE) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field FEIE[1] (RW)
 *
 * Enables the framing error flag, S1[FE], to generate interrupt requests.
 *
 * Values:
 * - 0 - FE interrupt requests are disabled.
 * - 1 - FE interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_FEIE      (1U)          /*!< Bit position for UART_C3_FEIE. */
#define BM_UART_C3_FEIE      (0x02U)       /*!< Bit mask for UART_C3_FEIE. */
#define BS_UART_C3_FEIE      (1U)          /*!< Bit field size in bits for UART_C3_FEIE. */

/*! @brief Read current value of the UART_C3_FEIE field. */
#define BR_UART_C3_FEIE(x)   (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_FEIE))

/*! @brief Format value for bitfield UART_C3_FEIE. */
#define BF_UART_C3_FEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_FEIE) & BM_UART_C3_FEIE)

/*! @brief Set the FEIE field to a new value. */
#define BW_UART_C3_FEIE(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_FEIE) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field NEIE[2] (RW)
 *
 * Enables the noise flag, S1[NF], to generate interrupt requests.
 *
 * Values:
 * - 0 - NF interrupt requests are disabled.
 * - 1 - NF interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_NEIE      (2U)          /*!< Bit position for UART_C3_NEIE. */
#define BM_UART_C3_NEIE      (0x04U)       /*!< Bit mask for UART_C3_NEIE. */
#define BS_UART_C3_NEIE      (1U)          /*!< Bit field size in bits for UART_C3_NEIE. */

/*! @brief Read current value of the UART_C3_NEIE field. */
#define BR_UART_C3_NEIE(x)   (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_NEIE))

/*! @brief Format value for bitfield UART_C3_NEIE. */
#define BF_UART_C3_NEIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_NEIE) & BM_UART_C3_NEIE)

/*! @brief Set the NEIE field to a new value. */
#define BW_UART_C3_NEIE(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_NEIE) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field ORIE[3] (RW)
 *
 * Enables the overrun error flag, S1[OR], to generate interrupt requests.
 *
 * Values:
 * - 0 - OR interrupts are disabled.
 * - 1 - OR interrupt requests are enabled.
 */
/*@{*/
#define BP_UART_C3_ORIE      (3U)          /*!< Bit position for UART_C3_ORIE. */
#define BM_UART_C3_ORIE      (0x08U)       /*!< Bit mask for UART_C3_ORIE. */
#define BS_UART_C3_ORIE      (1U)          /*!< Bit field size in bits for UART_C3_ORIE. */

/*! @brief Read current value of the UART_C3_ORIE field. */
#define BR_UART_C3_ORIE(x)   (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_ORIE))

/*! @brief Format value for bitfield UART_C3_ORIE. */
#define BF_UART_C3_ORIE(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C3_ORIE) & BM_UART_C3_ORIE)

/*! @brief Set the ORIE field to a new value. */
#define BW_UART_C3_ORIE(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_ORIE) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field TXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the transmitted data output. In
 * NRZ format, a one is represented by a mark and a zero is represented by a space
 * for normal polarity, and the opposite for inverted polarity. In IrDA format,
 * a zero is represented by short high pulse in the middle of a bit time
 * remaining idle low for a one for normal polarity, and a zero is represented by short
 * low pulse in the middle of a bit time remaining idle high for a one for
 * inverted polarity. This field is automatically set when C7816[INIT] and
 * C7816[ISO7816E] are enabled and an initial character is detected in T = 0 protocol mode.
 * Setting TXINV inverts all transmitted values, including idle, break, start, and
 * stop bits. In loop mode, if TXINV is set, the receiver gets the transmit
 * inversion bit when RXINV is disabled. When C7816[ISO7816E] is set/enabled then only
 * the transmitted data bits and parity bit are inverted.
 *
 * Values:
 * - 0 - Transmit data is not inverted.
 * - 1 - Transmit data is inverted.
 */
/*@{*/
#define BP_UART_C3_TXINV     (4U)          /*!< Bit position for UART_C3_TXINV. */
#define BM_UART_C3_TXINV     (0x10U)       /*!< Bit mask for UART_C3_TXINV. */
#define BS_UART_C3_TXINV     (1U)          /*!< Bit field size in bits for UART_C3_TXINV. */

/*! @brief Read current value of the UART_C3_TXINV field. */
#define BR_UART_C3_TXINV(x)  (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_TXINV))

/*! @brief Format value for bitfield UART_C3_TXINV. */
#define BF_UART_C3_TXINV(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C3_TXINV) & BM_UART_C3_TXINV)

/*! @brief Set the TXINV field to a new value. */
#define BW_UART_C3_TXINV(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_TXINV) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field TXDIR[5] (RW)
 *
 * Determines whether the TXD pin is used as an input or output in the
 * single-wire mode of operation. This field is relevant only to the single wire mode.
 * When C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 1, this field is
 * automatically cleared after the requested block is transmitted. This condition is
 * detected when TL7816[TLEN] = 0 and 4 additional characters are transmitted.
 * Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0 and a NACK is
 * being transmitted, the hardware automatically overrides this field as needed. In
 * this situation, TXDIR does not reflect the temporary state associated with
 * the NACK.
 *
 * Values:
 * - 0 - TXD pin is an input in single wire mode.
 * - 1 - TXD pin is an output in single wire mode.
 */
/*@{*/
#define BP_UART_C3_TXDIR     (5U)          /*!< Bit position for UART_C3_TXDIR. */
#define BM_UART_C3_TXDIR     (0x20U)       /*!< Bit mask for UART_C3_TXDIR. */
#define BS_UART_C3_TXDIR     (1U)          /*!< Bit field size in bits for UART_C3_TXDIR. */

/*! @brief Read current value of the UART_C3_TXDIR field. */
#define BR_UART_C3_TXDIR(x)  (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_TXDIR))

/*! @brief Format value for bitfield UART_C3_TXDIR. */
#define BF_UART_C3_TXDIR(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C3_TXDIR) & BM_UART_C3_TXDIR)

/*! @brief Set the TXDIR field to a new value. */
#define BW_UART_C3_TXDIR(x, v) (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_TXDIR) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field T8[6] (RW)
 *
 * T8 is the ninth data bit transmitted when the UART is configured for 9-bit
 * data format, that is, if C1[M] = 1 or C4[M10] = 1. If the value of T8 is the
 * same as in the previous transmission, T8 does not have to be rewritten. The same
 * value is transmitted until T8 is rewritten. To correctly transmit the 9th bit,
 * write UARTx_C3[T8] to the desired value, then write the UARTx_D register with
 * the remaining data.
 */
/*@{*/
#define BP_UART_C3_T8        (6U)          /*!< Bit position for UART_C3_T8. */
#define BM_UART_C3_T8        (0x40U)       /*!< Bit mask for UART_C3_T8. */
#define BS_UART_C3_T8        (1U)          /*!< Bit field size in bits for UART_C3_T8. */

/*! @brief Read current value of the UART_C3_T8 field. */
#define BR_UART_C3_T8(x)     (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_T8))

/*! @brief Format value for bitfield UART_C3_T8. */
#define BF_UART_C3_T8(v)     ((uint8_t)((uint8_t)(v) << BP_UART_C3_T8) & BM_UART_C3_T8)

/*! @brief Set the T8 field to a new value. */
#define BW_UART_C3_T8(x, v)  (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_T8) = (v))
/*@}*/

/*!
 * @name Register UART_C3, field R8[7] (RO)
 *
 * R8 is the ninth data bit received when the UART is configured for 9-bit data
 * format, that is, if C1[M] = 1 or C4[M10] = 1. The R8 value corresponds to the
 * current data value in the UARTx_D register. To read the 9th bit, read the
 * value of UARTx_C3[R8], then read the UARTx_D register.
 */
/*@{*/
#define BP_UART_C3_R8        (7U)          /*!< Bit position for UART_C3_R8. */
#define BM_UART_C3_R8        (0x80U)       /*!< Bit mask for UART_C3_R8. */
#define BS_UART_C3_R8        (1U)          /*!< Bit field size in bits for UART_C3_R8. */

/*! @brief Read current value of the UART_C3_R8 field. */
#define BR_UART_C3_R8(x)     (BITBAND_ACCESS8(HW_UART_C3_ADDR(x), BP_UART_C3_R8))
/*@}*/

/*******************************************************************************
 * HW_UART_D - UART Data Register
 ******************************************************************************/

/*!
 * @brief HW_UART_D - UART Data Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data register and writes go to the write-only transmit
 * data register. In 8-bit or 9-bit data format, only UART data register (D)
 * needs to be accessed to clear the S1[RDRF] bit (assuming receiver buffer level is
 * less than RWFIFO[RXWATER]). The C3 register needs to be read, prior to the D
 * register, only if the ninth bit of data needs to be captured. Similarly, the
 * ED register needs to be read, prior to the D register, only if the additional
 * flag data for the dataword needs to be captured. In the normal 8-bit mode (M
 * bit cleared) if the parity is enabled, you get seven data bits and one parity
 * bit. That one parity bit is loaded into the D register. So, for the data bits,
 * mask off the parity bit from the value you read out of this register. When
 * transmitting in 9-bit data format and using 8-bit write instructions, write first
 * to transmit bit 8 in UART control register 3 (C3[T8]), then D. A write to
 * C3[T8] stores the data in a temporary register. If D register is written first,
 * and then the new data on data bus is stored in D, the temporary value written by
 * the last write to C3[T8] gets stored in the C3[T8] register.
 */
typedef union _hw_uart_d
{
    uint8_t U;
    struct _hw_uart_d_bitfields
    {
        uint8_t RT : 8;                /*!< [7:0]  */
    } B;
} hw_uart_d_t;

/*!
 * @name Constants and macros for entire UART_D register
 */
/*@{*/
#define HW_UART_D_ADDR(x)        ((uint32_t)(x) + 0x7U)

#define HW_UART_D(x)             (*(__IO hw_uart_d_t *) HW_UART_D_ADDR(x))
#define HW_UART_D_RD(x)          (HW_UART_D(x).U)
#define HW_UART_D_WR(x, v)       (HW_UART_D(x).U = (v))
#define HW_UART_D_SET(x, v)      (HW_UART_D_WR(x, HW_UART_D_RD(x) |  (v)))
#define HW_UART_D_CLR(x, v)      (HW_UART_D_WR(x, HW_UART_D_RD(x) & ~(v)))
#define HW_UART_D_TOG(x, v)      (HW_UART_D_WR(x, HW_UART_D_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_D bitfields
 */

/*!
 * @name Register UART_D, field RT[7:0] (RW)
 *
 * Reads return the contents of the read-only receive data register and writes
 * go to the write-only transmit data register.
 */
/*@{*/
#define BP_UART_D_RT         (0U)          /*!< Bit position for UART_D_RT. */
#define BM_UART_D_RT         (0xFFU)       /*!< Bit mask for UART_D_RT. */
#define BS_UART_D_RT         (8U)          /*!< Bit field size in bits for UART_D_RT. */

/*! @brief Read current value of the UART_D_RT field. */
#define BR_UART_D_RT(x)      (HW_UART_D(x).U)

/*! @brief Format value for bitfield UART_D_RT. */
#define BF_UART_D_RT(v)      ((uint8_t)((uint8_t)(v) << BP_UART_D_RT) & BM_UART_D_RT)

/*! @brief Set the RT field to a new value. */
#define BW_UART_D_RT(x, v)   (HW_UART_D_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_MA1 - UART Match Address Registers 1
 ******************************************************************************/

/*!
 * @brief HW_UART_MA1 - UART Match Address Registers 1 (RW)
 *
 * Reset value: 0x00U
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated C4[MAEN] field is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. These registers can be read and written at
 * anytime.
 */
typedef union _hw_uart_ma1
{
    uint8_t U;
    struct _hw_uart_ma1_bitfields
    {
        uint8_t MA : 8;                /*!< [7:0] Match Address */
    } B;
} hw_uart_ma1_t;

/*!
 * @name Constants and macros for entire UART_MA1 register
 */
/*@{*/
#define HW_UART_MA1_ADDR(x)      ((uint32_t)(x) + 0x8U)

#define HW_UART_MA1(x)           (*(__IO hw_uart_ma1_t *) HW_UART_MA1_ADDR(x))
#define HW_UART_MA1_RD(x)        (HW_UART_MA1(x).U)
#define HW_UART_MA1_WR(x, v)     (HW_UART_MA1(x).U = (v))
#define HW_UART_MA1_SET(x, v)    (HW_UART_MA1_WR(x, HW_UART_MA1_RD(x) |  (v)))
#define HW_UART_MA1_CLR(x, v)    (HW_UART_MA1_WR(x, HW_UART_MA1_RD(x) & ~(v)))
#define HW_UART_MA1_TOG(x, v)    (HW_UART_MA1_WR(x, HW_UART_MA1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_MA1 bitfields
 */

/*!
 * @name Register UART_MA1, field MA[7:0] (RW)
 */
/*@{*/
#define BP_UART_MA1_MA       (0U)          /*!< Bit position for UART_MA1_MA. */
#define BM_UART_MA1_MA       (0xFFU)       /*!< Bit mask for UART_MA1_MA. */
#define BS_UART_MA1_MA       (8U)          /*!< Bit field size in bits for UART_MA1_MA. */

/*! @brief Read current value of the UART_MA1_MA field. */
#define BR_UART_MA1_MA(x)    (HW_UART_MA1(x).U)

/*! @brief Format value for bitfield UART_MA1_MA. */
#define BF_UART_MA1_MA(v)    ((uint8_t)((uint8_t)(v) << BP_UART_MA1_MA) & BM_UART_MA1_MA)

/*! @brief Set the MA field to a new value. */
#define BW_UART_MA1_MA(x, v) (HW_UART_MA1_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_MA2 - UART Match Address Registers 2
 ******************************************************************************/

/*!
 * @brief HW_UART_MA2 - UART Match Address Registers 2 (RW)
 *
 * Reset value: 0x00U
 *
 * These registers can be read and written at anytime. The MA1 and MA2 registers
 * are compared to input data addresses when the most significant bit is set and
 * the associated C4[MAEN] field is set. If a match occurs, the following data
 * is transferred to the data register. If a match fails, the following data is
 * discarded.
 */
typedef union _hw_uart_ma2
{
    uint8_t U;
    struct _hw_uart_ma2_bitfields
    {
        uint8_t MA : 8;                /*!< [7:0] Match Address */
    } B;
} hw_uart_ma2_t;

/*!
 * @name Constants and macros for entire UART_MA2 register
 */
/*@{*/
#define HW_UART_MA2_ADDR(x)      ((uint32_t)(x) + 0x9U)

#define HW_UART_MA2(x)           (*(__IO hw_uart_ma2_t *) HW_UART_MA2_ADDR(x))
#define HW_UART_MA2_RD(x)        (HW_UART_MA2(x).U)
#define HW_UART_MA2_WR(x, v)     (HW_UART_MA2(x).U = (v))
#define HW_UART_MA2_SET(x, v)    (HW_UART_MA2_WR(x, HW_UART_MA2_RD(x) |  (v)))
#define HW_UART_MA2_CLR(x, v)    (HW_UART_MA2_WR(x, HW_UART_MA2_RD(x) & ~(v)))
#define HW_UART_MA2_TOG(x, v)    (HW_UART_MA2_WR(x, HW_UART_MA2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_MA2 bitfields
 */

/*!
 * @name Register UART_MA2, field MA[7:0] (RW)
 */
/*@{*/
#define BP_UART_MA2_MA       (0U)          /*!< Bit position for UART_MA2_MA. */
#define BM_UART_MA2_MA       (0xFFU)       /*!< Bit mask for UART_MA2_MA. */
#define BS_UART_MA2_MA       (8U)          /*!< Bit field size in bits for UART_MA2_MA. */

/*! @brief Read current value of the UART_MA2_MA field. */
#define BR_UART_MA2_MA(x)    (HW_UART_MA2(x).U)

/*! @brief Format value for bitfield UART_MA2_MA. */
#define BF_UART_MA2_MA(v)    ((uint8_t)((uint8_t)(v) << BP_UART_MA2_MA) & BM_UART_MA2_MA)

/*! @brief Set the MA field to a new value. */
#define BW_UART_MA2_MA(x, v) (HW_UART_MA2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_C4 - UART Control Register 4
 ******************************************************************************/

/*!
 * @brief HW_UART_C4 - UART Control Register 4 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_c4
{
    uint8_t U;
    struct _hw_uart_c4_bitfields
    {
        uint8_t BRFA : 5;              /*!< [4:0] Baud Rate Fine Adjust */
        uint8_t M10 : 1;               /*!< [5] 10-bit Mode select */
        uint8_t MAEN2 : 1;             /*!< [6] Match Address Mode Enable 2 */
        uint8_t MAEN1 : 1;             /*!< [7] Match Address Mode Enable 1 */
    } B;
} hw_uart_c4_t;

/*!
 * @name Constants and macros for entire UART_C4 register
 */
/*@{*/
#define HW_UART_C4_ADDR(x)       ((uint32_t)(x) + 0xAU)

#define HW_UART_C4(x)            (*(__IO hw_uart_c4_t *) HW_UART_C4_ADDR(x))
#define HW_UART_C4_RD(x)         (HW_UART_C4(x).U)
#define HW_UART_C4_WR(x, v)      (HW_UART_C4(x).U = (v))
#define HW_UART_C4_SET(x, v)     (HW_UART_C4_WR(x, HW_UART_C4_RD(x) |  (v)))
#define HW_UART_C4_CLR(x, v)     (HW_UART_C4_WR(x, HW_UART_C4_RD(x) & ~(v)))
#define HW_UART_C4_TOG(x, v)     (HW_UART_C4_WR(x, HW_UART_C4_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C4 bitfields
 */

/*!
 * @name Register UART_C4, field BRFA[4:0] (RW)
 *
 * This bit field is used to add more timing resolution to the average baud
 * frequency, in increments of 1/32. See Baud rate generation for more information.
 */
/*@{*/
#define BP_UART_C4_BRFA      (0U)          /*!< Bit position for UART_C4_BRFA. */
#define BM_UART_C4_BRFA      (0x1FU)       /*!< Bit mask for UART_C4_BRFA. */
#define BS_UART_C4_BRFA      (5U)          /*!< Bit field size in bits for UART_C4_BRFA. */

/*! @brief Read current value of the UART_C4_BRFA field. */
#define BR_UART_C4_BRFA(x)   (HW_UART_C4(x).B.BRFA)

/*! @brief Format value for bitfield UART_C4_BRFA. */
#define BF_UART_C4_BRFA(v)   ((uint8_t)((uint8_t)(v) << BP_UART_C4_BRFA) & BM_UART_C4_BRFA)

/*! @brief Set the BRFA field to a new value. */
#define BW_UART_C4_BRFA(x, v) (HW_UART_C4_WR(x, (HW_UART_C4_RD(x) & ~BM_UART_C4_BRFA) | BF_UART_C4_BRFA(v)))
/*@}*/

/*!
 * @name Register UART_C4, field M10[5] (RW)
 *
 * Causes a tenth, non-memory mapped bit to be part of the serial transmission.
 * This tenth bit is generated and interpreted as a parity bit. The M10 field
 * does not affect the LIN send or detect break behavior. If M10 is set, then both
 * C1[M] and C1[PE] must also be set. This field must be cleared when
 * C7816[ISO7816E] is set/enabled. See Data format (non ISO-7816) for more information.
 *
 * Values:
 * - 0 - The parity bit is the ninth bit in the serial transmission.
 * - 1 - The parity bit is the tenth bit in the serial transmission.
 */
/*@{*/
#define BP_UART_C4_M10       (5U)          /*!< Bit position for UART_C4_M10. */
#define BM_UART_C4_M10       (0x20U)       /*!< Bit mask for UART_C4_M10. */
#define BS_UART_C4_M10       (1U)          /*!< Bit field size in bits for UART_C4_M10. */

/*! @brief Read current value of the UART_C4_M10 field. */
#define BR_UART_C4_M10(x)    (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_M10))

/*! @brief Format value for bitfield UART_C4_M10. */
#define BF_UART_C4_M10(v)    ((uint8_t)((uint8_t)(v) << BP_UART_C4_M10) & BM_UART_C4_M10)

/*! @brief Set the M10 field to a new value. */
#define BW_UART_C4_M10(x, v) (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_M10) = (v))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN2[6] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN1 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA2 register. If no match occurs, the data is discarded. If a
 *     match occurs, data is transferred to the data buffer. This field must be
 *     cleared when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
#define BP_UART_C4_MAEN2     (6U)          /*!< Bit position for UART_C4_MAEN2. */
#define BM_UART_C4_MAEN2     (0x40U)       /*!< Bit mask for UART_C4_MAEN2. */
#define BS_UART_C4_MAEN2     (1U)          /*!< Bit field size in bits for UART_C4_MAEN2. */

/*! @brief Read current value of the UART_C4_MAEN2 field. */
#define BR_UART_C4_MAEN2(x)  (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN2))

/*! @brief Format value for bitfield UART_C4_MAEN2. */
#define BF_UART_C4_MAEN2(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C4_MAEN2) & BM_UART_C4_MAEN2)

/*! @brief Set the MAEN2 field to a new value. */
#define BW_UART_C4_MAEN2(x, v) (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN2) = (v))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN1[7] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN2 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA1 register. If no match occurs, the data is discarded. If match
 *     occurs, data is transferred to the data buffer. This field must be cleared
 *     when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
#define BP_UART_C4_MAEN1     (7U)          /*!< Bit position for UART_C4_MAEN1. */
#define BM_UART_C4_MAEN1     (0x80U)       /*!< Bit mask for UART_C4_MAEN1. */
#define BS_UART_C4_MAEN1     (1U)          /*!< Bit field size in bits for UART_C4_MAEN1. */

/*! @brief Read current value of the UART_C4_MAEN1 field. */
#define BR_UART_C4_MAEN1(x)  (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN1))

/*! @brief Format value for bitfield UART_C4_MAEN1. */
#define BF_UART_C4_MAEN1(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C4_MAEN1) & BM_UART_C4_MAEN1)

/*! @brief Set the MAEN1 field to a new value. */
#define BW_UART_C4_MAEN1(x, v) (BITBAND_ACCESS8(HW_UART_C4_ADDR(x), BP_UART_C4_MAEN1) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_C5 - UART Control Register 5
 ******************************************************************************/

/*!
 * @brief HW_UART_C5 - UART Control Register 5 (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_uart_c5
{
    uint8_t U;
    struct _hw_uart_c5_bitfields
    {
        uint8_t RESERVED0 : 3;         /*!< [2:0]  */
        uint8_t LBKDDMAS : 1;          /*!< [3] LIN Break Detect DMA Select Bit */
        uint8_t ILDMAS : 1;            /*!< [4] Idle Line DMA Select */
        uint8_t RDMAS : 1;             /*!< [5] Receiver Full DMA Select */
        uint8_t TCDMAS : 1;            /*!< [6] Transmission Complete DMA Select */
        uint8_t TDMAS : 1;             /*!< [7] Transmitter DMA Select */
    } B;
} hw_uart_c5_t;

/*!
 * @name Constants and macros for entire UART_C5 register
 */
/*@{*/
#define HW_UART_C5_ADDR(x)       ((uint32_t)(x) + 0xBU)

#define HW_UART_C5(x)            (*(__IO hw_uart_c5_t *) HW_UART_C5_ADDR(x))
#define HW_UART_C5_RD(x)         (HW_UART_C5(x).U)
#define HW_UART_C5_WR(x, v)      (HW_UART_C5(x).U = (v))
#define HW_UART_C5_SET(x, v)     (HW_UART_C5_WR(x, HW_UART_C5_RD(x) |  (v)))
#define HW_UART_C5_CLR(x, v)     (HW_UART_C5_WR(x, HW_UART_C5_RD(x) & ~(v)))
#define HW_UART_C5_TOG(x, v)     (HW_UART_C5_WR(x, HW_UART_C5_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C5 bitfields
 */

/*!
 * @name Register UART_C5, field LBKDDMAS[3] (RW)
 *
 * Configures the LIN break detect flag, S2[LBKDIF], to generate interrupt or
 * DMA requests if BDH[LBKDIE] is set. If BDH[LBKDIE] is cleared, and S2[LBKDIF] is
 * set, the LBKDIF DMA and LBKDIF interrupt signals are not asserted, regardless
 * of the state of LBKDDMAS.
 *
 * Values:
 * - 0 - If BDH[LBKDIE] and S2[LBKDIF] are set, the LBKDIF interrupt signal is
 *     asserted to request an interrupt service.
 * - 1 - If BDH[LBKDIE] and S2[LBKDIF] are set, the LBKDIF DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C5_LBKDDMAS  (3U)          /*!< Bit position for UART_C5_LBKDDMAS. */
#define BM_UART_C5_LBKDDMAS  (0x08U)       /*!< Bit mask for UART_C5_LBKDDMAS. */
#define BS_UART_C5_LBKDDMAS  (1U)          /*!< Bit field size in bits for UART_C5_LBKDDMAS. */

/*! @brief Read current value of the UART_C5_LBKDDMAS field. */
#define BR_UART_C5_LBKDDMAS(x) (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_LBKDDMAS))

/*! @brief Format value for bitfield UART_C5_LBKDDMAS. */
#define BF_UART_C5_LBKDDMAS(v) ((uint8_t)((uint8_t)(v) << BP_UART_C5_LBKDDMAS) & BM_UART_C5_LBKDDMAS)

/*! @brief Set the LBKDDMAS field to a new value. */
#define BW_UART_C5_LBKDDMAS(x, v) (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_LBKDDMAS) = (v))
/*@}*/

/*!
 * @name Register UART_C5, field ILDMAS[4] (RW)
 *
 * Configures the idle line flag, S1[IDLE], to generate interrupt or DMA
 * requests if C2[ILIE] is set. If C2[ILIE] is cleared, and S1[IDLE] is set, the IDLE
 * DMA and IDLE interrupt request signals are not asserted, regardless of the state
 * of ILDMAS.
 *
 * Values:
 * - 0 - If C2[ILIE] and S1[IDLE] are set, the IDLE interrupt request signal is
 *     asserted to request an interrupt service.
 * - 1 - If C2[ILIE] and S1[IDLE] are set, the IDLE DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C5_ILDMAS    (4U)          /*!< Bit position for UART_C5_ILDMAS. */
#define BM_UART_C5_ILDMAS    (0x10U)       /*!< Bit mask for UART_C5_ILDMAS. */
#define BS_UART_C5_ILDMAS    (1U)          /*!< Bit field size in bits for UART_C5_ILDMAS. */

/*! @brief Read current value of the UART_C5_ILDMAS field. */
#define BR_UART_C5_ILDMAS(x) (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_ILDMAS))

/*! @brief Format value for bitfield UART_C5_ILDMAS. */
#define BF_UART_C5_ILDMAS(v) ((uint8_t)((uint8_t)(v) << BP_UART_C5_ILDMAS) & BM_UART_C5_ILDMAS)

/*! @brief Set the ILDMAS field to a new value. */
#define BW_UART_C5_ILDMAS(x, v) (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_ILDMAS) = (v))
/*@}*/

/*!
 * @name Register UART_C5, field RDMAS[5] (RW)
 *
 * Configures the receiver data register full flag, S1[RDRF], to generate
 * interrupt or DMA requests if C2[RIE] is set. If C2[RIE] is cleared, and S1[RDRF] is
 * set, the RDRF DMA and RDFR interrupt request signals are not asserted,
 * regardless of the state of RDMAS.
 *
 * Values:
 * - 0 - If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is
 *     asserted to request an interrupt service.
 * - 1 - If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C5_RDMAS     (5U)          /*!< Bit position for UART_C5_RDMAS. */
#define BM_UART_C5_RDMAS     (0x20U)       /*!< Bit mask for UART_C5_RDMAS. */
#define BS_UART_C5_RDMAS     (1U)          /*!< Bit field size in bits for UART_C5_RDMAS. */

/*! @brief Read current value of the UART_C5_RDMAS field. */
#define BR_UART_C5_RDMAS(x)  (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_RDMAS))

/*! @brief Format value for bitfield UART_C5_RDMAS. */
#define BF_UART_C5_RDMAS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C5_RDMAS) & BM_UART_C5_RDMAS)

/*! @brief Set the RDMAS field to a new value. */
#define BW_UART_C5_RDMAS(x, v) (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_RDMAS) = (v))
/*@}*/

/*!
 * @name Register UART_C5, field TCDMAS[6] (RW)
 *
 * Configures the transmission complete flag, S1[TC], to generate interrupt or
 * DMA requests if C2[TCIE] is set. If C2[TCIE] is cleared, the TC DMA and TC
 * interrupt request signals are not asserted when the S1[TC] flag is set, regardless
 * of the state of TCDMAS. If C2[TCIE] and TCDMAS are both set, then C2[TIE]
 * must be cleared, and D must not be written unless a DMA request is being serviced.
 *
 * Values:
 * - 0 - If C2[TCIE] is set and the S1[TC] flag is set, the TC interrupt request
 *     signal is asserted to request an interrupt service.
 * - 1 - If C2[TCIE] is set and the S1[TC] flag is set, the TC DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C5_TCDMAS    (6U)          /*!< Bit position for UART_C5_TCDMAS. */
#define BM_UART_C5_TCDMAS    (0x40U)       /*!< Bit mask for UART_C5_TCDMAS. */
#define BS_UART_C5_TCDMAS    (1U)          /*!< Bit field size in bits for UART_C5_TCDMAS. */

/*! @brief Read current value of the UART_C5_TCDMAS field. */
#define BR_UART_C5_TCDMAS(x) (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_TCDMAS))

/*! @brief Format value for bitfield UART_C5_TCDMAS. */
#define BF_UART_C5_TCDMAS(v) ((uint8_t)((uint8_t)(v) << BP_UART_C5_TCDMAS) & BM_UART_C5_TCDMAS)

/*! @brief Set the TCDMAS field to a new value. */
#define BW_UART_C5_TCDMAS(x, v) (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_TCDMAS) = (v))
/*@}*/

/*!
 * @name Register UART_C5, field TDMAS[7] (RW)
 *
 * Configures the transmit data register empty flag, S1[TDRE], to generate
 * interrupt or DMA requests if C2[TIE] is set. If C2[TIE] is cleared, TDRE DMA and
 * TDRE interrupt request signals are not asserted when the TDRE flag is set,
 * regardless of the state of TDMAS. If C2[TIE] and TDMAS are both set, then C2[TCIE]
 * must be cleared, and D must not be written unless a DMA request is being
 * serviced.
 *
 * Values:
 * - 0 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt
 *     request signal is asserted to request interrupt service.
 * - 1 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
#define BP_UART_C5_TDMAS     (7U)          /*!< Bit position for UART_C5_TDMAS. */
#define BM_UART_C5_TDMAS     (0x80U)       /*!< Bit mask for UART_C5_TDMAS. */
#define BS_UART_C5_TDMAS     (1U)          /*!< Bit field size in bits for UART_C5_TDMAS. */

/*! @brief Read current value of the UART_C5_TDMAS field. */
#define BR_UART_C5_TDMAS(x)  (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_TDMAS))

/*! @brief Format value for bitfield UART_C5_TDMAS. */
#define BF_UART_C5_TDMAS(v)  ((uint8_t)((uint8_t)(v) << BP_UART_C5_TDMAS) & BM_UART_C5_TDMAS)

/*! @brief Set the TDMAS field to a new value. */
#define BW_UART_C5_TDMAS(x, v) (BITBAND_ACCESS8(HW_UART_C5_ADDR(x), BP_UART_C5_TDMAS) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_ED - UART Extended Data Register
 ******************************************************************************/

/*!
 * @brief HW_UART_ED - UART Extended Data Register (RO)
 *
 * Reset value: 0x00U
 *
 * This register contains additional information flags that are stored with a
 * received dataword. This register may be read at any time but contains valid data
 * only if there is a dataword in the receive FIFO. The data contained in this
 * register represents additional information regarding the conditions on which a
 * dataword was received. The importance of this data varies with the
 * application, and in some cases maybe completely optional. These fields automatically
 * update to reflect the conditions of the next dataword whenever D is read. If
 * S1[NF] and S1[PF] have not been set since the last time the receive buffer was
 * empty, the NOISY and PARITYE fields will be zero.
 */
typedef union _hw_uart_ed
{
    uint8_t U;
    struct _hw_uart_ed_bitfields
    {
        uint8_t RESERVED0 : 6;         /*!< [5:0]  */
        uint8_t PARITYE : 1;           /*!< [6]  */
        uint8_t NOISY : 1;             /*!< [7]  */
    } B;
} hw_uart_ed_t;

/*!
 * @name Constants and macros for entire UART_ED register
 */
/*@{*/
#define HW_UART_ED_ADDR(x)       ((uint32_t)(x) + 0xCU)

#define HW_UART_ED(x)            (*(__I hw_uart_ed_t *) HW_UART_ED_ADDR(x))
#define HW_UART_ED_RD(x)         (HW_UART_ED(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_ED bitfields
 */

/*!
 * @name Register UART_ED, field PARITYE[6] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with a
 * parity error.
 *
 * Values:
 * - 0 - The dataword was received without a parity error.
 * - 1 - The dataword was received with a parity error.
 */
/*@{*/
#define BP_UART_ED_PARITYE   (6U)          /*!< Bit position for UART_ED_PARITYE. */
#define BM_UART_ED_PARITYE   (0x40U)       /*!< Bit mask for UART_ED_PARITYE. */
#define BS_UART_ED_PARITYE   (1U)          /*!< Bit field size in bits for UART_ED_PARITYE. */

/*! @brief Read current value of the UART_ED_PARITYE field. */
#define BR_UART_ED_PARITYE(x) (BITBAND_ACCESS8(HW_UART_ED_ADDR(x), BP_UART_ED_PARITYE))
/*@}*/

/*!
 * @name Register UART_ED, field NOISY[7] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with
 * noise.
 *
 * Values:
 * - 0 - The dataword was received without noise.
 * - 1 - The data was received with noise.
 */
/*@{*/
#define BP_UART_ED_NOISY     (7U)          /*!< Bit position for UART_ED_NOISY. */
#define BM_UART_ED_NOISY     (0x80U)       /*!< Bit mask for UART_ED_NOISY. */
#define BS_UART_ED_NOISY     (1U)          /*!< Bit field size in bits for UART_ED_NOISY. */

/*! @brief Read current value of the UART_ED_NOISY field. */
#define BR_UART_ED_NOISY(x)  (BITBAND_ACCESS8(HW_UART_ED_ADDR(x), BP_UART_ED_NOISY))
/*@}*/

/*******************************************************************************
 * HW_UART_MODEM - UART Modem Register
 ******************************************************************************/

/*!
 * @brief HW_UART_MODEM - UART Modem Register (RW)
 *
 * Reset value: 0x00U
 *
 * The MODEM register controls options for setting the modem configuration.
 * RXRTSE, TXRTSPOL, TXRTSE, and TXCTSE must all be cleared when C7816[ISO7816EN] is
 * enabled. This will cause the RTS to deassert during ISO-7816 wait times. The
 * ISO-7816 protocol does not use the RTS and CTS signals.
 */
typedef union _hw_uart_modem
{
    uint8_t U;
    struct _hw_uart_modem_bitfields
    {
        uint8_t TXCTSE : 1;            /*!< [0] Transmitter clear-to-send enable */
        uint8_t TXRTSE : 1;            /*!< [1] Transmitter request-to-send enable */
        uint8_t TXRTSPOL : 1;          /*!< [2] Transmitter request-to-send polarity */
        uint8_t RXRTSE : 1;            /*!< [3] Receiver request-to-send enable */
        uint8_t RESERVED0 : 4;         /*!< [7:4]  */
    } B;
} hw_uart_modem_t;

/*!
 * @name Constants and macros for entire UART_MODEM register
 */
/*@{*/
#define HW_UART_MODEM_ADDR(x)    ((uint32_t)(x) + 0xDU)

#define HW_UART_MODEM(x)         (*(__IO hw_uart_modem_t *) HW_UART_MODEM_ADDR(x))
#define HW_UART_MODEM_RD(x)      (HW_UART_MODEM(x).U)
#define HW_UART_MODEM_WR(x, v)   (HW_UART_MODEM(x).U = (v))
#define HW_UART_MODEM_SET(x, v)  (HW_UART_MODEM_WR(x, HW_UART_MODEM_RD(x) |  (v)))
#define HW_UART_MODEM_CLR(x, v)  (HW_UART_MODEM_WR(x, HW_UART_MODEM_RD(x) & ~(v)))
#define HW_UART_MODEM_TOG(x, v)  (HW_UART_MODEM_WR(x, HW_UART_MODEM_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_MODEM bitfields
 */

/*!
 * @name Register UART_MODEM, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0 - CTS has no effect on the transmitter.
 * - 1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as a
 *     character is being sent do not affect its transmission.
 */
/*@{*/
#define BP_UART_MODEM_TXCTSE (0U)          /*!< Bit position for UART_MODEM_TXCTSE. */
#define BM_UART_MODEM_TXCTSE (0x01U)       /*!< Bit mask for UART_MODEM_TXCTSE. */
#define BS_UART_MODEM_TXCTSE (1U)          /*!< Bit field size in bits for UART_MODEM_TXCTSE. */

/*! @brief Read current value of the UART_MODEM_TXCTSE field. */
#define BR_UART_MODEM_TXCTSE(x) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXCTSE))

/*! @brief Format value for bitfield UART_MODEM_TXCTSE. */
#define BF_UART_MODEM_TXCTSE(v) ((uint8_t)((uint8_t)(v) << BP_UART_MODEM_TXCTSE) & BM_UART_MODEM_TXCTSE)

/*! @brief Set the TXCTSE field to a new value. */
#define BW_UART_MODEM_TXCTSE(x, v) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXCTSE) = (v))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0 - The transmitter has no effect on RTS.
 * - 1 - When a character is placed into an empty transmitter data buffer , RTS
 *     asserts one bit time before the start bit is transmitted. RTS deasserts
 *     one bit time after all characters in the transmitter data buffer and shift
 *     register are completely sent, including the last stop bit. (FIFO) (FIFO)
 */
/*@{*/
#define BP_UART_MODEM_TXRTSE (1U)          /*!< Bit position for UART_MODEM_TXRTSE. */
#define BM_UART_MODEM_TXRTSE (0x02U)       /*!< Bit mask for UART_MODEM_TXRTSE. */
#define BS_UART_MODEM_TXRTSE (1U)          /*!< Bit field size in bits for UART_MODEM_TXRTSE. */

/*! @brief Read current value of the UART_MODEM_TXRTSE field. */
#define BR_UART_MODEM_TXRTSE(x) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXRTSE))

/*! @brief Format value for bitfield UART_MODEM_TXRTSE. */
#define BF_UART_MODEM_TXRTSE(v) ((uint8_t)((uint8_t)(v) << BP_UART_MODEM_TXRTSE) & BM_UART_MODEM_TXRTSE)

/*! @brief Set the TXRTSE field to a new value. */
#define BW_UART_MODEM_TXRTSE(x, v) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXRTSE) = (v))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0 - Transmitter RTS is active low.
 * - 1 - Transmitter RTS is active high.
 */
/*@{*/
#define BP_UART_MODEM_TXRTSPOL (2U)        /*!< Bit position for UART_MODEM_TXRTSPOL. */
#define BM_UART_MODEM_TXRTSPOL (0x04U)     /*!< Bit mask for UART_MODEM_TXRTSPOL. */
#define BS_UART_MODEM_TXRTSPOL (1U)        /*!< Bit field size in bits for UART_MODEM_TXRTSPOL. */

/*! @brief Read current value of the UART_MODEM_TXRTSPOL field. */
#define BR_UART_MODEM_TXRTSPOL(x) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXRTSPOL))

/*! @brief Format value for bitfield UART_MODEM_TXRTSPOL. */
#define BF_UART_MODEM_TXRTSPOL(v) ((uint8_t)((uint8_t)(v) << BP_UART_MODEM_TXRTSPOL) & BM_UART_MODEM_TXRTSPOL)

/*! @brief Set the TXRTSPOL field to a new value. */
#define BW_UART_MODEM_TXRTSPOL(x, v) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_TXRTSPOL) = (v))
/*@}*/

/*!
 * @name Register UART_MODEM, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0 - The receiver has no effect on RTS.
 * - 1 - RTS is deasserted if the number of characters in the receiver data
 *     register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted
 *     when the number of characters in the receiver data register (FIFO) is less
 *     than RWFIFO[RXWATER].
 */
/*@{*/
#define BP_UART_MODEM_RXRTSE (3U)          /*!< Bit position for UART_MODEM_RXRTSE. */
#define BM_UART_MODEM_RXRTSE (0x08U)       /*!< Bit mask for UART_MODEM_RXRTSE. */
#define BS_UART_MODEM_RXRTSE (1U)          /*!< Bit field size in bits for UART_MODEM_RXRTSE. */

/*! @brief Read current value of the UART_MODEM_RXRTSE field. */
#define BR_UART_MODEM_RXRTSE(x) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_RXRTSE))

/*! @brief Format value for bitfield UART_MODEM_RXRTSE. */
#define BF_UART_MODEM_RXRTSE(v) ((uint8_t)((uint8_t)(v) << BP_UART_MODEM_RXRTSE) & BM_UART_MODEM_RXRTSE)

/*! @brief Set the RXRTSE field to a new value. */
#define BW_UART_MODEM_RXRTSE(x, v) (BITBAND_ACCESS8(HW_UART_MODEM_ADDR(x), BP_UART_MODEM_RXRTSE) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_IR - UART Infrared Register
 ******************************************************************************/

/*!
 * @brief HW_UART_IR - UART Infrared Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IR register controls options for setting the infrared configuration.
 */
typedef union _hw_uart_ir
{
    uint8_t U;
    struct _hw_uart_ir_bitfields
    {
        uint8_t TNP : 2;               /*!< [1:0] Transmitter narrow pulse */
        uint8_t IREN : 1;              /*!< [2] Infrared enable */
        uint8_t RESERVED0 : 5;         /*!< [7:3]  */
    } B;
} hw_uart_ir_t;

/*!
 * @name Constants and macros for entire UART_IR register
 */
/*@{*/
#define HW_UART_IR_ADDR(x)       ((uint32_t)(x) + 0xEU)

#define HW_UART_IR(x)            (*(__IO hw_uart_ir_t *) HW_UART_IR_ADDR(x))
#define HW_UART_IR_RD(x)         (HW_UART_IR(x).U)
#define HW_UART_IR_WR(x, v)      (HW_UART_IR(x).U = (v))
#define HW_UART_IR_SET(x, v)     (HW_UART_IR_WR(x, HW_UART_IR_RD(x) |  (v)))
#define HW_UART_IR_CLR(x, v)     (HW_UART_IR_WR(x, HW_UART_IR_RD(x) & ~(v)))
#define HW_UART_IR_TOG(x, v)     (HW_UART_IR_WR(x, HW_UART_IR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_IR bitfields
 */

/*!
 * @name Register UART_IR, field TNP[1:0] (RW)
 *
 * Enables whether the UART transmits a 1/16, 3/16, 1/32, or 1/4 narrow pulse.
 *
 * Values:
 * - 00 - 3/16.
 * - 01 - 1/16.
 * - 10 - 1/32.
 * - 11 - 1/4.
 */
/*@{*/
#define BP_UART_IR_TNP       (0U)          /*!< Bit position for UART_IR_TNP. */
#define BM_UART_IR_TNP       (0x03U)       /*!< Bit mask for UART_IR_TNP. */
#define BS_UART_IR_TNP       (2U)          /*!< Bit field size in bits for UART_IR_TNP. */

/*! @brief Read current value of the UART_IR_TNP field. */
#define BR_UART_IR_TNP(x)    (HW_UART_IR(x).B.TNP)

/*! @brief Format value for bitfield UART_IR_TNP. */
#define BF_UART_IR_TNP(v)    ((uint8_t)((uint8_t)(v) << BP_UART_IR_TNP) & BM_UART_IR_TNP)

/*! @brief Set the TNP field to a new value. */
#define BW_UART_IR_TNP(x, v) (HW_UART_IR_WR(x, (HW_UART_IR_RD(x) & ~BM_UART_IR_TNP) | BF_UART_IR_TNP(v)))
/*@}*/

/*!
 * @name Register UART_IR, field IREN[2] (RW)
 *
 * Enables/disables the infrared modulation/demodulation.
 *
 * Values:
 * - 0 - IR disabled.
 * - 1 - IR enabled.
 */
/*@{*/
#define BP_UART_IR_IREN      (2U)          /*!< Bit position for UART_IR_IREN. */
#define BM_UART_IR_IREN      (0x04U)       /*!< Bit mask for UART_IR_IREN. */
#define BS_UART_IR_IREN      (1U)          /*!< Bit field size in bits for UART_IR_IREN. */

/*! @brief Read current value of the UART_IR_IREN field. */
#define BR_UART_IR_IREN(x)   (BITBAND_ACCESS8(HW_UART_IR_ADDR(x), BP_UART_IR_IREN))

/*! @brief Format value for bitfield UART_IR_IREN. */
#define BF_UART_IR_IREN(v)   ((uint8_t)((uint8_t)(v) << BP_UART_IR_IREN) & BM_UART_IR_IREN)

/*! @brief Set the IREN field to a new value. */
#define BW_UART_IR_IREN(x, v) (BITBAND_ACCESS8(HW_UART_IR_ADDR(x), BP_UART_IR_IREN) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_PFIFO - UART FIFO Parameters
 ******************************************************************************/

/*!
 * @brief HW_UART_PFIFO - UART FIFO Parameters (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability for the programmer to turn on and off FIFO
 * functionality. It also provides the size of the FIFO that has been
 * implemented. This register may be read at any time. This register must be written only
 * when C2[RE] and C2[TE] are cleared/not set and when the data buffer/FIFO is
 * empty.
 */
typedef union _hw_uart_pfifo
{
    uint8_t U;
    struct _hw_uart_pfifo_bitfields
    {
        uint8_t RXFIFOSIZE : 3;        /*!< [2:0] Receive FIFO. Buffer Depth */
        uint8_t RXFE : 1;              /*!< [3] Receive FIFO Enable */
        uint8_t TXFIFOSIZE : 3;        /*!< [6:4] Transmit FIFO. Buffer Depth */
        uint8_t TXFE : 1;              /*!< [7] Transmit FIFO Enable */
    } B;
} hw_uart_pfifo_t;

/*!
 * @name Constants and macros for entire UART_PFIFO register
 */
/*@{*/
#define HW_UART_PFIFO_ADDR(x)    ((uint32_t)(x) + 0x10U)

#define HW_UART_PFIFO(x)         (*(__IO hw_uart_pfifo_t *) HW_UART_PFIFO_ADDR(x))
#define HW_UART_PFIFO_RD(x)      (HW_UART_PFIFO(x).U)
#define HW_UART_PFIFO_WR(x, v)   (HW_UART_PFIFO(x).U = (v))
#define HW_UART_PFIFO_SET(x, v)  (HW_UART_PFIFO_WR(x, HW_UART_PFIFO_RD(x) |  (v)))
#define HW_UART_PFIFO_CLR(x, v)  (HW_UART_PFIFO_WR(x, HW_UART_PFIFO_RD(x) & ~(v)))
#define HW_UART_PFIFO_TOG(x, v)  (HW_UART_PFIFO_WR(x, HW_UART_PFIFO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_PFIFO bitfields
 */

/*!
 * @name Register UART_PFIFO, field RXFIFOSIZE[2:0] (RO)
 *
 * The maximum number of receive datawords that can be stored in the receive
 * buffer before an overrun occurs. This field is read only.
 *
 * Values:
 * - 000 - Receive FIFO/Buffer depth = 1 dataword.
 * - 001 - Receive FIFO/Buffer depth = 4 datawords.
 * - 010 - Receive FIFO/Buffer depth = 8 datawords.
 * - 011 - Receive FIFO/Buffer depth = 16 datawords.
 * - 100 - Receive FIFO/Buffer depth = 32 datawords.
 * - 101 - Receive FIFO/Buffer depth = 64 datawords.
 * - 110 - Receive FIFO/Buffer depth = 128 datawords.
 * - 111 - Reserved.
 */
/*@{*/
#define BP_UART_PFIFO_RXFIFOSIZE (0U)      /*!< Bit position for UART_PFIFO_RXFIFOSIZE. */
#define BM_UART_PFIFO_RXFIFOSIZE (0x07U)   /*!< Bit mask for UART_PFIFO_RXFIFOSIZE. */
#define BS_UART_PFIFO_RXFIFOSIZE (3U)      /*!< Bit field size in bits for UART_PFIFO_RXFIFOSIZE. */

/*! @brief Read current value of the UART_PFIFO_RXFIFOSIZE field. */
#define BR_UART_PFIFO_RXFIFOSIZE(x) (HW_UART_PFIFO(x).B.RXFIFOSIZE)
/*@}*/

/*!
 * @name Register UART_PFIFO, field RXFE[3] (RW)
 *
 * When this field is set, the built in FIFO structure for the receive buffer is
 * enabled. The size of the FIFO structure is indicated by the RXFIFOSIZE field.
 * If this field is not set, the receive buffer operates as a FIFO of depth one
 * dataword regardless of the value in RXFIFOSIZE. Both C2[TE] and C2[RE] must be
 * cleared prior to changing this field. Additionally, TXFLUSH and RXFLUSH
 * commands must be issued immediately after changing this field.
 *
 * Values:
 * - 0 - Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
 * - 1 - Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
 */
/*@{*/
#define BP_UART_PFIFO_RXFE   (3U)          /*!< Bit position for UART_PFIFO_RXFE. */
#define BM_UART_PFIFO_RXFE   (0x08U)       /*!< Bit mask for UART_PFIFO_RXFE. */
#define BS_UART_PFIFO_RXFE   (1U)          /*!< Bit field size in bits for UART_PFIFO_RXFE. */

/*! @brief Read current value of the UART_PFIFO_RXFE field. */
#define BR_UART_PFIFO_RXFE(x) (BITBAND_ACCESS8(HW_UART_PFIFO_ADDR(x), BP_UART_PFIFO_RXFE))

/*! @brief Format value for bitfield UART_PFIFO_RXFE. */
#define BF_UART_PFIFO_RXFE(v) ((uint8_t)((uint8_t)(v) << BP_UART_PFIFO_RXFE) & BM_UART_PFIFO_RXFE)

/*! @brief Set the RXFE field to a new value. */
#define BW_UART_PFIFO_RXFE(x, v) (BITBAND_ACCESS8(HW_UART_PFIFO_ADDR(x), BP_UART_PFIFO_RXFE) = (v))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFIFOSIZE[6:4] (RO)
 *
 * The maximum number of transmit datawords that can be stored in the transmit
 * buffer. This field is read only.
 *
 * Values:
 * - 000 - Transmit FIFO/Buffer depth = 1 dataword.
 * - 001 - Transmit FIFO/Buffer depth = 4 datawords.
 * - 010 - Transmit FIFO/Buffer depth = 8 datawords.
 * - 011 - Transmit FIFO/Buffer depth = 16 datawords.
 * - 100 - Transmit FIFO/Buffer depth = 32 datawords.
 * - 101 - Transmit FIFO/Buffer depth = 64 datawords.
 * - 110 - Transmit FIFO/Buffer depth = 128 datawords.
 * - 111 - Reserved.
 */
/*@{*/
#define BP_UART_PFIFO_TXFIFOSIZE (4U)      /*!< Bit position for UART_PFIFO_TXFIFOSIZE. */
#define BM_UART_PFIFO_TXFIFOSIZE (0x70U)   /*!< Bit mask for UART_PFIFO_TXFIFOSIZE. */
#define BS_UART_PFIFO_TXFIFOSIZE (3U)      /*!< Bit field size in bits for UART_PFIFO_TXFIFOSIZE. */

/*! @brief Read current value of the UART_PFIFO_TXFIFOSIZE field. */
#define BR_UART_PFIFO_TXFIFOSIZE(x) (HW_UART_PFIFO(x).B.TXFIFOSIZE)
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFE[7] (RW)
 *
 * When this field is set, the built in FIFO structure for the transmit buffer
 * is enabled. The size of the FIFO structure is indicated by TXFIFOSIZE. If this
 * field is not set, the transmit buffer operates as a FIFO of depth one dataword
 * regardless of the value in TXFIFOSIZE. Both C2[TE] and C2[RE] must be cleared
 * prior to changing this field. Additionally, TXFLUSH and RXFLUSH commands must
 * be issued immediately after changing this field.
 *
 * Values:
 * - 0 - Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
 * - 1 - Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
 */
/*@{*/
#define BP_UART_PFIFO_TXFE   (7U)          /*!< Bit position for UART_PFIFO_TXFE. */
#define BM_UART_PFIFO_TXFE   (0x80U)       /*!< Bit mask for UART_PFIFO_TXFE. */
#define BS_UART_PFIFO_TXFE   (1U)          /*!< Bit field size in bits for UART_PFIFO_TXFE. */

/*! @brief Read current value of the UART_PFIFO_TXFE field. */
#define BR_UART_PFIFO_TXFE(x) (BITBAND_ACCESS8(HW_UART_PFIFO_ADDR(x), BP_UART_PFIFO_TXFE))

/*! @brief Format value for bitfield UART_PFIFO_TXFE. */
#define BF_UART_PFIFO_TXFE(v) ((uint8_t)((uint8_t)(v) << BP_UART_PFIFO_TXFE) & BM_UART_PFIFO_TXFE)

/*! @brief Set the TXFE field to a new value. */
#define BW_UART_PFIFO_TXFE(x, v) (BITBAND_ACCESS8(HW_UART_PFIFO_ADDR(x), BP_UART_PFIFO_TXFE) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_CFIFO - UART FIFO Control Register
 ******************************************************************************/

/*!
 * @brief HW_UART_CFIFO - UART FIFO Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to program various control fields for FIFO
 * operation. This register may be read or written at any time. Note that
 * writing to TXFLUSH and RXFLUSH may result in data loss and requires careful action
 * to prevent unintended/unpredictable behavior. Therefore, it is recommended that
 * TE and RE be cleared prior to flushing the corresponding FIFO.
 */
typedef union _hw_uart_cfifo
{
    uint8_t U;
    struct _hw_uart_cfifo_bitfields
    {
        uint8_t RXUFE : 1;             /*!< [0] Receive FIFO Underflow Interrupt Enable */
        uint8_t TXOFE : 1;             /*!< [1] Transmit FIFO Overflow Interrupt Enable */
        uint8_t RXOFE : 1;             /*!< [2] Receive FIFO Overflow Interrupt Enable */
        uint8_t RESERVED0 : 3;         /*!< [5:3]  */
        uint8_t RXFLUSH : 1;           /*!< [6] Receive FIFO/Buffer Flush */
        uint8_t TXFLUSH : 1;           /*!< [7] Transmit FIFO/Buffer Flush */
    } B;
} hw_uart_cfifo_t;

/*!
 * @name Constants and macros for entire UART_CFIFO register
 */
/*@{*/
#define HW_UART_CFIFO_ADDR(x)    ((uint32_t)(x) + 0x11U)

#define HW_UART_CFIFO(x)         (*(__IO hw_uart_cfifo_t *) HW_UART_CFIFO_ADDR(x))
#define HW_UART_CFIFO_RD(x)      (HW_UART_CFIFO(x).U)
#define HW_UART_CFIFO_WR(x, v)   (HW_UART_CFIFO(x).U = (v))
#define HW_UART_CFIFO_SET(x, v)  (HW_UART_CFIFO_WR(x, HW_UART_CFIFO_RD(x) |  (v)))
#define HW_UART_CFIFO_CLR(x, v)  (HW_UART_CFIFO_WR(x, HW_UART_CFIFO_RD(x) & ~(v)))
#define HW_UART_CFIFO_TOG(x, v)  (HW_UART_CFIFO_WR(x, HW_UART_CFIFO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_CFIFO bitfields
 */

/*!
 * @name Register UART_CFIFO, field RXUFE[0] (RW)
 *
 * When this field is set, the RXUF flag generates an interrupt to the host.
 *
 * Values:
 * - 0 - RXUF flag does not generate an interrupt to the host.
 * - 1 - RXUF flag generates an interrupt to the host.
 */
/*@{*/
#define BP_UART_CFIFO_RXUFE  (0U)          /*!< Bit position for UART_CFIFO_RXUFE. */
#define BM_UART_CFIFO_RXUFE  (0x01U)       /*!< Bit mask for UART_CFIFO_RXUFE. */
#define BS_UART_CFIFO_RXUFE  (1U)          /*!< Bit field size in bits for UART_CFIFO_RXUFE. */

/*! @brief Read current value of the UART_CFIFO_RXUFE field. */
#define BR_UART_CFIFO_RXUFE(x) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_RXUFE))

/*! @brief Format value for bitfield UART_CFIFO_RXUFE. */
#define BF_UART_CFIFO_RXUFE(v) ((uint8_t)((uint8_t)(v) << BP_UART_CFIFO_RXUFE) & BM_UART_CFIFO_RXUFE)

/*! @brief Set the RXUFE field to a new value. */
#define BW_UART_CFIFO_RXUFE(x, v) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_RXUFE) = (v))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXOFE[1] (RW)
 *
 * When this field is set, the TXOF flag generates an interrupt to the host.
 *
 * Values:
 * - 0 - TXOF flag does not generate an interrupt to the host.
 * - 1 - TXOF flag generates an interrupt to the host.
 */
/*@{*/
#define BP_UART_CFIFO_TXOFE  (1U)          /*!< Bit position for UART_CFIFO_TXOFE. */
#define BM_UART_CFIFO_TXOFE  (0x02U)       /*!< Bit mask for UART_CFIFO_TXOFE. */
#define BS_UART_CFIFO_TXOFE  (1U)          /*!< Bit field size in bits for UART_CFIFO_TXOFE. */

/*! @brief Read current value of the UART_CFIFO_TXOFE field. */
#define BR_UART_CFIFO_TXOFE(x) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_TXOFE))

/*! @brief Format value for bitfield UART_CFIFO_TXOFE. */
#define BF_UART_CFIFO_TXOFE(v) ((uint8_t)((uint8_t)(v) << BP_UART_CFIFO_TXOFE) & BM_UART_CFIFO_TXOFE)

/*! @brief Set the TXOFE field to a new value. */
#define BW_UART_CFIFO_TXOFE(x, v) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_TXOFE) = (v))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXOFE[2] (RW)
 *
 * When this field is set, the RXOF flag generates an interrupt to the host.
 *
 * Values:
 * - 0 - RXOF flag does not generate an interrupt to the host.
 * - 1 - RXOF flag generates an interrupt to the host.
 */
/*@{*/
#define BP_UART_CFIFO_RXOFE  (2U)          /*!< Bit position for UART_CFIFO_RXOFE. */
#define BM_UART_CFIFO_RXOFE  (0x04U)       /*!< Bit mask for UART_CFIFO_RXOFE. */
#define BS_UART_CFIFO_RXOFE  (1U)          /*!< Bit field size in bits for UART_CFIFO_RXOFE. */

/*! @brief Read current value of the UART_CFIFO_RXOFE field. */
#define BR_UART_CFIFO_RXOFE(x) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_RXOFE))

/*! @brief Format value for bitfield UART_CFIFO_RXOFE. */
#define BF_UART_CFIFO_RXOFE(v) ((uint8_t)((uint8_t)(v) << BP_UART_CFIFO_RXOFE) & BM_UART_CFIFO_RXOFE)

/*! @brief Set the RXOFE field to a new value. */
#define BW_UART_CFIFO_RXOFE(x, v) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_RXOFE) = (v))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXFLUSH[6] (WORZ)
 *
 * Writing to this field causes all data that is stored in the receive
 * FIFO/buffer to be flushed. This does not affect data that is in the receive shift
 * register.
 *
 * Values:
 * - 0 - No flush operation occurs.
 * - 1 - All data in the receive FIFO/buffer is cleared out.
 */
/*@{*/
#define BP_UART_CFIFO_RXFLUSH (6U)         /*!< Bit position for UART_CFIFO_RXFLUSH. */
#define BM_UART_CFIFO_RXFLUSH (0x40U)      /*!< Bit mask for UART_CFIFO_RXFLUSH. */
#define BS_UART_CFIFO_RXFLUSH (1U)         /*!< Bit field size in bits for UART_CFIFO_RXFLUSH. */

/*! @brief Format value for bitfield UART_CFIFO_RXFLUSH. */
#define BF_UART_CFIFO_RXFLUSH(v) ((uint8_t)((uint8_t)(v) << BP_UART_CFIFO_RXFLUSH) & BM_UART_CFIFO_RXFLUSH)

/*! @brief Set the RXFLUSH field to a new value. */
#define BW_UART_CFIFO_RXFLUSH(x, v) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_RXFLUSH) = (v))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXFLUSH[7] (WORZ)
 *
 * Writing to this field causes all data that is stored in the transmit
 * FIFO/buffer to be flushed. This does not affect data that is in the transmit shift
 * register.
 *
 * Values:
 * - 0 - No flush operation occurs.
 * - 1 - All data in the transmit FIFO/Buffer is cleared out.
 */
/*@{*/
#define BP_UART_CFIFO_TXFLUSH (7U)         /*!< Bit position for UART_CFIFO_TXFLUSH. */
#define BM_UART_CFIFO_TXFLUSH (0x80U)      /*!< Bit mask for UART_CFIFO_TXFLUSH. */
#define BS_UART_CFIFO_TXFLUSH (1U)         /*!< Bit field size in bits for UART_CFIFO_TXFLUSH. */

/*! @brief Format value for bitfield UART_CFIFO_TXFLUSH. */
#define BF_UART_CFIFO_TXFLUSH(v) ((uint8_t)((uint8_t)(v) << BP_UART_CFIFO_TXFLUSH) & BM_UART_CFIFO_TXFLUSH)

/*! @brief Set the TXFLUSH field to a new value. */
#define BW_UART_CFIFO_TXFLUSH(x, v) (BITBAND_ACCESS8(HW_UART_CFIFO_ADDR(x), BP_UART_CFIFO_TXFLUSH) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_SFIFO - UART FIFO Status Register
 ******************************************************************************/

/*!
 * @brief HW_UART_SFIFO - UART FIFO Status Register (RW)
 *
 * Reset value: 0xC0U
 *
 * This register provides status information regarding the transmit and receiver
 * buffers/FIFOs, including interrupt information. This register may be written
 * to or read at any time.
 */
typedef union _hw_uart_sfifo
{
    uint8_t U;
    struct _hw_uart_sfifo_bitfields
    {
        uint8_t RXUF : 1;              /*!< [0] Receiver Buffer Underflow Flag */
        uint8_t TXOF : 1;              /*!< [1] Transmitter Buffer Overflow Flag */
        uint8_t RXOF : 1;              /*!< [2] Receiver Buffer Overflow Flag */
        uint8_t RESERVED0 : 3;         /*!< [5:3]  */
        uint8_t RXEMPT : 1;            /*!< [6] Receive Buffer/FIFO Empty */
        uint8_t TXEMPT : 1;            /*!< [7] Transmit Buffer/FIFO Empty */
    } B;
} hw_uart_sfifo_t;

/*!
 * @name Constants and macros for entire UART_SFIFO register
 */
/*@{*/
#define HW_UART_SFIFO_ADDR(x)    ((uint32_t)(x) + 0x12U)

#define HW_UART_SFIFO(x)         (*(__IO hw_uart_sfifo_t *) HW_UART_SFIFO_ADDR(x))
#define HW_UART_SFIFO_RD(x)      (HW_UART_SFIFO(x).U)
#define HW_UART_SFIFO_WR(x, v)   (HW_UART_SFIFO(x).U = (v))
#define HW_UART_SFIFO_SET(x, v)  (HW_UART_SFIFO_WR(x, HW_UART_SFIFO_RD(x) |  (v)))
#define HW_UART_SFIFO_CLR(x, v)  (HW_UART_SFIFO_WR(x, HW_UART_SFIFO_RD(x) & ~(v)))
#define HW_UART_SFIFO_TOG(x, v)  (HW_UART_SFIFO_WR(x, HW_UART_SFIFO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_SFIFO bitfields
 */

/*!
 * @name Register UART_SFIFO, field RXUF[0] (W1C)
 *
 * Indicates that more data has been read from the receive buffer than was
 * present. This field will assert regardless of the value of CFIFO[RXUFE]. However,
 * an interrupt will be issued to the host only if CFIFO[RXUFE] is set. This flag
 * is cleared by writing a 1.
 *
 * Values:
 * - 0 - No receive buffer underflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one receive buffer underflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
#define BP_UART_SFIFO_RXUF   (0U)          /*!< Bit position for UART_SFIFO_RXUF. */
#define BM_UART_SFIFO_RXUF   (0x01U)       /*!< Bit mask for UART_SFIFO_RXUF. */
#define BS_UART_SFIFO_RXUF   (1U)          /*!< Bit field size in bits for UART_SFIFO_RXUF. */

/*! @brief Read current value of the UART_SFIFO_RXUF field. */
#define BR_UART_SFIFO_RXUF(x) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_RXUF))

/*! @brief Format value for bitfield UART_SFIFO_RXUF. */
#define BF_UART_SFIFO_RXUF(v) ((uint8_t)((uint8_t)(v) << BP_UART_SFIFO_RXUF) & BM_UART_SFIFO_RXUF)

/*! @brief Set the RXUF field to a new value. */
#define BW_UART_SFIFO_RXUF(x, v) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_RXUF) = (v))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXOF[1] (W1C)
 *
 * Indicates that more data has been written to the transmit buffer than it can
 * hold. This field will assert regardless of the value of CFIFO[TXOFE]. However,
 * an interrupt will be issued to the host only if CFIFO[TXOFE] is set. This
 * flag is cleared by writing a 1.
 *
 * Values:
 * - 0 - No transmit buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one transmit buffer overflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
#define BP_UART_SFIFO_TXOF   (1U)          /*!< Bit position for UART_SFIFO_TXOF. */
#define BM_UART_SFIFO_TXOF   (0x02U)       /*!< Bit mask for UART_SFIFO_TXOF. */
#define BS_UART_SFIFO_TXOF   (1U)          /*!< Bit field size in bits for UART_SFIFO_TXOF. */

/*! @brief Read current value of the UART_SFIFO_TXOF field. */
#define BR_UART_SFIFO_TXOF(x) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_TXOF))

/*! @brief Format value for bitfield UART_SFIFO_TXOF. */
#define BF_UART_SFIFO_TXOF(v) ((uint8_t)((uint8_t)(v) << BP_UART_SFIFO_TXOF) & BM_UART_SFIFO_TXOF)

/*! @brief Set the TXOF field to a new value. */
#define BW_UART_SFIFO_TXOF(x, v) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_TXOF) = (v))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXOF[2] (W1C)
 *
 * Indicates that more data has been written to the receive buffer than it can
 * hold. This field will assert regardless of the value of CFIFO[RXOFE]. However,
 * an interrupt will be issued to the host only if CFIFO[RXOFE] is set. This flag
 * is cleared by writing a 1.
 *
 * Values:
 * - 0 - No receive buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one receive buffer overflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
#define BP_UART_SFIFO_RXOF   (2U)          /*!< Bit position for UART_SFIFO_RXOF. */
#define BM_UART_SFIFO_RXOF   (0x04U)       /*!< Bit mask for UART_SFIFO_RXOF. */
#define BS_UART_SFIFO_RXOF   (1U)          /*!< Bit field size in bits for UART_SFIFO_RXOF. */

/*! @brief Read current value of the UART_SFIFO_RXOF field. */
#define BR_UART_SFIFO_RXOF(x) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_RXOF))

/*! @brief Format value for bitfield UART_SFIFO_RXOF. */
#define BF_UART_SFIFO_RXOF(v) ((uint8_t)((uint8_t)(v) << BP_UART_SFIFO_RXOF) & BM_UART_SFIFO_RXOF)

/*! @brief Set the RXOF field to a new value. */
#define BW_UART_SFIFO_RXOF(x, v) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_RXOF) = (v))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXEMPT[6] (RO)
 *
 * Asserts when there is no data in the receive FIFO/Buffer. This field does not
 * take into account data that is in the receive shift register.
 *
 * Values:
 * - 0 - Receive buffer is not empty.
 * - 1 - Receive buffer is empty.
 */
/*@{*/
#define BP_UART_SFIFO_RXEMPT (6U)          /*!< Bit position for UART_SFIFO_RXEMPT. */
#define BM_UART_SFIFO_RXEMPT (0x40U)       /*!< Bit mask for UART_SFIFO_RXEMPT. */
#define BS_UART_SFIFO_RXEMPT (1U)          /*!< Bit field size in bits for UART_SFIFO_RXEMPT. */

/*! @brief Read current value of the UART_SFIFO_RXEMPT field. */
#define BR_UART_SFIFO_RXEMPT(x) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_RXEMPT))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXEMPT[7] (RO)
 *
 * Asserts when there is no data in the Transmit FIFO/buffer. This field does
 * not take into account data that is in the transmit shift register.
 *
 * Values:
 * - 0 - Transmit buffer is not empty.
 * - 1 - Transmit buffer is empty.
 */
/*@{*/
#define BP_UART_SFIFO_TXEMPT (7U)          /*!< Bit position for UART_SFIFO_TXEMPT. */
#define BM_UART_SFIFO_TXEMPT (0x80U)       /*!< Bit mask for UART_SFIFO_TXEMPT. */
#define BS_UART_SFIFO_TXEMPT (1U)          /*!< Bit field size in bits for UART_SFIFO_TXEMPT. */

/*! @brief Read current value of the UART_SFIFO_TXEMPT field. */
#define BR_UART_SFIFO_TXEMPT(x) (BITBAND_ACCESS8(HW_UART_SFIFO_ADDR(x), BP_UART_SFIFO_TXEMPT))
/*@}*/

/*******************************************************************************
 * HW_UART_TWFIFO - UART FIFO Transmit Watermark
 ******************************************************************************/

/*!
 * @brief HW_UART_TWFIFO - UART FIFO Transmit Watermark (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of needing additional transmit data. This register may be read at any
 * time but must be written only when C2[TE] is not set. Changing the value of the
 * watermark will not clear the S1[TDRE] flag.
 */
typedef union _hw_uart_twfifo
{
    uint8_t U;
    struct _hw_uart_twfifo_bitfields
    {
        uint8_t TXWATER : 8;           /*!< [7:0] Transmit Watermark */
    } B;
} hw_uart_twfifo_t;

/*!
 * @name Constants and macros for entire UART_TWFIFO register
 */
/*@{*/
#define HW_UART_TWFIFO_ADDR(x)   ((uint32_t)(x) + 0x13U)

#define HW_UART_TWFIFO(x)        (*(__IO hw_uart_twfifo_t *) HW_UART_TWFIFO_ADDR(x))
#define HW_UART_TWFIFO_RD(x)     (HW_UART_TWFIFO(x).U)
#define HW_UART_TWFIFO_WR(x, v)  (HW_UART_TWFIFO(x).U = (v))
#define HW_UART_TWFIFO_SET(x, v) (HW_UART_TWFIFO_WR(x, HW_UART_TWFIFO_RD(x) |  (v)))
#define HW_UART_TWFIFO_CLR(x, v) (HW_UART_TWFIFO_WR(x, HW_UART_TWFIFO_RD(x) & ~(v)))
#define HW_UART_TWFIFO_TOG(x, v) (HW_UART_TWFIFO_WR(x, HW_UART_TWFIFO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_TWFIFO bitfields
 */

/*!
 * @name Register UART_TWFIFO, field TXWATER[7:0] (RW)
 *
 * When the number of datawords in the transmit FIFO/buffer is equal to or less
 * than the value in this register field, an interrupt via S1[TDRE] or a DMA
 * request via C5[TDMAS] is generated as determined by C5[TDMAS] and C2[TIE]. For
 * proper operation, the value in TXWATER must be set to be less than the size of
 * the transmit buffer/FIFO size as indicated by PFIFO[TXFIFOSIZE] and PFIFO[TXFE].
 */
/*@{*/
#define BP_UART_TWFIFO_TXWATER (0U)        /*!< Bit position for UART_TWFIFO_TXWATER. */
#define BM_UART_TWFIFO_TXWATER (0xFFU)     /*!< Bit mask for UART_TWFIFO_TXWATER. */
#define BS_UART_TWFIFO_TXWATER (8U)        /*!< Bit field size in bits for UART_TWFIFO_TXWATER. */

/*! @brief Read current value of the UART_TWFIFO_TXWATER field. */
#define BR_UART_TWFIFO_TXWATER(x) (HW_UART_TWFIFO(x).U)

/*! @brief Format value for bitfield UART_TWFIFO_TXWATER. */
#define BF_UART_TWFIFO_TXWATER(v) ((uint8_t)((uint8_t)(v) << BP_UART_TWFIFO_TXWATER) & BM_UART_TWFIFO_TXWATER)

/*! @brief Set the TXWATER field to a new value. */
#define BW_UART_TWFIFO_TXWATER(x, v) (HW_UART_TWFIFO_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_TCFIFO - UART FIFO Transmit Count
 ******************************************************************************/

/*!
 * @brief HW_UART_TCFIFO - UART FIFO Transmit Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the transmit buffer/FIFO. It may be read at any time.
 */
typedef union _hw_uart_tcfifo
{
    uint8_t U;
    struct _hw_uart_tcfifo_bitfields
    {
        uint8_t TXCOUNT : 8;           /*!< [7:0] Transmit Counter */
    } B;
} hw_uart_tcfifo_t;

/*!
 * @name Constants and macros for entire UART_TCFIFO register
 */
/*@{*/
#define HW_UART_TCFIFO_ADDR(x)   ((uint32_t)(x) + 0x14U)

#define HW_UART_TCFIFO(x)        (*(__I hw_uart_tcfifo_t *) HW_UART_TCFIFO_ADDR(x))
#define HW_UART_TCFIFO_RD(x)     (HW_UART_TCFIFO(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_TCFIFO bitfields
 */

/*!
 * @name Register UART_TCFIFO, field TXCOUNT[7:0] (RO)
 *
 * The value in this register indicates the number of datawords that are in the
 * transmit FIFO/buffer. If a dataword is being transmitted, that is, in the
 * transmit shift register, it is not included in the count. This value may be used
 * in conjunction with PFIFO[TXFIFOSIZE] to calculate how much room is left in the
 * transmit FIFO/buffer.
 */
/*@{*/
#define BP_UART_TCFIFO_TXCOUNT (0U)        /*!< Bit position for UART_TCFIFO_TXCOUNT. */
#define BM_UART_TCFIFO_TXCOUNT (0xFFU)     /*!< Bit mask for UART_TCFIFO_TXCOUNT. */
#define BS_UART_TCFIFO_TXCOUNT (8U)        /*!< Bit field size in bits for UART_TCFIFO_TXCOUNT. */

/*! @brief Read current value of the UART_TCFIFO_TXCOUNT field. */
#define BR_UART_TCFIFO_TXCOUNT(x) (HW_UART_TCFIFO(x).U)
/*@}*/

/*******************************************************************************
 * HW_UART_RWFIFO - UART FIFO Receive Watermark
 ******************************************************************************/

/*!
 * @brief HW_UART_RWFIFO - UART FIFO Receive Watermark (RW)
 *
 * Reset value: 0x01U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of the need to remove data from the receiver FIFO/buffer. This register
 * may be read at any time but must be written only when C2[RE] is not asserted.
 * Changing the value in this register will not clear S1[RDRF].
 */
typedef union _hw_uart_rwfifo
{
    uint8_t U;
    struct _hw_uart_rwfifo_bitfields
    {
        uint8_t RXWATER : 8;           /*!< [7:0] Receive Watermark */
    } B;
} hw_uart_rwfifo_t;

/*!
 * @name Constants and macros for entire UART_RWFIFO register
 */
/*@{*/
#define HW_UART_RWFIFO_ADDR(x)   ((uint32_t)(x) + 0x15U)

#define HW_UART_RWFIFO(x)        (*(__IO hw_uart_rwfifo_t *) HW_UART_RWFIFO_ADDR(x))
#define HW_UART_RWFIFO_RD(x)     (HW_UART_RWFIFO(x).U)
#define HW_UART_RWFIFO_WR(x, v)  (HW_UART_RWFIFO(x).U = (v))
#define HW_UART_RWFIFO_SET(x, v) (HW_UART_RWFIFO_WR(x, HW_UART_RWFIFO_RD(x) |  (v)))
#define HW_UART_RWFIFO_CLR(x, v) (HW_UART_RWFIFO_WR(x, HW_UART_RWFIFO_RD(x) & ~(v)))
#define HW_UART_RWFIFO_TOG(x, v) (HW_UART_RWFIFO_WR(x, HW_UART_RWFIFO_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_RWFIFO bitfields
 */

/*!
 * @name Register UART_RWFIFO, field RXWATER[7:0] (RW)
 *
 * When the number of datawords in the receive FIFO/buffer is equal to or
 * greater than the value in this register field, an interrupt via S1[RDRF] or a DMA
 * request via C5[RDMAS] is generated as determined by C5[RDMAS] and C2[RIE]. For
 * proper operation, the value in RXWATER must be set to be less than the receive
 * FIFO/buffer size as indicated by PFIFO[RXFIFOSIZE] and PFIFO[RXFE] and must be
 * greater than 0.
 */
/*@{*/
#define BP_UART_RWFIFO_RXWATER (0U)        /*!< Bit position for UART_RWFIFO_RXWATER. */
#define BM_UART_RWFIFO_RXWATER (0xFFU)     /*!< Bit mask for UART_RWFIFO_RXWATER. */
#define BS_UART_RWFIFO_RXWATER (8U)        /*!< Bit field size in bits for UART_RWFIFO_RXWATER. */

/*! @brief Read current value of the UART_RWFIFO_RXWATER field. */
#define BR_UART_RWFIFO_RXWATER(x) (HW_UART_RWFIFO(x).U)

/*! @brief Format value for bitfield UART_RWFIFO_RXWATER. */
#define BF_UART_RWFIFO_RXWATER(v) ((uint8_t)((uint8_t)(v) << BP_UART_RWFIFO_RXWATER) & BM_UART_RWFIFO_RXWATER)

/*! @brief Set the RXWATER field to a new value. */
#define BW_UART_RWFIFO_RXWATER(x, v) (HW_UART_RWFIFO_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_RCFIFO - UART FIFO Receive Count
 ******************************************************************************/

/*!
 * @brief HW_UART_RCFIFO - UART FIFO Receive Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the receive FIFO/buffer. It may be read at any time.
 */
typedef union _hw_uart_rcfifo
{
    uint8_t U;
    struct _hw_uart_rcfifo_bitfields
    {
        uint8_t RXCOUNT : 8;           /*!< [7:0] Receive Counter */
    } B;
} hw_uart_rcfifo_t;

/*!
 * @name Constants and macros for entire UART_RCFIFO register
 */
/*@{*/
#define HW_UART_RCFIFO_ADDR(x)   ((uint32_t)(x) + 0x16U)

#define HW_UART_RCFIFO(x)        (*(__I hw_uart_rcfifo_t *) HW_UART_RCFIFO_ADDR(x))
#define HW_UART_RCFIFO_RD(x)     (HW_UART_RCFIFO(x).U)
/*@}*/

/*
 * Constants & macros for individual UART_RCFIFO bitfields
 */

/*!
 * @name Register UART_RCFIFO, field RXCOUNT[7:0] (RO)
 *
 * The value in this register indicates the number of datawords that are in the
 * receive FIFO/buffer. If a dataword is being received, that is, in the receive
 * shift register, it is not included in the count. This value may be used in
 * conjunction with PFIFO[RXFIFOSIZE] to calculate how much room is left in the
 * receive FIFO/buffer.
 */
/*@{*/
#define BP_UART_RCFIFO_RXCOUNT (0U)        /*!< Bit position for UART_RCFIFO_RXCOUNT. */
#define BM_UART_RCFIFO_RXCOUNT (0xFFU)     /*!< Bit mask for UART_RCFIFO_RXCOUNT. */
#define BS_UART_RCFIFO_RXCOUNT (8U)        /*!< Bit field size in bits for UART_RCFIFO_RXCOUNT. */

/*! @brief Read current value of the UART_RCFIFO_RXCOUNT field. */
#define BR_UART_RCFIFO_RXCOUNT(x) (HW_UART_RCFIFO(x).U)
/*@}*/

/*******************************************************************************
 * HW_UART_C7816 - UART 7816 Control Register
 ******************************************************************************/

/*!
 * @brief HW_UART_C7816 - UART 7816 Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The C7816 register is the primary control register for ISO-7816 specific
 * functionality. This register is specific to 7816 functionality and the values in
 * this register have no effect on UART operation and should be ignored if
 * ISO_7816E is not set/enabled. This register may be read at any time but values must
 * be changed only when ISO_7816E is not set.
 */
typedef union _hw_uart_c7816
{
    uint8_t U;
    struct _hw_uart_c7816_bitfields
    {
        uint8_t ISO_7816E : 1;         /*!< [0] ISO-7816 Functionality Enabled */
        uint8_t TTYPE : 1;             /*!< [1] Transfer Type */
        uint8_t INIT : 1;              /*!< [2] Detect Initial Character */
        uint8_t ANACK : 1;             /*!< [3] Generate NACK on Error */
        uint8_t ONACK : 1;             /*!< [4] Generate NACK on Overflow */
        uint8_t RESERVED0 : 3;         /*!< [7:5]  */
    } B;
} hw_uart_c7816_t;

/*!
 * @name Constants and macros for entire UART_C7816 register
 */
/*@{*/
#define HW_UART_C7816_ADDR(x)    ((uint32_t)(x) + 0x18U)

#define HW_UART_C7816(x)         (*(__IO hw_uart_c7816_t *) HW_UART_C7816_ADDR(x))
#define HW_UART_C7816_RD(x)      (HW_UART_C7816(x).U)
#define HW_UART_C7816_WR(x, v)   (HW_UART_C7816(x).U = (v))
#define HW_UART_C7816_SET(x, v)  (HW_UART_C7816_WR(x, HW_UART_C7816_RD(x) |  (v)))
#define HW_UART_C7816_CLR(x, v)  (HW_UART_C7816_WR(x, HW_UART_C7816_RD(x) & ~(v)))
#define HW_UART_C7816_TOG(x, v)  (HW_UART_C7816_WR(x, HW_UART_C7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_C7816 bitfields
 */

/*!
 * @name Register UART_C7816, field ISO_7816E[0] (RW)
 *
 * Indicates that the UART is operating according to the ISO-7816 protocol. This
 * field must be modified only when no transmit or receive is occurring. If this
 * field is changed during a data transfer, the data being transmitted or
 * received may be transferred incorrectly.
 *
 * Values:
 * - 0 - ISO-7816 functionality is turned off/not enabled.
 * - 1 - ISO-7816 functionality is turned on/enabled.
 */
/*@{*/
#define BP_UART_C7816_ISO_7816E (0U)       /*!< Bit position for UART_C7816_ISO_7816E. */
#define BM_UART_C7816_ISO_7816E (0x01U)    /*!< Bit mask for UART_C7816_ISO_7816E. */
#define BS_UART_C7816_ISO_7816E (1U)       /*!< Bit field size in bits for UART_C7816_ISO_7816E. */

/*! @brief Read current value of the UART_C7816_ISO_7816E field. */
#define BR_UART_C7816_ISO_7816E(x) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ISO_7816E))

/*! @brief Format value for bitfield UART_C7816_ISO_7816E. */
#define BF_UART_C7816_ISO_7816E(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ISO_7816E) & BM_UART_C7816_ISO_7816E)

/*! @brief Set the ISO_7816E field to a new value. */
#define BW_UART_C7816_ISO_7816E(x, v) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ISO_7816E) = (v))
/*@}*/

/*!
 * @name Register UART_C7816, field TTYPE[1] (RW)
 *
 * Indicates the transfer protocol being used. See ISO-7816 / smartcard support
 * for more details.
 *
 * Values:
 * - 0 - T = 0 per the ISO-7816 specification.
 * - 1 - T = 1 per the ISO-7816 specification.
 */
/*@{*/
#define BP_UART_C7816_TTYPE  (1U)          /*!< Bit position for UART_C7816_TTYPE. */
#define BM_UART_C7816_TTYPE  (0x02U)       /*!< Bit mask for UART_C7816_TTYPE. */
#define BS_UART_C7816_TTYPE  (1U)          /*!< Bit field size in bits for UART_C7816_TTYPE. */

/*! @brief Read current value of the UART_C7816_TTYPE field. */
#define BR_UART_C7816_TTYPE(x) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_TTYPE))

/*! @brief Format value for bitfield UART_C7816_TTYPE. */
#define BF_UART_C7816_TTYPE(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_TTYPE) & BM_UART_C7816_TTYPE)

/*! @brief Set the TTYPE field to a new value. */
#define BW_UART_C7816_TTYPE(x, v) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_TTYPE) = (v))
/*@}*/

/*!
 * @name Register UART_C7816, field INIT[2] (RW)
 *
 * When this field is set, all received characters are searched for a valid
 * initial character. If an invalid initial character is identified, and ANACK is
 * set, a NACK is sent. All received data is discarded and error flags blocked
 * (S1[NF], S1[OR], S1[FE], S1[PF], IS7816[WT], IS7816[CWT], IS7816[BWT], IS7816[GTV])
 * until a valid initial character is detected. Upon detecting a valid initial
 * character, the configuration values S2[MSBF], C3[TXINV], and S2[RXINV] are
 * automatically updated to reflect the initial character that was received. The
 * actual INIT data value is not stored in the receive buffer. Additionally, upon
 * detection of a valid initial character, IS7816[INITD] is set and an interrupt
 * issued as programmed by IE7816[INITDE]. When a valid initial character is
 * detected, INIT is automatically cleared. This Initial Character Detect feature is
 * supported only in T = 0 protocol mode.
 *
 * Values:
 * - 0 - Normal operating mode. Receiver does not seek to identify initial
 *     character.
 * - 1 - Receiver searches for initial character.
 */
/*@{*/
#define BP_UART_C7816_INIT   (2U)          /*!< Bit position for UART_C7816_INIT. */
#define BM_UART_C7816_INIT   (0x04U)       /*!< Bit mask for UART_C7816_INIT. */
#define BS_UART_C7816_INIT   (1U)          /*!< Bit field size in bits for UART_C7816_INIT. */

/*! @brief Read current value of the UART_C7816_INIT field. */
#define BR_UART_C7816_INIT(x) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_INIT))

/*! @brief Format value for bitfield UART_C7816_INIT. */
#define BF_UART_C7816_INIT(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_INIT) & BM_UART_C7816_INIT)

/*! @brief Set the INIT field to a new value. */
#define BW_UART_C7816_INIT(x, v) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_INIT) = (v))
/*@}*/

/*!
 * @name Register UART_C7816, field ANACK[3] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a parity error occurs or if INIT is set and an invalid initial character is
 * detected. A NACK is generated only if TTYPE = 0. If ANACK is set, the UART
 * attempts to retransmit the data indefinitely. To stop retransmission attempts,
 * clear C2[TE] or ISO_7816E and do not set until S1[TC] sets C2[TE] again.
 *
 * Values:
 * - 0 - No NACK is automatically generated.
 * - 1 - A NACK is automatically generated if a parity error is detected or if
 *     an invalid initial character is detected.
 */
/*@{*/
#define BP_UART_C7816_ANACK  (3U)          /*!< Bit position for UART_C7816_ANACK. */
#define BM_UART_C7816_ANACK  (0x08U)       /*!< Bit mask for UART_C7816_ANACK. */
#define BS_UART_C7816_ANACK  (1U)          /*!< Bit field size in bits for UART_C7816_ANACK. */

/*! @brief Read current value of the UART_C7816_ANACK field. */
#define BR_UART_C7816_ANACK(x) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ANACK))

/*! @brief Format value for bitfield UART_C7816_ANACK. */
#define BF_UART_C7816_ANACK(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ANACK) & BM_UART_C7816_ANACK)

/*! @brief Set the ANACK field to a new value. */
#define BW_UART_C7816_ANACK(x, v) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ANACK) = (v))
/*@}*/

/*!
 * @name Register UART_C7816, field ONACK[4] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a receive buffer overrun occurs, as indicated by S1[OR]. In many systems,
 * this results in the transmitter resending the packet that overflowed until the
 * retransmit threshold for that transmitter is reached. A NACK is generated only
 * if TTYPE=0. This field operates independently of ANACK. See . Overrun NACK
 * considerations
 *
 * Values:
 * - 0 - The received data does not generate a NACK when the receipt of the data
 *     results in an overflow event.
 * - 1 - If the receiver buffer overflows, a NACK is automatically sent on a
 *     received character.
 */
/*@{*/
#define BP_UART_C7816_ONACK  (4U)          /*!< Bit position for UART_C7816_ONACK. */
#define BM_UART_C7816_ONACK  (0x10U)       /*!< Bit mask for UART_C7816_ONACK. */
#define BS_UART_C7816_ONACK  (1U)          /*!< Bit field size in bits for UART_C7816_ONACK. */

/*! @brief Read current value of the UART_C7816_ONACK field. */
#define BR_UART_C7816_ONACK(x) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ONACK))

/*! @brief Format value for bitfield UART_C7816_ONACK. */
#define BF_UART_C7816_ONACK(v) ((uint8_t)((uint8_t)(v) << BP_UART_C7816_ONACK) & BM_UART_C7816_ONACK)

/*! @brief Set the ONACK field to a new value. */
#define BW_UART_C7816_ONACK(x, v) (BITBAND_ACCESS8(HW_UART_C7816_ADDR(x), BP_UART_C7816_ONACK) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_IE7816 - UART 7816 Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief HW_UART_IE7816 - UART 7816 Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IE7816 register controls which flags result in an interrupt being issued.
 * This register is specific to 7816 functionality, the corresponding flags that
 * drive the interrupts are not asserted when 7816E is not set/enabled. However,
 * these flags may remain set if they are asserted while 7816E was set and not
 * subsequently cleared. This register may be read or written to at any time.
 */
typedef union _hw_uart_ie7816
{
    uint8_t U;
    struct _hw_uart_ie7816_bitfields
    {
        uint8_t RXTE : 1;              /*!< [0] Receive Threshold Exceeded Interrupt
                                        * Enable */
        uint8_t TXTE : 1;              /*!< [1] Transmit Threshold Exceeded Interrupt
                                        * Enable */
        uint8_t GTVE : 1;              /*!< [2] Guard Timer Violated Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [3]  */
        uint8_t INITDE : 1;            /*!< [4] Initial Character Detected Interrupt
                                        * Enable */
        uint8_t BWTE : 1;              /*!< [5] Block Wait Timer Interrupt Enable */
        uint8_t CWTE : 1;              /*!< [6] Character Wait Timer Interrupt Enable */
        uint8_t WTE : 1;               /*!< [7] Wait Timer Interrupt Enable */
    } B;
} hw_uart_ie7816_t;

/*!
 * @name Constants and macros for entire UART_IE7816 register
 */
/*@{*/
#define HW_UART_IE7816_ADDR(x)   ((uint32_t)(x) + 0x19U)

#define HW_UART_IE7816(x)        (*(__IO hw_uart_ie7816_t *) HW_UART_IE7816_ADDR(x))
#define HW_UART_IE7816_RD(x)     (HW_UART_IE7816(x).U)
#define HW_UART_IE7816_WR(x, v)  (HW_UART_IE7816(x).U = (v))
#define HW_UART_IE7816_SET(x, v) (HW_UART_IE7816_WR(x, HW_UART_IE7816_RD(x) |  (v)))
#define HW_UART_IE7816_CLR(x, v) (HW_UART_IE7816_WR(x, HW_UART_IE7816_RD(x) & ~(v)))
#define HW_UART_IE7816_TOG(x, v) (HW_UART_IE7816_WR(x, HW_UART_IE7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_IE7816 bitfields
 */

/*!
 * @name Register UART_IE7816, field RXTE[0] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[RXT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[RXT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_RXTE  (0U)          /*!< Bit position for UART_IE7816_RXTE. */
#define BM_UART_IE7816_RXTE  (0x01U)       /*!< Bit mask for UART_IE7816_RXTE. */
#define BS_UART_IE7816_RXTE  (1U)          /*!< Bit field size in bits for UART_IE7816_RXTE. */

/*! @brief Read current value of the UART_IE7816_RXTE field. */
#define BR_UART_IE7816_RXTE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_RXTE))

/*! @brief Format value for bitfield UART_IE7816_RXTE. */
#define BF_UART_IE7816_RXTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_RXTE) & BM_UART_IE7816_RXTE)

/*! @brief Set the RXTE field to a new value. */
#define BW_UART_IE7816_RXTE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_RXTE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field TXTE[1] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[TXT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[TXT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_TXTE  (1U)          /*!< Bit position for UART_IE7816_TXTE. */
#define BM_UART_IE7816_TXTE  (0x02U)       /*!< Bit mask for UART_IE7816_TXTE. */
#define BS_UART_IE7816_TXTE  (1U)          /*!< Bit field size in bits for UART_IE7816_TXTE. */

/*! @brief Read current value of the UART_IE7816_TXTE field. */
#define BR_UART_IE7816_TXTE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_TXTE))

/*! @brief Format value for bitfield UART_IE7816_TXTE. */
#define BF_UART_IE7816_TXTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_TXTE) & BM_UART_IE7816_TXTE)

/*! @brief Set the TXTE field to a new value. */
#define BW_UART_IE7816_TXTE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_TXTE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field GTVE[2] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[GTV] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[GTV] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_GTVE  (2U)          /*!< Bit position for UART_IE7816_GTVE. */
#define BM_UART_IE7816_GTVE  (0x04U)       /*!< Bit mask for UART_IE7816_GTVE. */
#define BS_UART_IE7816_GTVE  (1U)          /*!< Bit field size in bits for UART_IE7816_GTVE. */

/*! @brief Read current value of the UART_IE7816_GTVE field. */
#define BR_UART_IE7816_GTVE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_GTVE))

/*! @brief Format value for bitfield UART_IE7816_GTVE. */
#define BF_UART_IE7816_GTVE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_GTVE) & BM_UART_IE7816_GTVE)

/*! @brief Set the GTVE field to a new value. */
#define BW_UART_IE7816_GTVE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_GTVE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field INITDE[4] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[INITD] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[INITD] results in the generation of an
 *     interrupt.
 */
/*@{*/
#define BP_UART_IE7816_INITDE (4U)         /*!< Bit position for UART_IE7816_INITDE. */
#define BM_UART_IE7816_INITDE (0x10U)      /*!< Bit mask for UART_IE7816_INITDE. */
#define BS_UART_IE7816_INITDE (1U)         /*!< Bit field size in bits for UART_IE7816_INITDE. */

/*! @brief Read current value of the UART_IE7816_INITDE field. */
#define BR_UART_IE7816_INITDE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_INITDE))

/*! @brief Format value for bitfield UART_IE7816_INITDE. */
#define BF_UART_IE7816_INITDE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_INITDE) & BM_UART_IE7816_INITDE)

/*! @brief Set the INITDE field to a new value. */
#define BW_UART_IE7816_INITDE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_INITDE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field BWTE[5] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[BWT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[BWT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_BWTE  (5U)          /*!< Bit position for UART_IE7816_BWTE. */
#define BM_UART_IE7816_BWTE  (0x20U)       /*!< Bit mask for UART_IE7816_BWTE. */
#define BS_UART_IE7816_BWTE  (1U)          /*!< Bit field size in bits for UART_IE7816_BWTE. */

/*! @brief Read current value of the UART_IE7816_BWTE field. */
#define BR_UART_IE7816_BWTE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_BWTE))

/*! @brief Format value for bitfield UART_IE7816_BWTE. */
#define BF_UART_IE7816_BWTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_BWTE) & BM_UART_IE7816_BWTE)

/*! @brief Set the BWTE field to a new value. */
#define BW_UART_IE7816_BWTE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_BWTE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field CWTE[6] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[CWT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[CWT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_CWTE  (6U)          /*!< Bit position for UART_IE7816_CWTE. */
#define BM_UART_IE7816_CWTE  (0x40U)       /*!< Bit mask for UART_IE7816_CWTE. */
#define BS_UART_IE7816_CWTE  (1U)          /*!< Bit field size in bits for UART_IE7816_CWTE. */

/*! @brief Read current value of the UART_IE7816_CWTE field. */
#define BR_UART_IE7816_CWTE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_CWTE))

/*! @brief Format value for bitfield UART_IE7816_CWTE. */
#define BF_UART_IE7816_CWTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_CWTE) & BM_UART_IE7816_CWTE)

/*! @brief Set the CWTE field to a new value. */
#define BW_UART_IE7816_CWTE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_CWTE) = (v))
/*@}*/

/*!
 * @name Register UART_IE7816, field WTE[7] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[WT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[WT] results in the generation of an interrupt.
 */
/*@{*/
#define BP_UART_IE7816_WTE   (7U)          /*!< Bit position for UART_IE7816_WTE. */
#define BM_UART_IE7816_WTE   (0x80U)       /*!< Bit mask for UART_IE7816_WTE. */
#define BS_UART_IE7816_WTE   (1U)          /*!< Bit field size in bits for UART_IE7816_WTE. */

/*! @brief Read current value of the UART_IE7816_WTE field. */
#define BR_UART_IE7816_WTE(x) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_WTE))

/*! @brief Format value for bitfield UART_IE7816_WTE. */
#define BF_UART_IE7816_WTE(v) ((uint8_t)((uint8_t)(v) << BP_UART_IE7816_WTE) & BM_UART_IE7816_WTE)

/*! @brief Set the WTE field to a new value. */
#define BW_UART_IE7816_WTE(x, v) (BITBAND_ACCESS8(HW_UART_IE7816_ADDR(x), BP_UART_IE7816_WTE) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_IS7816 - UART 7816 Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief HW_UART_IS7816 - UART 7816 Interrupt Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IS7816 register provides a mechanism to read and clear the interrupt
 * flags. All flags/interrupts are cleared by writing a 1 to the field location.
 * Writing a 0 has no effect. All bits are "sticky", meaning they indicate that only
 * the flag condition that occurred since the last time the bit was cleared, not
 * that the condition currently exists. The status flags are set regardless of
 * whether the corresponding field in the IE7816 is set or cleared. The IE7816
 * controls only if an interrupt is issued to the host processor. This register is
 * specific to 7816 functionality and the values in this register have no affect on
 * UART operation and should be ignored if 7816E is not set/enabled. This
 * register may be read or written at anytime.
 */
typedef union _hw_uart_is7816
{
    uint8_t U;
    struct _hw_uart_is7816_bitfields
    {
        uint8_t RXT : 1;               /*!< [0] Receive Threshold Exceeded Interrupt */
        uint8_t TXT : 1;               /*!< [1] Transmit Threshold Exceeded Interrupt */
        uint8_t GTV : 1;               /*!< [2] Guard Timer Violated Interrupt */
        uint8_t RESERVED0 : 1;         /*!< [3]  */
        uint8_t INITD : 1;             /*!< [4] Initial Character Detected Interrupt */
        uint8_t BWT : 1;               /*!< [5] Block Wait Timer Interrupt */
        uint8_t CWT : 1;               /*!< [6] Character Wait Timer Interrupt */
        uint8_t WT : 1;                /*!< [7] Wait Timer Interrupt */
    } B;
} hw_uart_is7816_t;

/*!
 * @name Constants and macros for entire UART_IS7816 register
 */
/*@{*/
#define HW_UART_IS7816_ADDR(x)   ((uint32_t)(x) + 0x1AU)

#define HW_UART_IS7816(x)        (*(__IO hw_uart_is7816_t *) HW_UART_IS7816_ADDR(x))
#define HW_UART_IS7816_RD(x)     (HW_UART_IS7816(x).U)
#define HW_UART_IS7816_WR(x, v)  (HW_UART_IS7816(x).U = (v))
#define HW_UART_IS7816_SET(x, v) (HW_UART_IS7816_WR(x, HW_UART_IS7816_RD(x) |  (v)))
#define HW_UART_IS7816_CLR(x, v) (HW_UART_IS7816_WR(x, HW_UART_IS7816_RD(x) & ~(v)))
#define HW_UART_IS7816_TOG(x, v) (HW_UART_IS7816_WR(x, HW_UART_IS7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_IS7816 bitfields
 */

/*!
 * @name Register UART_IS7816, field RXT[0] (W1C)
 *
 * Indicates that there are more than ET7816[RXTHRESHOLD] consecutive NACKS
 * generated in response to parity errors on received data. This flag requires ANACK
 * to be set. Additionally, this flag asserts only when C7816[TTYPE] = 0.
 * Clearing this field also resets the counter keeping track of consecutive NACKS. The
 * UART will continue to attempt to receive data regardless of whether this flag
 * is set. If 7816E is cleared/disabled, RE is cleared/disabled, C7816[TTYPE] = 1,
 * or packet is received without needing to issue a NACK, the internal NACK
 * detection counter is cleared and the count restarts from zero on the next
 * transmitted NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is less than or equal to the value in
 *     ET7816[RXTHRESHOLD].
 * - 1 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].
 */
/*@{*/
#define BP_UART_IS7816_RXT   (0U)          /*!< Bit position for UART_IS7816_RXT. */
#define BM_UART_IS7816_RXT   (0x01U)       /*!< Bit mask for UART_IS7816_RXT. */
#define BS_UART_IS7816_RXT   (1U)          /*!< Bit field size in bits for UART_IS7816_RXT. */

/*! @brief Read current value of the UART_IS7816_RXT field. */
#define BR_UART_IS7816_RXT(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_RXT))

/*! @brief Format value for bitfield UART_IS7816_RXT. */
#define BF_UART_IS7816_RXT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_RXT) & BM_UART_IS7816_RXT)

/*! @brief Set the RXT field to a new value. */
#define BW_UART_IS7816_RXT(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_RXT) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field TXT[1] (W1C)
 *
 * Indicates that the transmit NACK threshold has been exceeded as indicated by
 * ET7816[TXTHRESHOLD]. Regardless of whether this flag is set, the UART
 * continues to retransmit indefinitely. This flag asserts only when C7816[TTYPE] = 0. If
 * 7816E is cleared/disabled, ANACK is cleared/disabled, C2[TE] is
 * cleared/disabled, C7816[TTYPE] = 1, or packet is transferred without receiving a NACK, the
 * internal NACK detection counter is cleared and the count restarts from zero on
 * the next received NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - The number of retries and corresponding NACKS does not exceed the value
 *     in ET7816[TXTHRESHOLD].
 * - 1 - The number of retries and corresponding NACKS exceeds the value in
 *     ET7816[TXTHRESHOLD].
 */
/*@{*/
#define BP_UART_IS7816_TXT   (1U)          /*!< Bit position for UART_IS7816_TXT. */
#define BM_UART_IS7816_TXT   (0x02U)       /*!< Bit mask for UART_IS7816_TXT. */
#define BS_UART_IS7816_TXT   (1U)          /*!< Bit field size in bits for UART_IS7816_TXT. */

/*! @brief Read current value of the UART_IS7816_TXT field. */
#define BR_UART_IS7816_TXT(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_TXT))

/*! @brief Format value for bitfield UART_IS7816_TXT. */
#define BF_UART_IS7816_TXT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_TXT) & BM_UART_IS7816_TXT)

/*! @brief Set the TXT field to a new value. */
#define BW_UART_IS7816_TXT(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_TXT) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field GTV[2] (W1C)
 *
 * Indicates that one or more of the character guard time, block guard time, or
 * guard time are violated. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - A guard time (GT, CGT, or BGT) has not been violated.
 * - 1 - A guard time (GT, CGT, or BGT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_GTV   (2U)          /*!< Bit position for UART_IS7816_GTV. */
#define BM_UART_IS7816_GTV   (0x04U)       /*!< Bit mask for UART_IS7816_GTV. */
#define BS_UART_IS7816_GTV   (1U)          /*!< Bit field size in bits for UART_IS7816_GTV. */

/*! @brief Read current value of the UART_IS7816_GTV field. */
#define BR_UART_IS7816_GTV(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_GTV))

/*! @brief Format value for bitfield UART_IS7816_GTV. */
#define BF_UART_IS7816_GTV(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_GTV) & BM_UART_IS7816_GTV)

/*! @brief Set the GTV field to a new value. */
#define BW_UART_IS7816_GTV(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_GTV) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field INITD[4] (W1C)
 *
 * Indicates that a valid initial character is received. This interrupt is
 * cleared by writing 1.
 *
 * Values:
 * - 0 - A valid initial character has not been received.
 * - 1 - A valid initial character has been received.
 */
/*@{*/
#define BP_UART_IS7816_INITD (4U)          /*!< Bit position for UART_IS7816_INITD. */
#define BM_UART_IS7816_INITD (0x10U)       /*!< Bit mask for UART_IS7816_INITD. */
#define BS_UART_IS7816_INITD (1U)          /*!< Bit field size in bits for UART_IS7816_INITD. */

/*! @brief Read current value of the UART_IS7816_INITD field. */
#define BR_UART_IS7816_INITD(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_INITD))

/*! @brief Format value for bitfield UART_IS7816_INITD. */
#define BF_UART_IS7816_INITD(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_INITD) & BM_UART_IS7816_INITD)

/*! @brief Set the INITD field to a new value. */
#define BW_UART_IS7816_INITD(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_INITD) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field BWT[5] (W1C)
 *
 * Indicates that the block wait time, the time between the leading edge of
 * first received character of a block and the leading edge of the last character the
 * previously transmitted block, has exceeded the programmed value. This flag
 * asserts only when C7816[TTYPE] = 1.This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - Block wait time (BWT) has not been violated.
 * - 1 - Block wait time (BWT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_BWT   (5U)          /*!< Bit position for UART_IS7816_BWT. */
#define BM_UART_IS7816_BWT   (0x20U)       /*!< Bit mask for UART_IS7816_BWT. */
#define BS_UART_IS7816_BWT   (1U)          /*!< Bit field size in bits for UART_IS7816_BWT. */

/*! @brief Read current value of the UART_IS7816_BWT field. */
#define BR_UART_IS7816_BWT(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_BWT))

/*! @brief Format value for bitfield UART_IS7816_BWT. */
#define BF_UART_IS7816_BWT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_BWT) & BM_UART_IS7816_BWT)

/*! @brief Set the BWT field to a new value. */
#define BW_UART_IS7816_BWT(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_BWT) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field CWT[6] (W1C)
 *
 * Indicates that the character wait time, the time between the leading edges of
 * two consecutive characters in a block, has exceeded the programmed value.
 * This flag asserts only when C7816[TTYPE] = 1. This interrupt is cleared by
 * writing 1.
 *
 * Values:
 * - 0 - Character wait time (CWT) has not been violated.
 * - 1 - Character wait time (CWT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_CWT   (6U)          /*!< Bit position for UART_IS7816_CWT. */
#define BM_UART_IS7816_CWT   (0x40U)       /*!< Bit mask for UART_IS7816_CWT. */
#define BS_UART_IS7816_CWT   (1U)          /*!< Bit field size in bits for UART_IS7816_CWT. */

/*! @brief Read current value of the UART_IS7816_CWT field. */
#define BR_UART_IS7816_CWT(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_CWT))

/*! @brief Format value for bitfield UART_IS7816_CWT. */
#define BF_UART_IS7816_CWT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_CWT) & BM_UART_IS7816_CWT)

/*! @brief Set the CWT field to a new value. */
#define BW_UART_IS7816_CWT(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_CWT) = (v))
/*@}*/

/*!
 * @name Register UART_IS7816, field WT[7] (W1C)
 *
 * Indicates that the wait time, the time between the leading edge of a
 * character being transmitted and the leading edge of the next response character, has
 * exceeded the programmed value. This flag asserts only when C7816[TTYPE] = 0.
 * This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - Wait time (WT) has not been violated.
 * - 1 - Wait time (WT) has been violated.
 */
/*@{*/
#define BP_UART_IS7816_WT    (7U)          /*!< Bit position for UART_IS7816_WT. */
#define BM_UART_IS7816_WT    (0x80U)       /*!< Bit mask for UART_IS7816_WT. */
#define BS_UART_IS7816_WT    (1U)          /*!< Bit field size in bits for UART_IS7816_WT. */

/*! @brief Read current value of the UART_IS7816_WT field. */
#define BR_UART_IS7816_WT(x) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_WT))

/*! @brief Format value for bitfield UART_IS7816_WT. */
#define BF_UART_IS7816_WT(v) ((uint8_t)((uint8_t)(v) << BP_UART_IS7816_WT) & BM_UART_IS7816_WT)

/*! @brief Set the WT field to a new value. */
#define BW_UART_IS7816_WT(x, v) (BITBAND_ACCESS8(HW_UART_IS7816_ADDR(x), BP_UART_IS7816_WT) = (v))
/*@}*/

/*******************************************************************************
 * HW_UART_WP7816T0 - UART 7816 Wait Parameter Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816T0 - UART 7816 Wait Parameter Register (RW)
 *
 * Reset value: 0x0AU
 *
 * The WP7816 register contains constants used in the generation of various wait
 * timer counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816t0
{
    uint8_t U;
    struct _hw_uart_wp7816t0_bitfields
    {
        uint8_t WI : 8;                /*!< [7:0] Wait Time Integer (C7816[TTYPE] = 0) */
    } B;
} hw_uart_wp7816t0_t;

/*!
 * @name Constants and macros for entire UART_WP7816T0 register
 */
/*@{*/
#define HW_UART_WP7816T0_ADDR(x) ((uint32_t)(x) + 0x1BU)

#define HW_UART_WP7816T0(x)      (*(__IO hw_uart_wp7816t0_t *) HW_UART_WP7816T0_ADDR(x))
#define HW_UART_WP7816T0_RD(x)   (HW_UART_WP7816T0(x).U)
#define HW_UART_WP7816T0_WR(x, v) (HW_UART_WP7816T0(x).U = (v))
#define HW_UART_WP7816T0_SET(x, v) (HW_UART_WP7816T0_WR(x, HW_UART_WP7816T0_RD(x) |  (v)))
#define HW_UART_WP7816T0_CLR(x, v) (HW_UART_WP7816T0_WR(x, HW_UART_WP7816T0_RD(x) & ~(v)))
#define HW_UART_WP7816T0_TOG(x, v) (HW_UART_WP7816T0_WR(x, HW_UART_WP7816T0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816T0 bitfields
 */

/*!
 * @name Register UART_WP7816T0, field WI[7:0] (RW)
 *
 * Used to calculate the value used for the WT counter. It represents a value
 * between 1 and 255. The value of zero is not valid. This value is used only when
 * C7816[TTYPE] = 0. See Wait time and guard time parameters.
 */
/*@{*/
#define BP_UART_WP7816T0_WI  (0U)          /*!< Bit position for UART_WP7816T0_WI. */
#define BM_UART_WP7816T0_WI  (0xFFU)       /*!< Bit mask for UART_WP7816T0_WI. */
#define BS_UART_WP7816T0_WI  (8U)          /*!< Bit field size in bits for UART_WP7816T0_WI. */

/*! @brief Read current value of the UART_WP7816T0_WI field. */
#define BR_UART_WP7816T0_WI(x) (HW_UART_WP7816T0(x).U)

/*! @brief Format value for bitfield UART_WP7816T0_WI. */
#define BF_UART_WP7816T0_WI(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816T0_WI) & BM_UART_WP7816T0_WI)

/*! @brief Set the WI field to a new value. */
#define BW_UART_WP7816T0_WI(x, v) (HW_UART_WP7816T0_WR(x, v))
/*@}*/
/*******************************************************************************
 * HW_UART_WP7816T1 - UART 7816 Wait Parameter Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WP7816T1 - UART 7816 Wait Parameter Register (RW)
 *
 * Reset value: 0x0AU
 *
 * The WP7816 register contains constants used in the generation of various wait
 * timer counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wp7816t1
{
    uint8_t U;
    struct _hw_uart_wp7816t1_bitfields
    {
        uint8_t BWI : 4;               /*!< [3:0] Block Wait Time Integer(C7816[TTYPE] = 1)
                                        * */
        uint8_t CWI : 4;               /*!< [7:4] Character Wait Time Integer (C7816[TTYPE]
                                        * = 1) */
    } B;
} hw_uart_wp7816t1_t;

/*!
 * @name Constants and macros for entire UART_WP7816T1 register
 */
/*@{*/
#define HW_UART_WP7816T1_ADDR(x) ((uint32_t)(x) + 0x1BU)

#define HW_UART_WP7816T1(x)      (*(__IO hw_uart_wp7816t1_t *) HW_UART_WP7816T1_ADDR(x))
#define HW_UART_WP7816T1_RD(x)   (HW_UART_WP7816T1(x).U)
#define HW_UART_WP7816T1_WR(x, v) (HW_UART_WP7816T1(x).U = (v))
#define HW_UART_WP7816T1_SET(x, v) (HW_UART_WP7816T1_WR(x, HW_UART_WP7816T1_RD(x) |  (v)))
#define HW_UART_WP7816T1_CLR(x, v) (HW_UART_WP7816T1_WR(x, HW_UART_WP7816T1_RD(x) & ~(v)))
#define HW_UART_WP7816T1_TOG(x, v) (HW_UART_WP7816T1_WR(x, HW_UART_WP7816T1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816T1 bitfields
 */

/*!
 * @name Register UART_WP7816T1, field BWI[3:0] (RW)
 *
 * Used to calculate the value used for the BWT counter. It represent a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
#define BP_UART_WP7816T1_BWI (0U)          /*!< Bit position for UART_WP7816T1_BWI. */
#define BM_UART_WP7816T1_BWI (0x0FU)       /*!< Bit mask for UART_WP7816T1_BWI. */
#define BS_UART_WP7816T1_BWI (4U)          /*!< Bit field size in bits for UART_WP7816T1_BWI. */

/*! @brief Read current value of the UART_WP7816T1_BWI field. */
#define BR_UART_WP7816T1_BWI(x) (HW_UART_WP7816T1(x).B.BWI)

/*! @brief Format value for bitfield UART_WP7816T1_BWI. */
#define BF_UART_WP7816T1_BWI(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816T1_BWI) & BM_UART_WP7816T1_BWI)

/*! @brief Set the BWI field to a new value. */
#define BW_UART_WP7816T1_BWI(x, v) (HW_UART_WP7816T1_WR(x, (HW_UART_WP7816T1_RD(x) & ~BM_UART_WP7816T1_BWI) | BF_UART_WP7816T1_BWI(v)))
/*@}*/

/*!
 * @name Register UART_WP7816T1, field CWI[7:4] (RW)
 *
 * Used to calculate the value used for the CWT counter. It represents a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
#define BP_UART_WP7816T1_CWI (4U)          /*!< Bit position for UART_WP7816T1_CWI. */
#define BM_UART_WP7816T1_CWI (0xF0U)       /*!< Bit mask for UART_WP7816T1_CWI. */
#define BS_UART_WP7816T1_CWI (4U)          /*!< Bit field size in bits for UART_WP7816T1_CWI. */

/*! @brief Read current value of the UART_WP7816T1_CWI field. */
#define BR_UART_WP7816T1_CWI(x) (HW_UART_WP7816T1(x).B.CWI)

/*! @brief Format value for bitfield UART_WP7816T1_CWI. */
#define BF_UART_WP7816T1_CWI(v) ((uint8_t)((uint8_t)(v) << BP_UART_WP7816T1_CWI) & BM_UART_WP7816T1_CWI)

/*! @brief Set the CWI field to a new value. */
#define BW_UART_WP7816T1_CWI(x, v) (HW_UART_WP7816T1_WR(x, (HW_UART_WP7816T1_RD(x) & ~BM_UART_WP7816T1_CWI) | BF_UART_WP7816T1_CWI(v)))
/*@}*/

/*******************************************************************************
 * HW_UART_WN7816 - UART 7816 Wait N Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WN7816 - UART 7816 Wait N Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WN7816 register contains a parameter that is used in the calculation of
 * the guard time counter. This register may be read at any time. This register
 * must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wn7816
{
    uint8_t U;
    struct _hw_uart_wn7816_bitfields
    {
        uint8_t GTN : 8;               /*!< [7:0] Guard Band N */
    } B;
} hw_uart_wn7816_t;

/*!
 * @name Constants and macros for entire UART_WN7816 register
 */
/*@{*/
#define HW_UART_WN7816_ADDR(x)   ((uint32_t)(x) + 0x1CU)

#define HW_UART_WN7816(x)        (*(__IO hw_uart_wn7816_t *) HW_UART_WN7816_ADDR(x))
#define HW_UART_WN7816_RD(x)     (HW_UART_WN7816(x).U)
#define HW_UART_WN7816_WR(x, v)  (HW_UART_WN7816(x).U = (v))
#define HW_UART_WN7816_SET(x, v) (HW_UART_WN7816_WR(x, HW_UART_WN7816_RD(x) |  (v)))
#define HW_UART_WN7816_CLR(x, v) (HW_UART_WN7816_WR(x, HW_UART_WN7816_RD(x) & ~(v)))
#define HW_UART_WN7816_TOG(x, v) (HW_UART_WN7816_WR(x, HW_UART_WN7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_WN7816 bitfields
 */

/*!
 * @name Register UART_WN7816, field GTN[7:0] (RW)
 *
 * Defines a parameter used in the calculation of GT, CGT, and BGT counters. The
 * value represents an integer number between 0 and 255. See Wait time and guard
 * time parameters .
 */
/*@{*/
#define BP_UART_WN7816_GTN   (0U)          /*!< Bit position for UART_WN7816_GTN. */
#define BM_UART_WN7816_GTN   (0xFFU)       /*!< Bit mask for UART_WN7816_GTN. */
#define BS_UART_WN7816_GTN   (8U)          /*!< Bit field size in bits for UART_WN7816_GTN. */

/*! @brief Read current value of the UART_WN7816_GTN field. */
#define BR_UART_WN7816_GTN(x) (HW_UART_WN7816(x).U)

/*! @brief Format value for bitfield UART_WN7816_GTN. */
#define BF_UART_WN7816_GTN(v) ((uint8_t)((uint8_t)(v) << BP_UART_WN7816_GTN) & BM_UART_WN7816_GTN)

/*! @brief Set the GTN field to a new value. */
#define BW_UART_WN7816_GTN(x, v) (HW_UART_WN7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_WF7816 - UART 7816 Wait FD Register
 ******************************************************************************/

/*!
 * @brief HW_UART_WF7816 - UART 7816 Wait FD Register (RW)
 *
 * Reset value: 0x01U
 *
 * The WF7816 contains parameters that are used in the generation of various
 * counters including GT, CGT, BGT, WT, and BWT. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_wf7816
{
    uint8_t U;
    struct _hw_uart_wf7816_bitfields
    {
        uint8_t GTFD : 8;              /*!< [7:0] FD Multiplier */
    } B;
} hw_uart_wf7816_t;

/*!
 * @name Constants and macros for entire UART_WF7816 register
 */
/*@{*/
#define HW_UART_WF7816_ADDR(x)   ((uint32_t)(x) + 0x1DU)

#define HW_UART_WF7816(x)        (*(__IO hw_uart_wf7816_t *) HW_UART_WF7816_ADDR(x))
#define HW_UART_WF7816_RD(x)     (HW_UART_WF7816(x).U)
#define HW_UART_WF7816_WR(x, v)  (HW_UART_WF7816(x).U = (v))
#define HW_UART_WF7816_SET(x, v) (HW_UART_WF7816_WR(x, HW_UART_WF7816_RD(x) |  (v)))
#define HW_UART_WF7816_CLR(x, v) (HW_UART_WF7816_WR(x, HW_UART_WF7816_RD(x) & ~(v)))
#define HW_UART_WF7816_TOG(x, v) (HW_UART_WF7816_WR(x, HW_UART_WF7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_WF7816 bitfields
 */

/*!
 * @name Register UART_WF7816, field GTFD[7:0] (RW)
 *
 * Used as another multiplier in the calculation of WT and BWT. This value
 * represents a number between 1 and 255. The value of 0 is invalid. This value is not
 * used in baud rate generation. See Wait time and guard time parameters and
 * Baud rate generation .
 */
/*@{*/
#define BP_UART_WF7816_GTFD  (0U)          /*!< Bit position for UART_WF7816_GTFD. */
#define BM_UART_WF7816_GTFD  (0xFFU)       /*!< Bit mask for UART_WF7816_GTFD. */
#define BS_UART_WF7816_GTFD  (8U)          /*!< Bit field size in bits for UART_WF7816_GTFD. */

/*! @brief Read current value of the UART_WF7816_GTFD field. */
#define BR_UART_WF7816_GTFD(x) (HW_UART_WF7816(x).U)

/*! @brief Format value for bitfield UART_WF7816_GTFD. */
#define BF_UART_WF7816_GTFD(v) ((uint8_t)((uint8_t)(v) << BP_UART_WF7816_GTFD) & BM_UART_WF7816_GTFD)

/*! @brief Set the GTFD field to a new value. */
#define BW_UART_WF7816_GTFD(x, v) (HW_UART_WF7816_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_UART_ET7816 - UART 7816 Error Threshold Register
 ******************************************************************************/

/*!
 * @brief HW_UART_ET7816 - UART 7816 Error Threshold Register (RW)
 *
 * Reset value: 0x00U
 *
 * The ET7816 register contains fields that determine the number of NACKs that
 * must be received or transmitted before the host processor is notified. This
 * register may be read at anytime. This register must be written to only when
 * C7816[ISO_7816E] is not set.
 */
typedef union _hw_uart_et7816
{
    uint8_t U;
    struct _hw_uart_et7816_bitfields
    {
        uint8_t RXTHRESHOLD : 4;       /*!< [3:0] Receive NACK Threshold */
        uint8_t TXTHRESHOLD : 4;       /*!< [7:4] Transmit NACK Threshold */
    } B;
} hw_uart_et7816_t;

/*!
 * @name Constants and macros for entire UART_ET7816 register
 */
/*@{*/
#define HW_UART_ET7816_ADDR(x)   ((uint32_t)(x) + 0x1EU)

#define HW_UART_ET7816(x)        (*(__IO hw_uart_et7816_t *) HW_UART_ET7816_ADDR(x))
#define HW_UART_ET7816_RD(x)     (HW_UART_ET7816(x).U)
#define HW_UART_ET7816_WR(x, v)  (HW_UART_ET7816(x).U = (v))
#define HW_UART_ET7816_SET(x, v) (HW_UART_ET7816_WR(x, HW_UART_ET7816_RD(x) |  (v)))
#define HW_UART_ET7816_CLR(x, v) (HW_UART_ET7816_WR(x, HW_UART_ET7816_RD(x) & ~(v)))
#define HW_UART_ET7816_TOG(x, v) (HW_UART_ET7816_WR(x, HW_UART_ET7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_ET7816 bitfields
 */

/*!
 * @name Register UART_ET7816, field RXTHRESHOLD[3:0] (RW)
 *
 * The value written to this field indicates the maximum number of consecutive
 * NACKs generated as a result of a parity error or receiver buffer overruns
 * before the host processor is notified. After the counter exceeds that value in the
 * field, the IS7816[RXT] is asserted. This field is meaningful only when
 * C7816[TTYPE] = 0. The value read from this field represents the number of consecutive
 * NACKs that have been transmitted since the last successful reception. This
 * counter saturates at 4'hF and does not wrap around. Regardless of the number of
 * NACKs sent, the UART continues to receive valid packets indefinitely. For
 * additional information, see IS7816[RXT] field description.
 */
/*@{*/
#define BP_UART_ET7816_RXTHRESHOLD (0U)    /*!< Bit position for UART_ET7816_RXTHRESHOLD. */
#define BM_UART_ET7816_RXTHRESHOLD (0x0FU) /*!< Bit mask for UART_ET7816_RXTHRESHOLD. */
#define BS_UART_ET7816_RXTHRESHOLD (4U)    /*!< Bit field size in bits for UART_ET7816_RXTHRESHOLD. */

/*! @brief Read current value of the UART_ET7816_RXTHRESHOLD field. */
#define BR_UART_ET7816_RXTHRESHOLD(x) (HW_UART_ET7816(x).B.RXTHRESHOLD)

/*! @brief Format value for bitfield UART_ET7816_RXTHRESHOLD. */
#define BF_UART_ET7816_RXTHRESHOLD(v) ((uint8_t)((uint8_t)(v) << BP_UART_ET7816_RXTHRESHOLD) & BM_UART_ET7816_RXTHRESHOLD)

/*! @brief Set the RXTHRESHOLD field to a new value. */
#define BW_UART_ET7816_RXTHRESHOLD(x, v) (HW_UART_ET7816_WR(x, (HW_UART_ET7816_RD(x) & ~BM_UART_ET7816_RXTHRESHOLD) | BF_UART_ET7816_RXTHRESHOLD(v)))
/*@}*/

/*!
 * @name Register UART_ET7816, field TXTHRESHOLD[7:4] (RW)
 *
 * The value written to this field indicates the maximum number of failed
 * attempts (NACKs) a transmitted character can have before the host processor is
 * notified. This field is meaningful only when C7816[TTYPE] = 0 and C7816[ANACK] = 1.
 * The value read from this field represents the number of consecutive NACKs
 * that have been received since the last successful transmission. This counter
 * saturates at 4'hF and does not wrap around. Regardless of how many NACKs that are
 * received, the UART continues to retransmit indefinitely. This flag only
 * asserts when C7816[TTYPE] = 0. For additional information see the IS7816[TXT] field
 * description.
 *
 * Values:
 * - 0 - TXT asserts on the first NACK that is received.
 * - 1 - TXT asserts on the second NACK that is received.
 */
/*@{*/
#define BP_UART_ET7816_TXTHRESHOLD (4U)    /*!< Bit position for UART_ET7816_TXTHRESHOLD. */
#define BM_UART_ET7816_TXTHRESHOLD (0xF0U) /*!< Bit mask for UART_ET7816_TXTHRESHOLD. */
#define BS_UART_ET7816_TXTHRESHOLD (4U)    /*!< Bit field size in bits for UART_ET7816_TXTHRESHOLD. */

/*! @brief Read current value of the UART_ET7816_TXTHRESHOLD field. */
#define BR_UART_ET7816_TXTHRESHOLD(x) (HW_UART_ET7816(x).B.TXTHRESHOLD)

/*! @brief Format value for bitfield UART_ET7816_TXTHRESHOLD. */
#define BF_UART_ET7816_TXTHRESHOLD(v) ((uint8_t)((uint8_t)(v) << BP_UART_ET7816_TXTHRESHOLD) & BM_UART_ET7816_TXTHRESHOLD)

/*! @brief Set the TXTHRESHOLD field to a new value. */
#define BW_UART_ET7816_TXTHRESHOLD(x, v) (HW_UART_ET7816_WR(x, (HW_UART_ET7816_RD(x) & ~BM_UART_ET7816_TXTHRESHOLD) | BF_UART_ET7816_TXTHRESHOLD(v)))
/*@}*/

/*******************************************************************************
 * HW_UART_TL7816 - UART 7816 Transmit Length Register
 ******************************************************************************/

/*!
 * @brief HW_UART_TL7816 - UART 7816 Transmit Length Register (RW)
 *
 * Reset value: 0x00U
 *
 * The TL7816 register is used to indicate the number of characters contained in
 * the block being transmitted. This register is used only when C7816[TTYPE] =
 * 1. This register may be read at anytime. This register must be written only
 * when C2[TE] is not enabled.
 */
typedef union _hw_uart_tl7816
{
    uint8_t U;
    struct _hw_uart_tl7816_bitfields
    {
        uint8_t TLEN : 8;              /*!< [7:0] Transmit Length */
    } B;
} hw_uart_tl7816_t;

/*!
 * @name Constants and macros for entire UART_TL7816 register
 */
/*@{*/
#define HW_UART_TL7816_ADDR(x)   ((uint32_t)(x) + 0x1FU)

#define HW_UART_TL7816(x)        (*(__IO hw_uart_tl7816_t *) HW_UART_TL7816_ADDR(x))
#define HW_UART_TL7816_RD(x)     (HW_UART_TL7816(x).U)
#define HW_UART_TL7816_WR(x, v)  (HW_UART_TL7816(x).U = (v))
#define HW_UART_TL7816_SET(x, v) (HW_UART_TL7816_WR(x, HW_UART_TL7816_RD(x) |  (v)))
#define HW_UART_TL7816_CLR(x, v) (HW_UART_TL7816_WR(x, HW_UART_TL7816_RD(x) & ~(v)))
#define HW_UART_TL7816_TOG(x, v) (HW_UART_TL7816_WR(x, HW_UART_TL7816_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual UART_TL7816 bitfields
 */

/*!
 * @name Register UART_TL7816, field TLEN[7:0] (RW)
 *
 * This value plus four indicates the number of characters contained in the
 * block being transmitted. This register is automatically decremented by 1 for each
 * character in the information field portion of the block. Additionally, this
 * register is automatically decremented by 1 for the first character of a CRC in
 * the epilogue field. Therefore, this register must be programmed with the number
 * of bytes in the data packet if an LRC is being transmitted, and the number of
 * bytes + 1 if a CRC is being transmitted. This register is not decremented for
 * characters that are assumed to be part of the Prologue field, that is, the
 * first three characters transmitted in a block, or the LRC or last CRC character
 * in the Epilogue field, that is, the last character transmitted. This field
 * must be programed or adjusted only when C2[TE] is cleared.
 */
/*@{*/
#define BP_UART_TL7816_TLEN  (0U)          /*!< Bit position for UART_TL7816_TLEN. */
#define BM_UART_TL7816_TLEN  (0xFFU)       /*!< Bit mask for UART_TL7816_TLEN. */
#define BS_UART_TL7816_TLEN  (8U)          /*!< Bit field size in bits for UART_TL7816_TLEN. */

/*! @brief Read current value of the UART_TL7816_TLEN field. */
#define BR_UART_TL7816_TLEN(x) (HW_UART_TL7816(x).U)

/*! @brief Format value for bitfield UART_TL7816_TLEN. */
#define BF_UART_TL7816_TLEN(v) ((uint8_t)((uint8_t)(v) << BP_UART_TL7816_TLEN) & BM_UART_TL7816_TLEN)

/*! @brief Set the TLEN field to a new value. */
#define BW_UART_TL7816_TLEN(x, v) (HW_UART_TL7816_WR(x, v))
/*@}*/

/*
** Start of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma push
  #pragma anon_unions
#elif defined(__CWCC__)
  #pragma push
  #pragma cpp_extensions on
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=extended
#else
  #error Not supported compiler type
#endif

/*******************************************************************************
 * hw_uart_t - module struct
 ******************************************************************************/
/*!
 * @brief All UART module registers.
 */
#pragma pack(1)
typedef struct _hw_uart
{
    __IO hw_uart_bdh_t BDH;                /*!< [0x0] UART Baud Rate Registers: High */
    __IO hw_uart_bdl_t BDL;                /*!< [0x1] UART Baud Rate Registers: Low */
    __IO hw_uart_c1_t C1;                  /*!< [0x2] UART Control Register 1 */
    __IO hw_uart_c2_t C2;                  /*!< [0x3] UART Control Register 2 */
    __I hw_uart_s1_t S1;                   /*!< [0x4] UART Status Register 1 */
    __IO hw_uart_s2_t S2;                  /*!< [0x5] UART Status Register 2 */
    __IO hw_uart_c3_t C3;                  /*!< [0x6] UART Control Register 3 */
    __IO hw_uart_d_t D;                    /*!< [0x7] UART Data Register */
    __IO hw_uart_ma1_t MA1;                /*!< [0x8] UART Match Address Registers 1 */
    __IO hw_uart_ma2_t MA2;                /*!< [0x9] UART Match Address Registers 2 */
    __IO hw_uart_c4_t C4;                  /*!< [0xA] UART Control Register 4 */
    __IO hw_uart_c5_t C5;                  /*!< [0xB] UART Control Register 5 */
    __I hw_uart_ed_t ED;                   /*!< [0xC] UART Extended Data Register */
    __IO hw_uart_modem_t MODEM;            /*!< [0xD] UART Modem Register */
    __IO hw_uart_ir_t IR;                  /*!< [0xE] UART Infrared Register */
    uint8_t _reserved0[1];
    __IO hw_uart_pfifo_t PFIFO;            /*!< [0x10] UART FIFO Parameters */
    __IO hw_uart_cfifo_t CFIFO;            /*!< [0x11] UART FIFO Control Register */
    __IO hw_uart_sfifo_t SFIFO;            /*!< [0x12] UART FIFO Status Register */
    __IO hw_uart_twfifo_t TWFIFO;          /*!< [0x13] UART FIFO Transmit Watermark */
    __I hw_uart_tcfifo_t TCFIFO;           /*!< [0x14] UART FIFO Transmit Count */
    __IO hw_uart_rwfifo_t RWFIFO;          /*!< [0x15] UART FIFO Receive Watermark */
    __I hw_uart_rcfifo_t RCFIFO;           /*!< [0x16] UART FIFO Receive Count */
    uint8_t _reserved1[1];
    __IO hw_uart_c7816_t C7816;            /*!< [0x18] UART 7816 Control Register */
    __IO hw_uart_ie7816_t IE7816;          /*!< [0x19] UART 7816 Interrupt Enable Register */
    __IO hw_uart_is7816_t IS7816;          /*!< [0x1A] UART 7816 Interrupt Status Register */
    union {
        __IO hw_uart_wp7816t0_t WP7816T0;  /*!< [0x1B] UART 7816 Wait Parameter Register */
        __IO hw_uart_wp7816t1_t WP7816T1;  /*!< [0x1B] UART 7816 Wait Parameter Register */
    };
    __IO hw_uart_wn7816_t WN7816;          /*!< [0x1C] UART 7816 Wait N Register */
    __IO hw_uart_wf7816_t WF7816;          /*!< [0x1D] UART 7816 Wait FD Register */
    __IO hw_uart_et7816_t ET7816;          /*!< [0x1E] UART 7816 Error Threshold Register */
    __IO hw_uart_tl7816_t TL7816;          /*!< [0x1F] UART 7816 Transmit Length Register */
} hw_uart_t;
#pragma pack()

/*! @brief Macro to access all UART registers. */
/*! @param x UART module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_UART_REGS(UART0_BASE)</code>. */
#define HW_UART_REGS(x) (*(hw_uart_t *)(x))

/*
** End of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma pop
#elif defined(__CWCC__)
  #pragma pop
#elif defined(__GNUC__)
  /* leave anonymous unions enabled */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=default
#else
  #error Not supported compiler type
#endif

/*
 * MK64F12 USB
 *
 * Universal Serial Bus, OTG Capable Controller
 *
 * Registers defined in this header file:
 * - HW_USB_PERID - Peripheral ID register
 * - HW_USB_IDCOMP - Peripheral ID Complement register
 * - HW_USB_REV - Peripheral Revision register
 * - HW_USB_ADDINFO - Peripheral Additional Info register
 * - HW_USB_OTGISTAT - OTG Interrupt Status register
 * - HW_USB_OTGICR - OTG Interrupt Control register
 * - HW_USB_OTGSTAT - OTG Status register
 * - HW_USB_OTGCTL - OTG Control register
 * - HW_USB_ISTAT - Interrupt Status register
 * - HW_USB_INTEN - Interrupt Enable register
 * - HW_USB_ERRSTAT - Error Interrupt Status register
 * - HW_USB_ERREN - Error Interrupt Enable register
 * - HW_USB_STAT - Status register
 * - HW_USB_CTL - Control register
 * - HW_USB_ADDR - Address register
 * - HW_USB_BDTPAGE1 - BDT Page register 1
 * - HW_USB_FRMNUML - Frame Number register Low
 * - HW_USB_FRMNUMH - Frame Number register High
 * - HW_USB_TOKEN - Token register
 * - HW_USB_SOFTHLD - SOF Threshold register
 * - HW_USB_BDTPAGE2 - BDT Page Register 2
 * - HW_USB_BDTPAGE3 - BDT Page Register 3
 * - HW_USB_ENDPTn - Endpoint Control register
 * - HW_USB_USBCTRL - USB Control register
 * - HW_USB_OBSERVE - USB OTG Observe register
 * - HW_USB_CONTROL - USB OTG Control register
 * - HW_USB_USBTRC0 - USB Transceiver Control register 0
 * - HW_USB_USBFRMADJUST - Frame Adjust Register
 * - HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control
 * - HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 * - HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 *
 * - hw_usb_t - Struct containing all module registers.
 */

#define HW_USB_INSTANCE_COUNT (1U) /*!< Number of instances of the USB module. */
#define HW_USB0 (0U) /*!< Instance number for USB0. */

/*******************************************************************************
 * HW_USB_PERID - Peripheral ID register
 ******************************************************************************/

/*!
 * @brief HW_USB_PERID - Peripheral ID register (RO)
 *
 * Reset value: 0x04U
 *
 * Reads back the value of 0x04. This value is defined for the USB peripheral.
 */
typedef union _hw_usb_perid
{
    uint8_t U;
    struct _hw_usb_perid_bitfields
    {
        uint8_t ID : 6;                /*!< [5:0] Peripheral Identification */
        uint8_t RESERVED0 : 2;         /*!< [7:6]  */
    } B;
} hw_usb_perid_t;

/*!
 * @name Constants and macros for entire USB_PERID register
 */
/*@{*/
#define HW_USB_PERID_ADDR(x)     ((uint32_t)(x) + 0x0U)

#define HW_USB_PERID(x)          (*(__I hw_usb_perid_t *) HW_USB_PERID_ADDR(x))
#define HW_USB_PERID_RD(x)       (HW_USB_PERID(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_PERID bitfields
 */

/*!
 * @name Register USB_PERID, field ID[5:0] (RO)
 *
 * This field always reads 0x4h.
 */
/*@{*/
#define BP_USB_PERID_ID      (0U)          /*!< Bit position for USB_PERID_ID. */
#define BM_USB_PERID_ID      (0x3FU)       /*!< Bit mask for USB_PERID_ID. */
#define BS_USB_PERID_ID      (6U)          /*!< Bit field size in bits for USB_PERID_ID. */

/*! @brief Read current value of the USB_PERID_ID field. */
#define BR_USB_PERID_ID(x)   (HW_USB_PERID(x).B.ID)
/*@}*/

/*******************************************************************************
 * HW_USB_IDCOMP - Peripheral ID Complement register
 ******************************************************************************/

/*!
 * @brief HW_USB_IDCOMP - Peripheral ID Complement register (RO)
 *
 * Reset value: 0xFBU
 *
 * Reads back the complement of the Peripheral ID register. For the USB
 * peripheral, the value is 0xFB.
 */
typedef union _hw_usb_idcomp
{
    uint8_t U;
    struct _hw_usb_idcomp_bitfields
    {
        uint8_t NID : 6;               /*!< [5:0]  */
        uint8_t RESERVED0 : 2;         /*!< [7:6]  */
    } B;
} hw_usb_idcomp_t;

/*!
 * @name Constants and macros for entire USB_IDCOMP register
 */
/*@{*/
#define HW_USB_IDCOMP_ADDR(x)    ((uint32_t)(x) + 0x4U)

#define HW_USB_IDCOMP(x)         (*(__I hw_usb_idcomp_t *) HW_USB_IDCOMP_ADDR(x))
#define HW_USB_IDCOMP_RD(x)      (HW_USB_IDCOMP(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_IDCOMP bitfields
 */

/*!
 * @name Register USB_IDCOMP, field NID[5:0] (RO)
 *
 * Ones' complement of PERID[ID]. bits.
 */
/*@{*/
#define BP_USB_IDCOMP_NID    (0U)          /*!< Bit position for USB_IDCOMP_NID. */
#define BM_USB_IDCOMP_NID    (0x3FU)       /*!< Bit mask for USB_IDCOMP_NID. */
#define BS_USB_IDCOMP_NID    (6U)          /*!< Bit field size in bits for USB_IDCOMP_NID. */

/*! @brief Read current value of the USB_IDCOMP_NID field. */
#define BR_USB_IDCOMP_NID(x) (HW_USB_IDCOMP(x).B.NID)
/*@}*/

/*******************************************************************************
 * HW_USB_REV - Peripheral Revision register
 ******************************************************************************/

/*!
 * @brief HW_USB_REV - Peripheral Revision register (RO)
 *
 * Reset value: 0x33U
 *
 * Contains the revision number of the USB module.
 */
typedef union _hw_usb_rev
{
    uint8_t U;
    struct _hw_usb_rev_bitfields
    {
        uint8_t REV : 8;               /*!< [7:0] Revision */
    } B;
} hw_usb_rev_t;

/*!
 * @name Constants and macros for entire USB_REV register
 */
/*@{*/
#define HW_USB_REV_ADDR(x)       ((uint32_t)(x) + 0x8U)

#define HW_USB_REV(x)            (*(__I hw_usb_rev_t *) HW_USB_REV_ADDR(x))
#define HW_USB_REV_RD(x)         (HW_USB_REV(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_REV bitfields
 */

/*!
 * @name Register USB_REV, field REV[7:0] (RO)
 *
 * Indicates the revision number of the USB Core.
 */
/*@{*/
#define BP_USB_REV_REV       (0U)          /*!< Bit position for USB_REV_REV. */
#define BM_USB_REV_REV       (0xFFU)       /*!< Bit mask for USB_REV_REV. */
#define BS_USB_REV_REV       (8U)          /*!< Bit field size in bits for USB_REV_REV. */

/*! @brief Read current value of the USB_REV_REV field. */
#define BR_USB_REV_REV(x)    (HW_USB_REV(x).U)
/*@}*/

/*******************************************************************************
 * HW_USB_ADDINFO - Peripheral Additional Info register
 ******************************************************************************/

/*!
 * @brief HW_USB_ADDINFO - Peripheral Additional Info register (RO)
 *
 * Reset value: 0x01U
 *
 * Reads back the value of the fixed Interrupt Request Level (IRQNUM) along with
 * the Host Enable bit.
 */
typedef union _hw_usb_addinfo
{
    uint8_t U;
    struct _hw_usb_addinfo_bitfields
    {
        uint8_t IEHOST : 1;            /*!< [0]  */
        uint8_t RESERVED0 : 2;         /*!< [2:1]  */
        uint8_t IRQNUM : 5;            /*!< [7:3] Assigned Interrupt Request Number */
    } B;
} hw_usb_addinfo_t;

/*!
 * @name Constants and macros for entire USB_ADDINFO register
 */
/*@{*/
#define HW_USB_ADDINFO_ADDR(x)   ((uint32_t)(x) + 0xCU)

#define HW_USB_ADDINFO(x)        (*(__I hw_usb_addinfo_t *) HW_USB_ADDINFO_ADDR(x))
#define HW_USB_ADDINFO_RD(x)     (HW_USB_ADDINFO(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_ADDINFO bitfields
 */

/*!
 * @name Register USB_ADDINFO, field IEHOST[0] (RO)
 *
 * This bit is set if host mode is enabled.
 */
/*@{*/
#define BP_USB_ADDINFO_IEHOST (0U)         /*!< Bit position for USB_ADDINFO_IEHOST. */
#define BM_USB_ADDINFO_IEHOST (0x01U)      /*!< Bit mask for USB_ADDINFO_IEHOST. */
#define BS_USB_ADDINFO_IEHOST (1U)         /*!< Bit field size in bits for USB_ADDINFO_IEHOST. */

/*! @brief Read current value of the USB_ADDINFO_IEHOST field. */
#define BR_USB_ADDINFO_IEHOST(x) (BITBAND_ACCESS8(HW_USB_ADDINFO_ADDR(x), BP_USB_ADDINFO_IEHOST))
/*@}*/

/*!
 * @name Register USB_ADDINFO, field IRQNUM[7:3] (RO)
 */
/*@{*/
#define BP_USB_ADDINFO_IRQNUM (3U)         /*!< Bit position for USB_ADDINFO_IRQNUM. */
#define BM_USB_ADDINFO_IRQNUM (0xF8U)      /*!< Bit mask for USB_ADDINFO_IRQNUM. */
#define BS_USB_ADDINFO_IRQNUM (5U)         /*!< Bit field size in bits for USB_ADDINFO_IRQNUM. */

/*! @brief Read current value of the USB_ADDINFO_IRQNUM field. */
#define BR_USB_ADDINFO_IRQNUM(x) (HW_USB_ADDINFO(x).B.IRQNUM)
/*@}*/

/*******************************************************************************
 * HW_USB_OTGISTAT - OTG Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_OTGISTAT - OTG Interrupt Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Records changes of the ID sense and VBUS signals. Software can read this
 * register to determine the event that triggers an interrupt. Only bits that have
 * changed since the last software read are set. Writing a one to a bit clears the
 * associated interrupt.
 */
typedef union _hw_usb_otgistat
{
    uint8_t U;
    struct _hw_usb_otgistat_bitfields
    {
        uint8_t AVBUSCHG : 1;          /*!< [0]  */
        uint8_t RESERVED0 : 1;         /*!< [1]  */
        uint8_t B_SESS_CHG : 1;        /*!< [2]  */
        uint8_t SESSVLDCHG : 1;        /*!< [3]  */
        uint8_t RESERVED1 : 1;         /*!< [4]  */
        uint8_t LINE_STATE_CHG : 1;    /*!< [5]  */
        uint8_t ONEMSEC : 1;           /*!< [6]  */
        uint8_t IDCHG : 1;             /*!< [7]  */
    } B;
} hw_usb_otgistat_t;

/*!
 * @name Constants and macros for entire USB_OTGISTAT register
 */
/*@{*/
#define HW_USB_OTGISTAT_ADDR(x)  ((uint32_t)(x) + 0x10U)

#define HW_USB_OTGISTAT(x)       (*(__IO hw_usb_otgistat_t *) HW_USB_OTGISTAT_ADDR(x))
#define HW_USB_OTGISTAT_RD(x)    (HW_USB_OTGISTAT(x).U)
#define HW_USB_OTGISTAT_WR(x, v) (HW_USB_OTGISTAT(x).U = (v))
#define HW_USB_OTGISTAT_SET(x, v) (HW_USB_OTGISTAT_WR(x, HW_USB_OTGISTAT_RD(x) |  (v)))
#define HW_USB_OTGISTAT_CLR(x, v) (HW_USB_OTGISTAT_WR(x, HW_USB_OTGISTAT_RD(x) & ~(v)))
#define HW_USB_OTGISTAT_TOG(x, v) (HW_USB_OTGISTAT_WR(x, HW_USB_OTGISTAT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGISTAT bitfields
 */

/*!
 * @name Register USB_OTGISTAT, field AVBUSCHG[0] (RW)
 *
 * This bit is set when a change in VBUS is detected on an A device.
 */
/*@{*/
#define BP_USB_OTGISTAT_AVBUSCHG (0U)      /*!< Bit position for USB_OTGISTAT_AVBUSCHG. */
#define BM_USB_OTGISTAT_AVBUSCHG (0x01U)   /*!< Bit mask for USB_OTGISTAT_AVBUSCHG. */
#define BS_USB_OTGISTAT_AVBUSCHG (1U)      /*!< Bit field size in bits for USB_OTGISTAT_AVBUSCHG. */

/*! @brief Read current value of the USB_OTGISTAT_AVBUSCHG field. */
#define BR_USB_OTGISTAT_AVBUSCHG(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_AVBUSCHG))

/*! @brief Format value for bitfield USB_OTGISTAT_AVBUSCHG. */
#define BF_USB_OTGISTAT_AVBUSCHG(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_AVBUSCHG) & BM_USB_OTGISTAT_AVBUSCHG)

/*! @brief Set the AVBUSCHG field to a new value. */
#define BW_USB_OTGISTAT_AVBUSCHG(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_AVBUSCHG) = (v))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field B_SESS_CHG[2] (RW)
 *
 * This bit is set when a change in VBUS is detected on a B device.
 */
/*@{*/
#define BP_USB_OTGISTAT_B_SESS_CHG (2U)    /*!< Bit position for USB_OTGISTAT_B_SESS_CHG. */
#define BM_USB_OTGISTAT_B_SESS_CHG (0x04U) /*!< Bit mask for USB_OTGISTAT_B_SESS_CHG. */
#define BS_USB_OTGISTAT_B_SESS_CHG (1U)    /*!< Bit field size in bits for USB_OTGISTAT_B_SESS_CHG. */

/*! @brief Read current value of the USB_OTGISTAT_B_SESS_CHG field. */
#define BR_USB_OTGISTAT_B_SESS_CHG(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_B_SESS_CHG))

/*! @brief Format value for bitfield USB_OTGISTAT_B_SESS_CHG. */
#define BF_USB_OTGISTAT_B_SESS_CHG(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_B_SESS_CHG) & BM_USB_OTGISTAT_B_SESS_CHG)

/*! @brief Set the B_SESS_CHG field to a new value. */
#define BW_USB_OTGISTAT_B_SESS_CHG(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_B_SESS_CHG) = (v))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field SESSVLDCHG[3] (RW)
 *
 * This bit is set when a change in VBUS is detected indicating a session valid
 * or a session no longer valid.
 */
/*@{*/
#define BP_USB_OTGISTAT_SESSVLDCHG (3U)    /*!< Bit position for USB_OTGISTAT_SESSVLDCHG. */
#define BM_USB_OTGISTAT_SESSVLDCHG (0x08U) /*!< Bit mask for USB_OTGISTAT_SESSVLDCHG. */
#define BS_USB_OTGISTAT_SESSVLDCHG (1U)    /*!< Bit field size in bits for USB_OTGISTAT_SESSVLDCHG. */

/*! @brief Read current value of the USB_OTGISTAT_SESSVLDCHG field. */
#define BR_USB_OTGISTAT_SESSVLDCHG(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_SESSVLDCHG))

/*! @brief Format value for bitfield USB_OTGISTAT_SESSVLDCHG. */
#define BF_USB_OTGISTAT_SESSVLDCHG(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_SESSVLDCHG) & BM_USB_OTGISTAT_SESSVLDCHG)

/*! @brief Set the SESSVLDCHG field to a new value. */
#define BW_USB_OTGISTAT_SESSVLDCHG(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_SESSVLDCHG) = (v))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field LINE_STATE_CHG[5] (RW)
 *
 * This interrupt is set when the USB line state (CTL[SE0] and CTL[JSTATE] bits)
 * are stable without change for 1 millisecond, and the value of the line state
 * is different from the last time when the line state was stable. It is set on
 * transitions between SE0 and J-state, SE0 and K-state, and J-state and K-state.
 * Changes in J-state while SE0 is true do not cause an interrupt. This interrupt
 * can be used in detecting Reset, Resume, Connect, and Data Line Pulse
 * signaling.
 */
/*@{*/
#define BP_USB_OTGISTAT_LINE_STATE_CHG (5U) /*!< Bit position for USB_OTGISTAT_LINE_STATE_CHG. */
#define BM_USB_OTGISTAT_LINE_STATE_CHG (0x20U) /*!< Bit mask for USB_OTGISTAT_LINE_STATE_CHG. */
#define BS_USB_OTGISTAT_LINE_STATE_CHG (1U) /*!< Bit field size in bits for USB_OTGISTAT_LINE_STATE_CHG. */

/*! @brief Read current value of the USB_OTGISTAT_LINE_STATE_CHG field. */
#define BR_USB_OTGISTAT_LINE_STATE_CHG(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_LINE_STATE_CHG))

/*! @brief Format value for bitfield USB_OTGISTAT_LINE_STATE_CHG. */
#define BF_USB_OTGISTAT_LINE_STATE_CHG(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_LINE_STATE_CHG) & BM_USB_OTGISTAT_LINE_STATE_CHG)

/*! @brief Set the LINE_STATE_CHG field to a new value. */
#define BW_USB_OTGISTAT_LINE_STATE_CHG(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_LINE_STATE_CHG) = (v))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field ONEMSEC[6] (RW)
 *
 * This bit is set when the 1 millisecond timer expires. This bit stays asserted
 * until cleared by software. The interrupt must be serviced every millisecond
 * to avoid losing 1msec counts.
 */
/*@{*/
#define BP_USB_OTGISTAT_ONEMSEC (6U)       /*!< Bit position for USB_OTGISTAT_ONEMSEC. */
#define BM_USB_OTGISTAT_ONEMSEC (0x40U)    /*!< Bit mask for USB_OTGISTAT_ONEMSEC. */
#define BS_USB_OTGISTAT_ONEMSEC (1U)       /*!< Bit field size in bits for USB_OTGISTAT_ONEMSEC. */

/*! @brief Read current value of the USB_OTGISTAT_ONEMSEC field. */
#define BR_USB_OTGISTAT_ONEMSEC(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_ONEMSEC))

/*! @brief Format value for bitfield USB_OTGISTAT_ONEMSEC. */
#define BF_USB_OTGISTAT_ONEMSEC(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_ONEMSEC) & BM_USB_OTGISTAT_ONEMSEC)

/*! @brief Set the ONEMSEC field to a new value. */
#define BW_USB_OTGISTAT_ONEMSEC(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_ONEMSEC) = (v))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field IDCHG[7] (RW)
 *
 * This bit is set when a change in the ID Signal from the USB connector is
 * sensed.
 */
/*@{*/
#define BP_USB_OTGISTAT_IDCHG (7U)         /*!< Bit position for USB_OTGISTAT_IDCHG. */
#define BM_USB_OTGISTAT_IDCHG (0x80U)      /*!< Bit mask for USB_OTGISTAT_IDCHG. */
#define BS_USB_OTGISTAT_IDCHG (1U)         /*!< Bit field size in bits for USB_OTGISTAT_IDCHG. */

/*! @brief Read current value of the USB_OTGISTAT_IDCHG field. */
#define BR_USB_OTGISTAT_IDCHG(x) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_IDCHG))

/*! @brief Format value for bitfield USB_OTGISTAT_IDCHG. */
#define BF_USB_OTGISTAT_IDCHG(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGISTAT_IDCHG) & BM_USB_OTGISTAT_IDCHG)

/*! @brief Set the IDCHG field to a new value. */
#define BW_USB_OTGISTAT_IDCHG(x, v) (BITBAND_ACCESS8(HW_USB_OTGISTAT_ADDR(x), BP_USB_OTGISTAT_IDCHG) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_OTGICR - OTG Interrupt Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_OTGICR - OTG Interrupt Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Enables the corresponding interrupt status bits defined in the OTG Interrupt
 * Status Register.
 */
typedef union _hw_usb_otgicr
{
    uint8_t U;
    struct _hw_usb_otgicr_bitfields
    {
        uint8_t AVBUSEN : 1;           /*!< [0] A VBUS Valid Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [1]  */
        uint8_t BSESSEN : 1;           /*!< [2] B Session END Interrupt Enable */
        uint8_t SESSVLDEN : 1;         /*!< [3] Session Valid Interrupt Enable */
        uint8_t RESERVED1 : 1;         /*!< [4]  */
        uint8_t LINESTATEEN : 1;       /*!< [5] Line State Change Interrupt Enable
                                        * */
        uint8_t ONEMSECEN : 1;         /*!< [6] One Millisecond Interrupt Enable */
        uint8_t IDEN : 1;              /*!< [7] ID Interrupt Enable */
    } B;
} hw_usb_otgicr_t;

/*!
 * @name Constants and macros for entire USB_OTGICR register
 */
/*@{*/
#define HW_USB_OTGICR_ADDR(x)    ((uint32_t)(x) + 0x14U)

#define HW_USB_OTGICR(x)         (*(__IO hw_usb_otgicr_t *) HW_USB_OTGICR_ADDR(x))
#define HW_USB_OTGICR_RD(x)      (HW_USB_OTGICR(x).U)
#define HW_USB_OTGICR_WR(x, v)   (HW_USB_OTGICR(x).U = (v))
#define HW_USB_OTGICR_SET(x, v)  (HW_USB_OTGICR_WR(x, HW_USB_OTGICR_RD(x) |  (v)))
#define HW_USB_OTGICR_CLR(x, v)  (HW_USB_OTGICR_WR(x, HW_USB_OTGICR_RD(x) & ~(v)))
#define HW_USB_OTGICR_TOG(x, v)  (HW_USB_OTGICR_WR(x, HW_USB_OTGICR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGICR bitfields
 */

/*!
 * @name Register USB_OTGICR, field AVBUSEN[0] (RW)
 *
 * Values:
 * - 0 - Disables the AVBUSCHG interrupt.
 * - 1 - Enables the AVBUSCHG interrupt.
 */
/*@{*/
#define BP_USB_OTGICR_AVBUSEN (0U)         /*!< Bit position for USB_OTGICR_AVBUSEN. */
#define BM_USB_OTGICR_AVBUSEN (0x01U)      /*!< Bit mask for USB_OTGICR_AVBUSEN. */
#define BS_USB_OTGICR_AVBUSEN (1U)         /*!< Bit field size in bits for USB_OTGICR_AVBUSEN. */

/*! @brief Read current value of the USB_OTGICR_AVBUSEN field. */
#define BR_USB_OTGICR_AVBUSEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_AVBUSEN))

/*! @brief Format value for bitfield USB_OTGICR_AVBUSEN. */
#define BF_USB_OTGICR_AVBUSEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_AVBUSEN) & BM_USB_OTGICR_AVBUSEN)

/*! @brief Set the AVBUSEN field to a new value. */
#define BW_USB_OTGICR_AVBUSEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_AVBUSEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGICR, field BSESSEN[2] (RW)
 *
 * Values:
 * - 0 - Disables the B_SESS_CHG interrupt.
 * - 1 - Enables the B_SESS_CHG interrupt.
 */
/*@{*/
#define BP_USB_OTGICR_BSESSEN (2U)         /*!< Bit position for USB_OTGICR_BSESSEN. */
#define BM_USB_OTGICR_BSESSEN (0x04U)      /*!< Bit mask for USB_OTGICR_BSESSEN. */
#define BS_USB_OTGICR_BSESSEN (1U)         /*!< Bit field size in bits for USB_OTGICR_BSESSEN. */

/*! @brief Read current value of the USB_OTGICR_BSESSEN field. */
#define BR_USB_OTGICR_BSESSEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_BSESSEN))

/*! @brief Format value for bitfield USB_OTGICR_BSESSEN. */
#define BF_USB_OTGICR_BSESSEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_BSESSEN) & BM_USB_OTGICR_BSESSEN)

/*! @brief Set the BSESSEN field to a new value. */
#define BW_USB_OTGICR_BSESSEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_BSESSEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGICR, field SESSVLDEN[3] (RW)
 *
 * Values:
 * - 0 - Disables the SESSVLDCHG interrupt.
 * - 1 - Enables the SESSVLDCHG interrupt.
 */
/*@{*/
#define BP_USB_OTGICR_SESSVLDEN (3U)       /*!< Bit position for USB_OTGICR_SESSVLDEN. */
#define BM_USB_OTGICR_SESSVLDEN (0x08U)    /*!< Bit mask for USB_OTGICR_SESSVLDEN. */
#define BS_USB_OTGICR_SESSVLDEN (1U)       /*!< Bit field size in bits for USB_OTGICR_SESSVLDEN. */

/*! @brief Read current value of the USB_OTGICR_SESSVLDEN field. */
#define BR_USB_OTGICR_SESSVLDEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_SESSVLDEN))

/*! @brief Format value for bitfield USB_OTGICR_SESSVLDEN. */
#define BF_USB_OTGICR_SESSVLDEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_SESSVLDEN) & BM_USB_OTGICR_SESSVLDEN)

/*! @brief Set the SESSVLDEN field to a new value. */
#define BW_USB_OTGICR_SESSVLDEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_SESSVLDEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGICR, field LINESTATEEN[5] (RW)
 *
 * Values:
 * - 0 - Disables the LINE_STAT_CHG interrupt.
 * - 1 - Enables the LINE_STAT_CHG interrupt.
 */
/*@{*/
#define BP_USB_OTGICR_LINESTATEEN (5U)     /*!< Bit position for USB_OTGICR_LINESTATEEN. */
#define BM_USB_OTGICR_LINESTATEEN (0x20U)  /*!< Bit mask for USB_OTGICR_LINESTATEEN. */
#define BS_USB_OTGICR_LINESTATEEN (1U)     /*!< Bit field size in bits for USB_OTGICR_LINESTATEEN. */

/*! @brief Read current value of the USB_OTGICR_LINESTATEEN field. */
#define BR_USB_OTGICR_LINESTATEEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_LINESTATEEN))

/*! @brief Format value for bitfield USB_OTGICR_LINESTATEEN. */
#define BF_USB_OTGICR_LINESTATEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_LINESTATEEN) & BM_USB_OTGICR_LINESTATEEN)

/*! @brief Set the LINESTATEEN field to a new value. */
#define BW_USB_OTGICR_LINESTATEEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_LINESTATEEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGICR, field ONEMSECEN[6] (RW)
 *
 * Values:
 * - 0 - Diables the 1ms timer interrupt.
 * - 1 - Enables the 1ms timer interrupt.
 */
/*@{*/
#define BP_USB_OTGICR_ONEMSECEN (6U)       /*!< Bit position for USB_OTGICR_ONEMSECEN. */
#define BM_USB_OTGICR_ONEMSECEN (0x40U)    /*!< Bit mask for USB_OTGICR_ONEMSECEN. */
#define BS_USB_OTGICR_ONEMSECEN (1U)       /*!< Bit field size in bits for USB_OTGICR_ONEMSECEN. */

/*! @brief Read current value of the USB_OTGICR_ONEMSECEN field. */
#define BR_USB_OTGICR_ONEMSECEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_ONEMSECEN))

/*! @brief Format value for bitfield USB_OTGICR_ONEMSECEN. */
#define BF_USB_OTGICR_ONEMSECEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_ONEMSECEN) & BM_USB_OTGICR_ONEMSECEN)

/*! @brief Set the ONEMSECEN field to a new value. */
#define BW_USB_OTGICR_ONEMSECEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_ONEMSECEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGICR, field IDEN[7] (RW)
 *
 * Values:
 * - 0 - The ID interrupt is disabled
 * - 1 - The ID interrupt is enabled
 */
/*@{*/
#define BP_USB_OTGICR_IDEN   (7U)          /*!< Bit position for USB_OTGICR_IDEN. */
#define BM_USB_OTGICR_IDEN   (0x80U)       /*!< Bit mask for USB_OTGICR_IDEN. */
#define BS_USB_OTGICR_IDEN   (1U)          /*!< Bit field size in bits for USB_OTGICR_IDEN. */

/*! @brief Read current value of the USB_OTGICR_IDEN field. */
#define BR_USB_OTGICR_IDEN(x) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_IDEN))

/*! @brief Format value for bitfield USB_OTGICR_IDEN. */
#define BF_USB_OTGICR_IDEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGICR_IDEN) & BM_USB_OTGICR_IDEN)

/*! @brief Set the IDEN field to a new value. */
#define BW_USB_OTGICR_IDEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGICR_ADDR(x), BP_USB_OTGICR_IDEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_OTGSTAT - OTG Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_OTGSTAT - OTG Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Displays the actual value from the external comparator outputs of the ID pin
 * and VBUS.
 */
typedef union _hw_usb_otgstat
{
    uint8_t U;
    struct _hw_usb_otgstat_bitfields
    {
        uint8_t AVBUSVLD : 1;          /*!< [0] A VBUS Valid */
        uint8_t RESERVED0 : 1;         /*!< [1]  */
        uint8_t BSESSEND : 1;          /*!< [2] B Session End */
        uint8_t SESS_VLD : 1;          /*!< [3] Session Valid */
        uint8_t RESERVED1 : 1;         /*!< [4]  */
        uint8_t LINESTATESTABLE : 1;   /*!< [5]  */
        uint8_t ONEMSECEN : 1;         /*!< [6]  */
        uint8_t ID : 1;                /*!< [7]  */
    } B;
} hw_usb_otgstat_t;

/*!
 * @name Constants and macros for entire USB_OTGSTAT register
 */
/*@{*/
#define HW_USB_OTGSTAT_ADDR(x)   ((uint32_t)(x) + 0x18U)

#define HW_USB_OTGSTAT(x)        (*(__IO hw_usb_otgstat_t *) HW_USB_OTGSTAT_ADDR(x))
#define HW_USB_OTGSTAT_RD(x)     (HW_USB_OTGSTAT(x).U)
#define HW_USB_OTGSTAT_WR(x, v)  (HW_USB_OTGSTAT(x).U = (v))
#define HW_USB_OTGSTAT_SET(x, v) (HW_USB_OTGSTAT_WR(x, HW_USB_OTGSTAT_RD(x) |  (v)))
#define HW_USB_OTGSTAT_CLR(x, v) (HW_USB_OTGSTAT_WR(x, HW_USB_OTGSTAT_RD(x) & ~(v)))
#define HW_USB_OTGSTAT_TOG(x, v) (HW_USB_OTGSTAT_WR(x, HW_USB_OTGSTAT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGSTAT bitfields
 */

/*!
 * @name Register USB_OTGSTAT, field AVBUSVLD[0] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is below the A VBUS Valid threshold.
 * - 1 - The VBUS voltage is above the A VBUS Valid threshold.
 */
/*@{*/
#define BP_USB_OTGSTAT_AVBUSVLD (0U)       /*!< Bit position for USB_OTGSTAT_AVBUSVLD. */
#define BM_USB_OTGSTAT_AVBUSVLD (0x01U)    /*!< Bit mask for USB_OTGSTAT_AVBUSVLD. */
#define BS_USB_OTGSTAT_AVBUSVLD (1U)       /*!< Bit field size in bits for USB_OTGSTAT_AVBUSVLD. */

/*! @brief Read current value of the USB_OTGSTAT_AVBUSVLD field. */
#define BR_USB_OTGSTAT_AVBUSVLD(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_AVBUSVLD))

/*! @brief Format value for bitfield USB_OTGSTAT_AVBUSVLD. */
#define BF_USB_OTGSTAT_AVBUSVLD(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_AVBUSVLD) & BM_USB_OTGSTAT_AVBUSVLD)

/*! @brief Set the AVBUSVLD field to a new value. */
#define BW_USB_OTGSTAT_AVBUSVLD(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_AVBUSVLD) = (v))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field BSESSEND[2] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is above the B session end threshold.
 * - 1 - The VBUS voltage is below the B session end threshold.
 */
/*@{*/
#define BP_USB_OTGSTAT_BSESSEND (2U)       /*!< Bit position for USB_OTGSTAT_BSESSEND. */
#define BM_USB_OTGSTAT_BSESSEND (0x04U)    /*!< Bit mask for USB_OTGSTAT_BSESSEND. */
#define BS_USB_OTGSTAT_BSESSEND (1U)       /*!< Bit field size in bits for USB_OTGSTAT_BSESSEND. */

/*! @brief Read current value of the USB_OTGSTAT_BSESSEND field. */
#define BR_USB_OTGSTAT_BSESSEND(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_BSESSEND))

/*! @brief Format value for bitfield USB_OTGSTAT_BSESSEND. */
#define BF_USB_OTGSTAT_BSESSEND(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_BSESSEND) & BM_USB_OTGSTAT_BSESSEND)

/*! @brief Set the BSESSEND field to a new value. */
#define BW_USB_OTGSTAT_BSESSEND(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_BSESSEND) = (v))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field SESS_VLD[3] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is below the B session valid threshold
 * - 1 - The VBUS voltage is above the B session valid threshold.
 */
/*@{*/
#define BP_USB_OTGSTAT_SESS_VLD (3U)       /*!< Bit position for USB_OTGSTAT_SESS_VLD. */
#define BM_USB_OTGSTAT_SESS_VLD (0x08U)    /*!< Bit mask for USB_OTGSTAT_SESS_VLD. */
#define BS_USB_OTGSTAT_SESS_VLD (1U)       /*!< Bit field size in bits for USB_OTGSTAT_SESS_VLD. */

/*! @brief Read current value of the USB_OTGSTAT_SESS_VLD field. */
#define BR_USB_OTGSTAT_SESS_VLD(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_SESS_VLD))

/*! @brief Format value for bitfield USB_OTGSTAT_SESS_VLD. */
#define BF_USB_OTGSTAT_SESS_VLD(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_SESS_VLD) & BM_USB_OTGSTAT_SESS_VLD)

/*! @brief Set the SESS_VLD field to a new value. */
#define BW_USB_OTGSTAT_SESS_VLD(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_SESS_VLD) = (v))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field LINESTATESTABLE[5] (RW)
 *
 * Indicates that the internal signals that control the LINE_STATE_CHG field of
 * OTGISTAT are stable for at least 1 millisecond. First read LINE_STATE_CHG
 * field and then read this field. If this field reads as 1, then the value of
 * LINE_STATE_CHG can be considered stable.
 *
 * Values:
 * - 0 - The LINE_STAT_CHG bit is not yet stable.
 * - 1 - The LINE_STAT_CHG bit has been debounced and is stable.
 */
/*@{*/
#define BP_USB_OTGSTAT_LINESTATESTABLE (5U) /*!< Bit position for USB_OTGSTAT_LINESTATESTABLE. */
#define BM_USB_OTGSTAT_LINESTATESTABLE (0x20U) /*!< Bit mask for USB_OTGSTAT_LINESTATESTABLE. */
#define BS_USB_OTGSTAT_LINESTATESTABLE (1U) /*!< Bit field size in bits for USB_OTGSTAT_LINESTATESTABLE. */

/*! @brief Read current value of the USB_OTGSTAT_LINESTATESTABLE field. */
#define BR_USB_OTGSTAT_LINESTATESTABLE(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_LINESTATESTABLE))

/*! @brief Format value for bitfield USB_OTGSTAT_LINESTATESTABLE. */
#define BF_USB_OTGSTAT_LINESTATESTABLE(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_LINESTATESTABLE) & BM_USB_OTGSTAT_LINESTATESTABLE)

/*! @brief Set the LINESTATESTABLE field to a new value. */
#define BW_USB_OTGSTAT_LINESTATESTABLE(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_LINESTATESTABLE) = (v))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field ONEMSECEN[6] (RW)
 *
 * This bit is reserved for the 1ms count, but it is not useful to software.
 */
/*@{*/
#define BP_USB_OTGSTAT_ONEMSECEN (6U)      /*!< Bit position for USB_OTGSTAT_ONEMSECEN. */
#define BM_USB_OTGSTAT_ONEMSECEN (0x40U)   /*!< Bit mask for USB_OTGSTAT_ONEMSECEN. */
#define BS_USB_OTGSTAT_ONEMSECEN (1U)      /*!< Bit field size in bits for USB_OTGSTAT_ONEMSECEN. */

/*! @brief Read current value of the USB_OTGSTAT_ONEMSECEN field. */
#define BR_USB_OTGSTAT_ONEMSECEN(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_ONEMSECEN))

/*! @brief Format value for bitfield USB_OTGSTAT_ONEMSECEN. */
#define BF_USB_OTGSTAT_ONEMSECEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_ONEMSECEN) & BM_USB_OTGSTAT_ONEMSECEN)

/*! @brief Set the ONEMSECEN field to a new value. */
#define BW_USB_OTGSTAT_ONEMSECEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_ONEMSECEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field ID[7] (RW)
 *
 * Indicates the current state of the ID pin on the USB connector
 *
 * Values:
 * - 0 - Indicates a Type A cable is plugged into the USB connector.
 * - 1 - Indicates no cable is attached or a Type B cable is plugged into the
 *     USB connector.
 */
/*@{*/
#define BP_USB_OTGSTAT_ID    (7U)          /*!< Bit position for USB_OTGSTAT_ID. */
#define BM_USB_OTGSTAT_ID    (0x80U)       /*!< Bit mask for USB_OTGSTAT_ID. */
#define BS_USB_OTGSTAT_ID    (1U)          /*!< Bit field size in bits for USB_OTGSTAT_ID. */

/*! @brief Read current value of the USB_OTGSTAT_ID field. */
#define BR_USB_OTGSTAT_ID(x) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_ID))

/*! @brief Format value for bitfield USB_OTGSTAT_ID. */
#define BF_USB_OTGSTAT_ID(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGSTAT_ID) & BM_USB_OTGSTAT_ID)

/*! @brief Set the ID field to a new value. */
#define BW_USB_OTGSTAT_ID(x, v) (BITBAND_ACCESS8(HW_USB_OTGSTAT_ADDR(x), BP_USB_OTGSTAT_ID) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_OTGCTL - OTG Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_OTGCTL - OTG Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Controls the operation of VBUS and Data Line termination resistors.
 */
typedef union _hw_usb_otgctl
{
    uint8_t U;
    struct _hw_usb_otgctl_bitfields
    {
        uint8_t RESERVED0 : 2;         /*!< [1:0]  */
        uint8_t OTGEN : 1;             /*!< [2] On-The-Go pullup/pulldown resistor enable
                                        * */
        uint8_t RESERVED1 : 1;         /*!< [3]  */
        uint8_t DMLOW : 1;             /*!< [4] D- Data Line pull-down resistor enable */
        uint8_t DPLOW : 1;             /*!< [5] D+ Data Line pull-down resistor enable */
        uint8_t RESERVED2 : 1;         /*!< [6]  */
        uint8_t DPHIGH : 1;            /*!< [7] D+ Data Line pullup resistor enable */
    } B;
} hw_usb_otgctl_t;

/*!
 * @name Constants and macros for entire USB_OTGCTL register
 */
/*@{*/
#define HW_USB_OTGCTL_ADDR(x)    ((uint32_t)(x) + 0x1CU)

#define HW_USB_OTGCTL(x)         (*(__IO hw_usb_otgctl_t *) HW_USB_OTGCTL_ADDR(x))
#define HW_USB_OTGCTL_RD(x)      (HW_USB_OTGCTL(x).U)
#define HW_USB_OTGCTL_WR(x, v)   (HW_USB_OTGCTL(x).U = (v))
#define HW_USB_OTGCTL_SET(x, v)  (HW_USB_OTGCTL_WR(x, HW_USB_OTGCTL_RD(x) |  (v)))
#define HW_USB_OTGCTL_CLR(x, v)  (HW_USB_OTGCTL_WR(x, HW_USB_OTGCTL_RD(x) & ~(v)))
#define HW_USB_OTGCTL_TOG(x, v)  (HW_USB_OTGCTL_WR(x, HW_USB_OTGCTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGCTL bitfields
 */

/*!
 * @name Register USB_OTGCTL, field OTGEN[2] (RW)
 *
 * Values:
 * - 0 - If USB_EN is 1 and HOST_MODE is 0 in the Control Register (CTL), then
 *     the D+ Data Line pull-up resistors are enabled. If HOST_MODE is 1 the D+
 *     and D- Data Line pull-down resistors are engaged.
 * - 1 - The pull-up and pull-down controls in this register are used.
 */
/*@{*/
#define BP_USB_OTGCTL_OTGEN  (2U)          /*!< Bit position for USB_OTGCTL_OTGEN. */
#define BM_USB_OTGCTL_OTGEN  (0x04U)       /*!< Bit mask for USB_OTGCTL_OTGEN. */
#define BS_USB_OTGCTL_OTGEN  (1U)          /*!< Bit field size in bits for USB_OTGCTL_OTGEN. */

/*! @brief Read current value of the USB_OTGCTL_OTGEN field. */
#define BR_USB_OTGCTL_OTGEN(x) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_OTGEN))

/*! @brief Format value for bitfield USB_OTGCTL_OTGEN. */
#define BF_USB_OTGCTL_OTGEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGCTL_OTGEN) & BM_USB_OTGCTL_OTGEN)

/*! @brief Set the OTGEN field to a new value. */
#define BW_USB_OTGCTL_OTGEN(x, v) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_OTGEN) = (v))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DMLOW[4] (RW)
 *
 * Values:
 * - 0 - D- pulldown resistor is not enabled.
 * - 1 - D- pulldown resistor is enabled.
 */
/*@{*/
#define BP_USB_OTGCTL_DMLOW  (4U)          /*!< Bit position for USB_OTGCTL_DMLOW. */
#define BM_USB_OTGCTL_DMLOW  (0x10U)       /*!< Bit mask for USB_OTGCTL_DMLOW. */
#define BS_USB_OTGCTL_DMLOW  (1U)          /*!< Bit field size in bits for USB_OTGCTL_DMLOW. */

/*! @brief Read current value of the USB_OTGCTL_DMLOW field. */
#define BR_USB_OTGCTL_DMLOW(x) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DMLOW))

/*! @brief Format value for bitfield USB_OTGCTL_DMLOW. */
#define BF_USB_OTGCTL_DMLOW(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGCTL_DMLOW) & BM_USB_OTGCTL_DMLOW)

/*! @brief Set the DMLOW field to a new value. */
#define BW_USB_OTGCTL_DMLOW(x, v) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DMLOW) = (v))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DPLOW[5] (RW)
 *
 * This bit should always be enabled together with bit 4 (DMLOW)
 *
 * Values:
 * - 0 - D+ pulldown resistor is not enabled.
 * - 1 - D+ pulldown resistor is enabled.
 */
/*@{*/
#define BP_USB_OTGCTL_DPLOW  (5U)          /*!< Bit position for USB_OTGCTL_DPLOW. */
#define BM_USB_OTGCTL_DPLOW  (0x20U)       /*!< Bit mask for USB_OTGCTL_DPLOW. */
#define BS_USB_OTGCTL_DPLOW  (1U)          /*!< Bit field size in bits for USB_OTGCTL_DPLOW. */

/*! @brief Read current value of the USB_OTGCTL_DPLOW field. */
#define BR_USB_OTGCTL_DPLOW(x) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DPLOW))

/*! @brief Format value for bitfield USB_OTGCTL_DPLOW. */
#define BF_USB_OTGCTL_DPLOW(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGCTL_DPLOW) & BM_USB_OTGCTL_DPLOW)

/*! @brief Set the DPLOW field to a new value. */
#define BW_USB_OTGCTL_DPLOW(x, v) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DPLOW) = (v))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DPHIGH[7] (RW)
 *
 * Values:
 * - 0 - D+ pullup resistor is not enabled
 * - 1 - D+ pullup resistor is enabled
 */
/*@{*/
#define BP_USB_OTGCTL_DPHIGH (7U)          /*!< Bit position for USB_OTGCTL_DPHIGH. */
#define BM_USB_OTGCTL_DPHIGH (0x80U)       /*!< Bit mask for USB_OTGCTL_DPHIGH. */
#define BS_USB_OTGCTL_DPHIGH (1U)          /*!< Bit field size in bits for USB_OTGCTL_DPHIGH. */

/*! @brief Read current value of the USB_OTGCTL_DPHIGH field. */
#define BR_USB_OTGCTL_DPHIGH(x) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DPHIGH))

/*! @brief Format value for bitfield USB_OTGCTL_DPHIGH. */
#define BF_USB_OTGCTL_DPHIGH(v) ((uint8_t)((uint8_t)(v) << BP_USB_OTGCTL_DPHIGH) & BM_USB_OTGCTL_DPHIGH)

/*! @brief Set the DPHIGH field to a new value. */
#define BW_USB_OTGCTL_DPHIGH(x, v) (BITBAND_ACCESS8(HW_USB_OTGCTL_ADDR(x), BP_USB_OTGCTL_DPHIGH) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_ISTAT - Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_ISTAT - Interrupt Status register (W1C)
 *
 * Reset value: 0x00U
 *
 * Contains fields for each of the interrupt sources within the USB Module. Each
 * of these fields are qualified with their respective interrupt enable bits.
 * All fields of this register are logically OR'd together along with the OTG
 * Interrupt Status Register (OTGSTAT) to form a single interrupt source for the
 * processor's interrupt controller. After an interrupt bit has been set it may only
 * be cleared by writing a one to the respective interrupt bit. This register
 * contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_istat
{
    uint8_t U;
    struct _hw_usb_istat_bitfields
    {
        uint8_t USBRST : 1;            /*!< [0]  */
        uint8_t ERROR : 1;             /*!< [1]  */
        uint8_t SOFTOK : 1;            /*!< [2]  */
        uint8_t TOKDNE : 1;            /*!< [3]  */
        uint8_t SLEEP : 1;             /*!< [4]  */
        uint8_t RESUME : 1;            /*!< [5]  */
        uint8_t ATTACH : 1;            /*!< [6] Attach Interrupt */
        uint8_t STALL : 1;             /*!< [7] Stall Interrupt */
    } B;
} hw_usb_istat_t;

/*!
 * @name Constants and macros for entire USB_ISTAT register
 */
/*@{*/
#define HW_USB_ISTAT_ADDR(x)     ((uint32_t)(x) + 0x80U)

#define HW_USB_ISTAT(x)          (*(__IO hw_usb_istat_t *) HW_USB_ISTAT_ADDR(x))
#define HW_USB_ISTAT_RD(x)       (HW_USB_ISTAT(x).U)
#define HW_USB_ISTAT_WR(x, v)    (HW_USB_ISTAT(x).U = (v))
#define HW_USB_ISTAT_SET(x, v)   (HW_USB_ISTAT_WR(x, HW_USB_ISTAT_RD(x) |  (v)))
#define HW_USB_ISTAT_CLR(x, v)   (HW_USB_ISTAT_WR(x, HW_USB_ISTAT_RD(x) & ~(v)))
#define HW_USB_ISTAT_TOG(x, v)   (HW_USB_ISTAT_WR(x, HW_USB_ISTAT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_ISTAT bitfields
 */

/*!
 * @name Register USB_ISTAT, field USBRST[0] (W1C)
 *
 * This bit is set when the USB Module has decoded a valid USB reset. This
 * informs the processor that it should write 0x00 into the address register and
 * enable endpoint 0. USBRST is set after a USB reset has been detected for 2.5
 * microseconds. It is not asserted again until the USB reset condition has been
 * removed and then reasserted.
 */
/*@{*/
#define BP_USB_ISTAT_USBRST  (0U)          /*!< Bit position for USB_ISTAT_USBRST. */
#define BM_USB_ISTAT_USBRST  (0x01U)       /*!< Bit mask for USB_ISTAT_USBRST. */
#define BS_USB_ISTAT_USBRST  (1U)          /*!< Bit field size in bits for USB_ISTAT_USBRST. */

/*! @brief Read current value of the USB_ISTAT_USBRST field. */
#define BR_USB_ISTAT_USBRST(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_USBRST))

/*! @brief Format value for bitfield USB_ISTAT_USBRST. */
#define BF_USB_ISTAT_USBRST(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_USBRST) & BM_USB_ISTAT_USBRST)

/*! @brief Set the USBRST field to a new value. */
#define BW_USB_ISTAT_USBRST(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_USBRST) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ERROR[1] (W1C)
 *
 * This bit is set when any of the error conditions within Error Interrupt
 * Status (ERRSTAT) register occur. The processor must then read the ERRSTAT register
 * to determine the source of the error.
 */
/*@{*/
#define BP_USB_ISTAT_ERROR   (1U)          /*!< Bit position for USB_ISTAT_ERROR. */
#define BM_USB_ISTAT_ERROR   (0x02U)       /*!< Bit mask for USB_ISTAT_ERROR. */
#define BS_USB_ISTAT_ERROR   (1U)          /*!< Bit field size in bits for USB_ISTAT_ERROR. */

/*! @brief Read current value of the USB_ISTAT_ERROR field. */
#define BR_USB_ISTAT_ERROR(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_ERROR))

/*! @brief Format value for bitfield USB_ISTAT_ERROR. */
#define BF_USB_ISTAT_ERROR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_ERROR) & BM_USB_ISTAT_ERROR)

/*! @brief Set the ERROR field to a new value. */
#define BW_USB_ISTAT_ERROR(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_ERROR) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SOFTOK[2] (W1C)
 *
 * This bit is set when the USB Module receives a Start Of Frame (SOF) token. In
 * Host mode this field is set when the SOF threshold is reached, so that
 * software can prepare for the next SOF.
 */
/*@{*/
#define BP_USB_ISTAT_SOFTOK  (2U)          /*!< Bit position for USB_ISTAT_SOFTOK. */
#define BM_USB_ISTAT_SOFTOK  (0x04U)       /*!< Bit mask for USB_ISTAT_SOFTOK. */
#define BS_USB_ISTAT_SOFTOK  (1U)          /*!< Bit field size in bits for USB_ISTAT_SOFTOK. */

/*! @brief Read current value of the USB_ISTAT_SOFTOK field. */
#define BR_USB_ISTAT_SOFTOK(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SOFTOK))

/*! @brief Format value for bitfield USB_ISTAT_SOFTOK. */
#define BF_USB_ISTAT_SOFTOK(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_SOFTOK) & BM_USB_ISTAT_SOFTOK)

/*! @brief Set the SOFTOK field to a new value. */
#define BW_USB_ISTAT_SOFTOK(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SOFTOK) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field TOKDNE[3] (W1C)
 *
 * This bit is set when the current token being processed has completed. The
 * processor must immediately read the STATUS (STAT) register to determine the
 * EndPoint and BD used for this token. Clearing this bit (by writing a one) causes
 * STAT to be cleared or the STAT holding register to be loaded into the STAT
 * register.
 */
/*@{*/
#define BP_USB_ISTAT_TOKDNE  (3U)          /*!< Bit position for USB_ISTAT_TOKDNE. */
#define BM_USB_ISTAT_TOKDNE  (0x08U)       /*!< Bit mask for USB_ISTAT_TOKDNE. */
#define BS_USB_ISTAT_TOKDNE  (1U)          /*!< Bit field size in bits for USB_ISTAT_TOKDNE. */

/*! @brief Read current value of the USB_ISTAT_TOKDNE field. */
#define BR_USB_ISTAT_TOKDNE(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_TOKDNE))

/*! @brief Format value for bitfield USB_ISTAT_TOKDNE. */
#define BF_USB_ISTAT_TOKDNE(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_TOKDNE) & BM_USB_ISTAT_TOKDNE)

/*! @brief Set the TOKDNE field to a new value. */
#define BW_USB_ISTAT_TOKDNE(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_TOKDNE) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SLEEP[4] (W1C)
 *
 * This bit is set when the USB Module detects a constant idle on the USB bus
 * for 3 ms. The sleep timer is reset by activity on the USB bus.
 */
/*@{*/
#define BP_USB_ISTAT_SLEEP   (4U)          /*!< Bit position for USB_ISTAT_SLEEP. */
#define BM_USB_ISTAT_SLEEP   (0x10U)       /*!< Bit mask for USB_ISTAT_SLEEP. */
#define BS_USB_ISTAT_SLEEP   (1U)          /*!< Bit field size in bits for USB_ISTAT_SLEEP. */

/*! @brief Read current value of the USB_ISTAT_SLEEP field. */
#define BR_USB_ISTAT_SLEEP(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SLEEP))

/*! @brief Format value for bitfield USB_ISTAT_SLEEP. */
#define BF_USB_ISTAT_SLEEP(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_SLEEP) & BM_USB_ISTAT_SLEEP)

/*! @brief Set the SLEEP field to a new value. */
#define BW_USB_ISTAT_SLEEP(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_SLEEP) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field RESUME[5] (W1C)
 *
 * This bit is set when a K-state is observed on the DP/DM signals for 2.5 us.
 * When not in suspend mode this interrupt must be disabled.
 */
/*@{*/
#define BP_USB_ISTAT_RESUME  (5U)          /*!< Bit position for USB_ISTAT_RESUME. */
#define BM_USB_ISTAT_RESUME  (0x20U)       /*!< Bit mask for USB_ISTAT_RESUME. */
#define BS_USB_ISTAT_RESUME  (1U)          /*!< Bit field size in bits for USB_ISTAT_RESUME. */

/*! @brief Read current value of the USB_ISTAT_RESUME field. */
#define BR_USB_ISTAT_RESUME(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_RESUME))

/*! @brief Format value for bitfield USB_ISTAT_RESUME. */
#define BF_USB_ISTAT_RESUME(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_RESUME) & BM_USB_ISTAT_RESUME)

/*! @brief Set the RESUME field to a new value. */
#define BW_USB_ISTAT_RESUME(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_RESUME) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ATTACH[6] (W1C)
 *
 * This bit is set when the USB Module detects an attach of a USB device. This
 * signal is only valid if HOSTMODEEN is true. This interrupt signifies that a
 * peripheral is now present and must be configured; it is asserted if there have
 * been no transitions on the USB for 2.5 us and the current bus state is not SE0."
 */
/*@{*/
#define BP_USB_ISTAT_ATTACH  (6U)          /*!< Bit position for USB_ISTAT_ATTACH. */
#define BM_USB_ISTAT_ATTACH  (0x40U)       /*!< Bit mask for USB_ISTAT_ATTACH. */
#define BS_USB_ISTAT_ATTACH  (1U)          /*!< Bit field size in bits for USB_ISTAT_ATTACH. */

/*! @brief Read current value of the USB_ISTAT_ATTACH field. */
#define BR_USB_ISTAT_ATTACH(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_ATTACH))

/*! @brief Format value for bitfield USB_ISTAT_ATTACH. */
#define BF_USB_ISTAT_ATTACH(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_ATTACH) & BM_USB_ISTAT_ATTACH)

/*! @brief Set the ATTACH field to a new value. */
#define BW_USB_ISTAT_ATTACH(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_ATTACH) = (v))
/*@}*/

/*!
 * @name Register USB_ISTAT, field STALL[7] (W1C)
 *
 * In Target mode this bit is asserted when a STALL handshake is sent by the
 * SIE. In Host mode this bit is set when the USB Module detects a STALL acknowledge
 * during the handshake phase of a USB transaction.This interrupt can be used to
 * determine whether the last USB transaction was completed successfully or
 * stalled.
 */
/*@{*/
#define BP_USB_ISTAT_STALL   (7U)          /*!< Bit position for USB_ISTAT_STALL. */
#define BM_USB_ISTAT_STALL   (0x80U)       /*!< Bit mask for USB_ISTAT_STALL. */
#define BS_USB_ISTAT_STALL   (1U)          /*!< Bit field size in bits for USB_ISTAT_STALL. */

/*! @brief Read current value of the USB_ISTAT_STALL field. */
#define BR_USB_ISTAT_STALL(x) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_STALL))

/*! @brief Format value for bitfield USB_ISTAT_STALL. */
#define BF_USB_ISTAT_STALL(v) ((uint8_t)((uint8_t)(v) << BP_USB_ISTAT_STALL) & BM_USB_ISTAT_STALL)

/*! @brief Set the STALL field to a new value. */
#define BW_USB_ISTAT_STALL(x, v) (BITBAND_ACCESS8(HW_USB_ISTAT_ADDR(x), BP_USB_ISTAT_STALL) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_INTEN - Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_INTEN - Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable fields for each of the interrupt sources within the USB
 * Module. Setting any of these bits enables the respective interrupt source in the
 * ISTAT register. This register contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_inten
{
    uint8_t U;
    struct _hw_usb_inten_bitfields
    {
        uint8_t USBRSTEN : 1;          /*!< [0] USBRST Interrupt Enable */
        uint8_t ERROREN : 1;           /*!< [1] ERROR Interrupt Enable */
        uint8_t SOFTOKEN : 1;          /*!< [2] SOFTOK Interrupt Enable */
        uint8_t TOKDNEEN : 1;          /*!< [3] TOKDNE Interrupt Enable */
        uint8_t SLEEPEN : 1;           /*!< [4] SLEEP Interrupt Enable */
        uint8_t RESUMEEN : 1;          /*!< [5] RESUME Interrupt Enable */
        uint8_t ATTACHEN : 1;          /*!< [6] ATTACH Interrupt Enable */
        uint8_t STALLEN : 1;           /*!< [7] STALL Interrupt Enable */
    } B;
} hw_usb_inten_t;

/*!
 * @name Constants and macros for entire USB_INTEN register
 */
/*@{*/
#define HW_USB_INTEN_ADDR(x)     ((uint32_t)(x) + 0x84U)

#define HW_USB_INTEN(x)          (*(__IO hw_usb_inten_t *) HW_USB_INTEN_ADDR(x))
#define HW_USB_INTEN_RD(x)       (HW_USB_INTEN(x).U)
#define HW_USB_INTEN_WR(x, v)    (HW_USB_INTEN(x).U = (v))
#define HW_USB_INTEN_SET(x, v)   (HW_USB_INTEN_WR(x, HW_USB_INTEN_RD(x) |  (v)))
#define HW_USB_INTEN_CLR(x, v)   (HW_USB_INTEN_WR(x, HW_USB_INTEN_RD(x) & ~(v)))
#define HW_USB_INTEN_TOG(x, v)   (HW_USB_INTEN_WR(x, HW_USB_INTEN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_INTEN bitfields
 */

/*!
 * @name Register USB_INTEN, field USBRSTEN[0] (RW)
 *
 * Values:
 * - 0 - Disables the USBRST interrupt.
 * - 1 - Enables the USBRST interrupt.
 */
/*@{*/
#define BP_USB_INTEN_USBRSTEN (0U)         /*!< Bit position for USB_INTEN_USBRSTEN. */
#define BM_USB_INTEN_USBRSTEN (0x01U)      /*!< Bit mask for USB_INTEN_USBRSTEN. */
#define BS_USB_INTEN_USBRSTEN (1U)         /*!< Bit field size in bits for USB_INTEN_USBRSTEN. */

/*! @brief Read current value of the USB_INTEN_USBRSTEN field. */
#define BR_USB_INTEN_USBRSTEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_USBRSTEN))

/*! @brief Format value for bitfield USB_INTEN_USBRSTEN. */
#define BF_USB_INTEN_USBRSTEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_USBRSTEN) & BM_USB_INTEN_USBRSTEN)

/*! @brief Set the USBRSTEN field to a new value. */
#define BW_USB_INTEN_USBRSTEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_USBRSTEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field ERROREN[1] (RW)
 *
 * Values:
 * - 0 - Disables the ERROR interrupt.
 * - 1 - Enables the ERROR interrupt.
 */
/*@{*/
#define BP_USB_INTEN_ERROREN (1U)          /*!< Bit position for USB_INTEN_ERROREN. */
#define BM_USB_INTEN_ERROREN (0x02U)       /*!< Bit mask for USB_INTEN_ERROREN. */
#define BS_USB_INTEN_ERROREN (1U)          /*!< Bit field size in bits for USB_INTEN_ERROREN. */

/*! @brief Read current value of the USB_INTEN_ERROREN field. */
#define BR_USB_INTEN_ERROREN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_ERROREN))

/*! @brief Format value for bitfield USB_INTEN_ERROREN. */
#define BF_USB_INTEN_ERROREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_ERROREN) & BM_USB_INTEN_ERROREN)

/*! @brief Set the ERROREN field to a new value. */
#define BW_USB_INTEN_ERROREN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_ERROREN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field SOFTOKEN[2] (RW)
 *
 * Values:
 * - 0 - Disbles the SOFTOK interrupt.
 * - 1 - Enables the SOFTOK interrupt.
 */
/*@{*/
#define BP_USB_INTEN_SOFTOKEN (2U)         /*!< Bit position for USB_INTEN_SOFTOKEN. */
#define BM_USB_INTEN_SOFTOKEN (0x04U)      /*!< Bit mask for USB_INTEN_SOFTOKEN. */
#define BS_USB_INTEN_SOFTOKEN (1U)         /*!< Bit field size in bits for USB_INTEN_SOFTOKEN. */

/*! @brief Read current value of the USB_INTEN_SOFTOKEN field. */
#define BR_USB_INTEN_SOFTOKEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SOFTOKEN))

/*! @brief Format value for bitfield USB_INTEN_SOFTOKEN. */
#define BF_USB_INTEN_SOFTOKEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_SOFTOKEN) & BM_USB_INTEN_SOFTOKEN)

/*! @brief Set the SOFTOKEN field to a new value. */
#define BW_USB_INTEN_SOFTOKEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SOFTOKEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field TOKDNEEN[3] (RW)
 *
 * Values:
 * - 0 - Disables the TOKDNE interrupt.
 * - 1 - Enables the TOKDNE interrupt.
 */
/*@{*/
#define BP_USB_INTEN_TOKDNEEN (3U)         /*!< Bit position for USB_INTEN_TOKDNEEN. */
#define BM_USB_INTEN_TOKDNEEN (0x08U)      /*!< Bit mask for USB_INTEN_TOKDNEEN. */
#define BS_USB_INTEN_TOKDNEEN (1U)         /*!< Bit field size in bits for USB_INTEN_TOKDNEEN. */

/*! @brief Read current value of the USB_INTEN_TOKDNEEN field. */
#define BR_USB_INTEN_TOKDNEEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_TOKDNEEN))

/*! @brief Format value for bitfield USB_INTEN_TOKDNEEN. */
#define BF_USB_INTEN_TOKDNEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_TOKDNEEN) & BM_USB_INTEN_TOKDNEEN)

/*! @brief Set the TOKDNEEN field to a new value. */
#define BW_USB_INTEN_TOKDNEEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_TOKDNEEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field SLEEPEN[4] (RW)
 *
 * Values:
 * - 0 - Disables the SLEEP interrupt.
 * - 1 - Enables the SLEEP interrupt.
 */
/*@{*/
#define BP_USB_INTEN_SLEEPEN (4U)          /*!< Bit position for USB_INTEN_SLEEPEN. */
#define BM_USB_INTEN_SLEEPEN (0x10U)       /*!< Bit mask for USB_INTEN_SLEEPEN. */
#define BS_USB_INTEN_SLEEPEN (1U)          /*!< Bit field size in bits for USB_INTEN_SLEEPEN. */

/*! @brief Read current value of the USB_INTEN_SLEEPEN field. */
#define BR_USB_INTEN_SLEEPEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SLEEPEN))

/*! @brief Format value for bitfield USB_INTEN_SLEEPEN. */
#define BF_USB_INTEN_SLEEPEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_SLEEPEN) & BM_USB_INTEN_SLEEPEN)

/*! @brief Set the SLEEPEN field to a new value. */
#define BW_USB_INTEN_SLEEPEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_SLEEPEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field RESUMEEN[5] (RW)
 *
 * Values:
 * - 0 - Disables the RESUME interrupt.
 * - 1 - Enables the RESUME interrupt.
 */
/*@{*/
#define BP_USB_INTEN_RESUMEEN (5U)         /*!< Bit position for USB_INTEN_RESUMEEN. */
#define BM_USB_INTEN_RESUMEEN (0x20U)      /*!< Bit mask for USB_INTEN_RESUMEEN. */
#define BS_USB_INTEN_RESUMEEN (1U)         /*!< Bit field size in bits for USB_INTEN_RESUMEEN. */

/*! @brief Read current value of the USB_INTEN_RESUMEEN field. */
#define BR_USB_INTEN_RESUMEEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_RESUMEEN))

/*! @brief Format value for bitfield USB_INTEN_RESUMEEN. */
#define BF_USB_INTEN_RESUMEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_RESUMEEN) & BM_USB_INTEN_RESUMEEN)

/*! @brief Set the RESUMEEN field to a new value. */
#define BW_USB_INTEN_RESUMEEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_RESUMEEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field ATTACHEN[6] (RW)
 *
 * Values:
 * - 0 - Disables the ATTACH interrupt.
 * - 1 - Enables the ATTACH interrupt.
 */
/*@{*/
#define BP_USB_INTEN_ATTACHEN (6U)         /*!< Bit position for USB_INTEN_ATTACHEN. */
#define BM_USB_INTEN_ATTACHEN (0x40U)      /*!< Bit mask for USB_INTEN_ATTACHEN. */
#define BS_USB_INTEN_ATTACHEN (1U)         /*!< Bit field size in bits for USB_INTEN_ATTACHEN. */

/*! @brief Read current value of the USB_INTEN_ATTACHEN field. */
#define BR_USB_INTEN_ATTACHEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_ATTACHEN))

/*! @brief Format value for bitfield USB_INTEN_ATTACHEN. */
#define BF_USB_INTEN_ATTACHEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_ATTACHEN) & BM_USB_INTEN_ATTACHEN)

/*! @brief Set the ATTACHEN field to a new value. */
#define BW_USB_INTEN_ATTACHEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_ATTACHEN) = (v))
/*@}*/

/*!
 * @name Register USB_INTEN, field STALLEN[7] (RW)
 *
 * Values:
 * - 0 - Diasbles the STALL interrupt.
 * - 1 - Enables the STALL interrupt.
 */
/*@{*/
#define BP_USB_INTEN_STALLEN (7U)          /*!< Bit position for USB_INTEN_STALLEN. */
#define BM_USB_INTEN_STALLEN (0x80U)       /*!< Bit mask for USB_INTEN_STALLEN. */
#define BS_USB_INTEN_STALLEN (1U)          /*!< Bit field size in bits for USB_INTEN_STALLEN. */

/*! @brief Read current value of the USB_INTEN_STALLEN field. */
#define BR_USB_INTEN_STALLEN(x) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_STALLEN))

/*! @brief Format value for bitfield USB_INTEN_STALLEN. */
#define BF_USB_INTEN_STALLEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_INTEN_STALLEN) & BM_USB_INTEN_STALLEN)

/*! @brief Set the STALLEN field to a new value. */
#define BW_USB_INTEN_STALLEN(x, v) (BITBAND_ACCESS8(HW_USB_INTEN_ADDR(x), BP_USB_INTEN_STALLEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_ERRSTAT - Error Interrupt Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_ERRSTAT - Error Interrupt Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error sources within the USB Module.
 * Each of these bits are qualified with their respective error enable bits. All
 * bits of this register are logically OR'd together and the result placed in the
 * ERROR bit of the ISTAT register. After an interrupt bit has been set it may only
 * be cleared by writing a one to the respective interrupt bit. Each bit is set
 * as soon as the error condition is detected. Therefore, the interrupt does not
 * typically correspond with the end of a token being processed. This register
 * contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_errstat
{
    uint8_t U;
    struct _hw_usb_errstat_bitfields
    {
        uint8_t PIDERR : 1;            /*!< [0]  */
        uint8_t CRC5EOF : 1;           /*!< [1]  */
        uint8_t CRC16 : 1;             /*!< [2]  */
        uint8_t DFN8 : 1;              /*!< [3]  */
        uint8_t BTOERR : 1;            /*!< [4]  */
        uint8_t DMAERR : 1;            /*!< [5]  */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t BTSERR : 1;            /*!< [7]  */
    } B;
} hw_usb_errstat_t;

/*!
 * @name Constants and macros for entire USB_ERRSTAT register
 */
/*@{*/
#define HW_USB_ERRSTAT_ADDR(x)   ((uint32_t)(x) + 0x88U)

#define HW_USB_ERRSTAT(x)        (*(__IO hw_usb_errstat_t *) HW_USB_ERRSTAT_ADDR(x))
#define HW_USB_ERRSTAT_RD(x)     (HW_USB_ERRSTAT(x).U)
#define HW_USB_ERRSTAT_WR(x, v)  (HW_USB_ERRSTAT(x).U = (v))
#define HW_USB_ERRSTAT_SET(x, v) (HW_USB_ERRSTAT_WR(x, HW_USB_ERRSTAT_RD(x) |  (v)))
#define HW_USB_ERRSTAT_CLR(x, v) (HW_USB_ERRSTAT_WR(x, HW_USB_ERRSTAT_RD(x) & ~(v)))
#define HW_USB_ERRSTAT_TOG(x, v) (HW_USB_ERRSTAT_WR(x, HW_USB_ERRSTAT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_ERRSTAT bitfields
 */

/*!
 * @name Register USB_ERRSTAT, field PIDERR[0] (W1C)
 *
 * This bit is set when the PID check field fails.
 */
/*@{*/
#define BP_USB_ERRSTAT_PIDERR (0U)         /*!< Bit position for USB_ERRSTAT_PIDERR. */
#define BM_USB_ERRSTAT_PIDERR (0x01U)      /*!< Bit mask for USB_ERRSTAT_PIDERR. */
#define BS_USB_ERRSTAT_PIDERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_PIDERR. */

/*! @brief Read current value of the USB_ERRSTAT_PIDERR field. */
#define BR_USB_ERRSTAT_PIDERR(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_PIDERR))

/*! @brief Format value for bitfield USB_ERRSTAT_PIDERR. */
#define BF_USB_ERRSTAT_PIDERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_PIDERR) & BM_USB_ERRSTAT_PIDERR)

/*! @brief Set the PIDERR field to a new value. */
#define BW_USB_ERRSTAT_PIDERR(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_PIDERR) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC5EOF[1] (W1C)
 *
 * This error interrupt has two functions. When the USB Module is operating in
 * peripheral mode (HOSTMODEEN=0), this interrupt detects CRC5 errors in the token
 * packets generated by the host. If set the token packet was rejected due to a
 * CRC5 error. When the USB Module is operating in host mode (HOSTMODEEN=1), this
 * interrupt detects End Of Frame (EOF) error conditions. This occurs when the
 * USB Module is transmitting or receiving data and the SOF counter reaches zero.
 * This interrupt is useful when developing USB packet scheduling software to
 * ensure that no USB transactions cross the start of the next frame.
 */
/*@{*/
#define BP_USB_ERRSTAT_CRC5EOF (1U)        /*!< Bit position for USB_ERRSTAT_CRC5EOF. */
#define BM_USB_ERRSTAT_CRC5EOF (0x02U)     /*!< Bit mask for USB_ERRSTAT_CRC5EOF. */
#define BS_USB_ERRSTAT_CRC5EOF (1U)        /*!< Bit field size in bits for USB_ERRSTAT_CRC5EOF. */

/*! @brief Read current value of the USB_ERRSTAT_CRC5EOF field. */
#define BR_USB_ERRSTAT_CRC5EOF(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC5EOF))

/*! @brief Format value for bitfield USB_ERRSTAT_CRC5EOF. */
#define BF_USB_ERRSTAT_CRC5EOF(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_CRC5EOF) & BM_USB_ERRSTAT_CRC5EOF)

/*! @brief Set the CRC5EOF field to a new value. */
#define BW_USB_ERRSTAT_CRC5EOF(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC5EOF) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC16[2] (W1C)
 *
 * This bit is set when a data packet is rejected due to a CRC16 error.
 */
/*@{*/
#define BP_USB_ERRSTAT_CRC16 (2U)          /*!< Bit position for USB_ERRSTAT_CRC16. */
#define BM_USB_ERRSTAT_CRC16 (0x04U)       /*!< Bit mask for USB_ERRSTAT_CRC16. */
#define BS_USB_ERRSTAT_CRC16 (1U)          /*!< Bit field size in bits for USB_ERRSTAT_CRC16. */

/*! @brief Read current value of the USB_ERRSTAT_CRC16 field. */
#define BR_USB_ERRSTAT_CRC16(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC16))

/*! @brief Format value for bitfield USB_ERRSTAT_CRC16. */
#define BF_USB_ERRSTAT_CRC16(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_CRC16) & BM_USB_ERRSTAT_CRC16)

/*! @brief Set the CRC16 field to a new value. */
#define BW_USB_ERRSTAT_CRC16(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_CRC16) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DFN8[3] (W1C)
 *
 * This bit is set if the data field received was not 8 bits in length. USB
 * Specification 1.0 requires that data fields be an integral number of bytes. If the
 * data field was not an integral number of bytes, this bit is set.
 */
/*@{*/
#define BP_USB_ERRSTAT_DFN8  (3U)          /*!< Bit position for USB_ERRSTAT_DFN8. */
#define BM_USB_ERRSTAT_DFN8  (0x08U)       /*!< Bit mask for USB_ERRSTAT_DFN8. */
#define BS_USB_ERRSTAT_DFN8  (1U)          /*!< Bit field size in bits for USB_ERRSTAT_DFN8. */

/*! @brief Read current value of the USB_ERRSTAT_DFN8 field. */
#define BR_USB_ERRSTAT_DFN8(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DFN8))

/*! @brief Format value for bitfield USB_ERRSTAT_DFN8. */
#define BF_USB_ERRSTAT_DFN8(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_DFN8) & BM_USB_ERRSTAT_DFN8)

/*! @brief Set the DFN8 field to a new value. */
#define BW_USB_ERRSTAT_DFN8(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DFN8) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTOERR[4] (W1C)
 *
 * This bit is set when a bus turnaround timeout error occurs. The USB module
 * contains a bus turnaround timer that keeps track of the amount of time elapsed
 * between the token and data phases of a SETUP or OUT TOKEN or the data and
 * handshake phases of a IN TOKEN. If more than 16 bit times are counted from the
 * previous EOP before a transition from IDLE, a bus turnaround timeout error occurs.
 */
/*@{*/
#define BP_USB_ERRSTAT_BTOERR (4U)         /*!< Bit position for USB_ERRSTAT_BTOERR. */
#define BM_USB_ERRSTAT_BTOERR (0x10U)      /*!< Bit mask for USB_ERRSTAT_BTOERR. */
#define BS_USB_ERRSTAT_BTOERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_BTOERR. */

/*! @brief Read current value of the USB_ERRSTAT_BTOERR field. */
#define BR_USB_ERRSTAT_BTOERR(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTOERR))

/*! @brief Format value for bitfield USB_ERRSTAT_BTOERR. */
#define BF_USB_ERRSTAT_BTOERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_BTOERR) & BM_USB_ERRSTAT_BTOERR)

/*! @brief Set the BTOERR field to a new value. */
#define BW_USB_ERRSTAT_BTOERR(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTOERR) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DMAERR[5] (W1C)
 *
 * This bit is set if the USB Module has requested a DMA access to read a new
 * BDT but has not been given the bus before it needs to receive or transmit data.
 * If processing a TX transfer this would cause a transmit data underflow
 * condition. If processing a RX transfer this would cause a receive data overflow
 * condition. This interrupt is useful when developing device arbitration hardware for
 * the microprocessor and the USB module to minimize bus request and bus grant
 * latency. This bit is also set if a data packet to or from the host is larger
 * than the buffer size allocated in the BDT. In this case the data packet is
 * truncated as it is put in buffer memory.
 */
/*@{*/
#define BP_USB_ERRSTAT_DMAERR (5U)         /*!< Bit position for USB_ERRSTAT_DMAERR. */
#define BM_USB_ERRSTAT_DMAERR (0x20U)      /*!< Bit mask for USB_ERRSTAT_DMAERR. */
#define BS_USB_ERRSTAT_DMAERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_DMAERR. */

/*! @brief Read current value of the USB_ERRSTAT_DMAERR field. */
#define BR_USB_ERRSTAT_DMAERR(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DMAERR))

/*! @brief Format value for bitfield USB_ERRSTAT_DMAERR. */
#define BF_USB_ERRSTAT_DMAERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_DMAERR) & BM_USB_ERRSTAT_DMAERR)

/*! @brief Set the DMAERR field to a new value. */
#define BW_USB_ERRSTAT_DMAERR(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_DMAERR) = (v))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTSERR[7] (W1C)
 *
 * This bit is set when a bit stuff error is detected. If set, the corresponding
 * packet is rejected due to the error.
 */
/*@{*/
#define BP_USB_ERRSTAT_BTSERR (7U)         /*!< Bit position for USB_ERRSTAT_BTSERR. */
#define BM_USB_ERRSTAT_BTSERR (0x80U)      /*!< Bit mask for USB_ERRSTAT_BTSERR. */
#define BS_USB_ERRSTAT_BTSERR (1U)         /*!< Bit field size in bits for USB_ERRSTAT_BTSERR. */

/*! @brief Read current value of the USB_ERRSTAT_BTSERR field. */
#define BR_USB_ERRSTAT_BTSERR(x) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTSERR))

/*! @brief Format value for bitfield USB_ERRSTAT_BTSERR. */
#define BF_USB_ERRSTAT_BTSERR(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERRSTAT_BTSERR) & BM_USB_ERRSTAT_BTSERR)

/*! @brief Set the BTSERR field to a new value. */
#define BW_USB_ERRSTAT_BTSERR(x, v) (BITBAND_ACCESS8(HW_USB_ERRSTAT_ADDR(x), BP_USB_ERRSTAT_BTSERR) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_ERREN - Error Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_ERREN - Error Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error interrupt sources within the USB
 * module. Setting any of these bits enables the respective interrupt source in
 * ERRSTAT. Each bit is set as soon as the error condition is detected. Therefore,
 * the interrupt does not typically correspond with the end of a token being
 * processed. This register contains the value of 0x00 after a reset.
 */
typedef union _hw_usb_erren
{
    uint8_t U;
    struct _hw_usb_erren_bitfields
    {
        uint8_t PIDERREN : 1;          /*!< [0] PIDERR Interrupt Enable */
        uint8_t CRC5EOFEN : 1;         /*!< [1] CRC5/EOF Interrupt Enable */
        uint8_t CRC16EN : 1;           /*!< [2] CRC16 Interrupt Enable */
        uint8_t DFN8EN : 1;            /*!< [3] DFN8 Interrupt Enable */
        uint8_t BTOERREN : 1;          /*!< [4] BTOERR Interrupt Enable */
        uint8_t DMAERREN : 1;          /*!< [5] DMAERR Interrupt Enable */
        uint8_t RESERVED0 : 1;         /*!< [6]  */
        uint8_t BTSERREN : 1;          /*!< [7] BTSERR Interrupt Enable */
    } B;
} hw_usb_erren_t;

/*!
 * @name Constants and macros for entire USB_ERREN register
 */
/*@{*/
#define HW_USB_ERREN_ADDR(x)     ((uint32_t)(x) + 0x8CU)

#define HW_USB_ERREN(x)          (*(__IO hw_usb_erren_t *) HW_USB_ERREN_ADDR(x))
#define HW_USB_ERREN_RD(x)       (HW_USB_ERREN(x).U)
#define HW_USB_ERREN_WR(x, v)    (HW_USB_ERREN(x).U = (v))
#define HW_USB_ERREN_SET(x, v)   (HW_USB_ERREN_WR(x, HW_USB_ERREN_RD(x) |  (v)))
#define HW_USB_ERREN_CLR(x, v)   (HW_USB_ERREN_WR(x, HW_USB_ERREN_RD(x) & ~(v)))
#define HW_USB_ERREN_TOG(x, v)   (HW_USB_ERREN_WR(x, HW_USB_ERREN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_ERREN bitfields
 */

/*!
 * @name Register USB_ERREN, field PIDERREN[0] (RW)
 *
 * Values:
 * - 0 - Disables the PIDERR interrupt.
 * - 1 - Enters the PIDERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_PIDERREN (0U)         /*!< Bit position for USB_ERREN_PIDERREN. */
#define BM_USB_ERREN_PIDERREN (0x01U)      /*!< Bit mask for USB_ERREN_PIDERREN. */
#define BS_USB_ERREN_PIDERREN (1U)         /*!< Bit field size in bits for USB_ERREN_PIDERREN. */

/*! @brief Read current value of the USB_ERREN_PIDERREN field. */
#define BR_USB_ERREN_PIDERREN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_PIDERREN))

/*! @brief Format value for bitfield USB_ERREN_PIDERREN. */
#define BF_USB_ERREN_PIDERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_PIDERREN) & BM_USB_ERREN_PIDERREN)

/*! @brief Set the PIDERREN field to a new value. */
#define BW_USB_ERREN_PIDERREN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_PIDERREN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC5EOFEN[1] (RW)
 *
 * Values:
 * - 0 - Disables the CRC5/EOF interrupt.
 * - 1 - Enables the CRC5/EOF interrupt.
 */
/*@{*/
#define BP_USB_ERREN_CRC5EOFEN (1U)        /*!< Bit position for USB_ERREN_CRC5EOFEN. */
#define BM_USB_ERREN_CRC5EOFEN (0x02U)     /*!< Bit mask for USB_ERREN_CRC5EOFEN. */
#define BS_USB_ERREN_CRC5EOFEN (1U)        /*!< Bit field size in bits for USB_ERREN_CRC5EOFEN. */

/*! @brief Read current value of the USB_ERREN_CRC5EOFEN field. */
#define BR_USB_ERREN_CRC5EOFEN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC5EOFEN))

/*! @brief Format value for bitfield USB_ERREN_CRC5EOFEN. */
#define BF_USB_ERREN_CRC5EOFEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_CRC5EOFEN) & BM_USB_ERREN_CRC5EOFEN)

/*! @brief Set the CRC5EOFEN field to a new value. */
#define BW_USB_ERREN_CRC5EOFEN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC5EOFEN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC16EN[2] (RW)
 *
 * Values:
 * - 0 - Disables the CRC16 interrupt.
 * - 1 - Enables the CRC16 interrupt.
 */
/*@{*/
#define BP_USB_ERREN_CRC16EN (2U)          /*!< Bit position for USB_ERREN_CRC16EN. */
#define BM_USB_ERREN_CRC16EN (0x04U)       /*!< Bit mask for USB_ERREN_CRC16EN. */
#define BS_USB_ERREN_CRC16EN (1U)          /*!< Bit field size in bits for USB_ERREN_CRC16EN. */

/*! @brief Read current value of the USB_ERREN_CRC16EN field. */
#define BR_USB_ERREN_CRC16EN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC16EN))

/*! @brief Format value for bitfield USB_ERREN_CRC16EN. */
#define BF_USB_ERREN_CRC16EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_CRC16EN) & BM_USB_ERREN_CRC16EN)

/*! @brief Set the CRC16EN field to a new value. */
#define BW_USB_ERREN_CRC16EN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_CRC16EN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field DFN8EN[3] (RW)
 *
 * Values:
 * - 0 - Disables the DFN8 interrupt.
 * - 1 - Enables the DFN8 interrupt.
 */
/*@{*/
#define BP_USB_ERREN_DFN8EN  (3U)          /*!< Bit position for USB_ERREN_DFN8EN. */
#define BM_USB_ERREN_DFN8EN  (0x08U)       /*!< Bit mask for USB_ERREN_DFN8EN. */
#define BS_USB_ERREN_DFN8EN  (1U)          /*!< Bit field size in bits for USB_ERREN_DFN8EN. */

/*! @brief Read current value of the USB_ERREN_DFN8EN field. */
#define BR_USB_ERREN_DFN8EN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DFN8EN))

/*! @brief Format value for bitfield USB_ERREN_DFN8EN. */
#define BF_USB_ERREN_DFN8EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_DFN8EN) & BM_USB_ERREN_DFN8EN)

/*! @brief Set the DFN8EN field to a new value. */
#define BW_USB_ERREN_DFN8EN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DFN8EN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTOERREN[4] (RW)
 *
 * Values:
 * - 0 - Disables the BTOERR interrupt.
 * - 1 - Enables the BTOERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_BTOERREN (4U)         /*!< Bit position for USB_ERREN_BTOERREN. */
#define BM_USB_ERREN_BTOERREN (0x10U)      /*!< Bit mask for USB_ERREN_BTOERREN. */
#define BS_USB_ERREN_BTOERREN (1U)         /*!< Bit field size in bits for USB_ERREN_BTOERREN. */

/*! @brief Read current value of the USB_ERREN_BTOERREN field. */
#define BR_USB_ERREN_BTOERREN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTOERREN))

/*! @brief Format value for bitfield USB_ERREN_BTOERREN. */
#define BF_USB_ERREN_BTOERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_BTOERREN) & BM_USB_ERREN_BTOERREN)

/*! @brief Set the BTOERREN field to a new value. */
#define BW_USB_ERREN_BTOERREN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTOERREN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field DMAERREN[5] (RW)
 *
 * Values:
 * - 0 - Disables the DMAERR interrupt.
 * - 1 - Enables the DMAERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_DMAERREN (5U)         /*!< Bit position for USB_ERREN_DMAERREN. */
#define BM_USB_ERREN_DMAERREN (0x20U)      /*!< Bit mask for USB_ERREN_DMAERREN. */
#define BS_USB_ERREN_DMAERREN (1U)         /*!< Bit field size in bits for USB_ERREN_DMAERREN. */

/*! @brief Read current value of the USB_ERREN_DMAERREN field. */
#define BR_USB_ERREN_DMAERREN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DMAERREN))

/*! @brief Format value for bitfield USB_ERREN_DMAERREN. */
#define BF_USB_ERREN_DMAERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_DMAERREN) & BM_USB_ERREN_DMAERREN)

/*! @brief Set the DMAERREN field to a new value. */
#define BW_USB_ERREN_DMAERREN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_DMAERREN) = (v))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTSERREN[7] (RW)
 *
 * Values:
 * - 0 - Disables the BTSERR interrupt.
 * - 1 - Enables the BTSERR interrupt.
 */
/*@{*/
#define BP_USB_ERREN_BTSERREN (7U)         /*!< Bit position for USB_ERREN_BTSERREN. */
#define BM_USB_ERREN_BTSERREN (0x80U)      /*!< Bit mask for USB_ERREN_BTSERREN. */
#define BS_USB_ERREN_BTSERREN (1U)         /*!< Bit field size in bits for USB_ERREN_BTSERREN. */

/*! @brief Read current value of the USB_ERREN_BTSERREN field. */
#define BR_USB_ERREN_BTSERREN(x) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTSERREN))

/*! @brief Format value for bitfield USB_ERREN_BTSERREN. */
#define BF_USB_ERREN_BTSERREN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ERREN_BTSERREN) & BM_USB_ERREN_BTSERREN)

/*! @brief Set the BTSERREN field to a new value. */
#define BW_USB_ERREN_BTSERREN(x, v) (BITBAND_ACCESS8(HW_USB_ERREN_ADDR(x), BP_USB_ERREN_BTSERREN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_STAT - Status register
 ******************************************************************************/

/*!
 * @brief HW_USB_STAT - Status register (RO)
 *
 * Reset value: 0x00U
 *
 * Reports the transaction status within the USB module. When the processor's
 * interrupt controller has received a TOKDNE, interrupt the Status Register must
 * be read to determine the status of the previous endpoint communication. The
 * data in the status register is valid when TOKDNE interrupt is asserted. The
 * Status register is actually a read window into a status FIFO maintained by the USB
 * module. When the USB module uses a BD, it updates the Status register. If
 * another USB transaction is performed before the TOKDNE interrupt is serviced, the
 * USB module stores the status of the next transaction in the STAT FIFO. Thus
 * STAT is actually a four byte FIFO that allows the processor core to process one
 * transaction while the SIE is processing the next transaction. Clearing the
 * TOKDNE bit in the ISTAT register causes the SIE to update STAT with the contents
 * of the next STAT value. If the data in the STAT holding register is valid, the
 * SIE immediately reasserts to TOKDNE interrupt.
 */
typedef union _hw_usb_stat
{
    uint8_t U;
    struct _hw_usb_stat_bitfields
    {
        uint8_t RESERVED0 : 2;         /*!< [1:0]  */
        uint8_t ODD : 1;               /*!< [2]  */
        uint8_t TX : 1;                /*!< [3] Transmit Indicator */
        uint8_t ENDP : 4;              /*!< [7:4]  */
    } B;
} hw_usb_stat_t;

/*!
 * @name Constants and macros for entire USB_STAT register
 */
/*@{*/
#define HW_USB_STAT_ADDR(x)      ((uint32_t)(x) + 0x90U)

#define HW_USB_STAT(x)           (*(__I hw_usb_stat_t *) HW_USB_STAT_ADDR(x))
#define HW_USB_STAT_RD(x)        (HW_USB_STAT(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_STAT bitfields
 */

/*!
 * @name Register USB_STAT, field ODD[2] (RO)
 *
 * This bit is set if the last buffer descriptor updated was in the odd bank of
 * the BDT.
 */
/*@{*/
#define BP_USB_STAT_ODD      (2U)          /*!< Bit position for USB_STAT_ODD. */
#define BM_USB_STAT_ODD      (0x04U)       /*!< Bit mask for USB_STAT_ODD. */
#define BS_USB_STAT_ODD      (1U)          /*!< Bit field size in bits for USB_STAT_ODD. */

/*! @brief Read current value of the USB_STAT_ODD field. */
#define BR_USB_STAT_ODD(x)   (BITBAND_ACCESS8(HW_USB_STAT_ADDR(x), BP_USB_STAT_ODD))
/*@}*/

/*!
 * @name Register USB_STAT, field TX[3] (RO)
 *
 * Values:
 * - 0 - The most recent transaction was a receive operation.
 * - 1 - The most recent transaction was a transmit operation.
 */
/*@{*/
#define BP_USB_STAT_TX       (3U)          /*!< Bit position for USB_STAT_TX. */
#define BM_USB_STAT_TX       (0x08U)       /*!< Bit mask for USB_STAT_TX. */
#define BS_USB_STAT_TX       (1U)          /*!< Bit field size in bits for USB_STAT_TX. */

/*! @brief Read current value of the USB_STAT_TX field. */
#define BR_USB_STAT_TX(x)    (BITBAND_ACCESS8(HW_USB_STAT_ADDR(x), BP_USB_STAT_TX))
/*@}*/

/*!
 * @name Register USB_STAT, field ENDP[7:4] (RO)
 *
 * This four-bit field encodes the endpoint address that received or transmitted
 * the previous token. This allows the processor core to determine the BDT entry
 * that was updated by the last USB transaction.
 */
/*@{*/
#define BP_USB_STAT_ENDP     (4U)          /*!< Bit position for USB_STAT_ENDP. */
#define BM_USB_STAT_ENDP     (0xF0U)       /*!< Bit mask for USB_STAT_ENDP. */
#define BS_USB_STAT_ENDP     (4U)          /*!< Bit field size in bits for USB_STAT_ENDP. */

/*! @brief Read current value of the USB_STAT_ENDP field. */
#define BR_USB_STAT_ENDP(x)  (HW_USB_STAT(x).B.ENDP)
/*@}*/

/*******************************************************************************
 * HW_USB_CTL - Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_CTL - Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Provides various control and configuration information for the USB module.
 */
typedef union _hw_usb_ctl
{
    uint8_t U;
    struct _hw_usb_ctl_bitfields
    {
        uint8_t USBENSOFEN : 1;        /*!< [0] USB Enable */
        uint8_t ODDRST : 1;            /*!< [1]  */
        uint8_t RESUME : 1;            /*!< [2]  */
        uint8_t HOSTMODEEN : 1;        /*!< [3]  */
        uint8_t RESET : 1;             /*!< [4]  */
        uint8_t TXSUSPENDTOKENBUSY : 1; /*!< [5]  */
        uint8_t SE0 : 1;               /*!< [6] Live USB Single Ended Zero signal */
        uint8_t JSTATE : 1;            /*!< [7] Live USB differential receiver JSTATE
                                        * signal */
    } B;
} hw_usb_ctl_t;

/*!
 * @name Constants and macros for entire USB_CTL register
 */
/*@{*/
#define HW_USB_CTL_ADDR(x)       ((uint32_t)(x) + 0x94U)

#define HW_USB_CTL(x)            (*(__IO hw_usb_ctl_t *) HW_USB_CTL_ADDR(x))
#define HW_USB_CTL_RD(x)         (HW_USB_CTL(x).U)
#define HW_USB_CTL_WR(x, v)      (HW_USB_CTL(x).U = (v))
#define HW_USB_CTL_SET(x, v)     (HW_USB_CTL_WR(x, HW_USB_CTL_RD(x) |  (v)))
#define HW_USB_CTL_CLR(x, v)     (HW_USB_CTL_WR(x, HW_USB_CTL_RD(x) & ~(v)))
#define HW_USB_CTL_TOG(x, v)     (HW_USB_CTL_WR(x, HW_USB_CTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_CTL bitfields
 */

/*!
 * @name Register USB_CTL, field USBENSOFEN[0] (RW)
 *
 * Setting this bit enables the USB-FS to operate; clearing it disables the
 * USB-FS. Setting the bit causes the SIE to reset all of its ODD bits to the BDTs.
 * Therefore, setting this bit resets much of the logic in the SIE. When host mode
 * is enabled, clearing this bit causes the SIE to stop sending SOF tokens.
 *
 * Values:
 * - 0 - Disables the USB Module.
 * - 1 - Enables the USB Module.
 */
/*@{*/
#define BP_USB_CTL_USBENSOFEN (0U)         /*!< Bit position for USB_CTL_USBENSOFEN. */
#define BM_USB_CTL_USBENSOFEN (0x01U)      /*!< Bit mask for USB_CTL_USBENSOFEN. */
#define BS_USB_CTL_USBENSOFEN (1U)         /*!< Bit field size in bits for USB_CTL_USBENSOFEN. */

/*! @brief Read current value of the USB_CTL_USBENSOFEN field. */
#define BR_USB_CTL_USBENSOFEN(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_USBENSOFEN))

/*! @brief Format value for bitfield USB_CTL_USBENSOFEN. */
#define BF_USB_CTL_USBENSOFEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_USBENSOFEN) & BM_USB_CTL_USBENSOFEN)

/*! @brief Set the USBENSOFEN field to a new value. */
#define BW_USB_CTL_USBENSOFEN(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_USBENSOFEN) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field ODDRST[1] (RW)
 *
 * Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which
 * then specifies the EVEN BDT bank.
 */
/*@{*/
#define BP_USB_CTL_ODDRST    (1U)          /*!< Bit position for USB_CTL_ODDRST. */
#define BM_USB_CTL_ODDRST    (0x02U)       /*!< Bit mask for USB_CTL_ODDRST. */
#define BS_USB_CTL_ODDRST    (1U)          /*!< Bit field size in bits for USB_CTL_ODDRST. */

/*! @brief Read current value of the USB_CTL_ODDRST field. */
#define BR_USB_CTL_ODDRST(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_ODDRST))

/*! @brief Format value for bitfield USB_CTL_ODDRST. */
#define BF_USB_CTL_ODDRST(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_ODDRST) & BM_USB_CTL_ODDRST)

/*! @brief Set the ODDRST field to a new value. */
#define BW_USB_CTL_ODDRST(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_ODDRST) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field RESUME[2] (RW)
 *
 * When set to 1 this bit enables the USB Module to execute resume signaling.
 * This allows the USB Module to perform remote wake-up. Software must set RESUME
 * to 1 for the required amount of time and then clear it to 0. If the HOSTMODEEN
 * bit is set, the USB module appends a Low Speed End of Packet to the Resume
 * signaling when the RESUME bit is cleared. For more information on RESUME
 * signaling see Section 7.1.4.5 of the USB specification version 1.0.
 */
/*@{*/
#define BP_USB_CTL_RESUME    (2U)          /*!< Bit position for USB_CTL_RESUME. */
#define BM_USB_CTL_RESUME    (0x04U)       /*!< Bit mask for USB_CTL_RESUME. */
#define BS_USB_CTL_RESUME    (1U)          /*!< Bit field size in bits for USB_CTL_RESUME. */

/*! @brief Read current value of the USB_CTL_RESUME field. */
#define BR_USB_CTL_RESUME(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_RESUME))

/*! @brief Format value for bitfield USB_CTL_RESUME. */
#define BF_USB_CTL_RESUME(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_RESUME) & BM_USB_CTL_RESUME)

/*! @brief Set the RESUME field to a new value. */
#define BW_USB_CTL_RESUME(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_RESUME) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field HOSTMODEEN[3] (RW)
 *
 * When set to 1, this bit enables the USB Module to operate in Host mode. In
 * host mode, the USB module performs USB transactions under the programmed control
 * of the host processor.
 */
/*@{*/
#define BP_USB_CTL_HOSTMODEEN (3U)         /*!< Bit position for USB_CTL_HOSTMODEEN. */
#define BM_USB_CTL_HOSTMODEEN (0x08U)      /*!< Bit mask for USB_CTL_HOSTMODEEN. */
#define BS_USB_CTL_HOSTMODEEN (1U)         /*!< Bit field size in bits for USB_CTL_HOSTMODEEN. */

/*! @brief Read current value of the USB_CTL_HOSTMODEEN field. */
#define BR_USB_CTL_HOSTMODEEN(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_HOSTMODEEN))

/*! @brief Format value for bitfield USB_CTL_HOSTMODEEN. */
#define BF_USB_CTL_HOSTMODEEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_HOSTMODEEN) & BM_USB_CTL_HOSTMODEEN)

/*! @brief Set the HOSTMODEEN field to a new value. */
#define BW_USB_CTL_HOSTMODEEN(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_HOSTMODEEN) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field RESET[4] (RW)
 *
 * Setting this bit enables the USB Module to generate USB reset signaling. This
 * allows the USB Module to reset USB peripherals. This control signal is only
 * valid in Host mode (HOSTMODEEN=1). Software must set RESET to 1 for the
 * required amount of time and then clear it to 0 to end reset signaling. For more
 * information on reset signaling see Section 7.1.4.3 of the USB specification version
 * 1.0.
 */
/*@{*/
#define BP_USB_CTL_RESET     (4U)          /*!< Bit position for USB_CTL_RESET. */
#define BM_USB_CTL_RESET     (0x10U)       /*!< Bit mask for USB_CTL_RESET. */
#define BS_USB_CTL_RESET     (1U)          /*!< Bit field size in bits for USB_CTL_RESET. */

/*! @brief Read current value of the USB_CTL_RESET field. */
#define BR_USB_CTL_RESET(x)  (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_RESET))

/*! @brief Format value for bitfield USB_CTL_RESET. */
#define BF_USB_CTL_RESET(v)  ((uint8_t)((uint8_t)(v) << BP_USB_CTL_RESET) & BM_USB_CTL_RESET)

/*! @brief Set the RESET field to a new value. */
#define BW_USB_CTL_RESET(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_RESET) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field TXSUSPENDTOKENBUSY[5] (RW)
 *
 * In Host mode, TOKEN_BUSY is set when the USB module is busy executing a USB
 * token. Software must not write more token commands to the Token Register when
 * TOKEN_BUSY is set. Software should check this field before writing any tokens
 * to the Token Register to ensure that token commands are not lost. In Target
 * mode, TXD_SUSPEND is set when the SIE has disabled packet transmission and
 * reception. Clearing this bit allows the SIE to continue token processing. This bit
 * is set by the SIE when a SETUP Token is received allowing software to dequeue
 * any pending packet transactions in the BDT before resuming token processing.
 */
/*@{*/
#define BP_USB_CTL_TXSUSPENDTOKENBUSY (5U) /*!< Bit position for USB_CTL_TXSUSPENDTOKENBUSY. */
#define BM_USB_CTL_TXSUSPENDTOKENBUSY (0x20U) /*!< Bit mask for USB_CTL_TXSUSPENDTOKENBUSY. */
#define BS_USB_CTL_TXSUSPENDTOKENBUSY (1U) /*!< Bit field size in bits for USB_CTL_TXSUSPENDTOKENBUSY. */

/*! @brief Read current value of the USB_CTL_TXSUSPENDTOKENBUSY field. */
#define BR_USB_CTL_TXSUSPENDTOKENBUSY(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_TXSUSPENDTOKENBUSY))

/*! @brief Format value for bitfield USB_CTL_TXSUSPENDTOKENBUSY. */
#define BF_USB_CTL_TXSUSPENDTOKENBUSY(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_TXSUSPENDTOKENBUSY) & BM_USB_CTL_TXSUSPENDTOKENBUSY)

/*! @brief Set the TXSUSPENDTOKENBUSY field to a new value. */
#define BW_USB_CTL_TXSUSPENDTOKENBUSY(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_TXSUSPENDTOKENBUSY) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field SE0[6] (RW)
 */
/*@{*/
#define BP_USB_CTL_SE0       (6U)          /*!< Bit position for USB_CTL_SE0. */
#define BM_USB_CTL_SE0       (0x40U)       /*!< Bit mask for USB_CTL_SE0. */
#define BS_USB_CTL_SE0       (1U)          /*!< Bit field size in bits for USB_CTL_SE0. */

/*! @brief Read current value of the USB_CTL_SE0 field. */
#define BR_USB_CTL_SE0(x)    (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_SE0))

/*! @brief Format value for bitfield USB_CTL_SE0. */
#define BF_USB_CTL_SE0(v)    ((uint8_t)((uint8_t)(v) << BP_USB_CTL_SE0) & BM_USB_CTL_SE0)

/*! @brief Set the SE0 field to a new value. */
#define BW_USB_CTL_SE0(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_SE0) = (v))
/*@}*/

/*!
 * @name Register USB_CTL, field JSTATE[7] (RW)
 *
 * The polarity of this signal is affected by the current state of LSEN .
 */
/*@{*/
#define BP_USB_CTL_JSTATE    (7U)          /*!< Bit position for USB_CTL_JSTATE. */
#define BM_USB_CTL_JSTATE    (0x80U)       /*!< Bit mask for USB_CTL_JSTATE. */
#define BS_USB_CTL_JSTATE    (1U)          /*!< Bit field size in bits for USB_CTL_JSTATE. */

/*! @brief Read current value of the USB_CTL_JSTATE field. */
#define BR_USB_CTL_JSTATE(x) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_JSTATE))

/*! @brief Format value for bitfield USB_CTL_JSTATE. */
#define BF_USB_CTL_JSTATE(v) ((uint8_t)((uint8_t)(v) << BP_USB_CTL_JSTATE) & BM_USB_CTL_JSTATE)

/*! @brief Set the JSTATE field to a new value. */
#define BW_USB_CTL_JSTATE(x, v) (BITBAND_ACCESS8(HW_USB_CTL_ADDR(x), BP_USB_CTL_JSTATE) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_ADDR - Address register
 ******************************************************************************/

/*!
 * @brief HW_USB_ADDR - Address register (RW)
 *
 * Reset value: 0x00U
 *
 * Holds the unique USB address that the USB module decodes when in Peripheral
 * mode (HOSTMODEEN=0). When operating in Host mode (HOSTMODEEN=1) the USB module
 * transmits this address with a TOKEN packet. This enables the USB module to
 * uniquely address any USB peripheral. In either mode, CTL[USBENSOFEN] must be 1.
 * The Address register is reset to 0x00 after the reset input becomes active or
 * the USB module decodes a USB reset signal. This action initializes the Address
 * register to decode address 0x00 as required by the USB specification.
 */
typedef union _hw_usb_addr
{
    uint8_t U;
    struct _hw_usb_addr_bitfields
    {
        uint8_t ADDR : 7;              /*!< [6:0] USB Address */
        uint8_t LSEN : 1;              /*!< [7] Low Speed Enable bit */
    } B;
} hw_usb_addr_t;

/*!
 * @name Constants and macros for entire USB_ADDR register
 */
/*@{*/
#define HW_USB_ADDR_ADDR(x)      ((uint32_t)(x) + 0x98U)

#define HW_USB_ADDR(x)           (*(__IO hw_usb_addr_t *) HW_USB_ADDR_ADDR(x))
#define HW_USB_ADDR_RD(x)        (HW_USB_ADDR(x).U)
#define HW_USB_ADDR_WR(x, v)     (HW_USB_ADDR(x).U = (v))
#define HW_USB_ADDR_SET(x, v)    (HW_USB_ADDR_WR(x, HW_USB_ADDR_RD(x) |  (v)))
#define HW_USB_ADDR_CLR(x, v)    (HW_USB_ADDR_WR(x, HW_USB_ADDR_RD(x) & ~(v)))
#define HW_USB_ADDR_TOG(x, v)    (HW_USB_ADDR_WR(x, HW_USB_ADDR_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_ADDR bitfields
 */

/*!
 * @name Register USB_ADDR, field ADDR[6:0] (RW)
 *
 * Defines the USB address that the USB module decodes in peripheral mode, or
 * transmits when in host mode.
 */
/*@{*/
#define BP_USB_ADDR_ADDR     (0U)          /*!< Bit position for USB_ADDR_ADDR. */
#define BM_USB_ADDR_ADDR     (0x7FU)       /*!< Bit mask for USB_ADDR_ADDR. */
#define BS_USB_ADDR_ADDR     (7U)          /*!< Bit field size in bits for USB_ADDR_ADDR. */

/*! @brief Read current value of the USB_ADDR_ADDR field. */
#define BR_USB_ADDR_ADDR(x)  (HW_USB_ADDR(x).B.ADDR)

/*! @brief Format value for bitfield USB_ADDR_ADDR. */
#define BF_USB_ADDR_ADDR(v)  ((uint8_t)((uint8_t)(v) << BP_USB_ADDR_ADDR) & BM_USB_ADDR_ADDR)

/*! @brief Set the ADDR field to a new value. */
#define BW_USB_ADDR_ADDR(x, v) (HW_USB_ADDR_WR(x, (HW_USB_ADDR_RD(x) & ~BM_USB_ADDR_ADDR) | BF_USB_ADDR_ADDR(v)))
/*@}*/

/*!
 * @name Register USB_ADDR, field LSEN[7] (RW)
 *
 * Informs the USB module that the next token command written to the token
 * register must be performed at low speed. This enables the USB module to perform the
 * necessary preamble required for low-speed data transmissions.
 */
/*@{*/
#define BP_USB_ADDR_LSEN     (7U)          /*!< Bit position for USB_ADDR_LSEN. */
#define BM_USB_ADDR_LSEN     (0x80U)       /*!< Bit mask for USB_ADDR_LSEN. */
#define BS_USB_ADDR_LSEN     (1U)          /*!< Bit field size in bits for USB_ADDR_LSEN. */

/*! @brief Read current value of the USB_ADDR_LSEN field. */
#define BR_USB_ADDR_LSEN(x)  (BITBAND_ACCESS8(HW_USB_ADDR_ADDR(x), BP_USB_ADDR_LSEN))

/*! @brief Format value for bitfield USB_ADDR_LSEN. */
#define BF_USB_ADDR_LSEN(v)  ((uint8_t)((uint8_t)(v) << BP_USB_ADDR_LSEN) & BM_USB_ADDR_LSEN)

/*! @brief Set the LSEN field to a new value. */
#define BW_USB_ADDR_LSEN(x, v) (BITBAND_ACCESS8(HW_USB_ADDR_ADDR(x), BP_USB_ADDR_LSEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE1 - BDT Page register 1
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE1 - BDT Page register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * Provides address bits 15 through 9 of the base address where the current
 * Buffer Descriptor Table (BDT) resides in system memory. See Buffer Descriptor
 * Table. The 32-bit BDT Base Address is always aligned on 512-byte boundaries, so
 * bits 8 through 0 of the base address are always zero.
 */
typedef union _hw_usb_bdtpage1
{
    uint8_t U;
    struct _hw_usb_bdtpage1_bitfields
    {
        uint8_t RESERVED0 : 1;         /*!< [0]  */
        uint8_t BDTBA : 7;             /*!< [7:1]  */
    } B;
} hw_usb_bdtpage1_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE1 register
 */
/*@{*/
#define HW_USB_BDTPAGE1_ADDR(x)  ((uint32_t)(x) + 0x9CU)

#define HW_USB_BDTPAGE1(x)       (*(__IO hw_usb_bdtpage1_t *) HW_USB_BDTPAGE1_ADDR(x))
#define HW_USB_BDTPAGE1_RD(x)    (HW_USB_BDTPAGE1(x).U)
#define HW_USB_BDTPAGE1_WR(x, v) (HW_USB_BDTPAGE1(x).U = (v))
#define HW_USB_BDTPAGE1_SET(x, v) (HW_USB_BDTPAGE1_WR(x, HW_USB_BDTPAGE1_RD(x) |  (v)))
#define HW_USB_BDTPAGE1_CLR(x, v) (HW_USB_BDTPAGE1_WR(x, HW_USB_BDTPAGE1_RD(x) & ~(v)))
#define HW_USB_BDTPAGE1_TOG(x, v) (HW_USB_BDTPAGE1_WR(x, HW_USB_BDTPAGE1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE1 bitfields
 */

/*!
 * @name Register USB_BDTPAGE1, field BDTBA[7:1] (RW)
 *
 * Provides address bits 15 through 9 of the BDT base address.
 */
/*@{*/
#define BP_USB_BDTPAGE1_BDTBA (1U)         /*!< Bit position for USB_BDTPAGE1_BDTBA. */
#define BM_USB_BDTPAGE1_BDTBA (0xFEU)      /*!< Bit mask for USB_BDTPAGE1_BDTBA. */
#define BS_USB_BDTPAGE1_BDTBA (7U)         /*!< Bit field size in bits for USB_BDTPAGE1_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE1_BDTBA field. */
#define BR_USB_BDTPAGE1_BDTBA(x) (HW_USB_BDTPAGE1(x).B.BDTBA)

/*! @brief Format value for bitfield USB_BDTPAGE1_BDTBA. */
#define BF_USB_BDTPAGE1_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE1_BDTBA) & BM_USB_BDTPAGE1_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE1_BDTBA(x, v) (HW_USB_BDTPAGE1_WR(x, (HW_USB_BDTPAGE1_RD(x) & ~BM_USB_BDTPAGE1_BDTBA) | BF_USB_BDTPAGE1_BDTBA(v)))
/*@}*/

/*******************************************************************************
 * HW_USB_FRMNUML - Frame Number register Low
 ******************************************************************************/

/*!
 * @brief HW_USB_FRMNUML - Frame Number register Low (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
typedef union _hw_usb_frmnuml
{
    uint8_t U;
    struct _hw_usb_frmnuml_bitfields
    {
        uint8_t FRM : 8;               /*!< [7:0]  */
    } B;
} hw_usb_frmnuml_t;

/*!
 * @name Constants and macros for entire USB_FRMNUML register
 */
/*@{*/
#define HW_USB_FRMNUML_ADDR(x)   ((uint32_t)(x) + 0xA0U)

#define HW_USB_FRMNUML(x)        (*(__IO hw_usb_frmnuml_t *) HW_USB_FRMNUML_ADDR(x))
#define HW_USB_FRMNUML_RD(x)     (HW_USB_FRMNUML(x).U)
#define HW_USB_FRMNUML_WR(x, v)  (HW_USB_FRMNUML(x).U = (v))
#define HW_USB_FRMNUML_SET(x, v) (HW_USB_FRMNUML_WR(x, HW_USB_FRMNUML_RD(x) |  (v)))
#define HW_USB_FRMNUML_CLR(x, v) (HW_USB_FRMNUML_WR(x, HW_USB_FRMNUML_RD(x) & ~(v)))
#define HW_USB_FRMNUML_TOG(x, v) (HW_USB_FRMNUML_WR(x, HW_USB_FRMNUML_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_FRMNUML bitfields
 */

/*!
 * @name Register USB_FRMNUML, field FRM[7:0] (RW)
 *
 * This 8-bit field and the 3-bit field in the Frame Number Register High are
 * used to compute the address where the current Buffer Descriptor Table (BDT)
 * resides in system memory.
 */
/*@{*/
#define BP_USB_FRMNUML_FRM   (0U)          /*!< Bit position for USB_FRMNUML_FRM. */
#define BM_USB_FRMNUML_FRM   (0xFFU)       /*!< Bit mask for USB_FRMNUML_FRM. */
#define BS_USB_FRMNUML_FRM   (8U)          /*!< Bit field size in bits for USB_FRMNUML_FRM. */

/*! @brief Read current value of the USB_FRMNUML_FRM field. */
#define BR_USB_FRMNUML_FRM(x) (HW_USB_FRMNUML(x).U)

/*! @brief Format value for bitfield USB_FRMNUML_FRM. */
#define BF_USB_FRMNUML_FRM(v) ((uint8_t)((uint8_t)(v) << BP_USB_FRMNUML_FRM) & BM_USB_FRMNUML_FRM)

/*! @brief Set the FRM field to a new value. */
#define BW_USB_FRMNUML_FRM(x, v) (HW_USB_FRMNUML_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_FRMNUMH - Frame Number register High
 ******************************************************************************/

/*!
 * @brief HW_USB_FRMNUMH - Frame Number register High (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
typedef union _hw_usb_frmnumh
{
    uint8_t U;
    struct _hw_usb_frmnumh_bitfields
    {
        uint8_t FRM : 3;               /*!< [2:0]  */
        uint8_t RESERVED0 : 5;         /*!< [7:3]  */
    } B;
} hw_usb_frmnumh_t;

/*!
 * @name Constants and macros for entire USB_FRMNUMH register
 */
/*@{*/
#define HW_USB_FRMNUMH_ADDR(x)   ((uint32_t)(x) + 0xA4U)

#define HW_USB_FRMNUMH(x)        (*(__IO hw_usb_frmnumh_t *) HW_USB_FRMNUMH_ADDR(x))
#define HW_USB_FRMNUMH_RD(x)     (HW_USB_FRMNUMH(x).U)
#define HW_USB_FRMNUMH_WR(x, v)  (HW_USB_FRMNUMH(x).U = (v))
#define HW_USB_FRMNUMH_SET(x, v) (HW_USB_FRMNUMH_WR(x, HW_USB_FRMNUMH_RD(x) |  (v)))
#define HW_USB_FRMNUMH_CLR(x, v) (HW_USB_FRMNUMH_WR(x, HW_USB_FRMNUMH_RD(x) & ~(v)))
#define HW_USB_FRMNUMH_TOG(x, v) (HW_USB_FRMNUMH_WR(x, HW_USB_FRMNUMH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_FRMNUMH bitfields
 */

/*!
 * @name Register USB_FRMNUMH, field FRM[2:0] (RW)
 *
 * This 3-bit field and the 8-bit field in the Frame Number Register Low are
 * used to compute the address where the current Buffer Descriptor Table (BDT)
 * resides in system memory.
 */
/*@{*/
#define BP_USB_FRMNUMH_FRM   (0U)          /*!< Bit position for USB_FRMNUMH_FRM. */
#define BM_USB_FRMNUMH_FRM   (0x07U)       /*!< Bit mask for USB_FRMNUMH_FRM. */
#define BS_USB_FRMNUMH_FRM   (3U)          /*!< Bit field size in bits for USB_FRMNUMH_FRM. */

/*! @brief Read current value of the USB_FRMNUMH_FRM field. */
#define BR_USB_FRMNUMH_FRM(x) (HW_USB_FRMNUMH(x).B.FRM)

/*! @brief Format value for bitfield USB_FRMNUMH_FRM. */
#define BF_USB_FRMNUMH_FRM(v) ((uint8_t)((uint8_t)(v) << BP_USB_FRMNUMH_FRM) & BM_USB_FRMNUMH_FRM)

/*! @brief Set the FRM field to a new value. */
#define BW_USB_FRMNUMH_FRM(x, v) (HW_USB_FRMNUMH_WR(x, (HW_USB_FRMNUMH_RD(x) & ~BM_USB_FRMNUMH_FRM) | BF_USB_FRMNUMH_FRM(v)))
/*@}*/

/*******************************************************************************
 * HW_USB_TOKEN - Token register
 ******************************************************************************/

/*!
 * @brief HW_USB_TOKEN - Token register (RW)
 *
 * Reset value: 0x00U
 *
 * Used to initiate USB transactions when in host mode (HOSTMODEEN=1). When the
 * software needs to execute a USB transaction to a peripheral, it writes the
 * TOKEN type and endpoint to this register. After this register has been written,
 * the USB module begins the specified USB transaction to the address contained in
 * the address register. The processor core must always check that the
 * TOKEN_BUSY bit in the control register is not 1 before writing to the Token Register.
 * This ensures that the token commands are not overwritten before they can be
 * executed. The address register and endpoint control register 0 are also used when
 * performing a token command and therefore must also be written before the
 * Token Register. The address register is used to select the USB peripheral address
 * transmitted by the token command. The endpoint control register determines the
 * handshake and retry policies used during the transfer.
 */
typedef union _hw_usb_token
{
    uint8_t U;
    struct _hw_usb_token_bitfields
    {
        uint8_t TOKENENDPT : 4;        /*!< [3:0]  */
        uint8_t TOKENPID : 4;          /*!< [7:4]  */
    } B;
} hw_usb_token_t;

/*!
 * @name Constants and macros for entire USB_TOKEN register
 */
/*@{*/
#define HW_USB_TOKEN_ADDR(x)     ((uint32_t)(x) + 0xA8U)

#define HW_USB_TOKEN(x)          (*(__IO hw_usb_token_t *) HW_USB_TOKEN_ADDR(x))
#define HW_USB_TOKEN_RD(x)       (HW_USB_TOKEN(x).U)
#define HW_USB_TOKEN_WR(x, v)    (HW_USB_TOKEN(x).U = (v))
#define HW_USB_TOKEN_SET(x, v)   (HW_USB_TOKEN_WR(x, HW_USB_TOKEN_RD(x) |  (v)))
#define HW_USB_TOKEN_CLR(x, v)   (HW_USB_TOKEN_WR(x, HW_USB_TOKEN_RD(x) & ~(v)))
#define HW_USB_TOKEN_TOG(x, v)   (HW_USB_TOKEN_WR(x, HW_USB_TOKEN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_TOKEN bitfields
 */

/*!
 * @name Register USB_TOKEN, field TOKENENDPT[3:0] (RW)
 *
 * Holds the Endpoint address for the token command. The four bit value written
 * must be a valid endpoint.
 */
/*@{*/
#define BP_USB_TOKEN_TOKENENDPT (0U)       /*!< Bit position for USB_TOKEN_TOKENENDPT. */
#define BM_USB_TOKEN_TOKENENDPT (0x0FU)    /*!< Bit mask for USB_TOKEN_TOKENENDPT. */
#define BS_USB_TOKEN_TOKENENDPT (4U)       /*!< Bit field size in bits for USB_TOKEN_TOKENENDPT. */

/*! @brief Read current value of the USB_TOKEN_TOKENENDPT field. */
#define BR_USB_TOKEN_TOKENENDPT(x) (HW_USB_TOKEN(x).B.TOKENENDPT)

/*! @brief Format value for bitfield USB_TOKEN_TOKENENDPT. */
#define BF_USB_TOKEN_TOKENENDPT(v) ((uint8_t)((uint8_t)(v) << BP_USB_TOKEN_TOKENENDPT) & BM_USB_TOKEN_TOKENENDPT)

/*! @brief Set the TOKENENDPT field to a new value. */
#define BW_USB_TOKEN_TOKENENDPT(x, v) (HW_USB_TOKEN_WR(x, (HW_USB_TOKEN_RD(x) & ~BM_USB_TOKEN_TOKENENDPT) | BF_USB_TOKEN_TOKENENDPT(v)))
/*@}*/

/*!
 * @name Register USB_TOKEN, field TOKENPID[7:4] (RW)
 *
 * Contains the token type executed by the USB module.
 *
 * Values:
 * - 0001 - OUT Token. USB Module performs an OUT (TX) transaction.
 * - 1001 - IN Token. USB Module performs an In (RX) transaction.
 * - 1101 - SETUP Token. USB Module performs a SETUP (TX) transaction
 */
/*@{*/
#define BP_USB_TOKEN_TOKENPID (4U)         /*!< Bit position for USB_TOKEN_TOKENPID. */
#define BM_USB_TOKEN_TOKENPID (0xF0U)      /*!< Bit mask for USB_TOKEN_TOKENPID. */
#define BS_USB_TOKEN_TOKENPID (4U)         /*!< Bit field size in bits for USB_TOKEN_TOKENPID. */

/*! @brief Read current value of the USB_TOKEN_TOKENPID field. */
#define BR_USB_TOKEN_TOKENPID(x) (HW_USB_TOKEN(x).B.TOKENPID)

/*! @brief Format value for bitfield USB_TOKEN_TOKENPID. */
#define BF_USB_TOKEN_TOKENPID(v) ((uint8_t)((uint8_t)(v) << BP_USB_TOKEN_TOKENPID) & BM_USB_TOKEN_TOKENPID)

/*! @brief Set the TOKENPID field to a new value. */
#define BW_USB_TOKEN_TOKENPID(x, v) (HW_USB_TOKEN_WR(x, (HW_USB_TOKEN_RD(x) & ~BM_USB_TOKEN_TOKENPID) | BF_USB_TOKEN_TOKENPID(v)))
/*@}*/

/*******************************************************************************
 * HW_USB_SOFTHLD - SOF Threshold register
 ******************************************************************************/

/*!
 * @brief HW_USB_SOFTHLD - SOF Threshold register (RW)
 *
 * Reset value: 0x00U
 *
 * The SOF Threshold Register is used only in Host mode (HOSTMODEEN=1). When in
 * Host mode, the 14-bit SOF counter counts the interval between SOF frames. The
 * SOF must be transmitted every 1ms so therefore the SOF counter is loaded with
 * a value of 12000. When the SOF counter reaches zero, a Start Of Frame (SOF)
 * token is transmitted. The SOF threshold register is used to program the number
 * of USB byte times before the SOF to stop initiating token packet transactions.
 * This register must be set to a value that ensures that other packets are not
 * actively being transmitted when the SOF time counts to zero. When the SOF
 * counter reaches the threshold value, no more tokens are transmitted until after the
 * SOF has been transmitted. The value programmed into the threshold register
 * must reserve enough time to ensure the worst case transaction completes. In
 * general the worst case transaction is an IN token followed by a data packet from
 * the target followed by the response from the host. The actual time required is
 * a function of the maximum packet size on the bus. Typical values for the SOF
 * threshold are: 64-byte packets=74; 32-byte packets=42; 16-byte packets=26;
 * 8-byte packets=18.
 */
typedef union _hw_usb_softhld
{
    uint8_t U;
    struct _hw_usb_softhld_bitfields
    {
        uint8_t CNT : 8;               /*!< [7:0]  */
    } B;
} hw_usb_softhld_t;

/*!
 * @name Constants and macros for entire USB_SOFTHLD register
 */
/*@{*/
#define HW_USB_SOFTHLD_ADDR(x)   ((uint32_t)(x) + 0xACU)

#define HW_USB_SOFTHLD(x)        (*(__IO hw_usb_softhld_t *) HW_USB_SOFTHLD_ADDR(x))
#define HW_USB_SOFTHLD_RD(x)     (HW_USB_SOFTHLD(x).U)
#define HW_USB_SOFTHLD_WR(x, v)  (HW_USB_SOFTHLD(x).U = (v))
#define HW_USB_SOFTHLD_SET(x, v) (HW_USB_SOFTHLD_WR(x, HW_USB_SOFTHLD_RD(x) |  (v)))
#define HW_USB_SOFTHLD_CLR(x, v) (HW_USB_SOFTHLD_WR(x, HW_USB_SOFTHLD_RD(x) & ~(v)))
#define HW_USB_SOFTHLD_TOG(x, v) (HW_USB_SOFTHLD_WR(x, HW_USB_SOFTHLD_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_SOFTHLD bitfields
 */

/*!
 * @name Register USB_SOFTHLD, field CNT[7:0] (RW)
 *
 * Represents the SOF count threshold in byte times.
 */
/*@{*/
#define BP_USB_SOFTHLD_CNT   (0U)          /*!< Bit position for USB_SOFTHLD_CNT. */
#define BM_USB_SOFTHLD_CNT   (0xFFU)       /*!< Bit mask for USB_SOFTHLD_CNT. */
#define BS_USB_SOFTHLD_CNT   (8U)          /*!< Bit field size in bits for USB_SOFTHLD_CNT. */

/*! @brief Read current value of the USB_SOFTHLD_CNT field. */
#define BR_USB_SOFTHLD_CNT(x) (HW_USB_SOFTHLD(x).U)

/*! @brief Format value for bitfield USB_SOFTHLD_CNT. */
#define BF_USB_SOFTHLD_CNT(v) ((uint8_t)((uint8_t)(v) << BP_USB_SOFTHLD_CNT) & BM_USB_SOFTHLD_CNT)

/*! @brief Set the CNT field to a new value. */
#define BW_USB_SOFTHLD_CNT(x, v) (HW_USB_SOFTHLD_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE2 - BDT Page Register 2
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE2 - BDT Page Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory. See Buffer Descriptor Table.
 */
typedef union _hw_usb_bdtpage2
{
    uint8_t U;
    struct _hw_usb_bdtpage2_bitfields
    {
        uint8_t BDTBA : 8;             /*!< [7:0]  */
    } B;
} hw_usb_bdtpage2_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE2 register
 */
/*@{*/
#define HW_USB_BDTPAGE2_ADDR(x)  ((uint32_t)(x) + 0xB0U)

#define HW_USB_BDTPAGE2(x)       (*(__IO hw_usb_bdtpage2_t *) HW_USB_BDTPAGE2_ADDR(x))
#define HW_USB_BDTPAGE2_RD(x)    (HW_USB_BDTPAGE2(x).U)
#define HW_USB_BDTPAGE2_WR(x, v) (HW_USB_BDTPAGE2(x).U = (v))
#define HW_USB_BDTPAGE2_SET(x, v) (HW_USB_BDTPAGE2_WR(x, HW_USB_BDTPAGE2_RD(x) |  (v)))
#define HW_USB_BDTPAGE2_CLR(x, v) (HW_USB_BDTPAGE2_WR(x, HW_USB_BDTPAGE2_RD(x) & ~(v)))
#define HW_USB_BDTPAGE2_TOG(x, v) (HW_USB_BDTPAGE2_WR(x, HW_USB_BDTPAGE2_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE2 bitfields
 */

/*!
 * @name Register USB_BDTPAGE2, field BDTBA[7:0] (RW)
 *
 * Provides address bits 23 through 16 of the BDT base address that defines the
 * location of Buffer Descriptor Table resides in system memory.
 */
/*@{*/
#define BP_USB_BDTPAGE2_BDTBA (0U)         /*!< Bit position for USB_BDTPAGE2_BDTBA. */
#define BM_USB_BDTPAGE2_BDTBA (0xFFU)      /*!< Bit mask for USB_BDTPAGE2_BDTBA. */
#define BS_USB_BDTPAGE2_BDTBA (8U)         /*!< Bit field size in bits for USB_BDTPAGE2_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE2_BDTBA field. */
#define BR_USB_BDTPAGE2_BDTBA(x) (HW_USB_BDTPAGE2(x).U)

/*! @brief Format value for bitfield USB_BDTPAGE2_BDTBA. */
#define BF_USB_BDTPAGE2_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE2_BDTBA) & BM_USB_BDTPAGE2_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE2_BDTBA(x, v) (HW_USB_BDTPAGE2_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_BDTPAGE3 - BDT Page Register 3
 ******************************************************************************/

/*!
 * @brief HW_USB_BDTPAGE3 - BDT Page Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory. See Buffer Descriptor Table.
 */
typedef union _hw_usb_bdtpage3
{
    uint8_t U;
    struct _hw_usb_bdtpage3_bitfields
    {
        uint8_t BDTBA : 8;             /*!< [7:0]  */
    } B;
} hw_usb_bdtpage3_t;

/*!
 * @name Constants and macros for entire USB_BDTPAGE3 register
 */
/*@{*/
#define HW_USB_BDTPAGE3_ADDR(x)  ((uint32_t)(x) + 0xB4U)

#define HW_USB_BDTPAGE3(x)       (*(__IO hw_usb_bdtpage3_t *) HW_USB_BDTPAGE3_ADDR(x))
#define HW_USB_BDTPAGE3_RD(x)    (HW_USB_BDTPAGE3(x).U)
#define HW_USB_BDTPAGE3_WR(x, v) (HW_USB_BDTPAGE3(x).U = (v))
#define HW_USB_BDTPAGE3_SET(x, v) (HW_USB_BDTPAGE3_WR(x, HW_USB_BDTPAGE3_RD(x) |  (v)))
#define HW_USB_BDTPAGE3_CLR(x, v) (HW_USB_BDTPAGE3_WR(x, HW_USB_BDTPAGE3_RD(x) & ~(v)))
#define HW_USB_BDTPAGE3_TOG(x, v) (HW_USB_BDTPAGE3_WR(x, HW_USB_BDTPAGE3_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE3 bitfields
 */

/*!
 * @name Register USB_BDTPAGE3, field BDTBA[7:0] (RW)
 *
 * Provides address bits 31 through 24 of the BDT base address that defines the
 * location of Buffer Descriptor Table resides in system memory.
 */
/*@{*/
#define BP_USB_BDTPAGE3_BDTBA (0U)         /*!< Bit position for USB_BDTPAGE3_BDTBA. */
#define BM_USB_BDTPAGE3_BDTBA (0xFFU)      /*!< Bit mask for USB_BDTPAGE3_BDTBA. */
#define BS_USB_BDTPAGE3_BDTBA (8U)         /*!< Bit field size in bits for USB_BDTPAGE3_BDTBA. */

/*! @brief Read current value of the USB_BDTPAGE3_BDTBA field. */
#define BR_USB_BDTPAGE3_BDTBA(x) (HW_USB_BDTPAGE3(x).U)

/*! @brief Format value for bitfield USB_BDTPAGE3_BDTBA. */
#define BF_USB_BDTPAGE3_BDTBA(v) ((uint8_t)((uint8_t)(v) << BP_USB_BDTPAGE3_BDTBA) & BM_USB_BDTPAGE3_BDTBA)

/*! @brief Set the BDTBA field to a new value. */
#define BW_USB_BDTPAGE3_BDTBA(x, v) (HW_USB_BDTPAGE3_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_ENDPTn - Endpoint Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_ENDPTn - Endpoint Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains the endpoint control bits for each of the 16 endpoints available
 * within the USB module for a decoded address. The format for these registers is
 * shown in the following figure. Endpoint 0 (ENDPT0) is associated with control
 * pipe 0, which is required for all USB functions. Therefore, after a USBRST
 * interrupt occurs the processor core should set ENDPT0 to contain 0x0D. In Host mode
 * ENDPT0 is used to determine the handshake, retry and low speed
 * characteristics of the host transfer. For Control, Bulk and Interrupt transfers, the EPHSHK
 * bit should be 1. For Isochronous transfers it should be 0. Common values to
 * use for ENDPT0 in host mode are 0x4D for Control, Bulk, and Interrupt transfers,
 * and 0x4C for Isochronous transfers. The three bits EPCTLDIS, EPRXEN, and
 * EPTXEN define if an endpoint is enabled and define the direction of the endpoint.
 * The endpoint enable/direction control is defined in the following table.
 * Endpoint enable and direction control EPCTLDIS EPRXEN EPTXEN Endpoint
 * enable/direction control X 0 0 Disable endpoint X 0 1 Enable endpoint for Tx transfers only
 * X 1 0 Enable endpoint for Rx transfers only 1 1 1 Enable endpoint for Rx and
 * Tx transfers 0 1 1 Enable Endpoint for RX and TX as well as control (SETUP)
 * transfers.
 */
typedef union _hw_usb_endptn
{
    uint8_t U;
    struct _hw_usb_endptn_bitfields
    {
        uint8_t EPHSHK : 1;            /*!< [0]  */
        uint8_t EPSTALL : 1;           /*!< [1]  */
        uint8_t EPTXEN : 1;            /*!< [2]  */
        uint8_t EPRXEN : 1;            /*!< [3]  */
        uint8_t EPCTLDIS : 1;          /*!< [4]  */
        uint8_t RESERVED0 : 1;         /*!< [5]  */
        uint8_t RETRYDIS : 1;          /*!< [6]  */
        uint8_t HOSTWOHUB : 1;         /*!< [7]  */
    } B;
} hw_usb_endptn_t;

/*!
 * @name Constants and macros for entire USB_ENDPTn register
 */
/*@{*/
#define HW_USB_ENDPTn_COUNT (16U)

#define HW_USB_ENDPTn_ADDR(x, n) ((uint32_t)(x) + 0xC0U + (0x4U * (n)))

#define HW_USB_ENDPTn(x, n)      (*(__IO hw_usb_endptn_t *) HW_USB_ENDPTn_ADDR(x, n))
#define HW_USB_ENDPTn_RD(x, n)   (HW_USB_ENDPTn(x, n).U)
#define HW_USB_ENDPTn_WR(x, n, v) (HW_USB_ENDPTn(x, n).U = (v))
#define HW_USB_ENDPTn_SET(x, n, v) (HW_USB_ENDPTn_WR(x, n, HW_USB_ENDPTn_RD(x, n) |  (v)))
#define HW_USB_ENDPTn_CLR(x, n, v) (HW_USB_ENDPTn_WR(x, n, HW_USB_ENDPTn_RD(x, n) & ~(v)))
#define HW_USB_ENDPTn_TOG(x, n, v) (HW_USB_ENDPTn_WR(x, n, HW_USB_ENDPTn_RD(x, n) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_ENDPTn bitfields
 */

/*!
 * @name Register USB_ENDPTn, field EPHSHK[0] (RW)
 *
 * When set this bit enables an endpoint to perform handshaking during a
 * transaction to this endpoint. This bit is generally 1 unless the endpoint is
 * Isochronous.
 */
/*@{*/
#define BP_USB_ENDPTn_EPHSHK (0U)          /*!< Bit position for USB_ENDPTn_EPHSHK. */
#define BM_USB_ENDPTn_EPHSHK (0x01U)       /*!< Bit mask for USB_ENDPTn_EPHSHK. */
#define BS_USB_ENDPTn_EPHSHK (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPHSHK. */

/*! @brief Read current value of the USB_ENDPTn_EPHSHK field. */
#define BR_USB_ENDPTn_EPHSHK(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPHSHK))

/*! @brief Format value for bitfield USB_ENDPTn_EPHSHK. */
#define BF_USB_ENDPTn_EPHSHK(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPHSHK) & BM_USB_ENDPTn_EPHSHK)

/*! @brief Set the EPHSHK field to a new value. */
#define BW_USB_ENDPTn_EPHSHK(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPHSHK) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPSTALL[1] (RW)
 *
 * When set this bit indicates that the endpoint is called. This bit has
 * priority over all other control bits in the EndPoint Enable Register, but it is only
 * valid if EPTXEN=1 or EPRXEN=1. Any access to this endpoint causes the USB
 * Module to return a STALL handshake. After an endpoint is stalled it requires
 * intervention from the Host Controller.
 */
/*@{*/
#define BP_USB_ENDPTn_EPSTALL (1U)         /*!< Bit position for USB_ENDPTn_EPSTALL. */
#define BM_USB_ENDPTn_EPSTALL (0x02U)      /*!< Bit mask for USB_ENDPTn_EPSTALL. */
#define BS_USB_ENDPTn_EPSTALL (1U)         /*!< Bit field size in bits for USB_ENDPTn_EPSTALL. */

/*! @brief Read current value of the USB_ENDPTn_EPSTALL field. */
#define BR_USB_ENDPTn_EPSTALL(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPSTALL))

/*! @brief Format value for bitfield USB_ENDPTn_EPSTALL. */
#define BF_USB_ENDPTn_EPSTALL(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPSTALL) & BM_USB_ENDPTn_EPSTALL)

/*! @brief Set the EPSTALL field to a new value. */
#define BW_USB_ENDPTn_EPSTALL(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPSTALL) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPTXEN[2] (RW)
 *
 * This bit, when set, enables the endpoint for TX transfers.
 */
/*@{*/
#define BP_USB_ENDPTn_EPTXEN (2U)          /*!< Bit position for USB_ENDPTn_EPTXEN. */
#define BM_USB_ENDPTn_EPTXEN (0x04U)       /*!< Bit mask for USB_ENDPTn_EPTXEN. */
#define BS_USB_ENDPTn_EPTXEN (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPTXEN. */

/*! @brief Read current value of the USB_ENDPTn_EPTXEN field. */
#define BR_USB_ENDPTn_EPTXEN(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPTXEN))

/*! @brief Format value for bitfield USB_ENDPTn_EPTXEN. */
#define BF_USB_ENDPTn_EPTXEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPTXEN) & BM_USB_ENDPTn_EPTXEN)

/*! @brief Set the EPTXEN field to a new value. */
#define BW_USB_ENDPTn_EPTXEN(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPTXEN) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPRXEN[3] (RW)
 *
 * This bit, when set, enables the endpoint for RX transfers.
 */
/*@{*/
#define BP_USB_ENDPTn_EPRXEN (3U)          /*!< Bit position for USB_ENDPTn_EPRXEN. */
#define BM_USB_ENDPTn_EPRXEN (0x08U)       /*!< Bit mask for USB_ENDPTn_EPRXEN. */
#define BS_USB_ENDPTn_EPRXEN (1U)          /*!< Bit field size in bits for USB_ENDPTn_EPRXEN. */

/*! @brief Read current value of the USB_ENDPTn_EPRXEN field. */
#define BR_USB_ENDPTn_EPRXEN(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPRXEN))

/*! @brief Format value for bitfield USB_ENDPTn_EPRXEN. */
#define BF_USB_ENDPTn_EPRXEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPRXEN) & BM_USB_ENDPTn_EPRXEN)

/*! @brief Set the EPRXEN field to a new value. */
#define BW_USB_ENDPTn_EPRXEN(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPRXEN) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field EPCTLDIS[4] (RW)
 *
 * This bit, when set, disables control (SETUP) transfers. When cleared, control
 * transfers are enabled. This applies if and only if the EPRXEN and EPTXEN bits
 * are also set.
 */
/*@{*/
#define BP_USB_ENDPTn_EPCTLDIS (4U)        /*!< Bit position for USB_ENDPTn_EPCTLDIS. */
#define BM_USB_ENDPTn_EPCTLDIS (0x10U)     /*!< Bit mask for USB_ENDPTn_EPCTLDIS. */
#define BS_USB_ENDPTn_EPCTLDIS (1U)        /*!< Bit field size in bits for USB_ENDPTn_EPCTLDIS. */

/*! @brief Read current value of the USB_ENDPTn_EPCTLDIS field. */
#define BR_USB_ENDPTn_EPCTLDIS(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPCTLDIS))

/*! @brief Format value for bitfield USB_ENDPTn_EPCTLDIS. */
#define BF_USB_ENDPTn_EPCTLDIS(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_EPCTLDIS) & BM_USB_ENDPTn_EPCTLDIS)

/*! @brief Set the EPCTLDIS field to a new value. */
#define BW_USB_ENDPTn_EPCTLDIS(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_EPCTLDIS) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field RETRYDIS[6] (RW)
 *
 * This is a Host mode only bit and is present in the control register for
 * endpoint 0 (ENDPT0) only. When set this bit causes the host to not retry NAK'ed
 * (Negative Acknowledgement) transactions. When a transaction is NAKed, the BDT PID
 * field is updated with the NAK PID, and the TOKEN_DNE interrupt is set. When
 * this bit is cleared, NAKed transactions are retried in hardware. This bit must
 * be set when the host is attempting to poll an interrupt endpoint.
 */
/*@{*/
#define BP_USB_ENDPTn_RETRYDIS (6U)        /*!< Bit position for USB_ENDPTn_RETRYDIS. */
#define BM_USB_ENDPTn_RETRYDIS (0x40U)     /*!< Bit mask for USB_ENDPTn_RETRYDIS. */
#define BS_USB_ENDPTn_RETRYDIS (1U)        /*!< Bit field size in bits for USB_ENDPTn_RETRYDIS. */

/*! @brief Read current value of the USB_ENDPTn_RETRYDIS field. */
#define BR_USB_ENDPTn_RETRYDIS(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_RETRYDIS))

/*! @brief Format value for bitfield USB_ENDPTn_RETRYDIS. */
#define BF_USB_ENDPTn_RETRYDIS(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_RETRYDIS) & BM_USB_ENDPTn_RETRYDIS)

/*! @brief Set the RETRYDIS field to a new value. */
#define BW_USB_ENDPTn_RETRYDIS(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_RETRYDIS) = (v))
/*@}*/

/*!
 * @name Register USB_ENDPTn, field HOSTWOHUB[7] (RW)
 *
 * This is a Host mode only field and is present in the control register for
 * endpoint 0 (ENDPT0) only. When set this bit allows the host to communicate to a
 * directly connected low speed device. When cleared, the host produces the
 * PRE_PID. It then switches to low-speed signaling when sending a token to a low speed
 * device as required to communicate with a low speed device through a hub.
 */
/*@{*/
#define BP_USB_ENDPTn_HOSTWOHUB (7U)       /*!< Bit position for USB_ENDPTn_HOSTWOHUB. */
#define BM_USB_ENDPTn_HOSTWOHUB (0x80U)    /*!< Bit mask for USB_ENDPTn_HOSTWOHUB. */
#define BS_USB_ENDPTn_HOSTWOHUB (1U)       /*!< Bit field size in bits for USB_ENDPTn_HOSTWOHUB. */

/*! @brief Read current value of the USB_ENDPTn_HOSTWOHUB field. */
#define BR_USB_ENDPTn_HOSTWOHUB(x, n) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_HOSTWOHUB))

/*! @brief Format value for bitfield USB_ENDPTn_HOSTWOHUB. */
#define BF_USB_ENDPTn_HOSTWOHUB(v) ((uint8_t)((uint8_t)(v) << BP_USB_ENDPTn_HOSTWOHUB) & BM_USB_ENDPTn_HOSTWOHUB)

/*! @brief Set the HOSTWOHUB field to a new value. */
#define BW_USB_ENDPTn_HOSTWOHUB(x, n, v) (BITBAND_ACCESS8(HW_USB_ENDPTn_ADDR(x, n), BP_USB_ENDPTn_HOSTWOHUB) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_USBCTRL - USB Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_USBCTRL - USB Control register (RW)
 *
 * Reset value: 0xC0U
 */
typedef union _hw_usb_usbctrl
{
    uint8_t U;
    struct _hw_usb_usbctrl_bitfields
    {
        uint8_t RESERVED0 : 6;         /*!< [5:0]  */
        uint8_t PDE : 1;               /*!< [6]  */
        uint8_t SUSP : 1;              /*!< [7]  */
    } B;
} hw_usb_usbctrl_t;

/*!
 * @name Constants and macros for entire USB_USBCTRL register
 */
/*@{*/
#define HW_USB_USBCTRL_ADDR(x)   ((uint32_t)(x) + 0x100U)

#define HW_USB_USBCTRL(x)        (*(__IO hw_usb_usbctrl_t *) HW_USB_USBCTRL_ADDR(x))
#define HW_USB_USBCTRL_RD(x)     (HW_USB_USBCTRL(x).U)
#define HW_USB_USBCTRL_WR(x, v)  (HW_USB_USBCTRL(x).U = (v))
#define HW_USB_USBCTRL_SET(x, v) (HW_USB_USBCTRL_WR(x, HW_USB_USBCTRL_RD(x) |  (v)))
#define HW_USB_USBCTRL_CLR(x, v) (HW_USB_USBCTRL_WR(x, HW_USB_USBCTRL_RD(x) & ~(v)))
#define HW_USB_USBCTRL_TOG(x, v) (HW_USB_USBCTRL_WR(x, HW_USB_USBCTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBCTRL bitfields
 */

/*!
 * @name Register USB_USBCTRL, field PDE[6] (RW)
 *
 * Enables the weak pulldowns on the USB transceiver.
 *
 * Values:
 * - 0 - Weak pulldowns are disabled on D+ and D-.
 * - 1 - Weak pulldowns are enabled on D+ and D-.
 */
/*@{*/
#define BP_USB_USBCTRL_PDE   (6U)          /*!< Bit position for USB_USBCTRL_PDE. */
#define BM_USB_USBCTRL_PDE   (0x40U)       /*!< Bit mask for USB_USBCTRL_PDE. */
#define BS_USB_USBCTRL_PDE   (1U)          /*!< Bit field size in bits for USB_USBCTRL_PDE. */

/*! @brief Read current value of the USB_USBCTRL_PDE field. */
#define BR_USB_USBCTRL_PDE(x) (BITBAND_ACCESS8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_PDE))

/*! @brief Format value for bitfield USB_USBCTRL_PDE. */
#define BF_USB_USBCTRL_PDE(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBCTRL_PDE) & BM_USB_USBCTRL_PDE)

/*! @brief Set the PDE field to a new value. */
#define BW_USB_USBCTRL_PDE(x, v) (BITBAND_ACCESS8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_PDE) = (v))
/*@}*/

/*!
 * @name Register USB_USBCTRL, field SUSP[7] (RW)
 *
 * Places the USB transceiver into the suspend state.
 *
 * Values:
 * - 0 - USB transceiver is not in suspend state.
 * - 1 - USB transceiver is in suspend state.
 */
/*@{*/
#define BP_USB_USBCTRL_SUSP  (7U)          /*!< Bit position for USB_USBCTRL_SUSP. */
#define BM_USB_USBCTRL_SUSP  (0x80U)       /*!< Bit mask for USB_USBCTRL_SUSP. */
#define BS_USB_USBCTRL_SUSP  (1U)          /*!< Bit field size in bits for USB_USBCTRL_SUSP. */

/*! @brief Read current value of the USB_USBCTRL_SUSP field. */
#define BR_USB_USBCTRL_SUSP(x) (BITBAND_ACCESS8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_SUSP))

/*! @brief Format value for bitfield USB_USBCTRL_SUSP. */
#define BF_USB_USBCTRL_SUSP(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBCTRL_SUSP) & BM_USB_USBCTRL_SUSP)

/*! @brief Set the SUSP field to a new value. */
#define BW_USB_USBCTRL_SUSP(x, v) (BITBAND_ACCESS8(HW_USB_USBCTRL_ADDR(x), BP_USB_USBCTRL_SUSP) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_OBSERVE - USB OTG Observe register
 ******************************************************************************/

/*!
 * @brief HW_USB_OBSERVE - USB OTG Observe register (RO)
 *
 * Reset value: 0x50U
 *
 * Provides visibility on the state of the pull-ups and pull-downs at the
 * transceiver. Useful when interfacing to an external OTG control module via a serial
 * interface.
 */
typedef union _hw_usb_observe
{
    uint8_t U;
    struct _hw_usb_observe_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t DMPD : 1;              /*!< [4]  */
        uint8_t RESERVED1 : 1;         /*!< [5]  */
        uint8_t DPPD : 1;              /*!< [6]  */
        uint8_t DPPU : 1;              /*!< [7]  */
    } B;
} hw_usb_observe_t;

/*!
 * @name Constants and macros for entire USB_OBSERVE register
 */
/*@{*/
#define HW_USB_OBSERVE_ADDR(x)   ((uint32_t)(x) + 0x104U)

#define HW_USB_OBSERVE(x)        (*(__I hw_usb_observe_t *) HW_USB_OBSERVE_ADDR(x))
#define HW_USB_OBSERVE_RD(x)     (HW_USB_OBSERVE(x).U)
/*@}*/

/*
 * Constants & macros for individual USB_OBSERVE bitfields
 */

/*!
 * @name Register USB_OBSERVE, field DMPD[4] (RO)
 *
 * Provides observability of the D- Pulldown enable at the USB transceiver.
 *
 * Values:
 * - 0 - D- pulldown disabled.
 * - 1 - D- pulldown enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DMPD  (4U)          /*!< Bit position for USB_OBSERVE_DMPD. */
#define BM_USB_OBSERVE_DMPD  (0x10U)       /*!< Bit mask for USB_OBSERVE_DMPD. */
#define BS_USB_OBSERVE_DMPD  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DMPD. */

/*! @brief Read current value of the USB_OBSERVE_DMPD field. */
#define BR_USB_OBSERVE_DMPD(x) (BITBAND_ACCESS8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DMPD))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPD[6] (RO)
 *
 * Provides observability of the D+ Pulldown enable at the USB transceiver.
 *
 * Values:
 * - 0 - D+ pulldown disabled.
 * - 1 - D+ pulldown enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DPPD  (6U)          /*!< Bit position for USB_OBSERVE_DPPD. */
#define BM_USB_OBSERVE_DPPD  (0x40U)       /*!< Bit mask for USB_OBSERVE_DPPD. */
#define BS_USB_OBSERVE_DPPD  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DPPD. */

/*! @brief Read current value of the USB_OBSERVE_DPPD field. */
#define BR_USB_OBSERVE_DPPD(x) (BITBAND_ACCESS8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DPPD))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPU[7] (RO)
 *
 * Provides observability of the D+ Pullup enable at the USB transceiver.
 *
 * Values:
 * - 0 - D+ pullup disabled.
 * - 1 - D+ pullup enabled.
 */
/*@{*/
#define BP_USB_OBSERVE_DPPU  (7U)          /*!< Bit position for USB_OBSERVE_DPPU. */
#define BM_USB_OBSERVE_DPPU  (0x80U)       /*!< Bit mask for USB_OBSERVE_DPPU. */
#define BS_USB_OBSERVE_DPPU  (1U)          /*!< Bit field size in bits for USB_OBSERVE_DPPU. */

/*! @brief Read current value of the USB_OBSERVE_DPPU field. */
#define BR_USB_OBSERVE_DPPU(x) (BITBAND_ACCESS8(HW_USB_OBSERVE_ADDR(x), BP_USB_OBSERVE_DPPU))
/*@}*/

/*******************************************************************************
 * HW_USB_CONTROL - USB OTG Control register
 ******************************************************************************/

/*!
 * @brief HW_USB_CONTROL - USB OTG Control register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_usb_control
{
    uint8_t U;
    struct _hw_usb_control_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t DPPULLUPNONOTG : 1;    /*!< [4]  */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_control_t;

/*!
 * @name Constants and macros for entire USB_CONTROL register
 */
/*@{*/
#define HW_USB_CONTROL_ADDR(x)   ((uint32_t)(x) + 0x108U)

#define HW_USB_CONTROL(x)        (*(__IO hw_usb_control_t *) HW_USB_CONTROL_ADDR(x))
#define HW_USB_CONTROL_RD(x)     (HW_USB_CONTROL(x).U)
#define HW_USB_CONTROL_WR(x, v)  (HW_USB_CONTROL(x).U = (v))
#define HW_USB_CONTROL_SET(x, v) (HW_USB_CONTROL_WR(x, HW_USB_CONTROL_RD(x) |  (v)))
#define HW_USB_CONTROL_CLR(x, v) (HW_USB_CONTROL_WR(x, HW_USB_CONTROL_RD(x) & ~(v)))
#define HW_USB_CONTROL_TOG(x, v) (HW_USB_CONTROL_WR(x, HW_USB_CONTROL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_CONTROL bitfields
 */

/*!
 * @name Register USB_CONTROL, field DPPULLUPNONOTG[4] (RW)
 *
 * Provides control of the DP Pullup in USBOTG, if USB is configured in non-OTG
 * device mode.
 *
 * Values:
 * - 0 - DP Pullup in non-OTG device mode is not enabled.
 * - 1 - DP Pullup in non-OTG device mode is enabled.
 */
/*@{*/
#define BP_USB_CONTROL_DPPULLUPNONOTG (4U) /*!< Bit position for USB_CONTROL_DPPULLUPNONOTG. */
#define BM_USB_CONTROL_DPPULLUPNONOTG (0x10U) /*!< Bit mask for USB_CONTROL_DPPULLUPNONOTG. */
#define BS_USB_CONTROL_DPPULLUPNONOTG (1U) /*!< Bit field size in bits for USB_CONTROL_DPPULLUPNONOTG. */

/*! @brief Read current value of the USB_CONTROL_DPPULLUPNONOTG field. */
#define BR_USB_CONTROL_DPPULLUPNONOTG(x) (BITBAND_ACCESS8(HW_USB_CONTROL_ADDR(x), BP_USB_CONTROL_DPPULLUPNONOTG))

/*! @brief Format value for bitfield USB_CONTROL_DPPULLUPNONOTG. */
#define BF_USB_CONTROL_DPPULLUPNONOTG(v) ((uint8_t)((uint8_t)(v) << BP_USB_CONTROL_DPPULLUPNONOTG) & BM_USB_CONTROL_DPPULLUPNONOTG)

/*! @brief Set the DPPULLUPNONOTG field to a new value. */
#define BW_USB_CONTROL_DPPULLUPNONOTG(x, v) (BITBAND_ACCESS8(HW_USB_CONTROL_ADDR(x), BP_USB_CONTROL_DPPULLUPNONOTG) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_USBTRC0 - USB Transceiver Control register 0
 ******************************************************************************/

/*!
 * @brief HW_USB_USBTRC0 - USB Transceiver Control register 0 (RW)
 *
 * Reset value: 0x00U
 *
 * Includes signals for basic operation of the on-chip USB Full Speed
 * transceiver and configuration of the USB data connection that are not otherwise included
 * in the USB Full Speed controller registers.
 */
typedef union _hw_usb_usbtrc0
{
    uint8_t U;
    struct _hw_usb_usbtrc0_bitfields
    {
        uint8_t USB_RESUME_INT : 1;    /*!< [0] USB Asynchronous Interrupt */
        uint8_t SYNC_DET : 1;          /*!< [1] Synchronous USB Interrupt Detect */
        uint8_t USB_CLK_RECOVERY_INT : 1; /*!< [2] Combined USB Clock
                                        * Recovery interrupt status */
        uint8_t RESERVED0 : 2;         /*!< [4:3]  */
        uint8_t USBRESMEN : 1;         /*!< [5] Asynchronous Resume Interrupt Enable
                                        * */
        uint8_t RESERVED1 : 1;         /*!< [6]  */
        uint8_t USBRESET : 1;          /*!< [7] USB Reset */
    } B;
} hw_usb_usbtrc0_t;

/*!
 * @name Constants and macros for entire USB_USBTRC0 register
 */
/*@{*/
#define HW_USB_USBTRC0_ADDR(x)   ((uint32_t)(x) + 0x10CU)

#define HW_USB_USBTRC0(x)        (*(__IO hw_usb_usbtrc0_t *) HW_USB_USBTRC0_ADDR(x))
#define HW_USB_USBTRC0_RD(x)     (HW_USB_USBTRC0(x).U)
#define HW_USB_USBTRC0_WR(x, v)  (HW_USB_USBTRC0(x).U = (v))
#define HW_USB_USBTRC0_SET(x, v) (HW_USB_USBTRC0_WR(x, HW_USB_USBTRC0_RD(x) |  (v)))
#define HW_USB_USBTRC0_CLR(x, v) (HW_USB_USBTRC0_WR(x, HW_USB_USBTRC0_RD(x) & ~(v)))
#define HW_USB_USBTRC0_TOG(x, v) (HW_USB_USBTRC0_WR(x, HW_USB_USBTRC0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBTRC0 bitfields
 */

/*!
 * @name Register USB_USBTRC0, field USB_RESUME_INT[0] (RO)
 *
 * Values:
 * - 0 - No interrupt was generated.
 * - 1 - Interrupt was generated because of the USB asynchronous interrupt.
 */
/*@{*/
#define BP_USB_USBTRC0_USB_RESUME_INT (0U) /*!< Bit position for USB_USBTRC0_USB_RESUME_INT. */
#define BM_USB_USBTRC0_USB_RESUME_INT (0x01U) /*!< Bit mask for USB_USBTRC0_USB_RESUME_INT. */
#define BS_USB_USBTRC0_USB_RESUME_INT (1U) /*!< Bit field size in bits for USB_USBTRC0_USB_RESUME_INT. */

/*! @brief Read current value of the USB_USBTRC0_USB_RESUME_INT field. */
#define BR_USB_USBTRC0_USB_RESUME_INT(x) (BITBAND_ACCESS8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USB_RESUME_INT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field SYNC_DET[1] (RO)
 *
 * Values:
 * - 0 - Synchronous interrupt has not been detected.
 * - 1 - Synchronous interrupt has been detected.
 */
/*@{*/
#define BP_USB_USBTRC0_SYNC_DET (1U)       /*!< Bit position for USB_USBTRC0_SYNC_DET. */
#define BM_USB_USBTRC0_SYNC_DET (0x02U)    /*!< Bit mask for USB_USBTRC0_SYNC_DET. */
#define BS_USB_USBTRC0_SYNC_DET (1U)       /*!< Bit field size in bits for USB_USBTRC0_SYNC_DET. */

/*! @brief Read current value of the USB_USBTRC0_SYNC_DET field. */
#define BR_USB_USBTRC0_SYNC_DET(x) (BITBAND_ACCESS8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_SYNC_DET))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USB_CLK_RECOVERY_INT[2] (RO)
 *
 * This read-only field will be set to value high at 1'b1 when any of USB clock
 * recovery interrupt conditions are detected and those interrupts are unmasked.
 * For customer use the only unmasked USB clock recovery interrupt condition
 * results from an overflow of the frequency trim setting values indicating that the
 * frequency trim calculated is out of the adjustment range of the IRC48M output
 * clock. To clear this bit after it has been set, Write 0xFF to register
 * USB_CLK_RECOVER_INT_STATUS.
 */
/*@{*/
#define BP_USB_USBTRC0_USB_CLK_RECOVERY_INT (2U) /*!< Bit position for USB_USBTRC0_USB_CLK_RECOVERY_INT. */
#define BM_USB_USBTRC0_USB_CLK_RECOVERY_INT (0x04U) /*!< Bit mask for USB_USBTRC0_USB_CLK_RECOVERY_INT. */
#define BS_USB_USBTRC0_USB_CLK_RECOVERY_INT (1U) /*!< Bit field size in bits for USB_USBTRC0_USB_CLK_RECOVERY_INT. */

/*! @brief Read current value of the USB_USBTRC0_USB_CLK_RECOVERY_INT field. */
#define BR_USB_USBTRC0_USB_CLK_RECOVERY_INT(x) (BITBAND_ACCESS8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USB_CLK_RECOVERY_INT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESMEN[5] (RW)
 *
 * This bit, when set, allows the USB module to send an asynchronous wakeup
 * event to the MCU upon detection of resume signaling on the USB bus. The MCU then
 * re-enables clocks to the USB module. It is used for low-power suspend mode when
 * USB module clocks are stopped or the USB transceiver is in Suspend mode.
 * Async wakeup only works in device mode.
 *
 * Values:
 * - 0 - USB asynchronous wakeup from suspend mode disabled.
 * - 1 - USB asynchronous wakeup from suspend mode enabled. The asynchronous
 *     resume interrupt differs from the synchronous resume interrupt in that it
 *     asynchronously detects K-state using the unfiltered state of the D+ and D-
 *     pins. This interrupt should only be enabled when the Transceiver is
 *     suspended.
 */
/*@{*/
#define BP_USB_USBTRC0_USBRESMEN (5U)      /*!< Bit position for USB_USBTRC0_USBRESMEN. */
#define BM_USB_USBTRC0_USBRESMEN (0x20U)   /*!< Bit mask for USB_USBTRC0_USBRESMEN. */
#define BS_USB_USBTRC0_USBRESMEN (1U)      /*!< Bit field size in bits for USB_USBTRC0_USBRESMEN. */

/*! @brief Read current value of the USB_USBTRC0_USBRESMEN field. */
#define BR_USB_USBTRC0_USBRESMEN(x) (BITBAND_ACCESS8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USBRESMEN))

/*! @brief Format value for bitfield USB_USBTRC0_USBRESMEN. */
#define BF_USB_USBTRC0_USBRESMEN(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBTRC0_USBRESMEN) & BM_USB_USBTRC0_USBRESMEN)

/*! @brief Set the USBRESMEN field to a new value. */
#define BW_USB_USBTRC0_USBRESMEN(x, v) (BITBAND_ACCESS8(HW_USB_USBTRC0_ADDR(x), BP_USB_USBTRC0_USBRESMEN) = (v))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESET[7] (WO)
 *
 * Generates a hard reset to USBOTG. After this bit is set and the reset occurs,
 * this bit is automatically cleared. This bit is always read as zero. Wait two
 * USB clock cycles after setting this bit.
 *
 * Values:
 * - 0 - Normal USB module operation.
 * - 1 - Returns the USB module to its reset state.
 */
/*@{*/
#define BP_USB_USBTRC0_USBRESET (7U)       /*!< Bit position for USB_USBTRC0_USBRESET. */
#define BM_USB_USBTRC0_USBRESET (0x80U)    /*!< Bit mask for USB_USBTRC0_USBRESET. */
#define BS_USB_USBTRC0_USBRESET (1U)       /*!< Bit field size in bits for USB_USBTRC0_USBRESET. */

/*! @brief Format value for bitfield USB_USBTRC0_USBRESET. */
#define BF_USB_USBTRC0_USBRESET(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBTRC0_USBRESET) & BM_USB_USBTRC0_USBRESET)
/*@}*/

/*******************************************************************************
 * HW_USB_USBFRMADJUST - Frame Adjust Register
 ******************************************************************************/

/*!
 * @brief HW_USB_USBFRMADJUST - Frame Adjust Register (RW)
 *
 * Reset value: 0x00U
 */
typedef union _hw_usb_usbfrmadjust
{
    uint8_t U;
    struct _hw_usb_usbfrmadjust_bitfields
    {
        uint8_t ADJ : 8;               /*!< [7:0] Frame Adjustment */
    } B;
} hw_usb_usbfrmadjust_t;

/*!
 * @name Constants and macros for entire USB_USBFRMADJUST register
 */
/*@{*/
#define HW_USB_USBFRMADJUST_ADDR(x) ((uint32_t)(x) + 0x114U)

#define HW_USB_USBFRMADJUST(x)   (*(__IO hw_usb_usbfrmadjust_t *) HW_USB_USBFRMADJUST_ADDR(x))
#define HW_USB_USBFRMADJUST_RD(x) (HW_USB_USBFRMADJUST(x).U)
#define HW_USB_USBFRMADJUST_WR(x, v) (HW_USB_USBFRMADJUST(x).U = (v))
#define HW_USB_USBFRMADJUST_SET(x, v) (HW_USB_USBFRMADJUST_WR(x, HW_USB_USBFRMADJUST_RD(x) |  (v)))
#define HW_USB_USBFRMADJUST_CLR(x, v) (HW_USB_USBFRMADJUST_WR(x, HW_USB_USBFRMADJUST_RD(x) & ~(v)))
#define HW_USB_USBFRMADJUST_TOG(x, v) (HW_USB_USBFRMADJUST_WR(x, HW_USB_USBFRMADJUST_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_USBFRMADJUST bitfields
 */

/*!
 * @name Register USB_USBFRMADJUST, field ADJ[7:0] (RW)
 *
 * In Host mode, the frame adjustment is a twos complement number that adjusts
 * the period of each USB frame in 12-MHz clock periods. A SOF is normally
 * generated every 12,000 12-MHz clock cycles. The Frame Adjust Register can adjust this
 * by -128 to +127 to compensate for inaccuracies in the USB 48-MHz clock.
 * Changes to the ADJ bit take effect at the next start of the next frame.
 */
/*@{*/
#define BP_USB_USBFRMADJUST_ADJ (0U)       /*!< Bit position for USB_USBFRMADJUST_ADJ. */
#define BM_USB_USBFRMADJUST_ADJ (0xFFU)    /*!< Bit mask for USB_USBFRMADJUST_ADJ. */
#define BS_USB_USBFRMADJUST_ADJ (8U)       /*!< Bit field size in bits for USB_USBFRMADJUST_ADJ. */

/*! @brief Read current value of the USB_USBFRMADJUST_ADJ field. */
#define BR_USB_USBFRMADJUST_ADJ(x) (HW_USB_USBFRMADJUST(x).U)

/*! @brief Format value for bitfield USB_USBFRMADJUST_ADJ. */
#define BF_USB_USBFRMADJUST_ADJ(v) ((uint8_t)((uint8_t)(v) << BP_USB_USBFRMADJUST_ADJ) & BM_USB_USBFRMADJUST_ADJ)

/*! @brief Set the ADJ field to a new value. */
#define BW_USB_USBFRMADJUST_ADJ(x, v) (HW_USB_USBFRMADJUST_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_CTRL - USB Clock recovery control (RW)
 *
 * Reset value: 0x00U
 *
 * Signals in this register control the crystal-less USB clock mode in which the
 * internal IRC48M oscillator is tuned to match the clock extracted from the
 * incoming USB data stream. The IRC48M internal oscillator module must be enabled
 * in register USB_CLK_RECOVER_IRC_EN for this mode.
 */
typedef union _hw_usb_clk_recover_ctrl
{
    uint8_t U;
    struct _hw_usb_clk_recover_ctrl_bitfields
    {
        uint8_t RESERVED0 : 5;         /*!< [4:0]  */
        uint8_t RESTART_IFRTRIM_EN : 1; /*!< [5] Restart from IFR trim value
                                        * */
        uint8_t RESET_RESUME_ROUGH_EN : 1; /*!< [6] Reset/resume to rough
                                        * phase enable */
        uint8_t CLOCK_RECOVER_EN : 1;  /*!< [7] Crystal-less USB enable */
    } B;
} hw_usb_clk_recover_ctrl_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_CTRL register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_CTRL_ADDR(x) ((uint32_t)(x) + 0x140U)

#define HW_USB_CLK_RECOVER_CTRL(x) (*(__IO hw_usb_clk_recover_ctrl_t *) HW_USB_CLK_RECOVER_CTRL_ADDR(x))
#define HW_USB_CLK_RECOVER_CTRL_RD(x) (HW_USB_CLK_RECOVER_CTRL(x).U)
#define HW_USB_CLK_RECOVER_CTRL_WR(x, v) (HW_USB_CLK_RECOVER_CTRL(x).U = (v))
#define HW_USB_CLK_RECOVER_CTRL_SET(x, v) (HW_USB_CLK_RECOVER_CTRL_WR(x, HW_USB_CLK_RECOVER_CTRL_RD(x) |  (v)))
#define HW_USB_CLK_RECOVER_CTRL_CLR(x, v) (HW_USB_CLK_RECOVER_CTRL_WR(x, HW_USB_CLK_RECOVER_CTRL_RD(x) & ~(v)))
#define HW_USB_CLK_RECOVER_CTRL_TOG(x, v) (HW_USB_CLK_RECOVER_CTRL_WR(x, HW_USB_CLK_RECOVER_CTRL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_CTRL bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESTART_IFRTRIM_EN[5] (RW)
 *
 * IRC48 has a default trim fine value whose default value is factory trimmed
 * (the IFR trim value). Clock recover block tracks the accuracy of the clock 48Mhz
 * and keeps updating the trim fine value accordingly
 *
 * Values:
 * - 0 - Trim fine adjustment always works based on the previous updated trim
 *     fine value (default)
 * - 1 - Trim fine restarts from the IFR trim value whenever
 *     bus_reset/bus_resume is detected or module enable is desasserted
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (5U) /*!< Bit position for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BM_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (0x20U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BS_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN. */
#define BF_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN) & BM_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN)

/*! @brief Set the RESTART_IFRTRIM_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN) = (v))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESET_RESUME_ROUGH_EN[6] (RW)
 *
 * The clock recovery block tracks the IRC48Mhz to get an accurate 48Mhz clock.
 * It has two phases after user enables clock_recover_en bit, rough phase and
 * tracking phase. The step to fine tune the IRC 48Mhz by adjusting the trim fine
 * value is different during these two phases. The step in rough phase is larger
 * than that in tracking phase. Switch back to rough stage whenever USB bus reset
 * or bus resume occurs.
 *
 * Values:
 * - 0 - Always works in tracking phase after the 1st time rough to track
 *     transition (default)
 * - 1 - Go back to rough stage whenever bus reset or bus resume occurs
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (6U) /*!< Bit position for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BM_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (0x40U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BS_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN. */
#define BF_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN) & BM_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN)

/*! @brief Set the RESET_RESUME_ROUGH_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN) = (v))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field CLOCK_RECOVER_EN[7] (RW)
 *
 * This bit must be enabled if user wants to use the crystal-less USB mode for
 * the Full Speed USB controller and transceiver. This bit should not be set for
 * USB host mode or OTG.
 *
 * Values:
 * - 0 - Disable clock recovery block (default)
 * - 1 - Enable clock recovery block
 */
/*@{*/
#define BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (7U) /*!< Bit position for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BM_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (0x80U) /*!< Bit mask for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BS_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN field. */
#define BR_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN. */
#define BF_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN) & BM_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN)

/*! @brief Set the CLOCK_RECOVER_EN field to a new value. */
#define BW_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_CTRL_ADDR(x), BP_USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register (RW)
 *
 * Reset value: 0x01U
 *
 * Controls basic operation of the on-chip IRC48M module used to produce nominal
 * 48MHz clocks for USB crystal-less operation and other functions. See
 * additional information about the IRC48M operation in the Clock Distribution chapter.
 */
typedef union _hw_usb_clk_recover_irc_en
{
    uint8_t U;
    struct _hw_usb_clk_recover_irc_en_bitfields
    {
        uint8_t REG_EN : 1;            /*!< [0] IRC48M regulator enable */
        uint8_t IRC_EN : 1;            /*!< [1] IRC48M enable */
        uint8_t RESERVED0 : 6;         /*!< [7:2]  */
    } B;
} hw_usb_clk_recover_irc_en_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_IRC_EN register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_IRC_EN_ADDR(x) ((uint32_t)(x) + 0x144U)

#define HW_USB_CLK_RECOVER_IRC_EN(x) (*(__IO hw_usb_clk_recover_irc_en_t *) HW_USB_CLK_RECOVER_IRC_EN_ADDR(x))
#define HW_USB_CLK_RECOVER_IRC_EN_RD(x) (HW_USB_CLK_RECOVER_IRC_EN(x).U)
#define HW_USB_CLK_RECOVER_IRC_EN_WR(x, v) (HW_USB_CLK_RECOVER_IRC_EN(x).U = (v))
#define HW_USB_CLK_RECOVER_IRC_EN_SET(x, v) (HW_USB_CLK_RECOVER_IRC_EN_WR(x, HW_USB_CLK_RECOVER_IRC_EN_RD(x) |  (v)))
#define HW_USB_CLK_RECOVER_IRC_EN_CLR(x, v) (HW_USB_CLK_RECOVER_IRC_EN_WR(x, HW_USB_CLK_RECOVER_IRC_EN_RD(x) & ~(v)))
#define HW_USB_CLK_RECOVER_IRC_EN_TOG(x, v) (HW_USB_CLK_RECOVER_IRC_EN_WR(x, HW_USB_CLK_RECOVER_IRC_EN_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_IRC_EN bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_IRC_EN, field REG_EN[0] (RW)
 *
 * This bit is used to enable the local analog regulator for IRC48Mhz module.
 * This bit must be set if user wants to use the crystal-less USB clock
 * configuration.
 *
 * Values:
 * - 0 - IRC48M local regulator is disabled
 * - 1 - IRC48M local regulator is enabled (default)
 */
/*@{*/
#define BP_USB_CLK_RECOVER_IRC_EN_REG_EN (0U) /*!< Bit position for USB_CLK_RECOVER_IRC_EN_REG_EN. */
#define BM_USB_CLK_RECOVER_IRC_EN_REG_EN (0x01U) /*!< Bit mask for USB_CLK_RECOVER_IRC_EN_REG_EN. */
#define BS_USB_CLK_RECOVER_IRC_EN_REG_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_IRC_EN_REG_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_IRC_EN_REG_EN field. */
#define BR_USB_CLK_RECOVER_IRC_EN_REG_EN(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), BP_USB_CLK_RECOVER_IRC_EN_REG_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_IRC_EN_REG_EN. */
#define BF_USB_CLK_RECOVER_IRC_EN_REG_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_IRC_EN_REG_EN) & BM_USB_CLK_RECOVER_IRC_EN_REG_EN)

/*! @brief Set the REG_EN field to a new value. */
#define BW_USB_CLK_RECOVER_IRC_EN_REG_EN(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), BP_USB_CLK_RECOVER_IRC_EN_REG_EN) = (v))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_IRC_EN, field IRC_EN[1] (RW)
 *
 * This bit is used to enable the on-chip IRC48Mhz module to generate clocks for
 * crystal-less USB. It can only be used for FS USB device mode operation. This
 * bit must be set before using the crystal-less USB clock configuration.
 *
 * Values:
 * - 0 - Disable the IRC48M module (default)
 * - 1 - Enable the IRC48M module
 */
/*@{*/
#define BP_USB_CLK_RECOVER_IRC_EN_IRC_EN (1U) /*!< Bit position for USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BM_USB_CLK_RECOVER_IRC_EN_IRC_EN (0x02U) /*!< Bit mask for USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BS_USB_CLK_RECOVER_IRC_EN_IRC_EN (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_IRC_EN_IRC_EN. */

/*! @brief Read current value of the USB_CLK_RECOVER_IRC_EN_IRC_EN field. */
#define BR_USB_CLK_RECOVER_IRC_EN_IRC_EN(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), BP_USB_CLK_RECOVER_IRC_EN_IRC_EN))

/*! @brief Format value for bitfield USB_CLK_RECOVER_IRC_EN_IRC_EN. */
#define BF_USB_CLK_RECOVER_IRC_EN_IRC_EN(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_IRC_EN_IRC_EN) & BM_USB_CLK_RECOVER_IRC_EN_IRC_EN)

/*! @brief Set the IRC_EN field to a new value. */
#define BW_USB_CLK_RECOVER_IRC_EN_IRC_EN(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_IRC_EN_ADDR(x), BP_USB_CLK_RECOVER_IRC_EN_IRC_EN) = (v))
/*@}*/

/*******************************************************************************
 * HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 ******************************************************************************/

/*!
 * @brief HW_USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status (W1C)
 *
 * Reset value: 0x00U
 *
 * A Write operation with value high at 1'b1 on any combination of individual
 * bits will clear those bits.
 */
typedef union _hw_usb_clk_recover_int_status
{
    uint8_t U;
    struct _hw_usb_clk_recover_int_status_bitfields
    {
        uint8_t RESERVED0 : 4;         /*!< [3:0]  */
        uint8_t OVF_ERROR : 1;         /*!< [4]  */
        uint8_t RESERVED1 : 3;         /*!< [7:5]  */
    } B;
} hw_usb_clk_recover_int_status_t;

/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_INT_STATUS register
 */
/*@{*/
#define HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x) ((uint32_t)(x) + 0x15CU)

#define HW_USB_CLK_RECOVER_INT_STATUS(x) (*(__IO hw_usb_clk_recover_int_status_t *) HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x))
#define HW_USB_CLK_RECOVER_INT_STATUS_RD(x) (HW_USB_CLK_RECOVER_INT_STATUS(x).U)
#define HW_USB_CLK_RECOVER_INT_STATUS_WR(x, v) (HW_USB_CLK_RECOVER_INT_STATUS(x).U = (v))
#define HW_USB_CLK_RECOVER_INT_STATUS_SET(x, v) (HW_USB_CLK_RECOVER_INT_STATUS_WR(x, HW_USB_CLK_RECOVER_INT_STATUS_RD(x) |  (v)))
#define HW_USB_CLK_RECOVER_INT_STATUS_CLR(x, v) (HW_USB_CLK_RECOVER_INT_STATUS_WR(x, HW_USB_CLK_RECOVER_INT_STATUS_RD(x) & ~(v)))
#define HW_USB_CLK_RECOVER_INT_STATUS_TOG(x, v) (HW_USB_CLK_RECOVER_INT_STATUS_WR(x, HW_USB_CLK_RECOVER_INT_STATUS_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_INT_STATUS bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_INT_STATUS, field OVF_ERROR[4] (W1C)
 *
 * Indicates that the USB clock recovery algorithm has detected that the
 * frequency trim adjustment needed for the IRC48M output clock is outside the available
 * TRIM_FINE adjustment range for the IRC48M module.
 *
 * Values:
 * - 0 - No interrupt is reported
 * - 1 - Unmasked interrupt has been generated
 */
/*@{*/
#define BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (4U) /*!< Bit position for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BM_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (0x10U) /*!< Bit mask for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BS_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR (1U) /*!< Bit field size in bits for USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */

/*! @brief Read current value of the USB_CLK_RECOVER_INT_STATUS_OVF_ERROR field. */
#define BR_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(x) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR))

/*! @brief Format value for bitfield USB_CLK_RECOVER_INT_STATUS_OVF_ERROR. */
#define BF_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(v) ((uint8_t)((uint8_t)(v) << BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR) & BM_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR)

/*! @brief Set the OVF_ERROR field to a new value. */
#define BW_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(x, v) (BITBAND_ACCESS8(HW_USB_CLK_RECOVER_INT_STATUS_ADDR(x), BP_USB_CLK_RECOVER_INT_STATUS_OVF_ERROR) = (v))
/*@}*/

/*******************************************************************************
 * hw_usb_t - module struct
 ******************************************************************************/
/*!
 * @brief All USB module registers.
 */
#pragma pack(1)
typedef struct _hw_usb
{
    __I hw_usb_perid_t PERID;              /*!< [0x0] Peripheral ID register */
    uint8_t _reserved0[3];
    __I hw_usb_idcomp_t IDCOMP;            /*!< [0x4] Peripheral ID Complement register */
    uint8_t _reserved1[3];
    __I hw_usb_rev_t REV;                  /*!< [0x8] Peripheral Revision register */
    uint8_t _reserved2[3];
    __I hw_usb_addinfo_t ADDINFO;          /*!< [0xC] Peripheral Additional Info register */
    uint8_t _reserved3[3];
    __IO hw_usb_otgistat_t OTGISTAT;       /*!< [0x10] OTG Interrupt Status register */
    uint8_t _reserved4[3];
    __IO hw_usb_otgicr_t OTGICR;           /*!< [0x14] OTG Interrupt Control register */
    uint8_t _reserved5[3];
    __IO hw_usb_otgstat_t OTGSTAT;         /*!< [0x18] OTG Status register */
    uint8_t _reserved6[3];
    __IO hw_usb_otgctl_t OTGCTL;           /*!< [0x1C] OTG Control register */
    uint8_t _reserved7[99];
    __IO hw_usb_istat_t ISTAT;             /*!< [0x80] Interrupt Status register */
    uint8_t _reserved8[3];
    __IO hw_usb_inten_t INTEN;             /*!< [0x84] Interrupt Enable register */
    uint8_t _reserved9[3];
    __IO hw_usb_errstat_t ERRSTAT;         /*!< [0x88] Error Interrupt Status register */
    uint8_t _reserved10[3];
    __IO hw_usb_erren_t ERREN;             /*!< [0x8C] Error Interrupt Enable register */
    uint8_t _reserved11[3];
    __I hw_usb_stat_t STAT;                /*!< [0x90] Status register */
    uint8_t _reserved12[3];
    __IO hw_usb_ctl_t CTL;                 /*!< [0x94] Control register */
    uint8_t _reserved13[3];
    __IO hw_usb_addr_t ADDR;               /*!< [0x98] Address register */
    uint8_t _reserved14[3];
    __IO hw_usb_bdtpage1_t BDTPAGE1;       /*!< [0x9C] BDT Page register 1 */
    uint8_t _reserved15[3];
    __IO hw_usb_frmnuml_t FRMNUML;         /*!< [0xA0] Frame Number register Low */
    uint8_t _reserved16[3];
    __IO hw_usb_frmnumh_t FRMNUMH;         /*!< [0xA4] Frame Number register High */
    uint8_t _reserved17[3];
    __IO hw_usb_token_t TOKEN;             /*!< [0xA8] Token register */
    uint8_t _reserved18[3];
    __IO hw_usb_softhld_t SOFTHLD;         /*!< [0xAC] SOF Threshold register */
    uint8_t _reserved19[3];
    __IO hw_usb_bdtpage2_t BDTPAGE2;       /*!< [0xB0] BDT Page Register 2 */
    uint8_t _reserved20[3];
    __IO hw_usb_bdtpage3_t BDTPAGE3;       /*!< [0xB4] BDT Page Register 3 */
    uint8_t _reserved21[11];
    struct {
        __IO hw_usb_endptn_t ENDPTn;       /*!< [0xC0] Endpoint Control register */
        uint8_t _reserved0[3];
    } ENDPOINT[16];
    __IO hw_usb_usbctrl_t USBCTRL;         /*!< [0x100] USB Control register */
    uint8_t _reserved22[3];
    __I hw_usb_observe_t OBSERVE;          /*!< [0x104] USB OTG Observe register */
    uint8_t _reserved23[3];
    __IO hw_usb_control_t CONTROL;         /*!< [0x108] USB OTG Control register */
    uint8_t _reserved24[3];
    __IO hw_usb_usbtrc0_t USBTRC0;         /*!< [0x10C] USB Transceiver Control register 0 */
    uint8_t _reserved25[7];
    __IO hw_usb_usbfrmadjust_t USBFRMADJUST; /*!< [0x114] Frame Adjust Register */
    uint8_t _reserved26[43];
    __IO hw_usb_clk_recover_ctrl_t CLK_RECOVER_CTRL; /*!< [0x140] USB Clock recovery control */
    uint8_t _reserved27[3];
    __IO hw_usb_clk_recover_irc_en_t CLK_RECOVER_IRC_EN; /*!< [0x144] IRC48M oscillator enable register */
    uint8_t _reserved28[23];
    __IO hw_usb_clk_recover_int_status_t CLK_RECOVER_INT_STATUS; /*!< [0x15C] Clock recovery separated interrupt status */
} hw_usb_t;
#pragma pack()

/*! @brief Macro to access all USB registers. */
/*! @param x USB module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_USB_REGS(USB0_BASE)</code>. */
#define HW_USB_REGS(x) (*(hw_usb_t *)(x))

/*
 * MK64F12 USBDCD
 *
 * USB Device Charger Detection module
 *
 * Registers defined in this header file:
 * - HW_USBDCD_CONTROL - Control register
 * - HW_USBDCD_CLOCK - Clock register
 * - HW_USBDCD_STATUS - Status register
 * - HW_USBDCD_TIMER0 - TIMER0 register
 * - HW_USBDCD_TIMER1 - TIMER1 register
 * - HW_USBDCD_TIMER2_BC11 - TIMER2_BC11 register
 * - HW_USBDCD_TIMER2_BC12 - TIMER2_BC12 register
 *
 * - hw_usbdcd_t - Struct containing all module registers.
 */

#define HW_USBDCD_INSTANCE_COUNT (1U) /*!< Number of instances of the USBDCD module. */
#define HW_USBDCD (0U) /*!< Instance number for USBDCD. */

/*******************************************************************************
 * HW_USBDCD_CONTROL - Control register
 ******************************************************************************/

/*!
 * @brief HW_USBDCD_CONTROL - Control register (RW)
 *
 * Reset value: 0x00010000U
 *
 * Contains the control and interrupt bit fields.
 */
typedef union _hw_usbdcd_control
{
    uint32_t U;
    struct _hw_usbdcd_control_bitfields
    {
        uint32_t IACK : 1;             /*!< [0] Interrupt Acknowledge */
        uint32_t RESERVED0 : 7;        /*!< [7:1]  */
        uint32_t IF : 1;               /*!< [8] Interrupt Flag */
        uint32_t RESERVED1 : 7;        /*!< [15:9]  */
        uint32_t IE : 1;               /*!< [16] Interrupt Enable */
        uint32_t BC12 : 1;             /*!< [17]  */
        uint32_t RESERVED2 : 6;        /*!< [23:18]  */
        uint32_t START : 1;            /*!< [24] Start Change Detection Sequence */
        uint32_t SR : 1;               /*!< [25] Software Reset */
        uint32_t RESERVED3 : 6;        /*!< [31:26]  */
    } B;
} hw_usbdcd_control_t;

/*!
 * @name Constants and macros for entire USBDCD_CONTROL register
 */
/*@{*/
#define HW_USBDCD_CONTROL_ADDR(x) ((uint32_t)(x) + 0x0U)

#define HW_USBDCD_CONTROL(x)     (*(__IO hw_usbdcd_control_t *) HW_USBDCD_CONTROL_ADDR(x))
#define HW_USBDCD_CONTROL_RD(x)  (HW_USBDCD_CONTROL(x).U)
#define HW_USBDCD_CONTROL_WR(x, v) (HW_USBDCD_CONTROL(x).U = (v))
#define HW_USBDCD_CONTROL_SET(x, v) (HW_USBDCD_CONTROL_WR(x, HW_USBDCD_CONTROL_RD(x) |  (v)))
#define HW_USBDCD_CONTROL_CLR(x, v) (HW_USBDCD_CONTROL_WR(x, HW_USBDCD_CONTROL_RD(x) & ~(v)))
#define HW_USBDCD_CONTROL_TOG(x, v) (HW_USBDCD_CONTROL_WR(x, HW_USBDCD_CONTROL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USBDCD_CONTROL bitfields
 */

/*!
 * @name Register USBDCD_CONTROL, field IACK[0] (WORZ)
 *
 * Determines whether the interrupt is cleared.
 *
 * Values:
 * - 0 - Do not clear the interrupt.
 * - 1 - Clear the IF bit (interrupt flag).
 */
/*@{*/
#define BP_USBDCD_CONTROL_IACK (0U)        /*!< Bit position for USBDCD_CONTROL_IACK. */
#define BM_USBDCD_CONTROL_IACK (0x00000001U) /*!< Bit mask for USBDCD_CONTROL_IACK. */
#define BS_USBDCD_CONTROL_IACK (1U)        /*!< Bit field size in bits for USBDCD_CONTROL_IACK. */

/*! @brief Format value for bitfield USBDCD_CONTROL_IACK. */
#define BF_USBDCD_CONTROL_IACK(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_CONTROL_IACK) & BM_USBDCD_CONTROL_IACK)

/*! @brief Set the IACK field to a new value. */
#define BW_USBDCD_CONTROL_IACK(x, v) (BITBAND_ACCESS32(HW_USBDCD_CONTROL_ADDR(x), BP_USBDCD_CONTROL_IACK) = (v))
/*@}*/

/*!
 * @name Register USBDCD_CONTROL, field IF[8] (RO)
 *
 * Determines whether an interrupt is pending.
 *
 * Values:
 * - 0 - No interrupt is pending.
 * - 1 - An interrupt is pending.
 */
/*@{*/
#define BP_USBDCD_CONTROL_IF (8U)          /*!< Bit position for USBDCD_CONTROL_IF. */
#define BM_USBDCD_CONTROL_IF (0x00000100U) /*!< Bit mask for USBDCD_CONTROL_IF. */
#define BS_USBDCD_CONTROL_IF (1U)          /*!< Bit field size in bits for USBDCD_CONTROL_IF. */

/*! @brief Read current value of the USBDCD_CONTROL_IF field. */
#define BR_USBDCD_CONTROL_IF(x) (BITBAND_ACCESS32(HW_USBDCD_CONTROL_ADDR(x), BP_USBDCD_CONTROL_IF))
/*@}*/

/*!
 * @name Register USBDCD_CONTROL, field IE[16] (RW)
 *
 * Enables/disables interrupts to the system.
 *
 * Values:
 * - 0 - Disable interrupts to the system.
 * - 1 - Enable interrupts to the system.
 */
/*@{*/
#define BP_USBDCD_CONTROL_IE (16U)         /*!< Bit position for USBDCD_CONTROL_IE. */
#define BM_USBDCD_CONTROL_IE (0x00010000U) /*!< Bit mask for USBDCD_CONTROL_IE. */
#define BS_USBDCD_CONTROL_IE (1U)          /*!< Bit field size in bits for USBDCD_CONTROL_IE. */

/*! @brief Read current value of the USBDCD_CONTROL_IE field. */
#define BR_USBDCD_CONTROL_IE(x) (BITBAND_ACCESS32(HW_USBDCD_CONTROL_ADDR(x), BP_USBDCD_CONTROL_IE))

/*! @brief Format value for bitfield USBDCD_CONTROL_IE. */
#define BF_USBDCD_CONTROL_IE(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_CONTROL_IE) & BM_USBDCD_CONTROL_IE)

/*! @brief Set the IE field to a new value. */
#define BW_USBDCD_CONTROL_IE(x, v) (BITBAND_ACCESS32(HW_USBDCD_CONTROL_ADDR(x), BP_USBDCD_CONTROL_IE) = (v))
/*@}*/

/*!
 * @name Register USBDCD_CONTROL, field BC12[17] (RW)
 *
 * BC1.2 compatibility. This bit cannot be changed after start detection.
 *
 * Values:
 * - 0 - Compatible with BC1.1 (default)
 * - 1 - Compatible with BC1.2
 */
/*@{*/
#define BP_USBDCD_CONTROL_BC12 (17U)       /*!< Bit position for USBDCD_CONTROL_BC12. */
#define BM_USBDCD_CONTROL_BC12 (0x00020000U) /*!< Bit mask for USBDCD_CONTROL_BC12. */
#define BS_USBDCD_CONTROL_BC12 (1U)        /*!< Bit field size in bits for USBDCD_CONTROL_BC12. */

/*! @brief Read current value of the USBDCD_CONTROL_BC12 field. */
#define BR_USBDCD_CONTROL_BC12(x) (BITBAND_ACCESS32(HW_USBDCD_CONTROL_ADDR(x), BP_USBDCD_CONTROL_BC12))

/*! @brief Format value for bitfield USBDCD_CONTROL_BC12. */
#define BF_USBDCD_CONTROL_BC12(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_CONTROL_BC12) & BM_USBDCD_CONTROL_BC12)

/*! @brief Set the BC12 field to a new value. */
#define BW_USBDCD_CONTROL_BC12(x, v) (BITBAND_ACCESS32(HW_USBDCD_CONTROL_ADDR(x), BP_USBDCD_CONTROL_BC12) = (v))
/*@}*/

/*!
 * @name Register USBDCD_CONTROL, field START[24] (WORZ)
 *
 * Determines whether the charger detection sequence is initiated.
 *
 * Values:
 * - 0 - Do not start the sequence. Writes of this value have no effect.
 * - 1 - Initiate the charger detection sequence. If the sequence is already
 *     running, writes of this value have no effect.
 */
/*@{*/
#define BP_USBDCD_CONTROL_START (24U)      /*!< Bit position for USBDCD_CONTROL_START. */
#define BM_USBDCD_CONTROL_START (0x01000000U) /*!< Bit mask for USBDCD_CONTROL_START. */
#define BS_USBDCD_CONTROL_START (1U)       /*!< Bit field size in bits for USBDCD_CONTROL_START. */

/*! @brief Format value for bitfield USBDCD_CONTROL_START. */
#define BF_USBDCD_CONTROL_START(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_CONTROL_START) & BM_USBDCD_CONTROL_START)

/*! @brief Set the START field to a new value. */
#define BW_USBDCD_CONTROL_START(x, v) (BITBAND_ACCESS32(HW_USBDCD_CONTROL_ADDR(x), BP_USBDCD_CONTROL_START) = (v))
/*@}*/

/*!
 * @name Register USBDCD_CONTROL, field SR[25] (WORZ)
 *
 * Determines whether a software reset is performed.
 *
 * Values:
 * - 0 - Do not perform a software reset.
 * - 1 - Perform a software reset.
 */
/*@{*/
#define BP_USBDCD_CONTROL_SR (25U)         /*!< Bit position for USBDCD_CONTROL_SR. */
#define BM_USBDCD_CONTROL_SR (0x02000000U) /*!< Bit mask for USBDCD_CONTROL_SR. */
#define BS_USBDCD_CONTROL_SR (1U)          /*!< Bit field size in bits for USBDCD_CONTROL_SR. */

/*! @brief Format value for bitfield USBDCD_CONTROL_SR. */
#define BF_USBDCD_CONTROL_SR(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_CONTROL_SR) & BM_USBDCD_CONTROL_SR)

/*! @brief Set the SR field to a new value. */
#define BW_USBDCD_CONTROL_SR(x, v) (BITBAND_ACCESS32(HW_USBDCD_CONTROL_ADDR(x), BP_USBDCD_CONTROL_SR) = (v))
/*@}*/

/*******************************************************************************
 * HW_USBDCD_CLOCK - Clock register
 ******************************************************************************/

/*!
 * @brief HW_USBDCD_CLOCK - Clock register (RW)
 *
 * Reset value: 0x000000C1U
 */
typedef union _hw_usbdcd_clock
{
    uint32_t U;
    struct _hw_usbdcd_clock_bitfields
    {
        uint32_t CLOCK_UNIT : 1;       /*!< [0] Unit of Measurement Encoding for
                                        * Clock Speed */
        uint32_t RESERVED0 : 1;        /*!< [1]  */
        uint32_t CLOCK_SPEED : 10;     /*!< [11:2] Numerical Value of Clock Speed
                                        * in Binary */
        uint32_t RESERVED1 : 20;       /*!< [31:12]  */
    } B;
} hw_usbdcd_clock_t;

/*!
 * @name Constants and macros for entire USBDCD_CLOCK register
 */
/*@{*/
#define HW_USBDCD_CLOCK_ADDR(x)  ((uint32_t)(x) + 0x4U)

#define HW_USBDCD_CLOCK(x)       (*(__IO hw_usbdcd_clock_t *) HW_USBDCD_CLOCK_ADDR(x))
#define HW_USBDCD_CLOCK_RD(x)    (HW_USBDCD_CLOCK(x).U)
#define HW_USBDCD_CLOCK_WR(x, v) (HW_USBDCD_CLOCK(x).U = (v))
#define HW_USBDCD_CLOCK_SET(x, v) (HW_USBDCD_CLOCK_WR(x, HW_USBDCD_CLOCK_RD(x) |  (v)))
#define HW_USBDCD_CLOCK_CLR(x, v) (HW_USBDCD_CLOCK_WR(x, HW_USBDCD_CLOCK_RD(x) & ~(v)))
#define HW_USBDCD_CLOCK_TOG(x, v) (HW_USBDCD_CLOCK_WR(x, HW_USBDCD_CLOCK_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USBDCD_CLOCK bitfields
 */

/*!
 * @name Register USBDCD_CLOCK, field CLOCK_UNIT[0] (RW)
 *
 * Specifies the unit of measure for the clock speed.
 *
 * Values:
 * - 0 - kHz Speed (between 1 kHz and 1023 kHz)
 * - 1 - MHz Speed (between 1 MHz and 1023 MHz)
 */
/*@{*/
#define BP_USBDCD_CLOCK_CLOCK_UNIT (0U)    /*!< Bit position for USBDCD_CLOCK_CLOCK_UNIT. */
#define BM_USBDCD_CLOCK_CLOCK_UNIT (0x00000001U) /*!< Bit mask for USBDCD_CLOCK_CLOCK_UNIT. */
#define BS_USBDCD_CLOCK_CLOCK_UNIT (1U)    /*!< Bit field size in bits for USBDCD_CLOCK_CLOCK_UNIT. */

/*! @brief Read current value of the USBDCD_CLOCK_CLOCK_UNIT field. */
#define BR_USBDCD_CLOCK_CLOCK_UNIT(x) (BITBAND_ACCESS32(HW_USBDCD_CLOCK_ADDR(x), BP_USBDCD_CLOCK_CLOCK_UNIT))

/*! @brief Format value for bitfield USBDCD_CLOCK_CLOCK_UNIT. */
#define BF_USBDCD_CLOCK_CLOCK_UNIT(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_CLOCK_CLOCK_UNIT) & BM_USBDCD_CLOCK_CLOCK_UNIT)

/*! @brief Set the CLOCK_UNIT field to a new value. */
#define BW_USBDCD_CLOCK_CLOCK_UNIT(x, v) (BITBAND_ACCESS32(HW_USBDCD_CLOCK_ADDR(x), BP_USBDCD_CLOCK_CLOCK_UNIT) = (v))
/*@}*/

/*!
 * @name Register USBDCD_CLOCK, field CLOCK_SPEED[11:2] (RW)
 *
 * The unit of measure is programmed in CLOCK_UNIT. The valid range is from 1 to
 * 1023 when clock unit is MHz and 4 to 1023 when clock unit is kHz. Examples
 * with CLOCK_UNIT = 1: For 48 MHz: 0b00_0011_0000 (48) (Default) For 24 MHz:
 * 0b00_0001_1000 (24) Examples with CLOCK_UNIT = 0: For 100 kHz: 0b00_0110_0100 (100)
 * For 500 kHz: 0b01_1111_0100 (500)
 */
/*@{*/
#define BP_USBDCD_CLOCK_CLOCK_SPEED (2U)   /*!< Bit position for USBDCD_CLOCK_CLOCK_SPEED. */
#define BM_USBDCD_CLOCK_CLOCK_SPEED (0x00000FFCU) /*!< Bit mask for USBDCD_CLOCK_CLOCK_SPEED. */
#define BS_USBDCD_CLOCK_CLOCK_SPEED (10U)  /*!< Bit field size in bits for USBDCD_CLOCK_CLOCK_SPEED. */

/*! @brief Read current value of the USBDCD_CLOCK_CLOCK_SPEED field. */
#define BR_USBDCD_CLOCK_CLOCK_SPEED(x) (HW_USBDCD_CLOCK(x).B.CLOCK_SPEED)

/*! @brief Format value for bitfield USBDCD_CLOCK_CLOCK_SPEED. */
#define BF_USBDCD_CLOCK_CLOCK_SPEED(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_CLOCK_CLOCK_SPEED) & BM_USBDCD_CLOCK_CLOCK_SPEED)

/*! @brief Set the CLOCK_SPEED field to a new value. */
#define BW_USBDCD_CLOCK_CLOCK_SPEED(x, v) (HW_USBDCD_CLOCK_WR(x, (HW_USBDCD_CLOCK_RD(x) & ~BM_USBDCD_CLOCK_CLOCK_SPEED) | BF_USBDCD_CLOCK_CLOCK_SPEED(v)))
/*@}*/

/*******************************************************************************
 * HW_USBDCD_STATUS - Status register
 ******************************************************************************/

/*!
 * @brief HW_USBDCD_STATUS - Status register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Provides the current state of the module for system software monitoring.
 */
typedef union _hw_usbdcd_status
{
    uint32_t U;
    struct _hw_usbdcd_status_bitfields
    {
        uint32_t RESERVED0 : 16;       /*!< [15:0]  */
        uint32_t SEQ_RES : 2;          /*!< [17:16] Charger Detection Sequence Results
                                        * */
        uint32_t SEQ_STAT : 2;         /*!< [19:18] Charger Detection Sequence Status
                                        * */
        uint32_t ERR : 1;              /*!< [20] Error Flag */
        uint32_t TO : 1;               /*!< [21] Timeout Flag */
        uint32_t ACTIVE : 1;           /*!< [22] Active Status Indicator */
        uint32_t RESERVED1 : 9;        /*!< [31:23]  */
    } B;
} hw_usbdcd_status_t;

/*!
 * @name Constants and macros for entire USBDCD_STATUS register
 */
/*@{*/
#define HW_USBDCD_STATUS_ADDR(x) ((uint32_t)(x) + 0x8U)

#define HW_USBDCD_STATUS(x)      (*(__I hw_usbdcd_status_t *) HW_USBDCD_STATUS_ADDR(x))
#define HW_USBDCD_STATUS_RD(x)   (HW_USBDCD_STATUS(x).U)
/*@}*/

/*
 * Constants & macros for individual USBDCD_STATUS bitfields
 */

/*!
 * @name Register USBDCD_STATUS, field SEQ_RES[17:16] (RO)
 *
 * Reports how the charger detection is attached.
 *
 * Values:
 * - 00 - No results to report.
 * - 01 - Attached to a standard host. Must comply with USB 2.0 by drawing only
 *     2.5 mA (max) until connected.
 * - 10 - Attached to a charging port. The exact meaning depends on bit 18: 0:
 *     Attached to either a charging host or a dedicated charger. The charger type
 *     detection has not completed. 1: Attached to a charging host. The charger
 *     type detection has completed.
 * - 11 - Attached to a dedicated charger.
 */
/*@{*/
#define BP_USBDCD_STATUS_SEQ_RES (16U)     /*!< Bit position for USBDCD_STATUS_SEQ_RES. */
#define BM_USBDCD_STATUS_SEQ_RES (0x00030000U) /*!< Bit mask for USBDCD_STATUS_SEQ_RES. */
#define BS_USBDCD_STATUS_SEQ_RES (2U)      /*!< Bit field size in bits for USBDCD_STATUS_SEQ_RES. */

/*! @brief Read current value of the USBDCD_STATUS_SEQ_RES field. */
#define BR_USBDCD_STATUS_SEQ_RES(x) (HW_USBDCD_STATUS(x).B.SEQ_RES)
/*@}*/

/*!
 * @name Register USBDCD_STATUS, field SEQ_STAT[19:18] (RO)
 *
 * Indicates the status of the charger detection sequence.
 *
 * Values:
 * - 00 - The module is either not enabled, or the module is enabled but the
 *     data pins have not yet been detected.
 * - 01 - Data pin contact detection is complete.
 * - 10 - Charging port detection is complete.
 * - 11 - Charger type detection is complete.
 */
/*@{*/
#define BP_USBDCD_STATUS_SEQ_STAT (18U)    /*!< Bit position for USBDCD_STATUS_SEQ_STAT. */
#define BM_USBDCD_STATUS_SEQ_STAT (0x000C0000U) /*!< Bit mask for USBDCD_STATUS_SEQ_STAT. */
#define BS_USBDCD_STATUS_SEQ_STAT (2U)     /*!< Bit field size in bits for USBDCD_STATUS_SEQ_STAT. */

/*! @brief Read current value of the USBDCD_STATUS_SEQ_STAT field. */
#define BR_USBDCD_STATUS_SEQ_STAT(x) (HW_USBDCD_STATUS(x).B.SEQ_STAT)
/*@}*/

/*!
 * @name Register USBDCD_STATUS, field ERR[20] (RO)
 *
 * Indicates whether there is an error in the detection sequence.
 *
 * Values:
 * - 0 - No sequence errors.
 * - 1 - Error in the detection sequence. See the SEQ_STAT field to determine
 *     the phase in which the error occurred.
 */
/*@{*/
#define BP_USBDCD_STATUS_ERR (20U)         /*!< Bit position for USBDCD_STATUS_ERR. */
#define BM_USBDCD_STATUS_ERR (0x00100000U) /*!< Bit mask for USBDCD_STATUS_ERR. */
#define BS_USBDCD_STATUS_ERR (1U)          /*!< Bit field size in bits for USBDCD_STATUS_ERR. */

/*! @brief Read current value of the USBDCD_STATUS_ERR field. */
#define BR_USBDCD_STATUS_ERR(x) (BITBAND_ACCESS32(HW_USBDCD_STATUS_ADDR(x), BP_USBDCD_STATUS_ERR))
/*@}*/

/*!
 * @name Register USBDCD_STATUS, field TO[21] (RO)
 *
 * Indicates whether the detection sequence has passed the timeout threshhold.
 *
 * Values:
 * - 0 - The detection sequence has not been running for over 1 s.
 * - 1 - It has been over 1 s since the data pin contact was detected and
 *     debounced.
 */
/*@{*/
#define BP_USBDCD_STATUS_TO  (21U)         /*!< Bit position for USBDCD_STATUS_TO. */
#define BM_USBDCD_STATUS_TO  (0x00200000U) /*!< Bit mask for USBDCD_STATUS_TO. */
#define BS_USBDCD_STATUS_TO  (1U)          /*!< Bit field size in bits for USBDCD_STATUS_TO. */

/*! @brief Read current value of the USBDCD_STATUS_TO field. */
#define BR_USBDCD_STATUS_TO(x) (BITBAND_ACCESS32(HW_USBDCD_STATUS_ADDR(x), BP_USBDCD_STATUS_TO))
/*@}*/

/*!
 * @name Register USBDCD_STATUS, field ACTIVE[22] (RO)
 *
 * Indicates whether the sequence is running.
 *
 * Values:
 * - 0 - The sequence is not running.
 * - 1 - The sequence is running.
 */
/*@{*/
#define BP_USBDCD_STATUS_ACTIVE (22U)      /*!< Bit position for USBDCD_STATUS_ACTIVE. */
#define BM_USBDCD_STATUS_ACTIVE (0x00400000U) /*!< Bit mask for USBDCD_STATUS_ACTIVE. */
#define BS_USBDCD_STATUS_ACTIVE (1U)       /*!< Bit field size in bits for USBDCD_STATUS_ACTIVE. */

/*! @brief Read current value of the USBDCD_STATUS_ACTIVE field. */
#define BR_USBDCD_STATUS_ACTIVE(x) (BITBAND_ACCESS32(HW_USBDCD_STATUS_ADDR(x), BP_USBDCD_STATUS_ACTIVE))
/*@}*/

/*******************************************************************************
 * HW_USBDCD_TIMER0 - TIMER0 register
 ******************************************************************************/

/*!
 * @brief HW_USBDCD_TIMER0 - TIMER0 register (RW)
 *
 * Reset value: 0x00100000U
 *
 * TIMER0 has an TSEQ_INIT field that represents the system latency in ms.
 * Latency is measured from the time when VBUS goes active until the time system
 * software initiates charger detection sequence in USBDCD module. When software sets
 * the CONTROL[START] bit, the Unit Connection Timer (TUNITCON) is initialized
 * with the value of TSEQ_INIT. Valid values are 0-1023, however the USB Battery
 * Charging Specification requires the entire sequence, including TSEQ_INIT, to be
 * completed in 1s or less.
 */
typedef union _hw_usbdcd_timer0
{
    uint32_t U;
    struct _hw_usbdcd_timer0_bitfields
    {
        uint32_t TUNITCON : 12;        /*!< [11:0] Unit Connection Timer Elapse (in
                                        * ms) */
        uint32_t RESERVED0 : 4;        /*!< [15:12]  */
        uint32_t TSEQ_INIT : 10;       /*!< [25:16] Sequence Initiation Time */
        uint32_t RESERVED1 : 6;        /*!< [31:26]  */
    } B;
} hw_usbdcd_timer0_t;

/*!
 * @name Constants and macros for entire USBDCD_TIMER0 register
 */
/*@{*/
#define HW_USBDCD_TIMER0_ADDR(x) ((uint32_t)(x) + 0x10U)

#define HW_USBDCD_TIMER0(x)      (*(__IO hw_usbdcd_timer0_t *) HW_USBDCD_TIMER0_ADDR(x))
#define HW_USBDCD_TIMER0_RD(x)   (HW_USBDCD_TIMER0(x).U)
#define HW_USBDCD_TIMER0_WR(x, v) (HW_USBDCD_TIMER0(x).U = (v))
#define HW_USBDCD_TIMER0_SET(x, v) (HW_USBDCD_TIMER0_WR(x, HW_USBDCD_TIMER0_RD(x) |  (v)))
#define HW_USBDCD_TIMER0_CLR(x, v) (HW_USBDCD_TIMER0_WR(x, HW_USBDCD_TIMER0_RD(x) & ~(v)))
#define HW_USBDCD_TIMER0_TOG(x, v) (HW_USBDCD_TIMER0_WR(x, HW_USBDCD_TIMER0_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USBDCD_TIMER0 bitfields
 */

/*!
 * @name Register USBDCD_TIMER0, field TUNITCON[11:0] (RO)
 *
 * Displays the amount of elapsed time since the event of setting the START bit
 * plus the value of TSEQ_INIT. The timer is automatically initialized with the
 * value of TSEQ_INIT before starting to count. This timer enables compliance with
 * the maximum time allowed to connect T UNIT_CON under the USB Battery Charging
 * Specification. If the timer reaches the one second limit, the module triggers
 * an interrupt and sets the error flag STATUS[ERR]. The timer continues
 * counting throughout the charger detection sequence, even when control has been passed
 * to software. As long as the module is active, the timer continues to count
 * until it reaches the maximum value of 0xFFF (4095 ms). The timer does not
 * rollover to zero. A software reset clears the timer.
 */
/*@{*/
#define BP_USBDCD_TIMER0_TUNITCON (0U)     /*!< Bit position for USBDCD_TIMER0_TUNITCON. */
#define BM_USBDCD_TIMER0_TUNITCON (0x00000FFFU) /*!< Bit mask for USBDCD_TIMER0_TUNITCON. */
#define BS_USBDCD_TIMER0_TUNITCON (12U)    /*!< Bit field size in bits for USBDCD_TIMER0_TUNITCON. */

/*! @brief Read current value of the USBDCD_TIMER0_TUNITCON field. */
#define BR_USBDCD_TIMER0_TUNITCON(x) (HW_USBDCD_TIMER0(x).B.TUNITCON)
/*@}*/

/*!
 * @name Register USBDCD_TIMER0, field TSEQ_INIT[25:16] (RW)
 *
 * TSEQ_INIT represents the system latency (in ms) measured from the time VBUS
 * goes active to the time system software initiates the charger detection
 * sequence in the USBDCD module. When software sets the CONTROL[START] bit, the Unit
 * Connection Timer (TUNITCON) is initialized with the value of TSEQ_INIT. Valid
 * values are 0-1023, but the USB Battery Charging Specification requires the
 * entire sequence, including TSEQ_INIT, to be completed in 1s or less.
 */
/*@{*/
#define BP_USBDCD_TIMER0_TSEQ_INIT (16U)   /*!< Bit position for USBDCD_TIMER0_TSEQ_INIT. */
#define BM_USBDCD_TIMER0_TSEQ_INIT (0x03FF0000U) /*!< Bit mask for USBDCD_TIMER0_TSEQ_INIT. */
#define BS_USBDCD_TIMER0_TSEQ_INIT (10U)   /*!< Bit field size in bits for USBDCD_TIMER0_TSEQ_INIT. */

/*! @brief Read current value of the USBDCD_TIMER0_TSEQ_INIT field. */
#define BR_USBDCD_TIMER0_TSEQ_INIT(x) (HW_USBDCD_TIMER0(x).B.TSEQ_INIT)

/*! @brief Format value for bitfield USBDCD_TIMER0_TSEQ_INIT. */
#define BF_USBDCD_TIMER0_TSEQ_INIT(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_TIMER0_TSEQ_INIT) & BM_USBDCD_TIMER0_TSEQ_INIT)

/*! @brief Set the TSEQ_INIT field to a new value. */
#define BW_USBDCD_TIMER0_TSEQ_INIT(x, v) (HW_USBDCD_TIMER0_WR(x, (HW_USBDCD_TIMER0_RD(x) & ~BM_USBDCD_TIMER0_TSEQ_INIT) | BF_USBDCD_TIMER0_TSEQ_INIT(v)))
/*@}*/

/*******************************************************************************
 * HW_USBDCD_TIMER1 - TIMER1 register
 ******************************************************************************/

/*!
 * @brief HW_USBDCD_TIMER1 - TIMER1 register (RW)
 *
 * Reset value: 0x000A0028U
 *
 * TIMER1 contains timing parameters. Note that register values can be written
 * that are not compliant with the USB Battery Charging Specification, so care
 * should be taken when overwriting the default values.
 */
typedef union _hw_usbdcd_timer1
{
    uint32_t U;
    struct _hw_usbdcd_timer1_bitfields
    {
        uint32_t TVDPSRC_ON : 10;      /*!< [9:0] Time Period Comparator Enabled */
        uint32_t RESERVED0 : 6;        /*!< [15:10]  */
        uint32_t TDCD_DBNC : 10;       /*!< [25:16] Time Period to Debounce D+
                                        * Signal */
        uint32_t RESERVED1 : 6;        /*!< [31:26]  */
    } B;
} hw_usbdcd_timer1_t;

/*!
 * @name Constants and macros for entire USBDCD_TIMER1 register
 */
/*@{*/
#define HW_USBDCD_TIMER1_ADDR(x) ((uint32_t)(x) + 0x14U)

#define HW_USBDCD_TIMER1(x)      (*(__IO hw_usbdcd_timer1_t *) HW_USBDCD_TIMER1_ADDR(x))
#define HW_USBDCD_TIMER1_RD(x)   (HW_USBDCD_TIMER1(x).U)
#define HW_USBDCD_TIMER1_WR(x, v) (HW_USBDCD_TIMER1(x).U = (v))
#define HW_USBDCD_TIMER1_SET(x, v) (HW_USBDCD_TIMER1_WR(x, HW_USBDCD_TIMER1_RD(x) |  (v)))
#define HW_USBDCD_TIMER1_CLR(x, v) (HW_USBDCD_TIMER1_WR(x, HW_USBDCD_TIMER1_RD(x) & ~(v)))
#define HW_USBDCD_TIMER1_TOG(x, v) (HW_USBDCD_TIMER1_WR(x, HW_USBDCD_TIMER1_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USBDCD_TIMER1 bitfields
 */

/*!
 * @name Register USBDCD_TIMER1, field TVDPSRC_ON[9:0] (RW)
 *
 * This timing parameter is used after detection of the data pin. See "Charging
 * Port Detection". Valid values are 1-1023, but the USB Battery Charging
 * Specification requires a minimum value of 40 ms.
 */
/*@{*/
#define BP_USBDCD_TIMER1_TVDPSRC_ON (0U)   /*!< Bit position for USBDCD_TIMER1_TVDPSRC_ON. */
#define BM_USBDCD_TIMER1_TVDPSRC_ON (0x000003FFU) /*!< Bit mask for USBDCD_TIMER1_TVDPSRC_ON. */
#define BS_USBDCD_TIMER1_TVDPSRC_ON (10U)  /*!< Bit field size in bits for USBDCD_TIMER1_TVDPSRC_ON. */

/*! @brief Read current value of the USBDCD_TIMER1_TVDPSRC_ON field. */
#define BR_USBDCD_TIMER1_TVDPSRC_ON(x) (HW_USBDCD_TIMER1(x).B.TVDPSRC_ON)

/*! @brief Format value for bitfield USBDCD_TIMER1_TVDPSRC_ON. */
#define BF_USBDCD_TIMER1_TVDPSRC_ON(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_TIMER1_TVDPSRC_ON) & BM_USBDCD_TIMER1_TVDPSRC_ON)

/*! @brief Set the TVDPSRC_ON field to a new value. */
#define BW_USBDCD_TIMER1_TVDPSRC_ON(x, v) (HW_USBDCD_TIMER1_WR(x, (HW_USBDCD_TIMER1_RD(x) & ~BM_USBDCD_TIMER1_TVDPSRC_ON) | BF_USBDCD_TIMER1_TVDPSRC_ON(v)))
/*@}*/

/*!
 * @name Register USBDCD_TIMER1, field TDCD_DBNC[25:16] (RW)
 *
 * Sets the time period (ms) to debounce the D+ signal during the data pin
 * contact detection phase. See "Debouncing the data pin contact" Valid values are
 * 1-1023, but the USB Battery Charging Specification requires a minimum value of 10
 * ms.
 */
/*@{*/
#define BP_USBDCD_TIMER1_TDCD_DBNC (16U)   /*!< Bit position for USBDCD_TIMER1_TDCD_DBNC. */
#define BM_USBDCD_TIMER1_TDCD_DBNC (0x03FF0000U) /*!< Bit mask for USBDCD_TIMER1_TDCD_DBNC. */
#define BS_USBDCD_TIMER1_TDCD_DBNC (10U)   /*!< Bit field size in bits for USBDCD_TIMER1_TDCD_DBNC. */

/*! @brief Read current value of the USBDCD_TIMER1_TDCD_DBNC field. */
#define BR_USBDCD_TIMER1_TDCD_DBNC(x) (HW_USBDCD_TIMER1(x).B.TDCD_DBNC)

/*! @brief Format value for bitfield USBDCD_TIMER1_TDCD_DBNC. */
#define BF_USBDCD_TIMER1_TDCD_DBNC(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_TIMER1_TDCD_DBNC) & BM_USBDCD_TIMER1_TDCD_DBNC)

/*! @brief Set the TDCD_DBNC field to a new value. */
#define BW_USBDCD_TIMER1_TDCD_DBNC(x, v) (HW_USBDCD_TIMER1_WR(x, (HW_USBDCD_TIMER1_RD(x) & ~BM_USBDCD_TIMER1_TDCD_DBNC) | BF_USBDCD_TIMER1_TDCD_DBNC(v)))
/*@}*/

/*******************************************************************************
 * HW_USBDCD_TIMER2_BC11 - TIMER2_BC11 register
 ******************************************************************************/

/*!
 * @brief HW_USBDCD_TIMER2_BC11 - TIMER2_BC11 register (RW)
 *
 * Reset value: 0x00280001U
 *
 * TIMER2_BC11 contains timing parameters for USB Battery Charging
 * Specification, v1.1. Register values can be written that are not compliant with the USB
 * Battery Charging Specification, so care should be taken when overwriting the
 * default values.
 */
typedef union _hw_usbdcd_timer2_bc11
{
    uint32_t U;
    struct _hw_usbdcd_timer2_bc11_bitfields
    {
        uint32_t CHECK_DM : 4;         /*!< [3:0] Time Before Check of D- Line */
        uint32_t RESERVED0 : 12;       /*!< [15:4]  */
        uint32_t TVDPSRC_CON : 10;     /*!< [25:16] Time Period Before Enabling
                                        * D+ Pullup */
        uint32_t RESERVED1 : 6;        /*!< [31:26]  */
    } B;
} hw_usbdcd_timer2_bc11_t;

/*!
 * @name Constants and macros for entire USBDCD_TIMER2_BC11 register
 */
/*@{*/
#define HW_USBDCD_TIMER2_BC11_ADDR(x) ((uint32_t)(x) + 0x18U)

#define HW_USBDCD_TIMER2_BC11(x) (*(__IO hw_usbdcd_timer2_bc11_t *) HW_USBDCD_TIMER2_BC11_ADDR(x))
#define HW_USBDCD_TIMER2_BC11_RD(x) (HW_USBDCD_TIMER2_BC11(x).U)
#define HW_USBDCD_TIMER2_BC11_WR(x, v) (HW_USBDCD_TIMER2_BC11(x).U = (v))
#define HW_USBDCD_TIMER2_BC11_SET(x, v) (HW_USBDCD_TIMER2_BC11_WR(x, HW_USBDCD_TIMER2_BC11_RD(x) |  (v)))
#define HW_USBDCD_TIMER2_BC11_CLR(x, v) (HW_USBDCD_TIMER2_BC11_WR(x, HW_USBDCD_TIMER2_BC11_RD(x) & ~(v)))
#define HW_USBDCD_TIMER2_BC11_TOG(x, v) (HW_USBDCD_TIMER2_BC11_WR(x, HW_USBDCD_TIMER2_BC11_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USBDCD_TIMER2_BC11 bitfields
 */

/*!
 * @name Register USBDCD_TIMER2_BC11, field CHECK_DM[3:0] (RW)
 *
 * Sets the amount of time (in ms) that the module waits after the device
 * connects to the USB bus until checking the state of the D- line to determine the
 * type of charging port. See "Charger Type Detection." Valid values are 1-15ms.
 */
/*@{*/
#define BP_USBDCD_TIMER2_BC11_CHECK_DM (0U) /*!< Bit position for USBDCD_TIMER2_BC11_CHECK_DM. */
#define BM_USBDCD_TIMER2_BC11_CHECK_DM (0x0000000FU) /*!< Bit mask for USBDCD_TIMER2_BC11_CHECK_DM. */
#define BS_USBDCD_TIMER2_BC11_CHECK_DM (4U) /*!< Bit field size in bits for USBDCD_TIMER2_BC11_CHECK_DM. */

/*! @brief Read current value of the USBDCD_TIMER2_BC11_CHECK_DM field. */
#define BR_USBDCD_TIMER2_BC11_CHECK_DM(x) (HW_USBDCD_TIMER2_BC11(x).B.CHECK_DM)

/*! @brief Format value for bitfield USBDCD_TIMER2_BC11_CHECK_DM. */
#define BF_USBDCD_TIMER2_BC11_CHECK_DM(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_TIMER2_BC11_CHECK_DM) & BM_USBDCD_TIMER2_BC11_CHECK_DM)

/*! @brief Set the CHECK_DM field to a new value. */
#define BW_USBDCD_TIMER2_BC11_CHECK_DM(x, v) (HW_USBDCD_TIMER2_BC11_WR(x, (HW_USBDCD_TIMER2_BC11_RD(x) & ~BM_USBDCD_TIMER2_BC11_CHECK_DM) | BF_USBDCD_TIMER2_BC11_CHECK_DM(v)))
/*@}*/

/*!
 * @name Register USBDCD_TIMER2_BC11, field TVDPSRC_CON[25:16] (RW)
 *
 * Sets the time period (ms) that the module waits after charging port detection
 * before system software must enable the D+ pullup to connect to the USB host.
 * Valid values are 1-1023, but the USB Battery Charging Specification requires a
 * minimum value of 40 ms.
 */
/*@{*/
#define BP_USBDCD_TIMER2_BC11_TVDPSRC_CON (16U) /*!< Bit position for USBDCD_TIMER2_BC11_TVDPSRC_CON. */
#define BM_USBDCD_TIMER2_BC11_TVDPSRC_CON (0x03FF0000U) /*!< Bit mask for USBDCD_TIMER2_BC11_TVDPSRC_CON. */
#define BS_USBDCD_TIMER2_BC11_TVDPSRC_CON (10U) /*!< Bit field size in bits for USBDCD_TIMER2_BC11_TVDPSRC_CON. */

/*! @brief Read current value of the USBDCD_TIMER2_BC11_TVDPSRC_CON field. */
#define BR_USBDCD_TIMER2_BC11_TVDPSRC_CON(x) (HW_USBDCD_TIMER2_BC11(x).B.TVDPSRC_CON)

/*! @brief Format value for bitfield USBDCD_TIMER2_BC11_TVDPSRC_CON. */
#define BF_USBDCD_TIMER2_BC11_TVDPSRC_CON(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_TIMER2_BC11_TVDPSRC_CON) & BM_USBDCD_TIMER2_BC11_TVDPSRC_CON)

/*! @brief Set the TVDPSRC_CON field to a new value. */
#define BW_USBDCD_TIMER2_BC11_TVDPSRC_CON(x, v) (HW_USBDCD_TIMER2_BC11_WR(x, (HW_USBDCD_TIMER2_BC11_RD(x) & ~BM_USBDCD_TIMER2_BC11_TVDPSRC_CON) | BF_USBDCD_TIMER2_BC11_TVDPSRC_CON(v)))
/*@}*/
/*******************************************************************************
 * HW_USBDCD_TIMER2_BC12 - TIMER2_BC12 register
 ******************************************************************************/

/*!
 * @brief HW_USBDCD_TIMER2_BC12 - TIMER2_BC12 register (RW)
 *
 * Reset value: 0x00010028U
 *
 * TIMER2_BC12 contains timing parameters for USB Battery Charging
 * Specification, v1.2. Register values can be written that are not compliant with the USB
 * Battery Charging Specification, so care should be taken when overwriting the
 * default values.
 */
typedef union _hw_usbdcd_timer2_bc12
{
    uint32_t U;
    struct _hw_usbdcd_timer2_bc12_bitfields
    {
        uint32_t TVDMSRC_ON : 10;      /*!< [9:0]  */
        uint32_t RESERVED0 : 6;        /*!< [15:10]  */
        uint32_t TWAIT_AFTER_PRD : 10; /*!< [25:16]  */
        uint32_t RESERVED1 : 6;        /*!< [31:26]  */
    } B;
} hw_usbdcd_timer2_bc12_t;

/*!
 * @name Constants and macros for entire USBDCD_TIMER2_BC12 register
 */
/*@{*/
#define HW_USBDCD_TIMER2_BC12_ADDR(x) ((uint32_t)(x) + 0x18U)

#define HW_USBDCD_TIMER2_BC12(x) (*(__IO hw_usbdcd_timer2_bc12_t *) HW_USBDCD_TIMER2_BC12_ADDR(x))
#define HW_USBDCD_TIMER2_BC12_RD(x) (HW_USBDCD_TIMER2_BC12(x).U)
#define HW_USBDCD_TIMER2_BC12_WR(x, v) (HW_USBDCD_TIMER2_BC12(x).U = (v))
#define HW_USBDCD_TIMER2_BC12_SET(x, v) (HW_USBDCD_TIMER2_BC12_WR(x, HW_USBDCD_TIMER2_BC12_RD(x) |  (v)))
#define HW_USBDCD_TIMER2_BC12_CLR(x, v) (HW_USBDCD_TIMER2_BC12_WR(x, HW_USBDCD_TIMER2_BC12_RD(x) & ~(v)))
#define HW_USBDCD_TIMER2_BC12_TOG(x, v) (HW_USBDCD_TIMER2_BC12_WR(x, HW_USBDCD_TIMER2_BC12_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual USBDCD_TIMER2_BC12 bitfields
 */

/*!
 * @name Register USBDCD_TIMER2_BC12, field TVDMSRC_ON[9:0] (RW)
 *
 * Sets the amount of time (in ms) that the module enables the VDM_SRC. Valid
 * values are 0-40ms.
 */
/*@{*/
#define BP_USBDCD_TIMER2_BC12_TVDMSRC_ON (0U) /*!< Bit position for USBDCD_TIMER2_BC12_TVDMSRC_ON. */
#define BM_USBDCD_TIMER2_BC12_TVDMSRC_ON (0x000003FFU) /*!< Bit mask for USBDCD_TIMER2_BC12_TVDMSRC_ON. */
#define BS_USBDCD_TIMER2_BC12_TVDMSRC_ON (10U) /*!< Bit field size in bits for USBDCD_TIMER2_BC12_TVDMSRC_ON. */

/*! @brief Read current value of the USBDCD_TIMER2_BC12_TVDMSRC_ON field. */
#define BR_USBDCD_TIMER2_BC12_TVDMSRC_ON(x) (HW_USBDCD_TIMER2_BC12(x).B.TVDMSRC_ON)

/*! @brief Format value for bitfield USBDCD_TIMER2_BC12_TVDMSRC_ON. */
#define BF_USBDCD_TIMER2_BC12_TVDMSRC_ON(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_TIMER2_BC12_TVDMSRC_ON) & BM_USBDCD_TIMER2_BC12_TVDMSRC_ON)

/*! @brief Set the TVDMSRC_ON field to a new value. */
#define BW_USBDCD_TIMER2_BC12_TVDMSRC_ON(x, v) (HW_USBDCD_TIMER2_BC12_WR(x, (HW_USBDCD_TIMER2_BC12_RD(x) & ~BM_USBDCD_TIMER2_BC12_TVDMSRC_ON) | BF_USBDCD_TIMER2_BC12_TVDMSRC_ON(v)))
/*@}*/

/*!
 * @name Register USBDCD_TIMER2_BC12, field TWAIT_AFTER_PRD[25:16] (RW)
 *
 * Sets the amount of time (in ms) that the module waits after primary detection
 * before start to secondary detection. Valid values are 1-1023ms. Default is
 * 1ms.
 */
/*@{*/
#define BP_USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD (16U) /*!< Bit position for USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD. */
#define BM_USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD (0x03FF0000U) /*!< Bit mask for USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD. */
#define BS_USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD (10U) /*!< Bit field size in bits for USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD. */

/*! @brief Read current value of the USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD field. */
#define BR_USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD(x) (HW_USBDCD_TIMER2_BC12(x).B.TWAIT_AFTER_PRD)

/*! @brief Format value for bitfield USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD. */
#define BF_USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD(v) ((uint32_t)((uint32_t)(v) << BP_USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD) & BM_USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD)

/*! @brief Set the TWAIT_AFTER_PRD field to a new value. */
#define BW_USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD(x, v) (HW_USBDCD_TIMER2_BC12_WR(x, (HW_USBDCD_TIMER2_BC12_RD(x) & ~BM_USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD) | BF_USBDCD_TIMER2_BC12_TWAIT_AFTER_PRD(v)))
/*@}*/

/*
** Start of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma push
  #pragma anon_unions
#elif defined(__CWCC__)
  #pragma push
  #pragma cpp_extensions on
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=extended
#else
  #error Not supported compiler type
#endif

/*******************************************************************************
 * hw_usbdcd_t - module struct
 ******************************************************************************/
/*!
 * @brief All USBDCD module registers.
 */
#pragma pack(1)
typedef struct _hw_usbdcd
{
    __IO hw_usbdcd_control_t CONTROL;      /*!< [0x0] Control register */
    __IO hw_usbdcd_clock_t CLOCK;          /*!< [0x4] Clock register */
    __I hw_usbdcd_status_t STATUS;         /*!< [0x8] Status register */
    uint8_t _reserved0[4];
    __IO hw_usbdcd_timer0_t TIMER0;        /*!< [0x10] TIMER0 register */
    __IO hw_usbdcd_timer1_t TIMER1;        /*!< [0x14] TIMER1 register */
    union {
        __IO hw_usbdcd_timer2_bc11_t TIMER2_BC11; /*!< [0x18] TIMER2_BC11 register */
        __IO hw_usbdcd_timer2_bc12_t TIMER2_BC12; /*!< [0x18] TIMER2_BC12 register */
    };
} hw_usbdcd_t;
#pragma pack()

/*! @brief Macro to access all USBDCD registers. */
/*! @param x USBDCD module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_USBDCD_REGS(USBDCD_BASE)</code>. */
#define HW_USBDCD_REGS(x) (*(hw_usbdcd_t *)(x))

/*
** End of section using anonymous unions
*/

#if defined(__ARMCC_VERSION)
  #pragma pop
#elif defined(__CWCC__)
  #pragma pop
#elif defined(__GNUC__)
  /* leave anonymous unions enabled */
#elif defined(__IAR_SYSTEMS_ICC__)
  #pragma language=default
#else
  #error Not supported compiler type
#endif

/*
 * MK64F12 VREF
 *
 * Voltage Reference
 *
 * Registers defined in this header file:
 * - HW_VREF_TRM - VREF Trim Register
 * - HW_VREF_SC - VREF Status and Control Register
 *
 * - hw_vref_t - Struct containing all module registers.
 */

#define HW_VREF_INSTANCE_COUNT (1U) /*!< Number of instances of the VREF module. */
#define HW_VREF (0U) /*!< Instance number for VREF. */

/*******************************************************************************
 * HW_VREF_TRM - VREF Trim Register
 ******************************************************************************/

/*!
 * @brief HW_VREF_TRM - VREF Trim Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains bits that contain the trim data for the Voltage
 * Reference.
 */
typedef union _hw_vref_trm
{
    uint8_t U;
    struct _hw_vref_trm_bitfields
    {
        uint8_t TRIM : 6;              /*!< [5:0] Trim bits */
        uint8_t CHOPEN : 1;            /*!< [6] Chop oscillator enable. When set,
                                        * internal chopping operation is enabled and the internal analog offset will be
                                        * minimized. */
        uint8_t RESERVED0 : 1;         /*!< [7]  */
    } B;
} hw_vref_trm_t;

/*!
 * @name Constants and macros for entire VREF_TRM register
 */
/*@{*/
#define HW_VREF_TRM_ADDR(x)      ((uint32_t)(x) + 0x0U)

#define HW_VREF_TRM(x)           (*(__IO hw_vref_trm_t *) HW_VREF_TRM_ADDR(x))
#define HW_VREF_TRM_RD(x)        (HW_VREF_TRM(x).U)
#define HW_VREF_TRM_WR(x, v)     (HW_VREF_TRM(x).U = (v))
#define HW_VREF_TRM_SET(x, v)    (HW_VREF_TRM_WR(x, HW_VREF_TRM_RD(x) |  (v)))
#define HW_VREF_TRM_CLR(x, v)    (HW_VREF_TRM_WR(x, HW_VREF_TRM_RD(x) & ~(v)))
#define HW_VREF_TRM_TOG(x, v)    (HW_VREF_TRM_WR(x, HW_VREF_TRM_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual VREF_TRM bitfields
 */

/*!
 * @name Register VREF_TRM, field TRIM[5:0] (RW)
 *
 * These bits change the resulting VREF by approximately +/- 0.5 mV for each
 * step. Min = minimum and max = maximum voltage reference output. For minimum and
 * maximum voltage reference output values, refer to the Data Sheet for this chip.
 *
 * Values:
 * - 000000 - Min
 * - 111111 - Max
 */
/*@{*/
#define BP_VREF_TRM_TRIM     (0U)          /*!< Bit position for VREF_TRM_TRIM. */
#define BM_VREF_TRM_TRIM     (0x3FU)       /*!< Bit mask for VREF_TRM_TRIM. */
#define BS_VREF_TRM_TRIM     (6U)          /*!< Bit field size in bits for VREF_TRM_TRIM. */

/*! @brief Read current value of the VREF_TRM_TRIM field. */
#define BR_VREF_TRM_TRIM(x)  (HW_VREF_TRM(x).B.TRIM)

/*! @brief Format value for bitfield VREF_TRM_TRIM. */
#define BF_VREF_TRM_TRIM(v)  ((uint8_t)((uint8_t)(v) << BP_VREF_TRM_TRIM) & BM_VREF_TRM_TRIM)

/*! @brief Set the TRIM field to a new value. */
#define BW_VREF_TRM_TRIM(x, v) (HW_VREF_TRM_WR(x, (HW_VREF_TRM_RD(x) & ~BM_VREF_TRM_TRIM) | BF_VREF_TRM_TRIM(v)))
/*@}*/

/*!
 * @name Register VREF_TRM, field CHOPEN[6] (RW)
 *
 * This bit is set during factory trimming of the VREF voltage. This bit should
 * be written to 1 to achieve the performance stated in the data sheet.
 *
 * Values:
 * - 0 - Chop oscillator is disabled.
 * - 1 - Chop oscillator is enabled.
 */
/*@{*/
#define BP_VREF_TRM_CHOPEN   (6U)          /*!< Bit position for VREF_TRM_CHOPEN. */
#define BM_VREF_TRM_CHOPEN   (0x40U)       /*!< Bit mask for VREF_TRM_CHOPEN. */
#define BS_VREF_TRM_CHOPEN   (1U)          /*!< Bit field size in bits for VREF_TRM_CHOPEN. */

/*! @brief Read current value of the VREF_TRM_CHOPEN field. */
#define BR_VREF_TRM_CHOPEN(x) (BITBAND_ACCESS8(HW_VREF_TRM_ADDR(x), BP_VREF_TRM_CHOPEN))

/*! @brief Format value for bitfield VREF_TRM_CHOPEN. */
#define BF_VREF_TRM_CHOPEN(v) ((uint8_t)((uint8_t)(v) << BP_VREF_TRM_CHOPEN) & BM_VREF_TRM_CHOPEN)

/*! @brief Set the CHOPEN field to a new value. */
#define BW_VREF_TRM_CHOPEN(x, v) (BITBAND_ACCESS8(HW_VREF_TRM_ADDR(x), BP_VREF_TRM_CHOPEN) = (v))
/*@}*/

/*******************************************************************************
 * HW_VREF_SC - VREF Status and Control Register
 ******************************************************************************/

/*!
 * @brief HW_VREF_SC - VREF Status and Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the control bits used to enable the internal voltage
 * reference and to select the buffer mode to be used.
 */
typedef union _hw_vref_sc
{
    uint8_t U;
    struct _hw_vref_sc_bitfields
    {
        uint8_t MODE_LV : 2;           /*!< [1:0] Buffer Mode selection */
        uint8_t VREFST : 1;            /*!< [2] Internal Voltage Reference stable */
        uint8_t RESERVED0 : 2;         /*!< [4:3]  */
        uint8_t ICOMPEN : 1;           /*!< [5] Second order curvature compensation
                                        * enable */
        uint8_t REGEN : 1;             /*!< [6] Regulator enable */
        uint8_t VREFEN : 1;            /*!< [7] Internal Voltage Reference enable */
    } B;
} hw_vref_sc_t;

/*!
 * @name Constants and macros for entire VREF_SC register
 */
/*@{*/
#define HW_VREF_SC_ADDR(x)       ((uint32_t)(x) + 0x1U)

#define HW_VREF_SC(x)            (*(__IO hw_vref_sc_t *) HW_VREF_SC_ADDR(x))
#define HW_VREF_SC_RD(x)         (HW_VREF_SC(x).U)
#define HW_VREF_SC_WR(x, v)      (HW_VREF_SC(x).U = (v))
#define HW_VREF_SC_SET(x, v)     (HW_VREF_SC_WR(x, HW_VREF_SC_RD(x) |  (v)))
#define HW_VREF_SC_CLR(x, v)     (HW_VREF_SC_WR(x, HW_VREF_SC_RD(x) & ~(v)))
#define HW_VREF_SC_TOG(x, v)     (HW_VREF_SC_WR(x, HW_VREF_SC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual VREF_SC bitfields
 */

/*!
 * @name Register VREF_SC, field MODE_LV[1:0] (RW)
 *
 * These bits select the buffer modes for the Voltage Reference module.
 *
 * Values:
 * - 00 - Bandgap on only, for stabilization and startup
 * - 01 - High power buffer mode enabled
 * - 10 - Low-power buffer mode enabled
 * - 11 - Reserved
 */
/*@{*/
#define BP_VREF_SC_MODE_LV   (0U)          /*!< Bit position for VREF_SC_MODE_LV. */
#define BM_VREF_SC_MODE_LV   (0x03U)       /*!< Bit mask for VREF_SC_MODE_LV. */
#define BS_VREF_SC_MODE_LV   (2U)          /*!< Bit field size in bits for VREF_SC_MODE_LV. */

/*! @brief Read current value of the VREF_SC_MODE_LV field. */
#define BR_VREF_SC_MODE_LV(x) (HW_VREF_SC(x).B.MODE_LV)

/*! @brief Format value for bitfield VREF_SC_MODE_LV. */
#define BF_VREF_SC_MODE_LV(v) ((uint8_t)((uint8_t)(v) << BP_VREF_SC_MODE_LV) & BM_VREF_SC_MODE_LV)

/*! @brief Set the MODE_LV field to a new value. */
#define BW_VREF_SC_MODE_LV(x, v) (HW_VREF_SC_WR(x, (HW_VREF_SC_RD(x) & ~BM_VREF_SC_MODE_LV) | BF_VREF_SC_MODE_LV(v)))
/*@}*/

/*!
 * @name Register VREF_SC, field VREFST[2] (RO)
 *
 * This bit indicates that the bandgap reference within the Voltage Reference
 * module has completed its startup and stabilization.
 *
 * Values:
 * - 0 - The module is disabled or not stable.
 * - 1 - The module is stable.
 */
/*@{*/
#define BP_VREF_SC_VREFST    (2U)          /*!< Bit position for VREF_SC_VREFST. */
#define BM_VREF_SC_VREFST    (0x04U)       /*!< Bit mask for VREF_SC_VREFST. */
#define BS_VREF_SC_VREFST    (1U)          /*!< Bit field size in bits for VREF_SC_VREFST. */

/*! @brief Read current value of the VREF_SC_VREFST field. */
#define BR_VREF_SC_VREFST(x) (BITBAND_ACCESS8(HW_VREF_SC_ADDR(x), BP_VREF_SC_VREFST))
/*@}*/

/*!
 * @name Register VREF_SC, field ICOMPEN[5] (RW)
 *
 * This bit is set during factory trimming of the VREF voltage. This bit should
 * be written to 1 to achieve the performance stated in the data sheet.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
#define BP_VREF_SC_ICOMPEN   (5U)          /*!< Bit position for VREF_SC_ICOMPEN. */
#define BM_VREF_SC_ICOMPEN   (0x20U)       /*!< Bit mask for VREF_SC_ICOMPEN. */
#define BS_VREF_SC_ICOMPEN   (1U)          /*!< Bit field size in bits for VREF_SC_ICOMPEN. */

/*! @brief Read current value of the VREF_SC_ICOMPEN field. */
#define BR_VREF_SC_ICOMPEN(x) (BITBAND_ACCESS8(HW_VREF_SC_ADDR(x), BP_VREF_SC_ICOMPEN))

/*! @brief Format value for bitfield VREF_SC_ICOMPEN. */
#define BF_VREF_SC_ICOMPEN(v) ((uint8_t)((uint8_t)(v) << BP_VREF_SC_ICOMPEN) & BM_VREF_SC_ICOMPEN)

/*! @brief Set the ICOMPEN field to a new value. */
#define BW_VREF_SC_ICOMPEN(x, v) (BITBAND_ACCESS8(HW_VREF_SC_ADDR(x), BP_VREF_SC_ICOMPEN) = (v))
/*@}*/

/*!
 * @name Register VREF_SC, field REGEN[6] (RW)
 *
 * This bit is used to enable the internal 1.75 V regulator to produce a
 * constant internal voltage supply in order to reduce the sensitivity to external
 * supply noise and variation. If it is desired to keep the regulator enabled in very
 * low power modes, refer to the Chip Configuration details for a description on
 * how this can be achieved. This bit is set during factory trimming of the VREF
 * voltage. This bit should be written to 1 to achieve the performance stated in
 * the data sheet.
 *
 * Values:
 * - 0 - Internal 1.75 V regulator is disabled.
 * - 1 - Internal 1.75 V regulator is enabled.
 */
/*@{*/
#define BP_VREF_SC_REGEN     (6U)          /*!< Bit position for VREF_SC_REGEN. */
#define BM_VREF_SC_REGEN     (0x40U)       /*!< Bit mask for VREF_SC_REGEN. */
#define BS_VREF_SC_REGEN     (1U)          /*!< Bit field size in bits for VREF_SC_REGEN. */

/*! @brief Read current value of the VREF_SC_REGEN field. */
#define BR_VREF_SC_REGEN(x)  (BITBAND_ACCESS8(HW_VREF_SC_ADDR(x), BP_VREF_SC_REGEN))

/*! @brief Format value for bitfield VREF_SC_REGEN. */
#define BF_VREF_SC_REGEN(v)  ((uint8_t)((uint8_t)(v) << BP_VREF_SC_REGEN) & BM_VREF_SC_REGEN)

/*! @brief Set the REGEN field to a new value. */
#define BW_VREF_SC_REGEN(x, v) (BITBAND_ACCESS8(HW_VREF_SC_ADDR(x), BP_VREF_SC_REGEN) = (v))
/*@}*/

/*!
 * @name Register VREF_SC, field VREFEN[7] (RW)
 *
 * This bit is used to enable the bandgap reference within the Voltage Reference
 * module. After the VREF is enabled, turning off the clock to the VREF module
 * via the corresponding clock gate register will not disable the VREF. VREF must
 * be disabled via this VREFEN bit.
 *
 * Values:
 * - 0 - The module is disabled.
 * - 1 - The module is enabled.
 */
/*@{*/
#define BP_VREF_SC_VREFEN    (7U)          /*!< Bit position for VREF_SC_VREFEN. */
#define BM_VREF_SC_VREFEN    (0x80U)       /*!< Bit mask for VREF_SC_VREFEN. */
#define BS_VREF_SC_VREFEN    (1U)          /*!< Bit field size in bits for VREF_SC_VREFEN. */

/*! @brief Read current value of the VREF_SC_VREFEN field. */
#define BR_VREF_SC_VREFEN(x) (BITBAND_ACCESS8(HW_VREF_SC_ADDR(x), BP_VREF_SC_VREFEN))

/*! @brief Format value for bitfield VREF_SC_VREFEN. */
#define BF_VREF_SC_VREFEN(v) ((uint8_t)((uint8_t)(v) << BP_VREF_SC_VREFEN) & BM_VREF_SC_VREFEN)

/*! @brief Set the VREFEN field to a new value. */
#define BW_VREF_SC_VREFEN(x, v) (BITBAND_ACCESS8(HW_VREF_SC_ADDR(x), BP_VREF_SC_VREFEN) = (v))
/*@}*/

/*******************************************************************************
 * hw_vref_t - module struct
 ******************************************************************************/
/*!
 * @brief All VREF module registers.
 */
#pragma pack(1)
typedef struct _hw_vref
{
    __IO hw_vref_trm_t TRM;                /*!< [0x0] VREF Trim Register */
    __IO hw_vref_sc_t SC;                  /*!< [0x1] VREF Status and Control Register */
} hw_vref_t;
#pragma pack()

/*! @brief Macro to access all VREF registers. */
/*! @param x VREF module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_VREF_REGS(VREF_BASE)</code>. */
#define HW_VREF_REGS(x) (*(hw_vref_t *)(x))

/*
 * MK64F12 WDOG
 *
 * Generation 2008 Watchdog Timer
 *
 * Registers defined in this header file:
 * - HW_WDOG_STCTRLH - Watchdog Status and Control Register High
 * - HW_WDOG_STCTRLL - Watchdog Status and Control Register Low
 * - HW_WDOG_TOVALH - Watchdog Time-out Value Register High
 * - HW_WDOG_TOVALL - Watchdog Time-out Value Register Low
 * - HW_WDOG_WINH - Watchdog Window Register High
 * - HW_WDOG_WINL - Watchdog Window Register Low
 * - HW_WDOG_REFRESH - Watchdog Refresh register
 * - HW_WDOG_UNLOCK - Watchdog Unlock register
 * - HW_WDOG_TMROUTH - Watchdog Timer Output Register High
 * - HW_WDOG_TMROUTL - Watchdog Timer Output Register Low
 * - HW_WDOG_RSTCNT - Watchdog Reset Count register
 * - HW_WDOG_PRESC - Watchdog Prescaler register
 *
 * - hw_wdog_t - Struct containing all module registers.
 */

#define HW_WDOG_INSTANCE_COUNT (1U) /*!< Number of instances of the WDOG module. */
#define HW_WDOG (0U) /*!< Instance number for WDOG. */

/*******************************************************************************
 * HW_WDOG_STCTRLH - Watchdog Status and Control Register High
 ******************************************************************************/

/*!
 * @brief HW_WDOG_STCTRLH - Watchdog Status and Control Register High (RW)
 *
 * Reset value: 0x01D3U
 */
typedef union _hw_wdog_stctrlh
{
    uint16_t U;
    struct _hw_wdog_stctrlh_bitfields
    {
        uint16_t WDOGEN : 1;           /*!< [0]  */
        uint16_t CLKSRC : 1;           /*!< [1]  */
        uint16_t IRQRSTEN : 1;         /*!< [2]  */
        uint16_t WINEN : 1;            /*!< [3]  */
        uint16_t ALLOWUPDATE : 1;      /*!< [4]  */
        uint16_t DBGEN : 1;            /*!< [5]  */
        uint16_t STOPEN : 1;           /*!< [6]  */
        uint16_t WAITEN : 1;           /*!< [7]  */
        uint16_t RESERVED0 : 2;        /*!< [9:8]  */
        uint16_t TESTWDOG : 1;         /*!< [10]  */
        uint16_t TESTSEL : 1;          /*!< [11]  */
        uint16_t BYTESEL : 2;          /*!< [13:12]  */
        uint16_t DISTESTWDOG : 1;      /*!< [14]  */
        uint16_t RESERVED1 : 1;        /*!< [15]  */
    } B;
} hw_wdog_stctrlh_t;

/*!
 * @name Constants and macros for entire WDOG_STCTRLH register
 */
/*@{*/
#define HW_WDOG_STCTRLH_ADDR(x)  ((uint32_t)(x) + 0x0U)

#define HW_WDOG_STCTRLH(x)       (*(__IO hw_wdog_stctrlh_t *) HW_WDOG_STCTRLH_ADDR(x))
#define HW_WDOG_STCTRLH_RD(x)    (HW_WDOG_STCTRLH(x).U)
#define HW_WDOG_STCTRLH_WR(x, v) (HW_WDOG_STCTRLH(x).U = (v))
#define HW_WDOG_STCTRLH_SET(x, v) (HW_WDOG_STCTRLH_WR(x, HW_WDOG_STCTRLH_RD(x) |  (v)))
#define HW_WDOG_STCTRLH_CLR(x, v) (HW_WDOG_STCTRLH_WR(x, HW_WDOG_STCTRLH_RD(x) & ~(v)))
#define HW_WDOG_STCTRLH_TOG(x, v) (HW_WDOG_STCTRLH_WR(x, HW_WDOG_STCTRLH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLH bitfields
 */

/*!
 * @name Register WDOG_STCTRLH, field WDOGEN[0] (RW)
 *
 * Enables or disables the WDOG's operation. In the disabled state, the watchdog
 * timer is kept in the reset state, but the other exception conditions can
 * still trigger a reset/interrupt. A change in the value of this bit must be held
 * for more than one WDOG_CLK cycle for the WDOG to be enabled or disabled.
 *
 * Values:
 * - 0 - WDOG is disabled.
 * - 1 - WDOG is enabled.
 */
/*@{*/
#define BP_WDOG_STCTRLH_WDOGEN (0U)        /*!< Bit position for WDOG_STCTRLH_WDOGEN. */
#define BM_WDOG_STCTRLH_WDOGEN (0x0001U)   /*!< Bit mask for WDOG_STCTRLH_WDOGEN. */
#define BS_WDOG_STCTRLH_WDOGEN (1U)        /*!< Bit field size in bits for WDOG_STCTRLH_WDOGEN. */

/*! @brief Read current value of the WDOG_STCTRLH_WDOGEN field. */
#define BR_WDOG_STCTRLH_WDOGEN(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_WDOGEN))

/*! @brief Format value for bitfield WDOG_STCTRLH_WDOGEN. */
#define BF_WDOG_STCTRLH_WDOGEN(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_WDOGEN) & BM_WDOG_STCTRLH_WDOGEN)

/*! @brief Set the WDOGEN field to a new value. */
#define BW_WDOG_STCTRLH_WDOGEN(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_WDOGEN) = (v))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field CLKSRC[1] (RW)
 *
 * Selects clock source for the WDOG timer and other internal timing operations.
 *
 * Values:
 * - 0 - WDOG clock sourced from LPO .
 * - 1 - WDOG clock sourced from alternate clock source.
 */
/*@{*/
#define BP_WDOG_STCTRLH_CLKSRC (1U)        /*!< Bit position for WDOG_STCTRLH_CLKSRC. */
#define BM_WDOG_STCTRLH_CLKSRC (0x0002U)   /*!< Bit mask for WDOG_STCTRLH_CLKSRC. */
#define BS_WDOG_STCTRLH_CLKSRC (1U)        /*!< Bit field size in bits for WDOG_STCTRLH_CLKSRC. */

/*! @brief Read current value of the WDOG_STCTRLH_CLKSRC field. */
#define BR_WDOG_STCTRLH_CLKSRC(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_CLKSRC))

/*! @brief Format value for bitfield WDOG_STCTRLH_CLKSRC. */
#define BF_WDOG_STCTRLH_CLKSRC(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_CLKSRC) & BM_WDOG_STCTRLH_CLKSRC)

/*! @brief Set the CLKSRC field to a new value. */
#define BW_WDOG_STCTRLH_CLKSRC(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_CLKSRC) = (v))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field IRQRSTEN[2] (RW)
 *
 * Used to enable the debug breadcrumbs feature. A change in this bit is updated
 * immediately, as opposed to updating after WCT.
 *
 * Values:
 * - 0 - WDOG time-out generates reset only.
 * - 1 - WDOG time-out initially generates an interrupt. After WCT, it generates
 *     a reset.
 */
/*@{*/
#define BP_WDOG_STCTRLH_IRQRSTEN (2U)      /*!< Bit position for WDOG_STCTRLH_IRQRSTEN. */
#define BM_WDOG_STCTRLH_IRQRSTEN (0x0004U) /*!< Bit mask for WDOG_STCTRLH_IRQRSTEN. */
#define BS_WDOG_STCTRLH_IRQRSTEN (1U)      /*!< Bit field size in bits for WDOG_STCTRLH_IRQRSTEN. */

/*! @brief Read current value of the WDOG_STCTRLH_IRQRSTEN field. */
#define BR_WDOG_STCTRLH_IRQRSTEN(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_IRQRSTEN))

/*! @brief Format value for bitfield WDOG_STCTRLH_IRQRSTEN. */
#define BF_WDOG_STCTRLH_IRQRSTEN(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_IRQRSTEN) & BM_WDOG_STCTRLH_IRQRSTEN)

/*! @brief Set the IRQRSTEN field to a new value. */
#define BW_WDOG_STCTRLH_IRQRSTEN(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_IRQRSTEN) = (v))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field WINEN[3] (RW)
 *
 * Enables Windowing mode.
 *
 * Values:
 * - 0 - Windowing mode is disabled.
 * - 1 - Windowing mode is enabled.
 */
/*@{*/
#define BP_WDOG_STCTRLH_WINEN (3U)         /*!< Bit position for WDOG_STCTRLH_WINEN. */
#define BM_WDOG_STCTRLH_WINEN (0x0008U)    /*!< Bit mask for WDOG_STCTRLH_WINEN. */
#define BS_WDOG_STCTRLH_WINEN (1U)         /*!< Bit field size in bits for WDOG_STCTRLH_WINEN. */

/*! @brief Read current value of the WDOG_STCTRLH_WINEN field. */
#define BR_WDOG_STCTRLH_WINEN(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_WINEN))

/*! @brief Format value for bitfield WDOG_STCTRLH_WINEN. */
#define BF_WDOG_STCTRLH_WINEN(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_WINEN) & BM_WDOG_STCTRLH_WINEN)

/*! @brief Set the WINEN field to a new value. */
#define BW_WDOG_STCTRLH_WINEN(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_WINEN) = (v))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field ALLOWUPDATE[4] (RW)
 *
 * Enables updates to watchdog write-once registers, after the reset-triggered
 * initial configuration window (WCT) closes, through unlock sequence.
 *
 * Values:
 * - 0 - No further updates allowed to WDOG write-once registers.
 * - 1 - WDOG write-once registers can be unlocked for updating.
 */
/*@{*/
#define BP_WDOG_STCTRLH_ALLOWUPDATE (4U)   /*!< Bit position for WDOG_STCTRLH_ALLOWUPDATE. */
#define BM_WDOG_STCTRLH_ALLOWUPDATE (0x0010U) /*!< Bit mask for WDOG_STCTRLH_ALLOWUPDATE. */
#define BS_WDOG_STCTRLH_ALLOWUPDATE (1U)   /*!< Bit field size in bits for WDOG_STCTRLH_ALLOWUPDATE. */

/*! @brief Read current value of the WDOG_STCTRLH_ALLOWUPDATE field. */
#define BR_WDOG_STCTRLH_ALLOWUPDATE(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_ALLOWUPDATE))

/*! @brief Format value for bitfield WDOG_STCTRLH_ALLOWUPDATE. */
#define BF_WDOG_STCTRLH_ALLOWUPDATE(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_ALLOWUPDATE) & BM_WDOG_STCTRLH_ALLOWUPDATE)

/*! @brief Set the ALLOWUPDATE field to a new value. */
#define BW_WDOG_STCTRLH_ALLOWUPDATE(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_ALLOWUPDATE) = (v))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DBGEN[5] (RW)
 *
 * Enables or disables WDOG in Debug mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU Debug mode.
 * - 1 - WDOG is enabled in CPU Debug mode.
 */
/*@{*/
#define BP_WDOG_STCTRLH_DBGEN (5U)         /*!< Bit position for WDOG_STCTRLH_DBGEN. */
#define BM_WDOG_STCTRLH_DBGEN (0x0020U)    /*!< Bit mask for WDOG_STCTRLH_DBGEN. */
#define BS_WDOG_STCTRLH_DBGEN (1U)         /*!< Bit field size in bits for WDOG_STCTRLH_DBGEN. */

/*! @brief Read current value of the WDOG_STCTRLH_DBGEN field. */
#define BR_WDOG_STCTRLH_DBGEN(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_DBGEN))

/*! @brief Format value for bitfield WDOG_STCTRLH_DBGEN. */
#define BF_WDOG_STCTRLH_DBGEN(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_DBGEN) & BM_WDOG_STCTRLH_DBGEN)

/*! @brief Set the DBGEN field to a new value. */
#define BW_WDOG_STCTRLH_DBGEN(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_DBGEN) = (v))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field STOPEN[6] (RW)
 *
 * Enables or disables WDOG in Stop mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU Stop mode.
 * - 1 - WDOG is enabled in CPU Stop mode.
 */
/*@{*/
#define BP_WDOG_STCTRLH_STOPEN (6U)        /*!< Bit position for WDOG_STCTRLH_STOPEN. */
#define BM_WDOG_STCTRLH_STOPEN (0x0040U)   /*!< Bit mask for WDOG_STCTRLH_STOPEN. */
#define BS_WDOG_STCTRLH_STOPEN (1U)        /*!< Bit field size in bits for WDOG_STCTRLH_STOPEN. */

/*! @brief Read current value of the WDOG_STCTRLH_STOPEN field. */
#define BR_WDOG_STCTRLH_STOPEN(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_STOPEN))

/*! @brief Format value for bitfield WDOG_STCTRLH_STOPEN. */
#define BF_WDOG_STCTRLH_STOPEN(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_STOPEN) & BM_WDOG_STCTRLH_STOPEN)

/*! @brief Set the STOPEN field to a new value. */
#define BW_WDOG_STCTRLH_STOPEN(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_STOPEN) = (v))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field WAITEN[7] (RW)
 *
 * Enables or disables WDOG in Wait mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU Wait mode.
 * - 1 - WDOG is enabled in CPU Wait mode.
 */
/*@{*/
#define BP_WDOG_STCTRLH_WAITEN (7U)        /*!< Bit position for WDOG_STCTRLH_WAITEN. */
#define BM_WDOG_STCTRLH_WAITEN (0x0080U)   /*!< Bit mask for WDOG_STCTRLH_WAITEN. */
#define BS_WDOG_STCTRLH_WAITEN (1U)        /*!< Bit field size in bits for WDOG_STCTRLH_WAITEN. */

/*! @brief Read current value of the WDOG_STCTRLH_WAITEN field. */
#define BR_WDOG_STCTRLH_WAITEN(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_WAITEN))

/*! @brief Format value for bitfield WDOG_STCTRLH_WAITEN. */
#define BF_WDOG_STCTRLH_WAITEN(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_WAITEN) & BM_WDOG_STCTRLH_WAITEN)

/*! @brief Set the WAITEN field to a new value. */
#define BW_WDOG_STCTRLH_WAITEN(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_WAITEN) = (v))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTWDOG[10] (RW)
 *
 * Puts the watchdog in the functional test mode. In this mode, the watchdog
 * timer and the associated compare and reset generation logic is tested for correct
 * operation. The clock for the timer is switched from the main watchdog clock
 * to the fast clock input for watchdog functional test. The TESTSEL bit selects
 * the test to be run.
 */
/*@{*/
#define BP_WDOG_STCTRLH_TESTWDOG (10U)     /*!< Bit position for WDOG_STCTRLH_TESTWDOG. */
#define BM_WDOG_STCTRLH_TESTWDOG (0x0400U) /*!< Bit mask for WDOG_STCTRLH_TESTWDOG. */
#define BS_WDOG_STCTRLH_TESTWDOG (1U)      /*!< Bit field size in bits for WDOG_STCTRLH_TESTWDOG. */

/*! @brief Read current value of the WDOG_STCTRLH_TESTWDOG field. */
#define BR_WDOG_STCTRLH_TESTWDOG(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_TESTWDOG))

/*! @brief Format value for bitfield WDOG_STCTRLH_TESTWDOG. */
#define BF_WDOG_STCTRLH_TESTWDOG(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_TESTWDOG) & BM_WDOG_STCTRLH_TESTWDOG)

/*! @brief Set the TESTWDOG field to a new value. */
#define BW_WDOG_STCTRLH_TESTWDOG(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_TESTWDOG) = (v))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTSEL[11] (RW)
 *
 * Effective only if TESTWDOG is set. Selects the test to be run on the watchdog
 * timer.
 *
 * Values:
 * - 0 - Quick test. The timer runs in normal operation. You can load a small
 *     time-out value to do a quick test.
 * - 1 - Byte test. Puts the timer in the byte test mode where individual bytes
 *     of the timer are enabled for operation and are compared for time-out
 *     against the corresponding byte of the programmed time-out value. Select the
 *     byte through BYTESEL[1:0] for testing.
 */
/*@{*/
#define BP_WDOG_STCTRLH_TESTSEL (11U)      /*!< Bit position for WDOG_STCTRLH_TESTSEL. */
#define BM_WDOG_STCTRLH_TESTSEL (0x0800U)  /*!< Bit mask for WDOG_STCTRLH_TESTSEL. */
#define BS_WDOG_STCTRLH_TESTSEL (1U)       /*!< Bit field size in bits for WDOG_STCTRLH_TESTSEL. */

/*! @brief Read current value of the WDOG_STCTRLH_TESTSEL field. */
#define BR_WDOG_STCTRLH_TESTSEL(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_TESTSEL))

/*! @brief Format value for bitfield WDOG_STCTRLH_TESTSEL. */
#define BF_WDOG_STCTRLH_TESTSEL(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_TESTSEL) & BM_WDOG_STCTRLH_TESTSEL)

/*! @brief Set the TESTSEL field to a new value. */
#define BW_WDOG_STCTRLH_TESTSEL(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_TESTSEL) = (v))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field BYTESEL[13:12] (RW)
 *
 * This 2-bit field selects the byte to be tested when the watchdog is in the
 * byte test mode.
 *
 * Values:
 * - 00 - Byte 0 selected
 * - 01 - Byte 1 selected
 * - 10 - Byte 2 selected
 * - 11 - Byte 3 selected
 */
/*@{*/
#define BP_WDOG_STCTRLH_BYTESEL (12U)      /*!< Bit position for WDOG_STCTRLH_BYTESEL. */
#define BM_WDOG_STCTRLH_BYTESEL (0x3000U)  /*!< Bit mask for WDOG_STCTRLH_BYTESEL. */
#define BS_WDOG_STCTRLH_BYTESEL (2U)       /*!< Bit field size in bits for WDOG_STCTRLH_BYTESEL. */

/*! @brief Read current value of the WDOG_STCTRLH_BYTESEL field. */
#define BR_WDOG_STCTRLH_BYTESEL(x) (HW_WDOG_STCTRLH(x).B.BYTESEL)

/*! @brief Format value for bitfield WDOG_STCTRLH_BYTESEL. */
#define BF_WDOG_STCTRLH_BYTESEL(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_BYTESEL) & BM_WDOG_STCTRLH_BYTESEL)

/*! @brief Set the BYTESEL field to a new value. */
#define BW_WDOG_STCTRLH_BYTESEL(x, v) (HW_WDOG_STCTRLH_WR(x, (HW_WDOG_STCTRLH_RD(x) & ~BM_WDOG_STCTRLH_BYTESEL) | BF_WDOG_STCTRLH_BYTESEL(v)))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DISTESTWDOG[14] (RW)
 *
 * Allows the WDOG's functional test mode to be disabled permanently. After it
 * is set, it can only be cleared by a reset. It cannot be unlocked for editing
 * after it is set.
 *
 * Values:
 * - 0 - WDOG functional test mode is not disabled.
 * - 1 - WDOG functional test mode is disabled permanently until reset.
 */
/*@{*/
#define BP_WDOG_STCTRLH_DISTESTWDOG (14U)  /*!< Bit position for WDOG_STCTRLH_DISTESTWDOG. */
#define BM_WDOG_STCTRLH_DISTESTWDOG (0x4000U) /*!< Bit mask for WDOG_STCTRLH_DISTESTWDOG. */
#define BS_WDOG_STCTRLH_DISTESTWDOG (1U)   /*!< Bit field size in bits for WDOG_STCTRLH_DISTESTWDOG. */

/*! @brief Read current value of the WDOG_STCTRLH_DISTESTWDOG field. */
#define BR_WDOG_STCTRLH_DISTESTWDOG(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_DISTESTWDOG))

/*! @brief Format value for bitfield WDOG_STCTRLH_DISTESTWDOG. */
#define BF_WDOG_STCTRLH_DISTESTWDOG(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLH_DISTESTWDOG) & BM_WDOG_STCTRLH_DISTESTWDOG)

/*! @brief Set the DISTESTWDOG field to a new value. */
#define BW_WDOG_STCTRLH_DISTESTWDOG(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLH_ADDR(x), BP_WDOG_STCTRLH_DISTESTWDOG) = (v))
/*@}*/

/*******************************************************************************
 * HW_WDOG_STCTRLL - Watchdog Status and Control Register Low
 ******************************************************************************/

/*!
 * @brief HW_WDOG_STCTRLL - Watchdog Status and Control Register Low (RW)
 *
 * Reset value: 0x0001U
 */
typedef union _hw_wdog_stctrll
{
    uint16_t U;
    struct _hw_wdog_stctrll_bitfields
    {
        uint16_t RESERVED0 : 15;       /*!< [14:0]  */
        uint16_t INTFLG : 1;           /*!< [15]  */
    } B;
} hw_wdog_stctrll_t;

/*!
 * @name Constants and macros for entire WDOG_STCTRLL register
 */
/*@{*/
#define HW_WDOG_STCTRLL_ADDR(x)  ((uint32_t)(x) + 0x2U)

#define HW_WDOG_STCTRLL(x)       (*(__IO hw_wdog_stctrll_t *) HW_WDOG_STCTRLL_ADDR(x))
#define HW_WDOG_STCTRLL_RD(x)    (HW_WDOG_STCTRLL(x).U)
#define HW_WDOG_STCTRLL_WR(x, v) (HW_WDOG_STCTRLL(x).U = (v))
#define HW_WDOG_STCTRLL_SET(x, v) (HW_WDOG_STCTRLL_WR(x, HW_WDOG_STCTRLL_RD(x) |  (v)))
#define HW_WDOG_STCTRLL_CLR(x, v) (HW_WDOG_STCTRLL_WR(x, HW_WDOG_STCTRLL_RD(x) & ~(v)))
#define HW_WDOG_STCTRLL_TOG(x, v) (HW_WDOG_STCTRLL_WR(x, HW_WDOG_STCTRLL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLL bitfields
 */

/*!
 * @name Register WDOG_STCTRLL, field INTFLG[15] (RW)
 *
 * Interrupt flag. It is set when an exception occurs. IRQRSTEN = 1 is a
 * precondition to set this flag. INTFLG = 1 results in an interrupt being issued
 * followed by a reset, WCT later. The interrupt can be cleared by writing 1 to this
 * bit. It also gets cleared on a system reset.
 */
/*@{*/
#define BP_WDOG_STCTRLL_INTFLG (15U)       /*!< Bit position for WDOG_STCTRLL_INTFLG. */
#define BM_WDOG_STCTRLL_INTFLG (0x8000U)   /*!< Bit mask for WDOG_STCTRLL_INTFLG. */
#define BS_WDOG_STCTRLL_INTFLG (1U)        /*!< Bit field size in bits for WDOG_STCTRLL_INTFLG. */

/*! @brief Read current value of the WDOG_STCTRLL_INTFLG field. */
#define BR_WDOG_STCTRLL_INTFLG(x) (BITBAND_ACCESS16(HW_WDOG_STCTRLL_ADDR(x), BP_WDOG_STCTRLL_INTFLG))

/*! @brief Format value for bitfield WDOG_STCTRLL_INTFLG. */
#define BF_WDOG_STCTRLL_INTFLG(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_STCTRLL_INTFLG) & BM_WDOG_STCTRLL_INTFLG)

/*! @brief Set the INTFLG field to a new value. */
#define BW_WDOG_STCTRLL_INTFLG(x, v) (BITBAND_ACCESS16(HW_WDOG_STCTRLL_ADDR(x), BP_WDOG_STCTRLL_INTFLG) = (v))
/*@}*/

/*******************************************************************************
 * HW_WDOG_TOVALH - Watchdog Time-out Value Register High
 ******************************************************************************/

/*!
 * @brief HW_WDOG_TOVALH - Watchdog Time-out Value Register High (RW)
 *
 * Reset value: 0x004CU
 */
typedef union _hw_wdog_tovalh
{
    uint16_t U;
    struct _hw_wdog_tovalh_bitfields
    {
        uint16_t TOVALHIGH : 16;       /*!< [15:0]  */
    } B;
} hw_wdog_tovalh_t;

/*!
 * @name Constants and macros for entire WDOG_TOVALH register
 */
/*@{*/
#define HW_WDOG_TOVALH_ADDR(x)   ((uint32_t)(x) + 0x4U)

#define HW_WDOG_TOVALH(x)        (*(__IO hw_wdog_tovalh_t *) HW_WDOG_TOVALH_ADDR(x))
#define HW_WDOG_TOVALH_RD(x)     (HW_WDOG_TOVALH(x).U)
#define HW_WDOG_TOVALH_WR(x, v)  (HW_WDOG_TOVALH(x).U = (v))
#define HW_WDOG_TOVALH_SET(x, v) (HW_WDOG_TOVALH_WR(x, HW_WDOG_TOVALH_RD(x) |  (v)))
#define HW_WDOG_TOVALH_CLR(x, v) (HW_WDOG_TOVALH_WR(x, HW_WDOG_TOVALH_RD(x) & ~(v)))
#define HW_WDOG_TOVALH_TOG(x, v) (HW_WDOG_TOVALH_WR(x, HW_WDOG_TOVALH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_TOVALH bitfields
 */

/*!
 * @name Register WDOG_TOVALH, field TOVALHIGH[15:0] (RW)
 *
 * Defines the upper 16 bits of the 32-bit time-out value for the watchdog
 * timer. It is defined in terms of cycles of the watchdog clock.
 */
/*@{*/
#define BP_WDOG_TOVALH_TOVALHIGH (0U)      /*!< Bit position for WDOG_TOVALH_TOVALHIGH. */
#define BM_WDOG_TOVALH_TOVALHIGH (0xFFFFU) /*!< Bit mask for WDOG_TOVALH_TOVALHIGH. */
#define BS_WDOG_TOVALH_TOVALHIGH (16U)     /*!< Bit field size in bits for WDOG_TOVALH_TOVALHIGH. */

/*! @brief Read current value of the WDOG_TOVALH_TOVALHIGH field. */
#define BR_WDOG_TOVALH_TOVALHIGH(x) (HW_WDOG_TOVALH(x).U)

/*! @brief Format value for bitfield WDOG_TOVALH_TOVALHIGH. */
#define BF_WDOG_TOVALH_TOVALHIGH(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_TOVALH_TOVALHIGH) & BM_WDOG_TOVALH_TOVALHIGH)

/*! @brief Set the TOVALHIGH field to a new value. */
#define BW_WDOG_TOVALH_TOVALHIGH(x, v) (HW_WDOG_TOVALH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_WDOG_TOVALL - Watchdog Time-out Value Register Low
 ******************************************************************************/

/*!
 * @brief HW_WDOG_TOVALL - Watchdog Time-out Value Register Low (RW)
 *
 * Reset value: 0x4B4CU
 *
 * The time-out value of the watchdog must be set to a minimum of four watchdog
 * clock cycles. This is to take into account the delay in new settings taking
 * effect in the watchdog clock domain.
 */
typedef union _hw_wdog_tovall
{
    uint16_t U;
    struct _hw_wdog_tovall_bitfields
    {
        uint16_t TOVALLOW : 16;        /*!< [15:0]  */
    } B;
} hw_wdog_tovall_t;

/*!
 * @name Constants and macros for entire WDOG_TOVALL register
 */
/*@{*/
#define HW_WDOG_TOVALL_ADDR(x)   ((uint32_t)(x) + 0x6U)

#define HW_WDOG_TOVALL(x)        (*(__IO hw_wdog_tovall_t *) HW_WDOG_TOVALL_ADDR(x))
#define HW_WDOG_TOVALL_RD(x)     (HW_WDOG_TOVALL(x).U)
#define HW_WDOG_TOVALL_WR(x, v)  (HW_WDOG_TOVALL(x).U = (v))
#define HW_WDOG_TOVALL_SET(x, v) (HW_WDOG_TOVALL_WR(x, HW_WDOG_TOVALL_RD(x) |  (v)))
#define HW_WDOG_TOVALL_CLR(x, v) (HW_WDOG_TOVALL_WR(x, HW_WDOG_TOVALL_RD(x) & ~(v)))
#define HW_WDOG_TOVALL_TOG(x, v) (HW_WDOG_TOVALL_WR(x, HW_WDOG_TOVALL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_TOVALL bitfields
 */

/*!
 * @name Register WDOG_TOVALL, field TOVALLOW[15:0] (RW)
 *
 * Defines the lower 16 bits of the 32-bit time-out value for the watchdog
 * timer. It is defined in terms of cycles of the watchdog clock.
 */
/*@{*/
#define BP_WDOG_TOVALL_TOVALLOW (0U)       /*!< Bit position for WDOG_TOVALL_TOVALLOW. */
#define BM_WDOG_TOVALL_TOVALLOW (0xFFFFU)  /*!< Bit mask for WDOG_TOVALL_TOVALLOW. */
#define BS_WDOG_TOVALL_TOVALLOW (16U)      /*!< Bit field size in bits for WDOG_TOVALL_TOVALLOW. */

/*! @brief Read current value of the WDOG_TOVALL_TOVALLOW field. */
#define BR_WDOG_TOVALL_TOVALLOW(x) (HW_WDOG_TOVALL(x).U)

/*! @brief Format value for bitfield WDOG_TOVALL_TOVALLOW. */
#define BF_WDOG_TOVALL_TOVALLOW(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_TOVALL_TOVALLOW) & BM_WDOG_TOVALL_TOVALLOW)

/*! @brief Set the TOVALLOW field to a new value. */
#define BW_WDOG_TOVALL_TOVALLOW(x, v) (HW_WDOG_TOVALL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_WDOG_WINH - Watchdog Window Register High
 ******************************************************************************/

/*!
 * @brief HW_WDOG_WINH - Watchdog Window Register High (RW)
 *
 * Reset value: 0x0000U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
typedef union _hw_wdog_winh
{
    uint16_t U;
    struct _hw_wdog_winh_bitfields
    {
        uint16_t WINHIGH : 16;         /*!< [15:0]  */
    } B;
} hw_wdog_winh_t;

/*!
 * @name Constants and macros for entire WDOG_WINH register
 */
/*@{*/
#define HW_WDOG_WINH_ADDR(x)     ((uint32_t)(x) + 0x8U)

#define HW_WDOG_WINH(x)          (*(__IO hw_wdog_winh_t *) HW_WDOG_WINH_ADDR(x))
#define HW_WDOG_WINH_RD(x)       (HW_WDOG_WINH(x).U)
#define HW_WDOG_WINH_WR(x, v)    (HW_WDOG_WINH(x).U = (v))
#define HW_WDOG_WINH_SET(x, v)   (HW_WDOG_WINH_WR(x, HW_WDOG_WINH_RD(x) |  (v)))
#define HW_WDOG_WINH_CLR(x, v)   (HW_WDOG_WINH_WR(x, HW_WDOG_WINH_RD(x) & ~(v)))
#define HW_WDOG_WINH_TOG(x, v)   (HW_WDOG_WINH_WR(x, HW_WDOG_WINH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_WINH bitfields
 */

/*!
 * @name Register WDOG_WINH, field WINHIGH[15:0] (RW)
 *
 * Defines the upper 16 bits of the 32-bit window for the windowed mode of
 * operation of the watchdog. It is defined in terms of cycles of the watchdog clock.
 * In this mode, the watchdog can be refreshed only when the timer has reached a
 * value greater than or equal to this window length. A refresh outside this
 * window resets the system or if IRQRSTEN is set, it interrupts and then resets the
 * system.
 */
/*@{*/
#define BP_WDOG_WINH_WINHIGH (0U)          /*!< Bit position for WDOG_WINH_WINHIGH. */
#define BM_WDOG_WINH_WINHIGH (0xFFFFU)     /*!< Bit mask for WDOG_WINH_WINHIGH. */
#define BS_WDOG_WINH_WINHIGH (16U)         /*!< Bit field size in bits for WDOG_WINH_WINHIGH. */

/*! @brief Read current value of the WDOG_WINH_WINHIGH field. */
#define BR_WDOG_WINH_WINHIGH(x) (HW_WDOG_WINH(x).U)

/*! @brief Format value for bitfield WDOG_WINH_WINHIGH. */
#define BF_WDOG_WINH_WINHIGH(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_WINH_WINHIGH) & BM_WDOG_WINH_WINHIGH)

/*! @brief Set the WINHIGH field to a new value. */
#define BW_WDOG_WINH_WINHIGH(x, v) (HW_WDOG_WINH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_WDOG_WINL - Watchdog Window Register Low
 ******************************************************************************/

/*!
 * @brief HW_WDOG_WINL - Watchdog Window Register Low (RW)
 *
 * Reset value: 0x0010U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
typedef union _hw_wdog_winl
{
    uint16_t U;
    struct _hw_wdog_winl_bitfields
    {
        uint16_t WINLOW : 16;          /*!< [15:0]  */
    } B;
} hw_wdog_winl_t;

/*!
 * @name Constants and macros for entire WDOG_WINL register
 */
/*@{*/
#define HW_WDOG_WINL_ADDR(x)     ((uint32_t)(x) + 0xAU)

#define HW_WDOG_WINL(x)          (*(__IO hw_wdog_winl_t *) HW_WDOG_WINL_ADDR(x))
#define HW_WDOG_WINL_RD(x)       (HW_WDOG_WINL(x).U)
#define HW_WDOG_WINL_WR(x, v)    (HW_WDOG_WINL(x).U = (v))
#define HW_WDOG_WINL_SET(x, v)   (HW_WDOG_WINL_WR(x, HW_WDOG_WINL_RD(x) |  (v)))
#define HW_WDOG_WINL_CLR(x, v)   (HW_WDOG_WINL_WR(x, HW_WDOG_WINL_RD(x) & ~(v)))
#define HW_WDOG_WINL_TOG(x, v)   (HW_WDOG_WINL_WR(x, HW_WDOG_WINL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_WINL bitfields
 */

/*!
 * @name Register WDOG_WINL, field WINLOW[15:0] (RW)
 *
 * Defines the lower 16 bits of the 32-bit window for the windowed mode of
 * operation of the watchdog. It is defined in terms of cycles of the pre-scaled
 * watchdog clock. In this mode, the watchdog can be refreshed only when the timer
 * reaches a value greater than or equal to this window length value. A refresh
 * outside of this window resets the system or if IRQRSTEN is set, it interrupts and
 * then resets the system.
 */
/*@{*/
#define BP_WDOG_WINL_WINLOW  (0U)          /*!< Bit position for WDOG_WINL_WINLOW. */
#define BM_WDOG_WINL_WINLOW  (0xFFFFU)     /*!< Bit mask for WDOG_WINL_WINLOW. */
#define BS_WDOG_WINL_WINLOW  (16U)         /*!< Bit field size in bits for WDOG_WINL_WINLOW. */

/*! @brief Read current value of the WDOG_WINL_WINLOW field. */
#define BR_WDOG_WINL_WINLOW(x) (HW_WDOG_WINL(x).U)

/*! @brief Format value for bitfield WDOG_WINL_WINLOW. */
#define BF_WDOG_WINL_WINLOW(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_WINL_WINLOW) & BM_WDOG_WINL_WINLOW)

/*! @brief Set the WINLOW field to a new value. */
#define BW_WDOG_WINL_WINLOW(x, v) (HW_WDOG_WINL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_WDOG_REFRESH - Watchdog Refresh register
 ******************************************************************************/

/*!
 * @brief HW_WDOG_REFRESH - Watchdog Refresh register (RW)
 *
 * Reset value: 0xB480U
 */
typedef union _hw_wdog_refresh
{
    uint16_t U;
    struct _hw_wdog_refresh_bitfields
    {
        uint16_t WDOGREFRESH : 16;     /*!< [15:0]  */
    } B;
} hw_wdog_refresh_t;

/*!
 * @name Constants and macros for entire WDOG_REFRESH register
 */
/*@{*/
#define HW_WDOG_REFRESH_ADDR(x)  ((uint32_t)(x) + 0xCU)

#define HW_WDOG_REFRESH(x)       (*(__IO hw_wdog_refresh_t *) HW_WDOG_REFRESH_ADDR(x))
#define HW_WDOG_REFRESH_RD(x)    (HW_WDOG_REFRESH(x).U)
#define HW_WDOG_REFRESH_WR(x, v) (HW_WDOG_REFRESH(x).U = (v))
#define HW_WDOG_REFRESH_SET(x, v) (HW_WDOG_REFRESH_WR(x, HW_WDOG_REFRESH_RD(x) |  (v)))
#define HW_WDOG_REFRESH_CLR(x, v) (HW_WDOG_REFRESH_WR(x, HW_WDOG_REFRESH_RD(x) & ~(v)))
#define HW_WDOG_REFRESH_TOG(x, v) (HW_WDOG_REFRESH_WR(x, HW_WDOG_REFRESH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_REFRESH bitfields
 */

/*!
 * @name Register WDOG_REFRESH, field WDOGREFRESH[15:0] (RW)
 *
 * Watchdog refresh register. A sequence of 0xA602 followed by 0xB480 within 20
 * bus clock cycles written to this register refreshes the WDOG and prevents it
 * from resetting the system. Writing a value other than the above mentioned
 * sequence or if the sequence is longer than 20 bus cycles, resets the system, or if
 * IRQRSTEN is set, it interrupts and then resets the system.
 */
/*@{*/
#define BP_WDOG_REFRESH_WDOGREFRESH (0U)   /*!< Bit position for WDOG_REFRESH_WDOGREFRESH. */
#define BM_WDOG_REFRESH_WDOGREFRESH (0xFFFFU) /*!< Bit mask for WDOG_REFRESH_WDOGREFRESH. */
#define BS_WDOG_REFRESH_WDOGREFRESH (16U)  /*!< Bit field size in bits for WDOG_REFRESH_WDOGREFRESH. */

/*! @brief Read current value of the WDOG_REFRESH_WDOGREFRESH field. */
#define BR_WDOG_REFRESH_WDOGREFRESH(x) (HW_WDOG_REFRESH(x).U)

/*! @brief Format value for bitfield WDOG_REFRESH_WDOGREFRESH. */
#define BF_WDOG_REFRESH_WDOGREFRESH(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_REFRESH_WDOGREFRESH) & BM_WDOG_REFRESH_WDOGREFRESH)

/*! @brief Set the WDOGREFRESH field to a new value. */
#define BW_WDOG_REFRESH_WDOGREFRESH(x, v) (HW_WDOG_REFRESH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_WDOG_UNLOCK - Watchdog Unlock register
 ******************************************************************************/

/*!
 * @brief HW_WDOG_UNLOCK - Watchdog Unlock register (RW)
 *
 * Reset value: 0xD928U
 */
typedef union _hw_wdog_unlock
{
    uint16_t U;
    struct _hw_wdog_unlock_bitfields
    {
        uint16_t WDOGUNLOCK : 16;      /*!< [15:0]  */
    } B;
} hw_wdog_unlock_t;

/*!
 * @name Constants and macros for entire WDOG_UNLOCK register
 */
/*@{*/
#define HW_WDOG_UNLOCK_ADDR(x)   ((uint32_t)(x) + 0xEU)

#define HW_WDOG_UNLOCK(x)        (*(__IO hw_wdog_unlock_t *) HW_WDOG_UNLOCK_ADDR(x))
#define HW_WDOG_UNLOCK_RD(x)     (HW_WDOG_UNLOCK(x).U)
#define HW_WDOG_UNLOCK_WR(x, v)  (HW_WDOG_UNLOCK(x).U = (v))
#define HW_WDOG_UNLOCK_SET(x, v) (HW_WDOG_UNLOCK_WR(x, HW_WDOG_UNLOCK_RD(x) |  (v)))
#define HW_WDOG_UNLOCK_CLR(x, v) (HW_WDOG_UNLOCK_WR(x, HW_WDOG_UNLOCK_RD(x) & ~(v)))
#define HW_WDOG_UNLOCK_TOG(x, v) (HW_WDOG_UNLOCK_WR(x, HW_WDOG_UNLOCK_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_UNLOCK bitfields
 */

/*!
 * @name Register WDOG_UNLOCK, field WDOGUNLOCK[15:0] (RW)
 *
 * Writing the unlock sequence values to this register to makes the watchdog
 * write-once registers writable again. The required unlock sequence is 0xC520
 * followed by 0xD928 within 20 bus clock cycles. A valid unlock sequence opens a
 * window equal in length to the WCT within which you can update the registers.
 * Writing a value other than the above mentioned sequence or if the sequence is
 * longer than 20 bus cycles, resets the system or if IRQRSTEN is set, it interrupts
 * and then resets the system. The unlock sequence is effective only if
 * ALLOWUPDATE is set.
 */
/*@{*/
#define BP_WDOG_UNLOCK_WDOGUNLOCK (0U)     /*!< Bit position for WDOG_UNLOCK_WDOGUNLOCK. */
#define BM_WDOG_UNLOCK_WDOGUNLOCK (0xFFFFU) /*!< Bit mask for WDOG_UNLOCK_WDOGUNLOCK. */
#define BS_WDOG_UNLOCK_WDOGUNLOCK (16U)    /*!< Bit field size in bits for WDOG_UNLOCK_WDOGUNLOCK. */

/*! @brief Read current value of the WDOG_UNLOCK_WDOGUNLOCK field. */
#define BR_WDOG_UNLOCK_WDOGUNLOCK(x) (HW_WDOG_UNLOCK(x).U)

/*! @brief Format value for bitfield WDOG_UNLOCK_WDOGUNLOCK. */
#define BF_WDOG_UNLOCK_WDOGUNLOCK(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_UNLOCK_WDOGUNLOCK) & BM_WDOG_UNLOCK_WDOGUNLOCK)

/*! @brief Set the WDOGUNLOCK field to a new value. */
#define BW_WDOG_UNLOCK_WDOGUNLOCK(x, v) (HW_WDOG_UNLOCK_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_WDOG_TMROUTH - Watchdog Timer Output Register High
 ******************************************************************************/

/*!
 * @brief HW_WDOG_TMROUTH - Watchdog Timer Output Register High (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_wdog_tmrouth
{
    uint16_t U;
    struct _hw_wdog_tmrouth_bitfields
    {
        uint16_t TIMEROUTHIGH : 16;    /*!< [15:0]  */
    } B;
} hw_wdog_tmrouth_t;

/*!
 * @name Constants and macros for entire WDOG_TMROUTH register
 */
/*@{*/
#define HW_WDOG_TMROUTH_ADDR(x)  ((uint32_t)(x) + 0x10U)

#define HW_WDOG_TMROUTH(x)       (*(__IO hw_wdog_tmrouth_t *) HW_WDOG_TMROUTH_ADDR(x))
#define HW_WDOG_TMROUTH_RD(x)    (HW_WDOG_TMROUTH(x).U)
#define HW_WDOG_TMROUTH_WR(x, v) (HW_WDOG_TMROUTH(x).U = (v))
#define HW_WDOG_TMROUTH_SET(x, v) (HW_WDOG_TMROUTH_WR(x, HW_WDOG_TMROUTH_RD(x) |  (v)))
#define HW_WDOG_TMROUTH_CLR(x, v) (HW_WDOG_TMROUTH_WR(x, HW_WDOG_TMROUTH_RD(x) & ~(v)))
#define HW_WDOG_TMROUTH_TOG(x, v) (HW_WDOG_TMROUTH_WR(x, HW_WDOG_TMROUTH_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_TMROUTH bitfields
 */

/*!
 * @name Register WDOG_TMROUTH, field TIMEROUTHIGH[15:0] (RW)
 *
 * Shows the value of the upper 16 bits of the watchdog timer.
 */
/*@{*/
#define BP_WDOG_TMROUTH_TIMEROUTHIGH (0U)  /*!< Bit position for WDOG_TMROUTH_TIMEROUTHIGH. */
#define BM_WDOG_TMROUTH_TIMEROUTHIGH (0xFFFFU) /*!< Bit mask for WDOG_TMROUTH_TIMEROUTHIGH. */
#define BS_WDOG_TMROUTH_TIMEROUTHIGH (16U) /*!< Bit field size in bits for WDOG_TMROUTH_TIMEROUTHIGH. */

/*! @brief Read current value of the WDOG_TMROUTH_TIMEROUTHIGH field. */
#define BR_WDOG_TMROUTH_TIMEROUTHIGH(x) (HW_WDOG_TMROUTH(x).U)

/*! @brief Format value for bitfield WDOG_TMROUTH_TIMEROUTHIGH. */
#define BF_WDOG_TMROUTH_TIMEROUTHIGH(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_TMROUTH_TIMEROUTHIGH) & BM_WDOG_TMROUTH_TIMEROUTHIGH)

/*! @brief Set the TIMEROUTHIGH field to a new value. */
#define BW_WDOG_TMROUTH_TIMEROUTHIGH(x, v) (HW_WDOG_TMROUTH_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_WDOG_TMROUTL - Watchdog Timer Output Register Low
 ******************************************************************************/

/*!
 * @brief HW_WDOG_TMROUTL - Watchdog Timer Output Register Low (RW)
 *
 * Reset value: 0x0000U
 *
 * During Stop mode, the WDOG_TIMER_OUT will be caught at the pre-stop value of
 * the watchdog timer. After exiting Stop mode, a maximum delay of 1 WDOG_CLK
 * cycle + 3 bus clock cycles will occur before the WDOG_TIMER_OUT starts following
 * the watchdog timer.
 */
typedef union _hw_wdog_tmroutl
{
    uint16_t U;
    struct _hw_wdog_tmroutl_bitfields
    {
        uint16_t TIMEROUTLOW : 16;     /*!< [15:0]  */
    } B;
} hw_wdog_tmroutl_t;

/*!
 * @name Constants and macros for entire WDOG_TMROUTL register
 */
/*@{*/
#define HW_WDOG_TMROUTL_ADDR(x)  ((uint32_t)(x) + 0x12U)

#define HW_WDOG_TMROUTL(x)       (*(__IO hw_wdog_tmroutl_t *) HW_WDOG_TMROUTL_ADDR(x))
#define HW_WDOG_TMROUTL_RD(x)    (HW_WDOG_TMROUTL(x).U)
#define HW_WDOG_TMROUTL_WR(x, v) (HW_WDOG_TMROUTL(x).U = (v))
#define HW_WDOG_TMROUTL_SET(x, v) (HW_WDOG_TMROUTL_WR(x, HW_WDOG_TMROUTL_RD(x) |  (v)))
#define HW_WDOG_TMROUTL_CLR(x, v) (HW_WDOG_TMROUTL_WR(x, HW_WDOG_TMROUTL_RD(x) & ~(v)))
#define HW_WDOG_TMROUTL_TOG(x, v) (HW_WDOG_TMROUTL_WR(x, HW_WDOG_TMROUTL_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_TMROUTL bitfields
 */

/*!
 * @name Register WDOG_TMROUTL, field TIMEROUTLOW[15:0] (RW)
 *
 * Shows the value of the lower 16 bits of the watchdog timer.
 */
/*@{*/
#define BP_WDOG_TMROUTL_TIMEROUTLOW (0U)   /*!< Bit position for WDOG_TMROUTL_TIMEROUTLOW. */
#define BM_WDOG_TMROUTL_TIMEROUTLOW (0xFFFFU) /*!< Bit mask for WDOG_TMROUTL_TIMEROUTLOW. */
#define BS_WDOG_TMROUTL_TIMEROUTLOW (16U)  /*!< Bit field size in bits for WDOG_TMROUTL_TIMEROUTLOW. */

/*! @brief Read current value of the WDOG_TMROUTL_TIMEROUTLOW field. */
#define BR_WDOG_TMROUTL_TIMEROUTLOW(x) (HW_WDOG_TMROUTL(x).U)

/*! @brief Format value for bitfield WDOG_TMROUTL_TIMEROUTLOW. */
#define BF_WDOG_TMROUTL_TIMEROUTLOW(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_TMROUTL_TIMEROUTLOW) & BM_WDOG_TMROUTL_TIMEROUTLOW)

/*! @brief Set the TIMEROUTLOW field to a new value. */
#define BW_WDOG_TMROUTL_TIMEROUTLOW(x, v) (HW_WDOG_TMROUTL_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_WDOG_RSTCNT - Watchdog Reset Count register
 ******************************************************************************/

/*!
 * @brief HW_WDOG_RSTCNT - Watchdog Reset Count register (RW)
 *
 * Reset value: 0x0000U
 */
typedef union _hw_wdog_rstcnt
{
    uint16_t U;
    struct _hw_wdog_rstcnt_bitfields
    {
        uint16_t RSTCNT : 16;          /*!< [15:0]  */
    } B;
} hw_wdog_rstcnt_t;

/*!
 * @name Constants and macros for entire WDOG_RSTCNT register
 */
/*@{*/
#define HW_WDOG_RSTCNT_ADDR(x)   ((uint32_t)(x) + 0x14U)

#define HW_WDOG_RSTCNT(x)        (*(__IO hw_wdog_rstcnt_t *) HW_WDOG_RSTCNT_ADDR(x))
#define HW_WDOG_RSTCNT_RD(x)     (HW_WDOG_RSTCNT(x).U)
#define HW_WDOG_RSTCNT_WR(x, v)  (HW_WDOG_RSTCNT(x).U = (v))
#define HW_WDOG_RSTCNT_SET(x, v) (HW_WDOG_RSTCNT_WR(x, HW_WDOG_RSTCNT_RD(x) |  (v)))
#define HW_WDOG_RSTCNT_CLR(x, v) (HW_WDOG_RSTCNT_WR(x, HW_WDOG_RSTCNT_RD(x) & ~(v)))
#define HW_WDOG_RSTCNT_TOG(x, v) (HW_WDOG_RSTCNT_WR(x, HW_WDOG_RSTCNT_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_RSTCNT bitfields
 */

/*!
 * @name Register WDOG_RSTCNT, field RSTCNT[15:0] (RW)
 *
 * Counts the number of times the watchdog resets the system. This register is
 * reset only on a POR. Writing 1 to the bit to be cleared enables you to clear
 * the contents of this register.
 */
/*@{*/
#define BP_WDOG_RSTCNT_RSTCNT (0U)         /*!< Bit position for WDOG_RSTCNT_RSTCNT. */
#define BM_WDOG_RSTCNT_RSTCNT (0xFFFFU)    /*!< Bit mask for WDOG_RSTCNT_RSTCNT. */
#define BS_WDOG_RSTCNT_RSTCNT (16U)        /*!< Bit field size in bits for WDOG_RSTCNT_RSTCNT. */

/*! @brief Read current value of the WDOG_RSTCNT_RSTCNT field. */
#define BR_WDOG_RSTCNT_RSTCNT(x) (HW_WDOG_RSTCNT(x).U)

/*! @brief Format value for bitfield WDOG_RSTCNT_RSTCNT. */
#define BF_WDOG_RSTCNT_RSTCNT(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_RSTCNT_RSTCNT) & BM_WDOG_RSTCNT_RSTCNT)

/*! @brief Set the RSTCNT field to a new value. */
#define BW_WDOG_RSTCNT_RSTCNT(x, v) (HW_WDOG_RSTCNT_WR(x, v))
/*@}*/

/*******************************************************************************
 * HW_WDOG_PRESC - Watchdog Prescaler register
 ******************************************************************************/

/*!
 * @brief HW_WDOG_PRESC - Watchdog Prescaler register (RW)
 *
 * Reset value: 0x0400U
 */
typedef union _hw_wdog_presc
{
    uint16_t U;
    struct _hw_wdog_presc_bitfields
    {
        uint16_t RESERVED0 : 8;        /*!< [7:0]  */
        uint16_t PRESCVAL : 3;         /*!< [10:8]  */
        uint16_t RESERVED1 : 5;        /*!< [15:11]  */
    } B;
} hw_wdog_presc_t;

/*!
 * @name Constants and macros for entire WDOG_PRESC register
 */
/*@{*/
#define HW_WDOG_PRESC_ADDR(x)    ((uint32_t)(x) + 0x16U)

#define HW_WDOG_PRESC(x)         (*(__IO hw_wdog_presc_t *) HW_WDOG_PRESC_ADDR(x))
#define HW_WDOG_PRESC_RD(x)      (HW_WDOG_PRESC(x).U)
#define HW_WDOG_PRESC_WR(x, v)   (HW_WDOG_PRESC(x).U = (v))
#define HW_WDOG_PRESC_SET(x, v)  (HW_WDOG_PRESC_WR(x, HW_WDOG_PRESC_RD(x) |  (v)))
#define HW_WDOG_PRESC_CLR(x, v)  (HW_WDOG_PRESC_WR(x, HW_WDOG_PRESC_RD(x) & ~(v)))
#define HW_WDOG_PRESC_TOG(x, v)  (HW_WDOG_PRESC_WR(x, HW_WDOG_PRESC_RD(x) ^  (v)))
/*@}*/

/*
 * Constants & macros for individual WDOG_PRESC bitfields
 */

/*!
 * @name Register WDOG_PRESC, field PRESCVAL[10:8] (RW)
 *
 * 3-bit prescaler for the watchdog clock source. A value of zero indicates no
 * division of the input WDOG clock. The watchdog clock is divided by (PRESCVAL +
 * 1) to provide the prescaled WDOG_CLK.
 */
/*@{*/
#define BP_WDOG_PRESC_PRESCVAL (8U)        /*!< Bit position for WDOG_PRESC_PRESCVAL. */
#define BM_WDOG_PRESC_PRESCVAL (0x0700U)   /*!< Bit mask for WDOG_PRESC_PRESCVAL. */
#define BS_WDOG_PRESC_PRESCVAL (3U)        /*!< Bit field size in bits for WDOG_PRESC_PRESCVAL. */

/*! @brief Read current value of the WDOG_PRESC_PRESCVAL field. */
#define BR_WDOG_PRESC_PRESCVAL(x) (HW_WDOG_PRESC(x).B.PRESCVAL)

/*! @brief Format value for bitfield WDOG_PRESC_PRESCVAL. */
#define BF_WDOG_PRESC_PRESCVAL(v) ((uint16_t)((uint16_t)(v) << BP_WDOG_PRESC_PRESCVAL) & BM_WDOG_PRESC_PRESCVAL)

/*! @brief Set the PRESCVAL field to a new value. */
#define BW_WDOG_PRESC_PRESCVAL(x, v) (HW_WDOG_PRESC_WR(x, (HW_WDOG_PRESC_RD(x) & ~BM_WDOG_PRESC_PRESCVAL) | BF_WDOG_PRESC_PRESCVAL(v)))
/*@}*/

/*******************************************************************************
 * hw_wdog_t - module struct
 ******************************************************************************/
/*!
 * @brief All WDOG module registers.
 */
#pragma pack(1)
typedef struct _hw_wdog
{
    __IO hw_wdog_stctrlh_t STCTRLH;        /*!< [0x0] Watchdog Status and Control Register High */
    __IO hw_wdog_stctrll_t STCTRLL;        /*!< [0x2] Watchdog Status and Control Register Low */
    __IO hw_wdog_tovalh_t TOVALH;          /*!< [0x4] Watchdog Time-out Value Register High */
    __IO hw_wdog_tovall_t TOVALL;          /*!< [0x6] Watchdog Time-out Value Register Low */
    __IO hw_wdog_winh_t WINH;              /*!< [0x8] Watchdog Window Register High */
    __IO hw_wdog_winl_t WINL;              /*!< [0xA] Watchdog Window Register Low */
    __IO hw_wdog_refresh_t REFRESH;        /*!< [0xC] Watchdog Refresh register */
    __IO hw_wdog_unlock_t UNLOCK;          /*!< [0xE] Watchdog Unlock register */
    __IO hw_wdog_tmrouth_t TMROUTH;        /*!< [0x10] Watchdog Timer Output Register High */
    __IO hw_wdog_tmroutl_t TMROUTL;        /*!< [0x12] Watchdog Timer Output Register Low */
    __IO hw_wdog_rstcnt_t RSTCNT;          /*!< [0x14] Watchdog Reset Count register */
    __IO hw_wdog_presc_t PRESC;            /*!< [0x16] Watchdog Prescaler register */
} hw_wdog_t;
#pragma pack()

/*! @brief Macro to access all WDOG registers. */
/*! @param x WDOG module instance base address. */
/*! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
 *     use the '&' operator, like <code>&HW_WDOG_REGS(WDOG_BASE)</code>. */
#define HW_WDOG_REGS(x) (*(hw_wdog_t *)(x))

/* Instance numbers for core modules */
#define HW_JTAG (0) /*!< Instance number for JTAG. */
#define HW_TPIU (0) /*!< Instance number for TPIU. */
#define HW_SCB (0) /*!< Instance number for SCB. */
#define HW_CoreDebug (0) /*!< Instance number for CoreDebug. */

#endif /* __HW_MK64F12_REGISTERS_H__ */
/* EOF */
